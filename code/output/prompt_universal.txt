
You are a financial data scientist specializing in **feature engineering for short-interest prediction** on equity time series.

I ran iterative feature engineering for multiple tickers and captured their best-performing codes. Please synthesize a **UNIVERSAL** feature construction function that keeps the strongest, non-redundant ideas **without** inflating feature count.

## Inputs provided
PERFORMANCE SUMMARY:
ABCB: MAPE = 8.30%, Features = 25
EIG: MAPE = 14.81%, Features = 25
FSS: MAPE = 11.69%, Features = 25
ABM: MAPE = 13.58%, Features = 25
IART: MAPE = 8.51%, Features = 25
SRPT: MAPE = 8.05%, Features = 25
EXTR: MAPE = 7.34%, Features = 25
SCSC: MAPE = 14.78%, Features = 25
SLG: MAPE = 5.75%, Features = 25
HL: MAPE = 9.87%, Features = 25
ANDE: MAPE = 14.43%, Features = 25
AROC: MAPE = 8.94%, Features = 25


BEST CODES (by ticker):

============================================================
TICKER: ABCB
============================================================
Best Performance: MAPE = 8.30%
Improvement over baseline: +0.18%
Feature count: 25
Significant features: 87

BEST FEATURE ENGINEERING CODE FOR ABCB:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Volume Trend - Exponentially weighted recent trend
        # Improved with more emphasis on recent days
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Short-term Price Momentum (3-day)
        # Simplified to focus on short-term momentum which showed higher importance
        if len(close_prices) >= 3:
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            short_momentum = 0
        eng.append(short_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        # Improved with adaptive band width based on volatility
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            # Adjust band width based on volatility
            k = 2 + volatility  # Dynamic multiplier
            upper_band = sma + k * std
            lower_band = sma - k * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved options sentiment metric
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        # Normalize implied vol against its typical range (assuming 0.2-0.6 is typical)
        normalized_iv = (implied_vol - 0.4) / 0.2  # Center around 0
        # Combined indicator: positive = bearish pressure, negative = bullish
        options_pressure = normalized_pc_ratio * (1 + abs(normalized_iv))
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator - Detect unusual volume activity
        # Improved with exponential weighting for recent volume
        if len(total_volume) >= 10:
            # Exponential weights for recent volume
            weights = np.array([0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.15])
            weighted_avg_vol = np.sum(weights * total_volume[-10:]) / np.sum(weights)
            recent_vol = total_volume[-1]
            denom = max(abs(weighted_avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Combined metric for squeeze likelihood
        # Improved with more emphasis on days to cover and volatility
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential with more emphasis on days to cover
            base_squeeze = (short_interest / (max(abs(shares_outstanding), 1e-8))) * (days_to_cover ** 1.5)
            
            # Incorporate volatility and recent price movement
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze potential
                momentum_factor = 1 + max(0, recent_return * 3)  # Increased weight
            else:
                momentum_factor = 1
                
            squeeze_potential = base_squeeze * momentum_factor * (1 + volatility * 2)  # More weight to volatility
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential * 3)  # Increased scaling factor for better differentiation
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. NEW: MACD Signal - Moving Average Convergence Divergence
        # Trend-following momentum indicator showing relationship between two moving averages
        if len(close_prices) >= 12:  # Need at least 12 days for meaningful EMA calculation
            # Calculate 12-day EMA
            ema12 = close_prices[-1]
            alpha12 = 2 / (12 + 1)
            for i in range(2, min(12, len(close_prices))+1):
                ema12 = close_prices[-i] * alpha12 + ema12 * (1 - alpha12)
            
            # Calculate 26-day EMA (or as many days as available, minimum 12)
            ema26 = close_prices[-1]
            alpha26 = 2 / (26 + 1)
            for i in range(2, min(26, len(close_prices))+1):
                ema26 = close_prices[-i] * alpha26 + ema26 * (1 - alpha26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-12:])
            denom = max(abs(avg_price), 1e-8)
            macd_normalized = macd_line / denom
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 14. NEW: Short Volume Acceleration
        # Second derivative of short volume to capture changing momentum in shorting activity
        if len(short_volume) >= 3:
            # First differences
            diff1 = short_volume[-1] - short_volume[-2]
            diff2 = short_volume[-2] - short_volume[-3]
            
            # Second difference (acceleration)
            short_vol_accel = diff1 - diff2
            
            # Normalize by average short volume
            avg_short_vol = np.mean(short_volume[-3:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_accel_norm = short_vol_accel / denom
            
            # Apply sigmoid-like transformation
            short_vol_acceleration = np.tanh(short_vol_accel_norm * 2)
        else:
            short_vol_acceleration = 0
        eng.append(short_vol_acceleration)
        
        # 15. NEW: Short Interest to Options Implied Volatility Ratio
        # Relationship between short interest and market's expectation of volatility
        si_to_iv_ratio = short_interest / max(abs(implied_vol), 1e-8)
        # Normalize to a reasonable range
        si_to_iv_ratio = np.tanh(si_to_iv_ratio / 1000)  # Scale factor based on typical values
        eng.append(si_to_iv_ratio)
        
        # 16. NEW: Price Gap Analysis
        # Measures overnight gaps which can signal significant sentiment shifts
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            # Calculate overnight gaps
            gaps = []
            for i in range(1, min(5, len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Average recent gap size (absolute value)
            avg_gap_size = np.mean(np.abs(gaps))
            
            # Direction of most recent gap
            recent_gap_direction = np.sign(gaps[0]) if gaps else 0
            
            # Combined metric: magnitude * direction
            gap_indicator = avg_gap_size * recent_gap_direction
            
            # Apply sigmoid-like transformation
            gap_indicator = np.tanh(gap_indicator * 10)  # Scale to emphasize significant gaps
        else:
            gap_indicator = 0
        eng.append(gap_indicator)
        
        # 17. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short sellers are timing their positions
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price returns
            returns = []
            for i in range(1, 5):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                ret = close_prices[-i] / denom - 1
                returns.append(ret)
            
            # Calculate correlation-like measure between short volume and subsequent returns
            # Negative correlation means shorts are effective (shorting before price drops)
            short_vol_norm = short_volume[-5:-1] / np.mean(short_volume[-5:-1])
            returns_norm = np.array(returns)
            
            # Simple dot product as correlation proxy
            efficiency = -np.sum(short_vol_norm * returns_norm) / 4
            
            # Apply sigmoid-like transformation
            short_efficiency = np.tanh(efficiency * 3)
        else:
            short_efficiency = 0
        eng.append(short_efficiency)
        
        # 18. NEW: Intraday Range Volatility Trend
        # Measures the trend in daily price ranges, indicating changing volatility
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            # Calculate daily ranges as percentage of price
            ranges = []
            for i in range(5):
                denom = max(abs(low_prices[-i-1]), 1e-8)
                daily_range = (high_prices[-i-1] - low_prices[-i-1]) / denom
                ranges.append(daily_range)
            
            # Calculate trend in ranges (simple linear regression slope)
            x = np.arange(5)
            y = np.array(ranges)
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average range
            denom = max(abs(mean_y), 1e-8)
            range_trend = slope / denom
            
            # Apply sigmoid-like transformation
            range_volatility_trend = np.tanh(range_trend * 10)
        else:
            range_volatility_trend = 0
        eng.append(range_volatility_trend)
        
        # 19. NEW: Short Volume to Price Momentum Divergence
        # Measures divergence between short selling activity and price momentum
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price momentum
            denom = max(abs(close_prices[-5]), 1e-8)
            price_momentum = close_prices[-1] / denom - 1
            
            # Calculate short volume momentum
            denom = max(abs(short_volume[-5]), 1e-8)
            short_vol_momentum = short_volume[-1] / denom - 1
            
            # Divergence: high when short volume increases but price also increases
            # or when short volume decreases but price also decreases
            divergence = short_vol_momentum * price_momentum
            
            # Apply sigmoid-like transformation
            short_price_divergence = np.tanh(divergence * 5)
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: EIG
============================================================
Best Performance: MAPE = 14.81%
Improvement over baseline: +0.33%
Feature count: 25
Significant features: 94

BEST FEATURE ENGINEERING CODE FOR EIG:
----------------------------------------
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features based on previous iterations' importance
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)      # Options put/call volume ratio
        raw_keep.append(synthetic_short_cost) # Options synthetic short cost
        raw_keep.append(implied_volatility)   # Options avg implied volatility
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days) - more responsive to recent changes
        recent_short_volume_ratio = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else np.mean(short_volume_ratio)
        eng.append(recent_short_volume_ratio)
        
        # 2. Short Interest to Shares Outstanding Ratio - key metric for squeeze potential
        si_to_shares_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares_ratio)
        
        # 3. Short Interest Growth Rate - improved with exponential weighting
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            # Apply sigmoid transformation to handle extreme values better
            si_growth_transformed = 2.0 / (1.0 + np.exp(-5.0 * si_growth)) - 1.0
        else:
            si_growth_transformed = 0.0
        eng.append(si_growth_transformed)
        
        # 4. Short Cost Pressure (synthetic_short_cost * short_interest)
        # High importance in previous iterations - measures cost pressure on shorts
        short_cost_pressure = synthetic_short_cost * short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(short_cost_pressure)
        
        # 5. Short Squeeze Potential - enhanced with volatility component
        # Combines days to cover, short interest ratio, put/call ratio, and implied volatility
        short_squeeze_potential = days_to_cover * si_to_shares_ratio * (1 + put_call_ratio) * (1 + implied_volatility/100)
        eng.append(short_squeeze_potential)
        
        # 6. Price Momentum with Volume Weighting (5-day)
        # Improved momentum calculation that accounts for volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_changes = np.diff(close_prices[-5:])
            vol_weights = total_volume[-5:] / max(abs(np.sum(total_volume[-5:])), 1e-8)
            vol_weighted_momentum = np.sum(price_changes * vol_weights[:-1]) / max(abs(close_prices[-5]), 1e-8)
        else:
            vol_weighted_momentum = 0.0
        eng.append(vol_weighted_momentum)
        
        # 7. Short Volume Acceleration - rate of change in short volume
        # Enhanced with exponential weighting to emphasize recent changes
        if len(short_volume) >= 5:
            weights = np.exp(np.linspace(0, 1, 4))
            weights = weights / np.sum(weights)
            short_vol_diff = np.diff(short_volume[-5:])
            short_vol_accel = np.sum(short_vol_diff * weights) / max(abs(np.mean(short_volume[-5:])), 1e-8)
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 8. Relative Strength Index (RSI) - improved calculation
        if len(close_prices) >= 5:
            delta = np.diff(close_prices[-5:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            # Normalize to [-1, 1] range for better model compatibility
            rsi_normalized = (rsi - 50) / 50
        else:
            rsi_normalized = 0.0
        eng.append(rsi_normalized)
        
        # 9. Short Interest to Float Ratio Normalized by Industry Average
        # Using a dynamic approximation based on recent history
        if t > 0:
            prev_si_ratio = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            relative_si_ratio = si_to_shares_ratio / max(abs(prev_si_ratio), 1e-8)
        else:
            relative_si_ratio = 1.0
        eng.append(relative_si_ratio)
        
        # 10. Options Implied Move vs Historical Move
        # Comparing implied volatility to actual price movement
        if len(close_prices) >= 5:
            historical_move = np.std(np.diff(close_prices[-5:]) / close_prices[-5:-1]) * np.sqrt(252)
            implied_vs_historical = implied_volatility / max(abs(historical_move), 1e-8)
            # Apply log transformation to handle extreme values better
            implied_vs_historical = np.log1p(implied_vs_historical) if implied_vs_historical > 0 else 0
        else:
            implied_vs_historical = 0.0
        eng.append(implied_vs_historical)
        
        # 11. Short Volume Trend Strength - improved with robust linear regression
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            if np.std(y) > 1e-8:
                # Use median-based trend to reduce outlier impact
                slope = np.median([(y[i+1] - y[i]) for i in range(len(y)-1)])
                trend_direction = np.sign(slope)
                trend_magnitude = abs(slope) / max(abs(np.median(y)), 1e-8)
                trend_strength = trend_direction * trend_magnitude
            else:
                trend_strength = 0.0
        else:
            trend_strength = 0.0
        eng.append(trend_strength)
        
        # 12. Price to Short Volume Correlation - improved with rank correlation
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Use rank changes instead of percentage changes for robustness
            price_ranks = np.argsort(np.argsort(close_prices[-5:]))
            short_vol_ranks = np.argsort(np.argsort(short_volume[-5:]))
            
            # Calculate Spearman's rank correlation
            if np.std(price_ranks) > 1e-8 and np.std(short_vol_ranks) > 1e-8:
                rank_diff_squared = np.sum((price_ranks - short_vol_ranks)**2)
                n = len(price_ranks)
                rank_correlation = 1 - (6 * rank_diff_squared) / (n * (n**2 - 1))
            else:
                rank_correlation = 0.0
        else:
            rank_correlation = 0.0
        eng.append(rank_correlation)
        
        # 13. Short Interest Concentration - ratio of short interest to average daily volume
        si_concentration = short_interest / max(abs(avg_volume * 5), 1e-8)  # 5-day equivalent
        # Apply log transformation to handle extreme values
        si_concentration = np.log1p(si_concentration) if si_concentration > 0 else 0
        eng.append(si_concentration)
        
        # 14. Synthetic Short Cost Trend - improved with momentum
        if t > 1:
            # Calculate acceleration (second derivative)
            prev_cost = data[t-1, 64]
            prev_prev_cost = data[t-2, 64] if t > 1 else prev_cost
            
            cost_change = (synthetic_short_cost - prev_cost) / max(abs(prev_cost), 1e-8)
            prev_cost_change = (prev_cost - prev_prev_cost) / max(abs(prev_prev_cost), 1e-8)
            
            short_cost_momentum = cost_change - prev_cost_change
        else:
            short_cost_momentum = 0.0
        eng.append(short_cost_momentum)
        
        # 15. Put-Call Ratio Trend - indicates changing sentiment
        if t > 0:
            pc_ratio_trend = (put_call_ratio / max(abs(data[t-1, 63]), 1e-8)) - 1.0
        else:
            pc_ratio_trend = 0.0
        eng.append(pc_ratio_trend)
        
        # 16. Volatility-Adjusted Short Interest - new feature combining volatility and short interest
        vol_adjusted_si = short_interest * implied_volatility / max(abs(shares_outstanding * 100), 1e-8)
        eng.append(vol_adjusted_si)
        
        # 17. Price Trend Reversal Signal - new feature to detect potential reversals
        if len(close_prices) >= 10:
            short_trend = np.mean(np.diff(close_prices[-5:]))
            long_trend = np.mean(np.diff(close_prices[-10:]))
            
            # Reversal signal: short-term trend differs from long-term trend
            reversal_signal = -1 * np.sign(short_trend) * np.sign(long_trend) if np.sign(short_trend) != np.sign(long_trend) else 0
            reversal_magnitude = abs(short_trend - long_trend) / max(abs(close_prices[-1]), 1e-8)
            reversal_indicator = reversal_signal * reversal_magnitude
        else:
            reversal_indicator = 0.0
        eng.append(reversal_indicator)
        
        # 18. Short Volume to Price Elasticity - improved calculation
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate percentage changes
            price_pct_change = np.diff(close_prices[-5:]) / close_prices[-5:-1]
            short_vol_pct_change = np.diff(short_volume[-5:]) / np.maximum(short_volume[-5:-1], 1e-8)
            
            # Calculate elasticity as ratio of average percentage changes
            avg_price_change = np.mean(abs(price_pct_change))
            avg_short_vol_change = np.mean(abs(short_vol_pct_change))
            
            elasticity = avg_price_change / max(abs(avg_short_vol_change), 1e-8)
            # Apply sigmoid transformation to handle extreme values
            elasticity = 2.0 / (1.0 + np.exp(-0.5 * elasticity)) - 1.0
        else:
            elasticity = 0.0
        eng.append(elasticity)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: FSS
============================================================
Best Performance: MAPE = 11.69%
Improvement over baseline: -0.61%
Feature count: 25
Significant features: 94

BEST FEATURE ENGINEERING CODE FOR FSS:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep most recent close price (high importance in previous iterations)
        raw_keep.append(close_prices[-1])
        
        # Keep options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding (important for normalization)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was a key indicator in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days average)
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else 0
        eng.append(recent_svr)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Price momentum - 5-day return
        # Feature_4_t1 had high importance in iteration 2
        price_return_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1) if len(close_prices) >= 5 else 0
        eng.append(price_return_5d)
        
        # 4. Short volume trend - 5-day change
        # Focus on short volume which showed high importance
        if len(short_volume) >= 5:
            short_vol_trend = (short_volume[-1] / max(abs(np.mean(short_volume[-5:-1])), 1e-8)) - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 5. Short interest change rate
        # If we have previous data point, calculate change rate
        si_change = 0
        if t > 0 and data[t-1, 0] > 0:
            si_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_change)
        
        # 6. Volatility (standard deviation of returns)
        # Feature_12_t3 had high importance in iteration 2
        daily_returns = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        
        volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 7. RSI (Relative Strength Index)
        # Feature_22_t3 had high importance in iteration 2
        gains = np.zeros(len(daily_returns))
        losses = np.zeros(len(daily_returns))
        for i in range(len(daily_returns)):
            if daily_returns[i] > 0:
                gains[i] = daily_returns[i]
            else:
                losses[i] = abs(daily_returns[i])
        
        avg_gain = np.mean(gains) if len(gains) > 0 else 0
        avg_loss = np.mean(losses) if len(losses) > 0 else 0
        
        if avg_loss > 0:
            rs = avg_gain / max(abs(avg_loss), 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 100 if avg_gain > 0 else 50
        
        eng.append(rsi)
        
        # 8. Short volume to total volume ratio trend
        # Captures the change in short selling pressure
        svr_trend = 0
        if len(short_volume_ratio) >= 10:
            recent_svr = np.mean(short_volume_ratio[-5:])
            prev_svr = np.mean(short_volume_ratio[-10:-5])
            svr_trend = (recent_svr / max(abs(prev_svr), 1e-8)) - 1
        eng.append(svr_trend)
        
        # 9. Price channel breakout indicator
        # Identifies potential trend reversals
        if len(close_prices) >= 10:
            upper_channel = np.max(close_prices[-10:-1])
            lower_channel = np.min(close_prices[-10:-1])
            channel_width = upper_channel - lower_channel
            if channel_width > 0:
                breakout = (close_prices[-1] - lower_channel) / max(abs(channel_width), 1e-8)
            else:
                breakout = 0.5
        else:
            breakout = 0.5
        eng.append(breakout)
        
        # 10. Bollinger Band position
        # Feature_24_t2 had high importance in iteration 2
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            if std > 0:
                bb_position = (close_prices[-1] - sma) / max(abs(std), 1e-8)
            else:
                bb_position = 0
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 11. Short interest to days to cover ratio
        # Relates short interest to the time needed to cover
        si_to_dtc = data[t, 0] / max(abs(data[t, 2]), 1e-8)
        eng.append(si_to_dtc)
        
        # 12. Options implied volatility to historical volatility ratio
        # Feature_15_t2 had high importance in iteration 2
        iv_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8) if volatility > 0 else 0
        eng.append(iv_hv_ratio)
        
        # 13. Short interest momentum
        # Measures acceleration in short interest changes
        si_momentum = 0
        if t >= 2 and data[t-2, 0] > 0:
            recent_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            prev_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_momentum = recent_change - prev_change
        eng.append(si_momentum)
        
        # 14. MACD-like indicator (difference between short and long EMAs)
        # Captures momentum and trend direction
        if len(close_prices) >= 12:
            # Simple implementation of EMA
            ema_short = np.mean(close_prices[-5:])
            ema_long = np.mean(close_prices[-12:])
            macd = (ema_short / max(abs(ema_long), 1e-8)) - 1
        else:
            macd = 0
        eng.append(macd)
        
        # 15. Short volume concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_5d_short = np.sum(short_volume[-5:])
            prev_5d_short = np.sum(short_volume[-10:-5])
            short_concentration = recent_5d_short / max(abs(prev_5d_short), 1e-8)
        else:
            short_concentration = 1.0
        eng.append(short_concentration)
        
        # 16. Put-call ratio trend
        # Captures changes in options sentiment
        put_call_trend = 0
        if t > 0 and data[t-1, 63] > 0:
            put_call_trend = (data[t, 63] / max(abs(data[t-1, 63]), 1e-8)) - 1
        eng.append(put_call_trend)
        
        # 17. Average True Range (ATR) - volatility measure
        # Captures price volatility including gaps
        atr = 0
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, min(10, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                true_ranges.append(max(high_low, high_close, low_close))
            atr = np.mean(true_ranges) if true_ranges else 0
        eng.append(atr)
        
        # 18. Normalized ATR (ATR / Close price)
        # Volatility relative to price level
        norm_atr = atr / max(abs(close_prices[-1]), 1e-8) if len(close_prices) > 0 else 0
        eng.append(norm_atr)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: ABM
============================================================
Best Performance: MAPE = 13.58%
Improvement over baseline: +0.64%
Feature count: 25
Significant features: 76

BEST FEATURE ENGINEERING CODE FOR ABM:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Improved Short Volume Ratio with adaptive weighting
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use adaptive weighting based on volatility of short volume ratio
        svr_std = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0.01
        svr_std = max(svr_std, 0.01)  # Ensure minimum volatility
        
        # Higher volatility = stronger recency bias
        exp_factor = 1 + (svr_std * 10)  # Scale volatility to reasonable range
        weights = np.exp(np.linspace(0, exp_factor, 15))
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio with trend adjustment
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Adjust based on recent trend if available
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            # Amplify signal when trend is strong
            short_interest_to_float *= (1 + 0.5 * abs(si_float_trend) * np.sign(si_float_trend))
        eng.append(short_interest_to_float)
        
        # 3. Multi-timeframe Price Momentum Composite
        # Combines multiple timeframes with adaptive weighting
        momentum_signals = []
        
        if len(close_prices) >= 10:
            # Short-term momentum (3-day)
            mom_3d = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            momentum_signals.append((mom_3d, 0.4))  # 40% weight
            
            # Medium-term momentum (5-day)
            mom_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            momentum_signals.append((mom_5d, 0.35))  # 35% weight
            
            # Longer-term momentum (10-day)
            mom_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            momentum_signals.append((mom_10d, 0.25))  # 25% weight
            
            # Combine signals with weights
            composite_momentum = sum(signal * weight for signal, weight in momentum_signals)
        else:
            # Use what's available
            if len(close_prices) >= 3:
                composite_momentum = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                composite_momentum = 0.0
        eng.append(composite_momentum)
        
        # 4. Enhanced RSI with volume weighting
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
                
            # Normalize RSI to [-1, 1] range for better gradient properties
            norm_rsi = (rsi / 50.0) - 1.0
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 5. Adaptive Price to Moving Average Ratio
        # Uses volatility to determine optimal lookback period
        if len(close_prices) >= 5:
            # Calculate price volatility to determine optimal MA period
            rolling_std = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            
            # Higher volatility = shorter MA period (more responsive)
            # Lower volatility = longer MA period (more stable)
            if rolling_std > 0.03:  # High volatility
                ma_period = min(5, len(close_prices))
            elif rolling_std > 0.01:  # Medium volatility
                ma_period = min(10, len(close_prices))
            else:  # Low volatility
                ma_period = min(15, len(close_prices))
                
            ma = np.mean(close_prices[-ma_period:])
            price_to_ma = close_prices[-1] / max(abs(ma), 1e-8)
            
            # Apply non-linear transformation to amplify deviations
            price_to_ma_signal = np.sign(price_to_ma - 1.0) * np.sqrt(abs(price_to_ma - 1.0))
        else:
            price_to_ma_signal = 0.0
        eng.append(price_to_ma_signal)
        
        # 6. Short Interest Momentum with Acceleration
        # Combines momentum and acceleration with adaptive smoothing
        if t > 0:
            si_current = data[t, 0]
            si_prev = data[t-1, 0]
            
            # Calculate momentum (first derivative)
            si_momentum = si_current / max(abs(si_prev), 1e-8) - 1.0
            
            # Add acceleration component if available
            if t > 1:
                si_prev2 = data[t-2, 0]
                prev_momentum = si_prev / max(abs(si_prev2), 1e-8) - 1.0
                
                # Calculate acceleration (second derivative)
                si_accel = si_momentum - prev_momentum
                
                # Adaptive smoothing based on acceleration magnitude
                accel_weight = min(0.7, 0.3 + abs(si_accel))
                si_momentum = (1 - accel_weight) * si_momentum + accel_weight * prev_momentum
                
                # Add non-linear amplification for strong signals
                if abs(si_momentum) > 0.05:
                    si_momentum *= (1 + 0.5 * abs(si_momentum))
            
            # Apply tanh to bound extreme values while preserving sign
            si_momentum_signal = np.tanh(si_momentum * 3)
        else:
            si_momentum_signal = 0.0
        eng.append(si_momentum_signal)
        
        # 7. Bollinger Band Position with Volume Confirmation
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            upper_band = ma20 + (2 * std20)
            lower_band = ma20 - (2 * std20)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Volume confirmation - check if volume supports the position
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify signal when volume confirms extreme positions
                    if (bb_position > 0.5 and vol_ratio > 1.2) or (bb_position < -0.5 and vol_ratio > 1.2):
                        bb_position *= vol_ratio
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 8. Short Interest Acceleration with Mean Reversion Component
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First differences (momentum)
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_acceleration = mom_t - mom_t1
            
            # Add mean reversion component
            if t >= 5:
                # Calculate average short interest over last 5 periods
                si_avg = np.mean([data[t-i, 0] for i in range(5)])
                
                # Calculate deviation from mean
                si_deviation = si_t / max(abs(si_avg), 1e-8) - 1.0
                
                # Mean reversion signal (stronger when deviation is large)
                mean_rev = -si_deviation * abs(si_deviation)
                
                # Combine acceleration and mean reversion
                si_accel_signal = 0.7 * si_acceleration + 0.3 * mean_rev
            else:
                si_accel_signal = si_acceleration
            
            # Apply sigmoid-like function to bound values
            si_accel_signal = si_accel_signal / max(1.0, abs(si_accel_signal) * 2)
        else:
            si_accel_signal = 0.0
        eng.append(si_accel_signal)
        
        # 9. Volume Trend with Price Confirmation
        if len(total_volume) >= 10:
            # Calculate recent volume trend
            recent_vol = np.mean(total_volume[-3:])
            older_vol = np.mean(total_volume[-10:-3])
            vol_trend = recent_vol / max(older_vol, 1e-8) - 1.0
            
            # Price confirmation
            if len(close_prices) >= 10:
                recent_price = np.mean(close_prices[-3:])
                older_price = np.mean(close_prices[-10:-3])
                price_trend = recent_price / max(older_price, 1e-8) - 1.0
                
                # Volume is more significant when it confirms price direction
                # or when it contradicts (potential reversal signal)
                if np.sign(vol_trend) == np.sign(price_trend):
                    # Confirming trend - amplify
                    vol_signal = vol_trend * (1 + abs(price_trend))
                else:
                    # Contradicting trend - potential reversal
                    vol_signal = vol_trend * (1 + 0.5 * abs(price_trend))
            else:
                vol_signal = vol_trend
            
            # Bound the signal
            vol_signal = np.tanh(vol_signal * 2)
        else:
            vol_signal = 0.0
        eng.append(vol_signal)
        
        # 10. Short Interest to Implied Volatility Ratio with Trend
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_iv = max(abs(data[t-i, 65]), 1e-8)
                    hist_ratios.append(data[t-i, 0] / hist_iv)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_iv_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        
        # Apply non-linear transformation to emphasize extremes
        si_iv_signal = np.sign(si_iv_signal) * np.sqrt(abs(si_iv_signal))
        eng.append(si_iv_signal)
        
        # 11. Enhanced MACD Signal with Volume Validation
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26 (approximated with weighted averages)
            weights_12 = np.exp(np.linspace(0, 3, min(12, len(close_prices))))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-min(12, len(close_prices)):] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 3, min(26, len(close_prices))))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-min(26, len(close_prices)):] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-min(26, len(close_prices)):])
            norm_macd = macd_line / max(abs(avg_price), 1e-8)
            
            # Volume validation
            if len(total_volume) >= 5:
                recent_vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
                
                # Amplify MACD when volume is high (more significant signal)
                if recent_vol_ratio > 1.2:
                    norm_macd *= np.sqrt(recent_vol_ratio)
                elif recent_vol_ratio < 0.8:
                    norm_macd *= np.sqrt(recent_vol_ratio)
            
            # Bound the signal
            macd_signal = np.tanh(norm_macd * 10)
        else:
            macd_signal = 0.0
        eng.append(macd_signal)
        
        # 12. Short Volume Trend with Acceleration
        if len(short_volume) >= 10:
            # Calculate short volume trend
            recent_short_vol = np.mean(short_volume[-3:])
            older_short_vol = np.mean(short_volume[-10:-3])
            sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Add acceleration component if possible
            if len(short_volume) >= 15:
                oldest_short_vol = np.mean(short_volume[:5])
                older_trend = older_short_vol / max(oldest_short_vol, 1e-8) - 1.0
                sv_accel = sv_trend - older_trend
                
                # Combine trend and acceleration
                sv_signal = 0.7 * sv_trend + 0.3 * sv_accel
            else:
                sv_signal = sv_trend
            
            # Apply non-linear transformation
            sv_signal = np.sign(sv_signal) * np.sqrt(abs(sv_signal))
        else:
            sv_signal = 0.0
        eng.append(sv_signal)
        
        # 13. Volatility-Adjusted Price Momentum with Mean Reversion
        if len(close_prices) >= 10:
            # Calculate recent price momentum
            recent_momentum = close_prices[-1] / max(close_prices[-5], 1e-8) - 1.0
            
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust momentum by volatility
            vol_adj_momentum = recent_momentum / max(rel_volatility, 0.01)
            
            # Add mean reversion component
            price_deviation = close_prices[-1] / max(price_mean, 1e-8) - 1.0
            mean_rev_signal = -price_deviation * abs(price_deviation)
            
            # Combine signals based on volatility regime
            if rel_volatility > 0.03:  # High volatility - favor mean reversion
                combined_signal = 0.4 * vol_adj_momentum + 0.6 * mean_rev_signal
            else:  # Low volatility - favor momentum
                combined_signal = 0.7 * vol_adj_momentum + 0.3 * mean_rev_signal
            
            # Bound the signal
            vol_adj_signal = np.tanh(combined_signal * 2)
        else:
            vol_adj_signal = 0.0
        eng.append(vol_adj_signal)
        
        # 14. Short Interest Efficiency with Adaptive Learning
        if t >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate weighted correlation-like measure
                # More recent points get higher weights
                weights = np.exp(np.linspace(0, 1, len(si_changes)))
                weights = weights / np.sum(weights)
                
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
                
                # Apply non-linear transformation to emphasize strong relationships
                si_efficiency_signal = np.sign(si_efficiency) * np.sqrt(abs(si_efficiency))
            else:
                si_efficiency_signal = 0.0
        else:
            si_efficiency_signal = 0.0
        eng.append(si_efficiency_signal)
        
        # 15. Synthetic Short Cost Change with Implied Volatility Context
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64] if t-1 >= 0 else current_cost
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            
            # Add context from implied volatility
            current_iv = data[t, 65]
            prev_iv = data[t-1, 65] if t-1 >= 0 else current_iv
            iv_change = current_iv / max(abs(prev_iv), 1e-8) - 1.0
            
            # Adjust cost change by IV context
            # Cost changes are more significant when they diverge from IV changes
            if np.sign(synth_cost_change) != np.sign(iv_change):
                # Divergence - amplify signal
                cost_signal = synth_cost_change * (1 + 0.5 * abs(iv_change))
            else:
                # Convergence - reduce signal
                cost_signal = synth_cost_change * (1 - 0.3 * abs(iv_change))
            
            # Bound the signal
            cost_signal = np.tanh(cost_signal * 3)
        else:
            cost_signal = 0.0
        eng.append(cost_signal)
        
        # 16. Price Trend Strength with Volume Profile Analysis
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate price changes
            price_changes = np.diff(close_prices[-10:])
            
            # Count positive and negative days
            pos_days = np.sum(price_changes > 0)
            neg_days = np.sum(price_changes < 0)
            
            # Calculate directional strength (ranges from -1 to 1)
            if pos_days + neg_days > 0:
                trend_strength = (pos_days - neg_days) / (pos_days + neg_days)
            else:
                trend_strength = 0.0
            
            # Enhanced volume profile analysis
            up_vol_sum = 0
            down_vol_sum = 0
            
            for i in range(1, min(10, len(total_volume))):
                if i < len(price_changes) + 1:
                    if price_changes[i-1] > 0:
                        up_vol_sum += total_volume[-i]
                    elif price_changes[i-1] < 0:
                        down_vol_sum += total_volume[-i]
            
            # Calculate volume strength ratio
            if up_vol_sum + down_vol_sum > 0:
                vol_strength = (up_vol_sum - down_vol_sum) / (up_vol_sum + down_vol_sum)
            else:
                vol_strength = 0.0
            
            # Combine price trend and volume strength
            # Higher weight to volume when they disagree (potential reversal)
            if np.sign(trend_strength) == np.sign(vol_strength):
                combined_trend = 0.6 * trend_strength + 0.4 * vol_strength
            else:
                combined_trend = 0.4 * trend_strength + 0.6 * vol_strength
        else:
            combined_trend = 0.0
        eng.append(combined_trend)
        
        # 17. Options Market Sentiment Indicator
        # Combines put/call ratio with implied volatility changes
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine signals - higher weight to put/call when IV is rising
            if iv_change > 0:
                options_sentiment = 0.7 * norm_pc_ratio + 0.3 * iv_change
            else:
                options_sentiment = 0.5 * norm_pc_ratio + 0.5 * iv_change
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal
        options_sentiment = np.tanh(options_sentiment * 2)
        eng.append(options_sentiment)
        
        # 18. Short Squeeze Potential Indicator
        # Combines short interest, price momentum, and volume
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Short squeeze conditions:
            # 1. High short interest
            # 2. Positive price momentum
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            
            squeeze_score = 0.0
            
            # High short interest base score
            if si_level > 0.1:  # More than 10% of float
                squeeze_score += 0.3 * min(si_level / 0.2, 1.0)  # Cap at 20% of float
            
            # Add momentum component (only positive momentum contributes)
            if price_momentum > 0:
                squeeze_score += 0.3 * min(price_momentum / 0.05, 1.0)  # Cap at 5% price increase
            
            # Add volume component
            if vol_surge > 0:
                squeeze_score += 0.2 * min(vol_surge / 0.5, 1.0)  # Cap at 50% volume increase
            
            # Add short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.2 * min(abs(si_change) / 0.05, 1.0)  # Cap at 5% SI reduction
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 19. Volatility Regime Indicator
        if len(close_prices) >= 20:
            # Calculate short-term and long-term volatility
            short_vol = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            long_vol = np.std(close_prices[-20:]) / max(np.mean(close_prices[-20:]), 1e-8)
            
            # Volatility regime (>1 means increasing volatility)
            vol_regime = short_vol / max(long_vol, 1e-8)
            
            # Normalize to a reasonable range
            vol_regime_signal = (vol_regime - 1.0) * 2
            
            # Bound the signal
            vol_regime_signal = np.tanh(vol_regime_signal)
        else:
            vol_regime_signal = 0.0
        eng.append(vol_regime_signal)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: IART
============================================================
Best Performance: MAPE = 8.51%
Improvement over baseline: +0.03%
Feature count: 25
Significant features: 80

BEST FEATURE ENGINEERING CODE FOR IART:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_7_t0, Feature_18_t3, Feature_16_t1, Feature_11_t3, Feature_23_t1 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest (critical target-related feature)
            avg_volume,                      # Always keep average volume (critical liquidity indicator)
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            shares_outstanding,              # Important for normalizing short interest
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        # High importance in previous iterations
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity - refined calculation
        if len(daily_short_ratio) >= 10:
            recent_short_ratio = np.mean(daily_short_ratio[-5:])
            earlier_short_ratio = np.mean(daily_short_ratio[-10:-5])
            short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric - high importance in previous iteration
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 8. Volatility-Adjusted Short Interest
        # Combines volatility with short interest - better signal in volatile conditions
        vol_adj_si = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            vol_adj_si = short_interest * price_volatility
        eng.append(vol_adj_si)
        
        # 9. Short Interest Acceleration (second derivative)
        # Second derivative of short interest - acceleration of short interest changes
        si_acceleration = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_si_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            current_si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            si_acceleration = current_si_growth - prev_si_growth
        eng.append(si_acceleration)
        
        # 10. Short Volume Trend Strength
        # Measures strength and consistency of short volume trend using regression
        sv_trend_strength = 0
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            sv_trend_strength = slope / max(np.mean(y), 1e-8)  # Normalized slope
        eng.append(sv_trend_strength)
        
        # 11. Options-Adjusted Short Interest
        # Combines short interest with options market sentiment
        options_adj_si = short_interest * options_put_call_ratio
        eng.append(options_adj_si)
        
        # 12. Short Interest Efficiency
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency = 0
        if len(close_prices) >= 5 and t > 0 and data[t-1, 0] > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            # Negative correlation is more efficient for shorts
            si_efficiency = -1 * si_change * np.sign(price_change) * np.log1p(abs(price_change) + 1e-8)
        eng.append(si_efficiency)
        
        # 13. Short Interest to Synthetic Short Cost Ratio
        # Compares actual short interest to the cost of creating synthetic shorts
        si_synthetic_ratio = short_interest / max(options_synthetic_short_cost, 1e-8)
        eng.append(si_synthetic_ratio)
        
        # 14. Short Interest Divergence from Volume
        # Measures when short interest and trading volume trends diverge
        si_volume_divergence = 0
        if t > 0 and data[t-1, 0] > 0 and data[t-1, 1] > 0:
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            vol_change = (avg_volume / max(data[t-1, 1], 1e-8)) - 1
            si_volume_divergence = si_change - vol_change
        eng.append(si_volume_divergence)
        
        # 15. Relative Short Interest Position
        # Measures current short interest relative to its recent range
        rel_si_position = 0
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min, si_max = np.min(si_history), np.max(si_history)
            si_range = si_max - si_min
            if si_range > 0:
                rel_si_position = (short_interest - si_min) / max(si_range, 1e-8)
            else:
                rel_si_position = 0.5  # Neutral if no range
        eng.append(rel_si_position)
        
        # 16. NEW: Short Interest to Price Ratio
        # Normalizes short interest by current price level
        si_price_ratio = 0
        if len(close_prices) > 0 and close_prices[-1] > 0:
            si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
        eng.append(si_price_ratio)
        
        # 17. NEW: Short Volume Concentration
        # Measures if short volume is concentrated in specific days
        sv_concentration = 0
        if len(short_volume) > 0 and np.sum(short_volume) > 0:
            normalized_sv = short_volume / max(np.sum(short_volume), 1e-8)
            # Gini-inspired concentration measure
            sv_concentration = np.sum(np.abs(normalized_sv - 1/len(normalized_sv)))
        eng.append(sv_concentration)
        
        # 18. NEW: Short Interest to Implied Volatility Ratio
        # Relates short interest to market's expectation of volatility
        si_iv_ratio = short_interest / max(options_avg_implied_volatility, 1e-8)
        eng.append(si_iv_ratio)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result

============================================================
TICKER: SRPT
============================================================
Best Performance: MAPE = 8.05%
Improvement over baseline: +1.33%
Feature count: 25
Significant features: 47

BEST FEATURE ENGINEERING CODE FOR SRPT:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover (important per baseline)
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options data (synthetic short cost had high importance)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This is a key indicator of short selling pressure
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent Short Volume Ratio Trend (last 5 days vs previous 10)
        recent_svr = np.mean(short_volume_ratio[-5:])
        previous_svr = np.mean(short_volume_ratio[:-5])
        svr_trend = recent_svr / max(previous_svr, 1e-8) - 1
        eng.append(svr_trend)
        
        # 3. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often correlates with short interest changes
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility indicator
        # Measures market volatility which can affect short selling
        atr_values = []
        for i in range(1, len(high_prices)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        normalized_atr = atr / max(close_prices[-1], 1e-8)
        eng.append(normalized_atr)
        
        # 7. Short Volume Acceleration
        # Measures the rate of change in short volume
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-5:-3])
            short_vol_accel = recent_short_vol / max(prev_short_vol, 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 8. Volume Pressure (ratio of recent volume to longer-term average)
        recent_volume = np.mean(total_volume[-3:])
        avg_volume = np.mean(total_volume)
        volume_pressure = recent_volume / max(avg_volume, 1e-8)
        eng.append(volume_pressure)
        
        # 9. Price Range Relative to Average
        # Measures if recent price movements are unusual
        if len(high_prices) > 0 and len(low_prices) > 0:
            recent_range = high_prices[-1] - low_prices[-1]
            avg_range = np.mean(high_prices - low_prices)
            relative_range = recent_range / max(avg_range, 1e-8)
        else:
            relative_range = 0
        eng.append(relative_range)
        
        # 10. Short Interest to Volume Ratio
        # Relates short interest to trading volume
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 11. Implied Volatility Normalized
        # Options implied volatility normalized by historical volatility
        implied_vol = data[t, 65]
        iv_normalized = implied_vol / max(volatility, 1e-8)
        eng.append(iv_normalized)
        
        # 12. Put-Call Ratio Change
        # Rate of change in options sentiment
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 13. Price to Moving Average Ratio
        # Indicates overbought/oversold conditions
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(ma10, 1e-8)
        else:
            price_to_ma = 1
        eng.append(price_to_ma)
        
        # 14. RSI (Relative Strength Index)
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) > 1:
            delta = np.diff(close_prices)
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            
            avg_gain = gain / max(len(delta), 1e-8)
            avg_loss = loss / max(len(delta), 1e-8)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50
        eng.append(rsi)
        
        # 15. Short Volume to Average Volume Ratio
        # Compares recent short volume to average trading volume
        recent_short_vol_avg = np.mean(short_volume[-5:])
        short_vol_to_avg = recent_short_vol_avg / max(data[t, 1], 1e-8)
        eng.append(short_vol_to_avg)
        
        # 16. OHLC Price Compression
        # Last day's OHLC data compressed to a single value
        if len(close_prices) > 0:
            last_open = open_prices[-1]
            last_high = high_prices[-1]
            last_low = low_prices[-1]
            last_close = close_prices[-1]
            
            # Normalize by the average price
            avg_price = (last_open + last_high + last_low + last_close) / 4
            price_compression = (last_high - last_low) / max(avg_price, 1e-8)
        else:
            price_compression = 0
        eng.append(price_compression)
        
        # 17. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 18. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # 19. Synthetic Short Cost to Implied Vol Ratio
        # Relationship between shorting cost and market expectations
        synth_short_to_iv = data[t, 64] / max(data[t, 65], 1e-8)
        eng.append(synth_short_to_iv)
        
        # 20. Days to Cover Change
        # Rate of change in days to cover
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: EXTR
============================================================
Best Performance: MAPE = 7.34%
Improvement over baseline: +0.30%
Feature count: 25
Significant features: 83

BEST FEATURE ENGINEERING CODE FOR EXTR:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
            data[t, 65], # options_avg_implied_volatility
            data[t, 66]  # shares_outstanding
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Add the most recent OHLC values (last day)
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio (short volume / total volume) - recent trend
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        # Average short ratio over last 5 days
        eng.append(np.mean(short_ratio[-5:]))
        
        # 2. Price momentum features
        # 5-day price momentum
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            eng.append(momentum_5d)
        else:
            eng.append(0)
        
        # 10-day price momentum
        if len(close_prices) >= 10:
            momentum_10d = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            eng.append(momentum_10d)
        else:
            eng.append(0)
        
        # 3. Volatility measures
        # Price range volatility (High-Low)/Close
        daily_volatility = np.zeros(15)
        for i in range(15):
            denom = max(abs(close_prices[i]), 1e-8)
            daily_volatility[i] = (high_prices[i] - low_prices[i]) / denom
        
        # 5-day average volatility
        eng.append(np.mean(daily_volatility[-5:]))
        
        # 4. Short interest to shares outstanding ratio
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_to_shares = data[t, 0] / shares_out
        eng.append(short_to_shares)
        
        # 5. Options-related metrics
        # Put/Call ratio (already in raw data at index 63)
        eng.append(data[t, 63])
        
        # Synthetic short cost (already in raw data at index 64)
        eng.append(data[t, 64])
        
        # 6. Volume trend features
        # 5-day volume trend compared to 15-day average
        recent_vol_avg = np.mean(total_volume[-5:])
        full_vol_avg = max(abs(np.mean(total_volume)), 1e-8)
        vol_trend = recent_vol_avg / full_vol_avg
        eng.append(vol_trend)
        
        # 7. Short volume trend
        recent_short_avg = np.mean(short_volume[-5:])
        full_short_avg = max(abs(np.mean(short_volume)), 1e-8)
        short_vol_trend = recent_short_avg / full_short_avg
        eng.append(short_vol_trend)
        
        # 8. RSI (Relative Strength Index) - 14 day
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain[-14:])
            avg_loss = max(abs(np.mean(loss[-14:])), 1e-8)
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50)  # Default RSI value
        
        # 9. Short interest acceleration (rate of change)
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_accel = (curr_short / denom) - 1
            eng.append(short_accel)
        else:
            eng.append(0)
        
        # 10. Price to volume ratio (Dollar volume)
        price_vol_ratio = close_prices[-1] * data[t, 1]  # Close * Avg Volume
        eng.append(price_vol_ratio)
        
        # 11. Short interest to average daily volume ratio
        si_to_adv = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_adv)
        
        # 12. Bollinger Band position
        if len(close_prices) >= 10:
            sma_20 = np.mean(close_prices[-10:])
            std_20 = np.std(close_prices[-10:])
            bb_position = (close_prices[-1] - sma_20) / max(abs(std_20), 1e-8)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 13. MACD-like indicator (5-day EMA vs 10-day EMA)
        if len(close_prices) >= 10:
            ema_5 = np.mean(close_prices[-5:])
            ema_10 = np.mean(close_prices[-10:])
            macd = ema_5 - ema_10
            eng.append(macd)
        else:
            eng.append(0)
        
        # 14. Short volume acceleration
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-2:])
            prev_short = max(abs(np.mean(short_volume[-5:-2])), 1e-8)
            short_vol_accel = (recent_short / prev_short) - 1
            eng.append(short_vol_accel)
        else:
            eng.append(0)
        
        # 15. Implied volatility to historical volatility ratio
        if len(daily_volatility) >= 5:
            hist_vol = np.mean(daily_volatility[-5:])
            impl_vol = max(abs(data[t, 65]), 1e-8)
            vol_ratio = data[t, 65] / impl_vol
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: SCSC
============================================================
Best Performance: MAPE = 14.78%
Improvement over baseline: -0.63%
Feature count: 25
Significant features: 78

BEST FEATURE ENGINEERING CODE FOR SCSC:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
            data[t, 63], # options_put_call_volume_ratio
            data[t, 64], # options_synthetic_short_cost
            data[t, 65]  # options_avg_implied_volatility
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Add the most recent close price (last day)
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was indicated as important in feature importance analysis
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            den = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / den
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent short volume ratio trend (last 5 days vs previous 10 days)
        recent_short_ratio = np.mean(short_volume_ratio[-5:])
        previous_short_ratio = np.mean(short_volume_ratio[:-5])
        den = max(abs(previous_short_ratio), 1e-8)
        short_ratio_trend = recent_short_ratio / den - 1
        eng.append(short_ratio_trend)
        
        # 3. Price momentum: 5-day return
        if len(close_prices) >= 5:
            den = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = close_prices[-1] / den - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 4. Price volatility: normalized range
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            den = max(abs(recent_low), 1e-8)
            normalized_range = (recent_high - recent_low) / den
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 5. Short interest to shares outstanding ratio
        shares_outstanding = data[t, 66]
        den = max(abs(shares_outstanding), 1e-8)
        short_interest_ratio = data[t, 0] / den
        eng.append(short_interest_ratio)
        
        # 6. Volume trend: recent volume vs previous volume
        recent_volume = np.mean(total_volume[-5:])
        previous_volume = np.mean(total_volume[:-5])
        den = max(abs(previous_volume), 1e-8)
        volume_trend = recent_volume / den - 1
        eng.append(volume_trend)
        
        # 7. Short volume acceleration
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-3:])
            previous_short = np.mean(short_volume[-5:-2])
            den = max(abs(previous_short), 1e-8)
            short_accel = recent_short / den - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 8. Price gap: difference between consecutive closes
        if len(close_prices) >= 2:
            den = max(abs(close_prices[-2]), 1e-8)
            price_gap = close_prices[-1] / den - 1
        else:
            price_gap = 0
        eng.append(price_gap)
        
        # 9. RSI (14-day)
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            den = max(abs(avg_loss), 1e-8)
            rs = avg_gain / den
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # neutral value when not enough data
        eng.append(rsi)
        
        # 10. Bollinger Band Width
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            den = max(abs(sma), 1e-8)
            bb_width = (2 * std) / den
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 11. Short volume to average daily volume ratio
        avg_short_volume = np.mean(short_volume)
        den = max(abs(data[t, 1]), 1e-8)
        short_to_avg_volume = avg_short_volume / den
        eng.append(short_to_avg_volume)
        
        # 12. Options implied volatility to historical volatility ratio
        if len(close_prices) >= 10:
            hist_vol = np.std(np.diff(np.log(close_prices[-10:]))) * np.sqrt(252)
            den = max(abs(hist_vol), 1e-8)
            iv_to_hv_ratio = data[t, 65] / den
        else:
            iv_to_hv_ratio = 1
        eng.append(iv_to_hv_ratio)
        
        # 13. Short interest momentum (if we have previous data)
        if t > 0:
            den = max(abs(data[t-1, 0]), 1e-8)
            si_momentum = data[t, 0] / den - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 14. VWAP (Volume Weighted Average Price) for last 5 days
        if len(close_prices) >= 5:
            vwap_num = np.sum(close_prices[-5:] * total_volume[-5:])
            vwap_den = max(np.sum(total_volume[-5:]), 1e-8)
            vwap = vwap_num / vwap_den
            den = max(abs(close_prices[-1]), 1e-8)
            vwap_ratio = vwap / den
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 15. Short volume volatility
        short_vol_std = np.std(short_volume_ratio)
        eng.append(short_vol_std)
        
        # 16. Put-call ratio trend
        if t > 0:
            den = max(abs(data[t-1, 63]), 1e-8)
            pc_ratio_trend = data[t, 63] / den - 1
        else:
            pc_ratio_trend = 0
        eng.append(pc_ratio_trend)
        
        # 17. Synthetic short cost trend
        if t > 0:
            den = max(abs(data[t-1, 64]), 1e-8)
            short_cost_trend = data[t, 64] / den - 1
        else:
            short_cost_trend = 0
        eng.append(short_cost_trend)
        
        # 18. Days to cover trend
        if t > 0:
            den = max(abs(data[t-1, 2]), 1e-8)
            dtc_trend = data[t, 2] / den - 1
        else:
            dtc_trend = 0
        eng.append(dtc_trend)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: SLG
============================================================
Best Performance: MAPE = 5.75%
Improvement over baseline: -0.06%
Feature count: 25
Significant features: 88

BEST FEATURE ENGINEERING CODE FOR SLG:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average daily volume
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)
        raw_keep.append(avg_daily_volume)
        raw_keep.append(days_to_cover)
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep important options data
        raw_keep.append(put_call_ratio)
        raw_keep.append(implied_volatility)
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        # This measures what percentage of total shares are sold short
        si_to_shares = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # Feature 2: Short volume ratio (average of last 15 days)
        # Higher ratio indicates more selling pressure
        short_volume_ratio = np.mean(short_volume / np.maximum(total_volume, 1e-8))
        eng.append(short_volume_ratio)
        
        # Feature 3: Recent short volume trend (last 5 days vs previous 10)
        recent_svr = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        earlier_svr = np.mean(short_volume[:-5] / np.maximum(total_volume[:-5], 1e-8))
        svr_trend = recent_svr / max(abs(earlier_svr), 1e-8) - 1
        eng.append(svr_trend)
        
        # Feature 4: Price momentum (5-day)
        # Captures recent price trend
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # Feature 5: Price momentum (10-day)
        # Captures medium-term price trend
        if len(close_prices) >= 10:
            price_momentum_10d = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
        else:
            price_momentum_10d = 0
        eng.append(price_momentum_10d)
        
        # Feature 6: Volatility (standard deviation of returns)
        # Higher volatility may attract short sellers
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # Feature 7: Average True Range (ATR) - volatility indicator
        # Measures market volatility
        atr_values = []
        for i in range(1, len(ohlc)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        eng.append(atr)
        
        # Feature 8: Relative strength index (RSI)
        # Overbought/oversold indicator
        if len(close_prices) > 1:
            diff = np.diff(close_prices)
            gains = np.sum(np.where(diff > 0, diff, 0))
            losses = np.sum(np.where(diff < 0, -diff, 0))
            
            if losses > 0:
                rs = gains / max(losses, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if gains > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # Feature 9: Short volume to average daily volume ratio
        # Indicates if short selling is higher than normal trading
        short_vol_to_avg_vol = np.mean(short_volume) / max(avg_daily_volume, 1e-8)
        eng.append(short_vol_to_avg_vol)
        
        # Feature 10: Implied volatility to historical volatility ratio
        # Indicates market expectations vs actual volatility
        if volatility > 0:
            iv_to_hv = implied_volatility / max(volatility, 1e-8)
        else:
            iv_to_hv = 1.0
        eng.append(iv_to_hv)
        
        # Feature 11: Recent volume trend (last 5 days vs previous 10)
        recent_vol = np.mean(total_volume[-5:])
        earlier_vol = np.mean(total_volume[:-5])
        vol_trend = recent_vol / max(abs(earlier_vol), 1e-8) - 1
        eng.append(vol_trend)
        
        # Feature 12: Price range relative to average
        # Indicates if recent price movement is unusual
        if len(high_prices) > 0 and len(low_prices) > 0:
            recent_range = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
            avg_range = np.mean((high_prices - low_prices) / np.maximum(close_prices, 1e-8))
            relative_range = recent_range / max(abs(avg_range), 1e-8)
        else:
            relative_range = 1.0
        eng.append(relative_range)
        
        # Feature 13: Short interest growth rate
        # Indicates acceleration in short positions
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_growth)
        
        # Feature 14: Synthetic short cost to implied volatility ratio
        # Cost efficiency of shorting relative to expected volatility
        synth_cost_to_iv = synthetic_short_cost / max(abs(implied_volatility), 1e-8)
        eng.append(synth_cost_to_iv)
        
        # Feature 15: VWAP (Volume Weighted Average Price)
        # Important price level watched by traders
        vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
        price_to_vwap = close_prices[-1] / max(abs(vwap), 1e-8) - 1
        eng.append(price_to_vwap)
        
        # Feature 16: Bollinger Band Width
        # Indicates if price is in a tight range (potential breakout)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Feature 17: Short interest to days to cover ratio
        si_to_dtc = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_to_dtc)
        
        # Feature 18: Recent short volume acceleration
        # Measures if short selling is accelerating
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            short_vol_accel = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result

============================================================
TICKER: HL
============================================================
Best Performance: MAPE = 9.87%
Improvement over baseline: +0.23%
Feature count: 25
Significant features: 92

BEST FEATURE ENGINEERING CODE FOR HL:
----------------------------------------
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Relative Strength Index (RSI) - momentum oscillator
        # Identifies overbought/oversold conditions that may trigger short covering
        if len(close_prices) >= 14:
            price_diff = np.diff(close_prices)
            gains = np.where(price_diff > 0, price_diff, 0)
            losses = np.where(price_diff < 0, -price_diff, 0)
            
            avg_gain = np.mean(gains)
            avg_loss = np.mean(losses)
            
            if avg_loss == 0:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 6. Short Volume Concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.sum(short_volume[-5:])
            total_short_vol = np.sum(short_volume[-10:])
            short_vol_concentration = recent_short_vol / max(total_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.5)  # Neutral concentration
        
        # 7. Price Volatility (ATR-based)
        # Higher volatility can lead to short covering or new short positions
        if len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            atr = np.mean(tr_values)
            # Normalize by price level
            norm_atr = atr / max(close_prices[-1], 1e-8)
            eng.append(norm_atr)
        else:
            eng.append(0.0)
        
        # 8. Short Volume Momentum
        # Rate of change in short volume over recent periods
        if len(short_volume) >= 10:
            recent_short_vol_avg = np.mean(short_volume[-5:])
            older_short_vol_avg = np.mean(short_volume[-10:-5])
            short_vol_momentum = (recent_short_vol_avg / max(older_short_vol_avg, 1e-8)) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # 9. Price to Moving Average Ratio
        # Indicates potential mean reversion or trend continuation points
        if len(close_prices) >= 10:
            sma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(sma10, 1e-8)
            eng.append(price_to_ma)
        else:
            eng.append(1.0)  # Neutral value
        
        # 10. Volume Trend
        # Increasing volume can signal potential short covering or new short positions
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_trend = (recent_vol_avg / max(older_vol_avg, 1e-8)) - 1
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 11. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover all shorts
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        eng.append(si_to_dtc)
        
        # 12. Options Implied Volatility to Price Ratio
        # Higher ratio may indicate increased likelihood of short covering
        implied_vol = data[t, 65]
        price = close_prices[-1] if len(close_prices) > 0 else 1.0
        iv_to_price = implied_vol / max(price, 1e-8)
        eng.append(iv_to_price)
        
        # 13. Short Volume Volatility
        # Measures the stability/volatility of short selling activity
        if len(short_volume) >= 5:
            short_vol_volatility = np.std(short_volume[-5:]) / max(np.mean(short_volume[-5:]), 1e-8)
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 14. Price Momentum (Rate of Change)
        # Strong price momentum can trigger short covering
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            eng.append(price_momentum)
        else:
            eng.append(0.0)
        
        # 15. Short Interest to Options Put/Call Ratio
        # Relationship between short interest and options sentiment
        put_call_ratio = max(data[t, 63], 1e-8)
        si_to_options = data[t, 0] / put_call_ratio
        eng.append(si_to_options)
        
        # 16. Synthetic Short Cost to Average Volume Ratio
        # Relates cost of shorting to liquidity
        synthetic_short_cost = data[t, 64]
        avg_volume = max(data[t, 1], 1e-8)
        cost_to_volume = synthetic_short_cost / avg_volume
        eng.append(cost_to_volume)
        
        # 17. Recent Price Range Relative to Historical
        # Identifies if current price action is unusual compared to historical
        if len(high_prices) >= 10 and len(low_prices) >= 10:
            recent_range = np.max(high_prices[-5:]) - np.min(low_prices[-5:])
            historical_range = np.max(high_prices[-10:]) - np.min(low_prices[-10:])
            relative_range = recent_range / max(historical_range, 1e-8)
            eng.append(relative_range)
        else:
            eng.append(1.0)
        
        # 18. Short Volume to Total Volume Acceleration
        # Second derivative of short volume ratio - captures changing momentum
        if len(short_volume_ratio) >= 10:
            recent_change = short_volume_ratio[-1] - short_volume_ratio[-5]
            older_change = short_volume_ratio[-6] - short_volume_ratio[-10]
            acceleration = recent_change - older_change
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features

============================================================
TICKER: ANDE
============================================================
Best Performance: MAPE = 14.43%
Improvement over baseline: +0.67%
Feature count: 25
Significant features: 89

BEST FEATURE ENGINEERING CODE FOR ANDE:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Most important target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data (showed high importance in previous iterations)
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)  # High importance in baseline
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was a high-importance feature in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short volume ratio trend (last 5 days vs previous 10)
        # Improved from previous iteration by using weighted average
        if len(short_volume_ratio) >= 15:
            weights = np.linspace(0.5, 1.5, 5)  # Increasing weights for recency
            recent_svr = np.average(short_volume_ratio[-5:], weights=weights)
            previous_svr = np.mean(short_volume_ratio[:-5])
            denom = max(abs(previous_svr), 1e-8)
            svr_trend = recent_svr / denom - 1
        else:
            svr_trend = 0
        eng.append(svr_trend)
        
        # 3. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 4. Short interest momentum (normalized by volume)
        # This was a high-importance feature in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 5. Short interest to days to cover ratio
        # Improved by normalizing to reduce scale issues
        si_dtc_ratio = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_dtc_ratio)
        
        # 6. Price momentum: 5-day return (improved calculation)
        if len(close_prices) >= 5:
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = close_prices[-1] / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 7. Price volatility: normalized range (high importance in previous iterations)
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            denom = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / denom
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 8. Volume trend: recent volume vs historical (improved calculation)
        if len(total_volume) >= 10:
            weights = np.linspace(0.5, 1.5, 5)  # Increasing weights for recency
            recent_volume = np.average(total_volume[-5:], weights=weights)
            historical_volume = np.mean(total_volume[-10:-5])
            denom = max(abs(historical_volume), 1e-8)
            volume_trend = recent_volume / denom - 1
        else:
            volume_trend = 0
        eng.append(volume_trend)
        
        # 9. Options sentiment indicator (combining put/call ratio with implied volatility)
        # This was a high-importance feature in previous iterations
        options_sentiment = options_put_call_ratio * options_avg_implied_volatility
        eng.append(options_sentiment)
        
        # 10. Short cost pressure (improved calculation)
        # Combines synthetic short cost with days to cover
        short_cost_pressure = options_synthetic_short_cost * days_to_cover
        eng.append(short_cost_pressure)
        
        # 11. RSI (14-day) - improved calculation with proper smoothing
        if len(close_prices) >= 15:
            deltas = np.diff(close_prices)
            seed = deltas[:14]
            up = seed[seed >= 0].sum() / 14.0
            down = -seed[seed < 0].sum() / 14.0
            
            if down != 0:
                rs = up / max(down, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                rsi = 100.0
        else:
            rsi = 50.0  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # 12. Short volume acceleration (improved calculation)
        if len(short_volume) >= 9:
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            # Second derivative approximation
            first_diff = recent_short_vol - mid_short_vol
            second_diff = (recent_short_vol - mid_short_vol) - (mid_short_vol - early_short_vol)
            
            denom = max(abs(mid_short_vol), 1e-8)
            short_vol_accel = second_diff / denom
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 13. Price-volume divergence (improved from correlation)
        # Measures when price and volume move in opposite directions
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate price change
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            # Calculate volume change
            volume_change = np.mean(total_volume[-3:]) / max(abs(np.mean(total_volume[-5:-2])), 1e-8) - 1
            
            # Divergence is high when signs are opposite
            price_vol_divergence = price_change * volume_change * -1
        else:
            price_vol_divergence = 0
        eng.append(price_vol_divergence)
        
        # 14. Volatility-adjusted short interest (high importance in previous iterations)
        vol_adjusted_si = short_interest * normalized_range
        eng.append(vol_adjusted_si)
        
        # 15. Short volume concentration (improved calculation)
        if len(short_volume) >= 5:
            max_short_vol = np.max(short_volume[-5:])
            avg_short_vol = np.mean(short_volume[-5:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_concentration = max_short_vol / denom
        else:
            short_vol_concentration = 1
        eng.append(short_vol_concentration)
        
        # 16. Implied volatility to historical volatility ratio (improved calculation)
        if len(close_prices) >= 10:
            returns = np.zeros(len(close_prices)-1)
            for i in range(1, len(close_prices)):
                denom = max(abs(close_prices[i-1]), 1e-8)
                returns[i-1] = close_prices[i] / denom - 1
            
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            denom = max(abs(hist_vol), 1e-8)
            iv_hv_ratio = options_avg_implied_volatility / denom
        else:
            iv_hv_ratio = 1
        eng.append(iv_hv_ratio)
        
        # 17. Short volume to options volume indicator (high importance in previous iterations)
        short_options_indicator = avg_short_volume_ratio * options_put_call_ratio
        eng.append(short_options_indicator)
        
        # 18. NEW: VWAP deviation
        # Measures how current price deviates from volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_deviation = close_prices[-1] / max(abs(vwap), 1e-8) - 1
        else:
            vwap_deviation = 0
        eng.append(vwap_deviation)
        
        # 19. NEW: Short interest rate of change
        # Measures acceleration in short interest changes
        si_roc = short_interest / max(abs(days_to_cover * avg_volume), 1e-8)
        eng.append(si_roc)
        
        # 20. NEW: Bollinger Band width (volatility measure)
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array

============================================================
TICKER: AROC
============================================================
Best Performance: MAPE = 8.94%
Improvement over baseline: +1.02%
Feature count: 25
Significant features: 70

BEST FEATURE ENGINEERING CODE FOR AROC:
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we're keeping the most important raw features
        # and dropping those with low importance
        raw_keep = [
            data[t, 0],  # short interest - critical target-related feature
            data[t, 1],  # average daily volume - high importance in previous iteration
            data[t, 2],  # days to cover - key short interest metric
            data[t, 63], # options_put_call_volume_ratio - options sentiment indicator
            data[t, 64], # options_synthetic_short_cost - cost of shorting
            data[t, 65], # options_avg_implied_volatility - market's volatility expectation
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - key metric for short squeeze potential
        si_float_ratio = data[t, 0] / max(data[t, 66], 1e-8)  # shares_outstanding is at index 66
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - improved version of days to cover
        si_adv_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Short volume ratio (average of last 5 days) - recent shorting intensity
        short_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        eng.append(short_ratio)
        
        # 4. Short volume trend (last 5 days vs previous 5 days) - acceleration in shorting
        if len(short_volume) >= 10:
            recent_short_avg = np.mean(short_volume[-5:])
            prev_short_avg = np.mean(short_volume[-10:-5])
            denom = max(abs(prev_short_avg), 1e-8)
            short_trend = (recent_short_avg / denom) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 5. Short interest growth rate - rate of change in reported short interest
        if t > 0:
            prev_si = data[t-1, 0]
            denom = max(abs(prev_si), 1e-8)
            si_growth = (data[t, 0] / denom) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 6. Volatility (standard deviation of returns over past 10 days)
        if len(close_prices) >= 11:
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 1 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 7. Options implied volatility to historical volatility ratio - market vs realized volatility
        iv_hv_ratio = data[t, 65] / max(volatility, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 8. Short cost to implied volatility ratio - cost efficiency of shorting
        cost_vol_ratio = data[t, 64] / max(data[t, 65], 1e-8)
        eng.append(cost_vol_ratio)
        
        # 9. RSI (14-day) - oversold/overbought indicator
        if len(close_prices) >= 15:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            denom = max(avg_loss, 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default neutral value
        eng.append(rsi)
        
        # 10. Bollinger Band Width - volatility measure
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)  # Normalized by price level
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 11. VWAP ratio - price relative to volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_ratio = close_prices[-1] / max(vwap, 1e-8)
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 12. Short volume to total volume ratio trend - change in shorting intensity
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
            prev_ratio = np.mean(short_volume[-10:-5] / np.maximum(total_volume[-10:-5], 1e-8))
            denom = max(abs(prev_ratio), 1e-8)
            ratio_trend = (recent_ratio / denom) - 1
        else:
            ratio_trend = 0
        eng.append(ratio_trend)
        
        # 13. Put-call ratio trend - options sentiment change
        if t > 0:
            prev_pc_ratio = data[t-1, 63]
            denom = max(abs(prev_pc_ratio), 1e-8)
            pc_ratio_trend = (data[t, 63] / denom) - 1
        else:
            pc_ratio_trend = 0
        eng.append(pc_ratio_trend)
        
        # 14. Price momentum (rate of change over 10 days)
        if len(close_prices) >= 10:
            momentum = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1
        else:
            momentum = 0
        eng.append(momentum)
        
        # 15. Average True Range (ATR) - volatility measure
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)] if i < len(close_prices)-1 else 0)
                low_close = abs(low_prices[-i] - close_prices[-(i+1)] if i < len(close_prices)-1 else 0)
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr = np.mean(tr_values)
            # Normalize by price
            atr_normalized = atr / max(close_prices[-1], 1e-8)
        else:
            atr_normalized = 0
        eng.append(atr_normalized)
        
        # 16. Short volume acceleration - second derivative of short volume
        if len(short_volume) >= 15:
            recent_change = np.mean(short_volume[-5:]) - np.mean(short_volume[-10:-5])
            prev_change = np.mean(short_volume[-10:-5]) - np.mean(short_volume[-15:-10])
            denom = max(abs(prev_change), 1e-8)
            short_accel = (recent_change / denom) - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 17. MACD Signal - trend strength and direction
        if len(close_prices) >= 15:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA
            ema26 = np.mean(close_prices[-15:])  # Using available data
            macd = ema12 - ema26
            # Normalize by price
            macd_normalized = macd / max(close_prices[-1], 1e-8)
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 18. Volume Oscillator - volume trend
        if len(total_volume) >= 10:
            short_vol_ma = np.mean(total_volume[-5:])
            long_vol_ma = np.mean(total_volume[-10:])
            vol_osc = (short_vol_ma / max(long_vol_ma, 1e-8)) - 1
        else:
            vol_osc = 0
        eng.append(vol_osc)
        
        # 19. High-Low range relative to price (average of last 5 days)
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            hl_range = np.mean((high_prices[-5:] - low_prices[-5:]) / np.maximum(close_prices[-5:], 1e-8))
        else:
            hl_range = 0
        eng.append(hl_range)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features


## Data schema
- Input to your function: a **numpy array** `data` with shape **(lookback_window, 97)** for a *single* sample.
- Feature layout at each timestep `t`:
  - `data[t, 0]` → **short interest** at time *T* (reported every 15 days)
  - `data[t, 1]` → **average daily volume (past 15 days)**
  - `data[t, 2]` → **days to cover** The number of days it would take to cover all short positions based on average daily trading volume.
  - `data[t, 3:63]` → **OHLC** over the past 15 days, flattened as **15 days × 4 columns** in order **[O, H, L, C]**  
    Use: `ohlc = data[t, 3:].reshape(15, 4)` → `open, high, low, close = ohlc[:,0], ohlc[:,1], ohlc[:,2], ohlc[:,3]`.
  - `data[t, 63]` → **options_put_call_volume_ratio** The ratio of the volume of put options to call options traded on that day.
  - `data[t, 64]` → **options_synthetic_short_cost** The cost associated with creating a synthetic short position using options.
  - `data[t, 65]` → **options_avg_implied_volatility** The average implied volatility of options, reflecting market expectations of future stock price volatility.
  - `data[t, 66]` → **shares_outstanding** The total number of shares of a company that are currently owned by all its shareholders, including restricted shares owned by company insiders and institutional investors.
  - `data[t, 67:82]` → Daily short interest volume for the stock over the past 15 days, flattened as **15 days × 1 columns**. Represents the total number of shares that were sold short on each day.
  - `data[t, 82:97]` → Daily total trading volume for the stock over the past 15 days, flattened as **15 days × 1 columns**.  Represents the total number of shares traded (buy + sell) on that trading day.

Total: 3 + 60 + 4 + 30 = 97 features(dimensions) per timestamp.

### Deliverable
Return **ONLY** the Python function code (no text outside the code).
