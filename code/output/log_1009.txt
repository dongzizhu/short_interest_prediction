🚀 Modular Iterative Agent-Based Feature Selection Examples
======================================================================
✅ API key loaded successfully

🔍 Example: Multi-Ticker Processing with SVM
==================================================
🤖 Using SVM model with kernel: rbf
   C: 1.0, Gamma: scale
   Epsilon: 0.1, Max iterations: 1000
Using device: cpu
✅ Claude API client initialized successfully!
🚀 Starting Multi-Ticker Iterative Agent-Based Feature Selection Process
================================================================================
Processing iterative tickers: ABCB, EIG, EYE, AAP, FSS, ABM, IART, SRPT, EXTR, SCSC, SLG, HL, ANDE, AROC
Available for validation: AAP, AAT, ABCB, ABG, ABM, ABR, ACAD, ACHC, ACIW, ACLS, ADMA, ADNT, ADUS, AEIS, AEO, AGO, AGYS, AHH, AIN, AIR, AKR, AL, ALEX, ALG, ALGT, ALKS, ALRM, AMN, AMPH, AMSF, AMWD, ANDE, ANGI, ANIP, AOSL, APAM, APLE, APOG, ARCB, ARI, AROC, ARR, ARWR, ASIX, ASTE, ATEN, ATGE, AVA, AWI, AWR, AXL, AZZ, BANC, BANF, BANR, BCC, BCPC, BDN, BFS, BHE, BJRI, BKE, BKU, BL, BLFS, BLMN, BMI, BOH, BOOT, BOX, BRC, BTU, BWA, BXMT, CABO, CAKE, CAL, CALM, CALX, CARG, CARS, CASH, CATY, CBRL, CBU, CC, CCOI, CCS, CE, CENT, CENTA, CENX, CEVA, CFFN, CHCO, CHEF, CLB, CNK, CNMD, CNS, CNXN, COHU, COLL, CORT, CPF, CPK, CPRX, CRI, CRK, CRVL, CSGS, CTRE, CTS, CUBI, CVBF, CVCO, CVI, CWT, CXW, CZR, DAN, DCOM, DEA, DEI, DFIN, DGII, DIOD, DLX, DNOW, DORM, DRH, DVAX, DXC, DXPE, DY, EAT, ECPG, EFC, EGBN, EIG, ENPH, ENR, ENVA, EPC, ESE, ETSY, EVTC, EXPI, EXTR, EYE, EZPW, FBK, FBNC, FBP, FCF, FCPT, FDP, FELE, FFBC, FHB, FIZZ, FMC, FORM, FOXF, FRPT, FSS, FUL, FULT, FUN, FWRD, GBX, GDEN, GEO, GES, GFF, GIII, GKOS, GNL, GNW, GOGO, GOLF, GPI, GRBK, GTY, GVA, HAFC, HASI, HBI, HCC, HCI, HCSG, HELE, HFWA, HI, HIW, HL, HLIT, HLX, HMN, HNI, HOPE, HP, HSII, HSTM, HTH, HTLD, HUBG, HWKN, HZO, IAC, IART, IBP, ICHR, ICUI, IDCC, IIIN, IIPR, INDB, INN, INSW, INVA, IOSP, IPAR, ITGR, ITRI, JBGS, JBLU, JBSS, JJSF, JOE, KAI, KALU, KAR, KFY, KLIC, KMT, KN, KOP, KREF, KRYS, KSS, KW, KWR, LCII, LEG, LGIH, LGND, LKFN, LMAT, LNC, LNN, LPG, LQDT, LRN, LTC, LXP, LZB, MAC, MAN, MARA, MATW, MATX, MC, MCRI, MCY, MD, MDU, MGEE, MGPI, MHO, MKTX, MMI, MMSI, MNRO, MPW, MRCY, MRTN, MSEX, MTH, MTRN, MTX, MWA, MXL, MYGN, MYRG, NAVI, NBHC, NBTB, NEO, NEOG, NGVT, NHC, NMIH, NOG, NPK, NPO, NSIT, NTCT, NWBI, NWL, NWN, NX, NXRT, OFG, OI, OII, OMCL, OSIS, OTTR, OUT, OXM, PAHC, PARR, PATK, PBH, PBI, PCRX, PDFS, PEB, PENN, PFBC, PFS, PI, PINC, PJT, PLAB, PLAY, PLUS, PLXS, PMT, POWL, PRA, PRAA, PRGS, PRK, PRLB, PSMT, PTEN, PTGX, PZZA, QDEL, QNST, QRVO, QTWO, RDN, RDNT, RES, REX, RGR, RHI, RHP, RNST, ROCK, ROG, RUN, RUSHA, RWT, SAFE, SABR, SAFT, SAH, SANM, SBCF, SBH, SBSI, SCHL, SCL, SCSC, SCVL, SEDG, SEE, SEM, SFBS, SFNC, SHAK, SHEN, SHO, SHOO, SIG, SKT, SKY, SKYW, SLG, SM, SMP, SMPL, SMTC, SNDR, SPSC, SPXC, SRPT, SSTK, STAA, STBA, STC, STRA, STRL, SUPN, SXC, SXI, SXT, TBBK, TDC, TDS, TDW, TFX, TGNA, TGTX, THRM, THS, TILE, TMP, TNC, TNDM, TPH, TR, TRIP, TRMK, TRN, TRNO, TRST, TRUP, TTMI, TWI, TWO, UCTT, UE, UFCS, UFPT, UHT, UNF, UNFI, UNIT, URBN, USNA, USPH, UTL, UVV, VBTX, VCEL, VCYT, VECO, VIAV, VICR, VIRT, VRTS, VSAT, VSH, WABC, WAFD, WD, WDFC, WEN, WERN, WGO, WOR, WRLD, WSC, WSFS, WSR, WWW, XHR, XNCR, YELP
================================================================================

================================================================================
PROCESSING TICKER 1/14: ABCB
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for ABCB
======================================================================
📊 Loading data from parquet file...
📊 Loading data for ABCB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ABCB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 151524.8042
RMSE: 201678.1524
MAPE: 8.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 294
   • Highly important features (top 5%): 143

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0001, rank=1
   2. Feature_84_t0: importance=0.0001, rank=2
   3. Feature_72_t0: importance=0.0001, rank=3
   4. Feature_1_t3: importance=0.0001, rank=4
   5. Feature_95_t0: importance=0.0001, rank=5

📊 Baseline Performance: MAPE = 8.74%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which likely has predictive power for short interest
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep shares outstanding
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent trend in short volume ratio (last 5 days vs previous 10 days)
        recent_svr = np.mean(short_volume_ratio[-5:])
        previous_svr = np.mean(short_volume_ratio[:-5])
        denom = max(abs(previous_svr), 1e-8)
        svr_trend = recent_svr / denom - 1
        eng.append(svr_trend)
        
        # 3. Price momentum (5-day)
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # 4. Price momentum (15-day)
        if len(close_prices) >= 15:
            price_momentum_15d = close_prices[-1] / max(abs(close_prices[0]), 1e-8) - 1
        else:
            price_momentum_15d = 0
        eng.append(price_momentum_15d)
        
        # 5. Volatility (standard deviation of returns)
        returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
        volatility = np.std(returns) if len(returns) > 0 else 0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility indicator
        tr_values = []
        for i in range(1, len(close_prices)):
            high_low = high_prices[i] - low_prices[i]
            high_close_prev = abs(high_prices[i] - close_prices[i-1])
            low_close_prev = abs(low_prices[i] - close_prices[i-1])
            tr = max(high_low, high_close_prev, low_close_prev)
            tr_values.append(tr)
        atr = np.mean(tr_values) if tr_values else 0
        eng.append(atr)
        
        # 7. Short interest to float ratio
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 8. Short interest to volume ratio
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 9. RSI (Relative Strength Index) - 14 period
        if len(close_prices) >= 15:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 10. VWAP (Volume Weighted Average Price)
        vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
        eng.append(vwap)
        
        # 11. Price to VWAP ratio
        price_to_vwap = close_prices[-1] / max(abs(vwap), 1e-8)
        eng.append(price_to_vwap)
        
        # 12. Options put/call ratio trend (if available in time series)
        options_ratio = data[t, 63]
        eng.append(options_ratio)
        
        # 13. Bollinger Band Width (volatility measure)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = std / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 14. Short volume acceleration (change in short volume)
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-5:-3])
            denom = max(abs(prev_short_vol), 1e-8)
            short_vol_accel = recent_short_vol / denom - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 15. Short interest to implied volatility ratio
        implied_vol = data[t, 65]
        denom = max(abs(implied_vol), 1e-8)
        si_to_implied_vol = short_interest / denom
        eng.append(si_to_implied_vol)
        
        # 16. Synthetic short cost to volume ratio
        synthetic_short_cost = data[t, 64]
        denom = max(abs(avg_volume), 1e-8)
        synthetic_cost_to_volume = synthetic_short_cost / denom
        eng.append(synthetic_cost_to_volume)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 154437.8622
RMSE: 214499.5357
MAPE: 9.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0004, rank=1
   2. Feature_0_t3: importance=0.0003, rank=2
   3. Feature_21_t1: importance=0.0003, rank=3
   4. Feature_6_t0: importance=0.0002, rank=4
   5. Feature_2_t0: importance=0.0002, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
📊 No significant improvement. Change: -0.26%

📈 Current best MAPE: 8.74%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep short interest and volume metrics
        raw_keep = [
            data[t, 0],  # short interest - highest importance from previous iterations
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent open price
        # Feature importance showed recent price data was valuable
        raw_keep.append(close_prices[-1])  # Most recent close price
        raw_keep.append(open_prices[-1])   # Most recent open price
        
        # Keep options data which likely has predictive power for short interest
        # Options data provides insights into market sentiment and expectations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent trend in short volume ratio (last 3 days vs previous 12 days)
        # Modified from previous iteration to focus on more recent trend
        recent_svr = np.mean(short_volume_ratio[-3:])
        previous_svr = np.mean(short_volume_ratio[:-3])
        denom = max(abs(previous_svr), 1e-8)
        svr_trend = recent_svr / denom - 1
        eng.append(svr_trend)
        
        # 3. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 4. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 5. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 6. Short volume acceleration (change in short volume)
        # Captures momentum in short selling activity
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            denom = max(abs(prev_short_vol), 1e-8)
            short_vol_accel = recent_short_vol / denom - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 7. Short interest to implied volatility ratio
        # Relationship between short interest and market's expectation of volatility
        implied_vol = data[t, 65]
        denom = max(abs(implied_vol), 1e-8)
        si_to_implied_vol = short_interest / denom
        eng.append(si_to_implied_vol)
        
        # 8. Price volatility (standard deviation of normalized returns)
        # Improved from previous iteration to use normalized returns
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 9. Price momentum (3-day) - shorter term momentum
        if len(close_prices) >= 3:
            price_momentum_3d = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            price_momentum_3d = 0
        eng.append(price_momentum_3d)
        
        # 10. Price momentum (10-day) - medium term momentum
        if len(close_prices) >= 10:
            price_momentum_10d = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
        else:
            price_momentum_10d = 0
        eng.append(price_momentum_10d)
        
        # 11. Bollinger Band Width (volatility measure)
        # Normalized measure of volatility
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = std / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 12. Gap analysis - overnight price changes can signal sentiment shifts
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gap = open_prices[-1] / max(abs(close_prices[-2]), 1e-8) - 1
        else:
            overnight_gap = 0
        eng.append(overnight_gap)
        
        # 13. Volume trend - increasing volume can signal increasing interest
        if len(total_volume) >= 5:
            recent_vol = np.mean(total_volume[-3:])
            prev_vol = np.mean(total_volume[-5:-3])
            denom = max(abs(prev_vol), 1e-8)
            volume_trend = recent_vol / denom - 1
        else:
            volume_trend = 0
        eng.append(volume_trend)
        
        # 14. Put-call ratio trend - options sentiment indicator
        # Options data provides forward-looking market sentiment
        options_ratio = data[t, 63]
        eng.append(options_ratio)
        
        # 15. High-Low Range relative to price - volatility measure
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_high = np.mean(high_prices[-5:])
            avg_low = np.mean(low_prices[-5:])
            avg_price = (avg_high + avg_low) / 2
            denom = max(abs(avg_price), 1e-8)
            hl_range = (avg_high - avg_low) / denom
        else:
            hl_range = 0
        eng.append(hl_range)
        
        # 16. Short volume to total volume ratio trend
        # Captures changing sentiment in short selling activity
        if len(short_volume_ratio) >= 5:
            recent_ratio = np.mean(short_volume_ratio[-2:])
            prev_ratio = np.mean(short_volume_ratio[-5:-2])
            denom = max(abs(prev_ratio), 1e-8)
            ratio_trend = recent_ratio / denom - 1
        else:
            ratio_trend = 0
        eng.append(ratio_trend)
        
        # 17. Synthetic short cost to implied volatility ratio
        # Relationship between cost of shorting and expected volatility
        synthetic_short_cost = data[t, 64]
        denom = max(abs(implied_vol), 1e-8)
        synthetic_cost_to_iv = synthetic_short_cost / denom
        eng.append(synthetic_cost_to_iv)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 149698.9507
RMSE: 206521.3848
MAPE: 8.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t1: importance=0.0004, rank=1
   2. Feature_1_t3: importance=0.0003, rank=2
   3. Feature_14_t3: importance=0.0002, rank=3
   4. Feature_0_t3: importance=0.0002, rank=4
   5. Feature_13_t3: importance=0.0002, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: +0.05%

📈 Current best MAPE: 8.74%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep short interest and volume metrics
        raw_keep = [
            data[t, 0],  # short interest - highest importance from previous iterations
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        # Feature importance showed recent price data was valuable
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which likely has predictive power for short interest
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding - important for normalization
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent trend in short volume ratio (last 5 days vs previous 10 days)
        # Modified to capture more meaningful trend periods
        if len(short_volume_ratio) >= 15:
            recent_svr = np.mean(short_volume_ratio[-5:])
            previous_svr = np.mean(short_volume_ratio[:-5])
            denom = max(abs(previous_svr), 1e-8)
            svr_trend = recent_svr / denom - 1
        else:
            svr_trend = 0
        eng.append(svr_trend)
        
        # 3. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 4. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 5. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Use exponential moving average for smoother RSI
            avg_gain = np.mean(gain[:13])
            avg_loss = np.mean(loss[:13])
            
            for i in range(13, len(delta)):
                avg_gain = (avg_gain * 13 + gain[i]) / 14
                avg_loss = (avg_loss * 13 + loss[i]) / 14
            
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 6. Short volume acceleration (rate of change in short volume)
        # Captures momentum in short selling activity
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            denom = max(abs(prev_short_vol), 1e-8)
            short_vol_accel = recent_short_vol / denom - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 7. Implied volatility to short interest ratio
        # Relationship between market's expectation of volatility and short interest
        implied_vol = data[t, 65]
        denom = max(abs(short_interest), 1e-8)
        implied_vol_to_si = implied_vol / denom
        eng.append(implied_vol_to_si)
        
        # 8. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 5:
            returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-6:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 9. VWAP (Volume Weighted Average Price) - 5 day
        # Important price level that institutional traders watch
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap_sum = 0
            volume_sum = 0
            for i in range(-5, 0):
                vwap_sum += close_prices[i] * total_volume[i]
                volume_sum += total_volume[i]
            denom = max(abs(volume_sum), 1e-8)
            vwap = vwap_sum / denom
            # Normalize VWAP relative to current price
            denom = max(abs(close_prices[-1]), 1e-8)
            vwap_ratio = vwap / denom - 1
        else:
            vwap_ratio = 0
        eng.append(vwap_ratio)
        
        # 10. Bollinger Band Width (volatility measure)
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            denom = max(abs(sma), 1e-8)
            bb_width = (2 * std) / denom  # 2 standard deviations
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 11. Bollinger Band Position (where price is within the bands)
        # Indicates potential overbought/oversold conditions
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_range = upper_band - lower_band
            denom = max(abs(band_range), 1e-8)
            bb_position = (close_prices[-1] - lower_band) / denom
        else:
            bb_position = 0.5  # Middle of the band
        eng.append(bb_position)
        
        # 12. Short volume trend relative to price trend
        # Captures divergence between short selling activity and price movement
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            short_vol_change = np.mean(short_volume[-2:]) / max(abs(np.mean(short_volume[-5:-2])), 1e-8) - 1
            short_price_divergence = short_vol_change - price_change
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # 13. Options synthetic short cost to put-call ratio
        # Relationship between cost of shorting and options sentiment
        synthetic_short_cost = data[t, 64]
        put_call_ratio = data[t, 63]
        denom = max(abs(put_call_ratio), 1e-8)
        synthetic_cost_to_pc = synthetic_short_cost / denom
        eng.append(synthetic_cost_to_pc)
        
        # 14. Short interest momentum (rate of change)
        # Captures acceleration in short interest
        if t > 0:
            prev_short_interest = data[t-1, 0]
            denom = max(abs(prev_short_interest), 1e-8)
            si_momentum = short_interest / denom - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 15. Average True Range (ATR) - volatility indicator
        # Captures the average range of price movement
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr = np.mean(tr_values)
            # Normalize ATR by price
            denom = max(abs(close_prices[-1]), 1e-8)
            atr_normalized = atr / denom
        else:
            atr_normalized = 0
        eng.append(atr_normalized)
        
        # 16. Short volume concentration (ratio of recent to total)
        # Indicates if short selling is becoming more concentrated recently
        if len(short_volume) >= 15:
            recent_short = np.sum(short_volume[-3:])
            total_short = np.sum(short_volume)
            denom = max(abs(total_short), 1e-8)
            short_concentration = recent_short / denom
        else:
            short_concentration = 0
        eng.append(short_concentration)
        
        # 17. Synthetic short cost trend
        # Captures changes in the cost of shorting
        if t > 0:
            prev_synthetic_cost = data[t-1, 64]
            denom = max(abs(prev_synthetic_cost), 1e-8)
            synthetic_cost_trend = synthetic_short_cost / denom - 1
        else:
            synthetic_cost_trend = 0
        eng.append(synthetic_cost_trend)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - key for liquidity assessment
            data[t, 2],  # days to cover - direct measure of short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent open price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which has predictive power for short interest
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding - important for normalization
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent trend in short volume ratio (last 5 days vs previous 10 days)
        # Modified to capture more recent trend changes
        if len(short_volume_ratio) >= 15:
            recent_svr = np.mean(short_volume_ratio[-5:])
            previous_svr = np.mean(short_volume_ratio[:-5])
            denom = max(abs(previous_svr), 1e-8)
            svr_trend = recent_svr / denom - 1
            eng.append(svr_trend)
        else:
            eng.append(0)
        
        # 3. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 4. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 5. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 6. Short volume acceleration (change in short volume)
        # Captures momentum in short selling activity
        if len(short_volume) >= 6:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-6:-3])
            denom = max(abs(prev_short_vol), 1e-8)
            short_vol_accel = recent_short_vol / denom - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 7. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 5:
            returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-6:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 8. Price momentum (5-day) - medium term momentum
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # 9. Bollinger Band Width (volatility measure)
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = std / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 10. Volume trend - increasing volume can signal increasing interest
        if len(total_volume) >= 6:
            recent_vol = np.mean(total_volume[-3:])
            prev_vol = np.mean(total_volume[-6:-3])
            denom = max(abs(prev_vol), 1e-8)
            volume_trend = recent_vol / denom - 1
        else:
            volume_trend = 0
        eng.append(volume_trend)
        
        # 11. High-Low Range relative to price - volatility measure
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_high = np.mean(high_prices[-5:])
            avg_low = np.mean(low_prices[-5:])
            avg_price = (avg_high + avg_low) / 2
            denom = max(abs(avg_price), 1e-8)
            hl_range = (avg_high - avg_low) / denom
        else:
            hl_range = 0
        eng.append(hl_range)
        
        # 12. Synthetic short cost to implied volatility ratio
        # Relationship between cost of shorting and expected volatility
        synthetic_short_cost = data[t, 64]
        implied_vol = data[t, 65]
        denom = max(abs(implied_vol), 1e-8)
        synthetic_cost_to_iv = synthetic_short_cost / denom
        eng.append(synthetic_cost_to_iv)
        
        # 13. MACD-like indicator (difference between short and long moving averages)
        if len(close_prices) >= 12:
            short_ma = np.mean(close_prices[-5:])
            long_ma = np.mean(close_prices[-12:])
            denom = max(abs(long_ma), 1e-8)
            macd = short_ma / denom - 1
        else:
            macd = 0
        eng.append(macd)
        
        # 14. Short interest change rate (if we have previous data)
        # This is a new feature to capture the rate of change in short interest
        if t > 0:
            prev_short_interest = data[t-1, 0]
            denom = max(abs(prev_short_interest), 1e-8)
            si_change_rate = short_interest / denom - 1
        else:
            si_change_rate = 0
        eng.append(si_change_rate)
        
        # 15. Short volume to total volume ratio weighted by price change
        # This captures the relationship between short selling and price movement
        if len(close_prices) >= 2 and len(short_volume_ratio) >= 1:
            price_change = close_prices[-1] / max(abs(close_prices[-2]), 1e-8) - 1
            weighted_svr = avg_short_volume_ratio * (1 + abs(price_change))
        else:
            weighted_svr = avg_short_volume_ratio
        eng.append(weighted_svr)
        
        # 16. Options implied volatility to historical volatility ratio
        # Captures market expectations vs. realized volatility
        implied_vol = data[t, 65]
        if volatility > 0:
            iv_to_hv = implied_vol / max(volatility, 1e-8)
        else:
            iv_to_hv = implied_vol
        eng.append(iv_to_hv)
        
        # 17. Normalized days to cover (days to cover / historical average)
        # This normalizes the days to cover metric against its historical context
        days_to_cover = data[t, 2]
        if t >= 5:
            historical_dtc = np.mean([data[max(0, t-i), 2] for i in range(1, 6)])
            denom = max(abs(historical_dtc), 1e-8)
            normalized_dtc = days_to_cover / denom
        else:
            normalized_dtc = days_to_cover
        eng.append(normalized_dtc)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 2/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep short interest and volume metrics
        raw_keep = [
            data[t, 0],  # short interest - highest importance from previous iterations
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent open price
        # Feature importance showed recent price data was valuable
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which likely has predictive power for short interest
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent trend in short volume ratio (last 3 days vs previous 12 days)
        # Modified to focus on more recent trend
        if len(short_volume_ratio) >= 5:
            recent_svr = np.mean(short_volume_ratio[-3:])
            previous_svr = np.mean(short_volume_ratio[:-3])
            denom = max(abs(previous_svr), 1e-8)
            svr_trend = recent_svr / denom - 1
            eng.append(svr_trend)
        else:
            eng.append(0)
        
        # 3. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 4. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 5. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 6. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 7. Price momentum (5-day) - medium term momentum
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # 8. Bollinger Band Width (volatility measure)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = std / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 9. Volume trend - increasing volume can signal increasing interest
        if len(total_volume) >= 5:
            recent_vol = np.mean(total_volume[-3:])
            prev_vol = np.mean(total_volume[-5:-3])
            denom = max(abs(prev_vol), 1e-8)
            volume_trend = recent_vol / denom - 1
        else:
            volume_trend = 0
        eng.append(volume_trend)
        
        # 10. High-Low Range relative to price - volatility measure
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_high = np.mean(high_prices[-5:])
            avg_low = np.mean(low_prices[-5:])
            avg_price = (avg_high + avg_low) / 2
            denom = max(abs(avg_price), 1e-8)
            hl_range = (avg_high - avg_low) / denom
        else:
            hl_range = 0
        eng.append(hl_range)
        
        # 11. MACD Signal Line (12-day EMA - 26-day EMA)
        # Momentum indicator showing relationship between two moving averages
        if len(close_prices) >= 12:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA calculation
            if len(close_prices) >= 26:
                ema26 = np.mean(close_prices[-26:])
            else:
                ema26 = np.mean(close_prices)
            macd = ema12 - ema26
            denom = max(abs(close_prices[-1]), 1e-8)
            macd_normalized = macd / denom
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 12. Short volume acceleration (rate of change in short volume)
        if len(short_volume) >= 5:
            recent_short_vol_change = np.mean(short_volume[-2:]) - np.mean(short_volume[-4:-2])
            denom = max(abs(np.mean(short_volume[-4:-2])), 1e-8)
            short_vol_accel = recent_short_vol_change / denom
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 13. Short interest to implied volatility ratio
        implied_vol = data[t, 65]
        denom = max(abs(implied_vol), 1e-8)
        si_to_implied_vol = short_interest / denom
        eng.append(si_to_implied_vol)
        
        # 14. Price gap analysis - overnight price changes
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            gaps = []
            for i in range(1, min(len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[i-1]), 1e-8)
                gap = open_prices[i] / denom - 1
                gaps.append(gap)
            avg_gap = np.mean(gaps) if gaps else 0
        else:
            avg_gap = 0
        eng.append(avg_gap)
        
        # 15. Synthetic short cost to implied volatility ratio
        synthetic_short_cost = data[t, 64]
        denom = max(abs(implied_vol), 1e-8)
        synthetic_cost_to_iv = synthetic_short_cost / denom
        eng.append(synthetic_cost_to_iv)
        
        # 16. Average True Range (ATR) - volatility indicator
        if len(high_prices) >= 2 and len(low_prices) >= 2 and len(close_prices) >= 2:
            tr_values = []
            for i in range(1, min(len(high_prices), len(low_prices), len(close_prices))):
                tr1 = high_prices[i] - low_prices[i]
                tr2 = abs(high_prices[i] - close_prices[i-1])
                tr3 = abs(low_prices[i] - close_prices[i-1])
                tr = max(tr1, tr2, tr3)
                tr_values.append(tr)
            atr = np.mean(tr_values) if tr_values else 0
            denom = max(abs(close_prices[-1]), 1e-8)
            atr_normalized = atr / denom
        else:
            atr_normalized = 0
        eng.append(atr_normalized)
        
        # 17. Short volume trend vs price trend correlation
        if len(short_volume) >= 5 and len(close_prices) >= 5:
            short_vol_changes = np.diff(short_volume[-5:])
            price_changes = np.diff(close_prices[-5:])
            
            if len(short_vol_changes) > 0 and len(price_changes) > 0:
                # Calculate correlation manually to avoid potential issues with np.corrcoef
                mean_sv_change = np.mean(short_vol_changes)
                mean_price_change = np.mean(price_changes)
                
                numerator = np.sum((short_vol_changes - mean_sv_change) * (price_changes - mean_price_change))
                denom1 = np.sqrt(np.sum((short_vol_changes - mean_sv_change)**2))
                denom2 = np.sqrt(np.sum((price_changes - mean_price_change)**2))
                
                denom = max(abs(denom1 * denom2), 1e-8)
                correlation = numerator / denom
            else:
                correlation = 0
        else:
            correlation = 0
        eng.append(correlation)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 148348.9769
RMSE: 211253.9104
MAPE: 8.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0003, rank=1
   2. Feature_0_t3: importance=0.0002, rank=2
   3. Feature_24_t0: importance=0.0002, rank=3
   4. Feature_1_t3: importance=0.0002, rank=4
   5. Feature_19_t3: importance=0.0002, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: +0.05%

📈 Current best MAPE: 8.74%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - highest importance from previous iterations
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short volume trend - NEW: Weighted recent trend (more weight to recent days)
        if len(short_volume) >= 5:
            weights = np.array([0.1, 0.15, 0.2, 0.25, 0.3])  # More weight to recent days
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights * short_volume[-5:].mean())
            weighted_short_vol_trend = weighted_short_vol_trend - 1  # Normalize around 0
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Short volume to price change correlation - NEW: Improved calculation
        if len(short_volume) >= 5 and len(close_prices) >= 6:
            # Calculate daily price changes
            price_changes = np.diff(close_prices[-6:])
            # Use short volume from the same days as price changes
            sv_subset = short_volume[-5:]
            
            # Normalize both series to make correlation more meaningful
            norm_price_changes = (price_changes - np.mean(price_changes)) / (np.std(price_changes) + 1e-8)
            norm_sv = (sv_subset - np.mean(sv_subset)) / (np.std(sv_subset) + 1e-8)
            
            # Calculate dot product for correlation
            corr_num = np.sum(norm_price_changes * norm_sv)
            corr_denom = max(len(price_changes), 1)
            sv_price_corr = corr_num / corr_denom
        else:
            sv_price_corr = 0
        eng.append(sv_price_corr)
        
        # 8. Bollinger Band Position - NEW: Position within the bands instead of width
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - NEW: Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - NEW: Combined options metrics
        # Combines put/call ratio with implied volatility to gauge market sentiment
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        options_pressure = put_call_ratio * implied_vol / (max(abs(np.mean([put_call_ratio, implied_vol])), 1e-8))
        eng.append(options_pressure)
        
        # 11. Price Gap Analysis - Improved: Focus on significant gaps
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            gaps = []
            for i in range(1, min(len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[i-1]), 1e-8)
                gap = open_prices[i] / denom - 1
                gaps.append(gap)
            
            # Only consider significant gaps (>0.5%)
            sig_gaps = [g for g in gaps if abs(g) > 0.005]
            avg_sig_gap = np.mean(sig_gaps) if sig_gaps else 0
        else:
            avg_sig_gap = 0
        eng.append(avg_sig_gap)
        
        # 12. Volume Spike Indicator - NEW: Detect unusual volume activity
        if len(total_volume) >= 10:
            recent_vol = total_volume[-1]
            avg_vol = np.mean(total_volume[-10:])
            denom = max(abs(avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 13. Short Squeeze Potential - NEW: Combined metric for squeeze likelihood
        # Combines short interest, volume, and days to cover
        if short_interest > 0 and avg_volume > 0:
            squeeze_potential = (short_interest / (max(abs(shares_outstanding), 1e-8))) * days_to_cover * (1 + volatility)
            # Normalize to a more reasonable range
            squeeze_potential = np.tanh(squeeze_potential)  # Bound between -1 and 1
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 14. Price Trend Strength - NEW: Directional movement strength
        if len(close_prices) >= 10:
            # Calculate linear regression slope
            x = np.arange(10)
            y = close_prices[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope manually
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average price
            trend_strength = slope / (max(abs(mean_y), 1e-8))
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 15. Short Volume Concentration - NEW: Measure of short volume clustering
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-5:]
            max_short_vol = np.max(recent_short_vol)
            min_short_vol = np.min(recent_short_vol)
            mean_short_vol = np.mean(recent_short_vol)
            denom = max(abs(mean_short_vol), 1e-8)
            # Higher values indicate more concentrated short volume
            short_vol_concentration = (max_short_vol - min_short_vol) / denom
        else:
            short_vol_concentration = 0
        eng.append(short_vol_concentration)
        
        # 16. Synthetic Short Cost Efficiency - NEW: Cost effectiveness of shorting
        synthetic_short_cost = data[t, 64]
        denom = max(abs(short_interest_to_float), 1e-8)
        short_cost_efficiency = synthetic_short_cost / denom
        eng.append(short_cost_efficiency)
        
        # 17. Market Sentiment Indicator - NEW: Combined price and volume sentiment
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = close_prices[-1] / (max(abs(close_prices[-5]), 1e-8)) - 1
            volume_change = total_volume[-1] / (max(abs(np.mean(total_volume[-5:])), 1e-8)) - 1
            
            # Positive when price and volume move together, negative when they diverge
            sentiment = price_change * volume_change
            # Apply sigmoid-like transformation
            market_sentiment = np.tanh(3 * sentiment)
        else:
            market_sentiment = 0
        eng.append(market_sentiment)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 145572.7898
RMSE: 205460.5567
MAPE: 8.48%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0004, rank=1
   2. Feature_24_t2: importance=0.0002, rank=2
   3. Feature_18_t2: importance=0.0002, rank=3
   4. Feature_9_t3: importance=0.0002, rank=4
   5. Feature_0_t3: importance=0.0002, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.26%

📈 Current best MAPE: 8.48%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - consistently high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent open price
        # These were identified as important in previous iterations
        raw_keep.append(close_prices[-1])  # Most recent close price
        raw_keep.append(open_prices[-1])   # Most recent open price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days) - more weight to recent activity
        if len(short_volume_ratio) >= 5:
            recent_svr = np.mean(short_volume_ratio[-5:])
        else:
            recent_svr = np.mean(short_volume_ratio)
        eng.append(recent_svr)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Improved Short Squeeze Potential Indicator
        # Combines short interest to float with days to cover and volatility
        days_to_cover = data[t, 2]
        
        # Calculate price volatility over the last 10 days
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = np.std(np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)) if len(close_prices) >= 2 else 0
        
        # Squeeze potential formula: higher when short interest, days to cover, and volatility are all high
        squeeze_potential = short_interest_to_float * days_to_cover * (1 + volatility)
        # Normalize with tanh to keep within reasonable bounds
        squeeze_potential = np.tanh(squeeze_potential)
        eng.append(squeeze_potential)
        
        # 4. RSI (Relative Strength Index) - 14 period or as many as available
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 3:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
            # Normalize to [-1, 1] range where 0 is neutral (RSI = 50)
            rsi_normalized = (rsi - 50) / 50
        else:
            rsi_normalized = 0
        eng.append(rsi_normalized)
        
        # 5. Short Volume Trend - Exponentially weighted recent trend
        # Gives more weight to recent days to capture acceleration/deceleration in shorting
        if len(short_volume) >= 5:
            # Exponential weights (more recent = higher weight)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol = np.sum(weights * short_volume[-5:])
            avg_short_vol = np.mean(short_volume[-5:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_trend = weighted_short_vol / denom - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 6. Price Momentum - Rate of change over different timeframes
        # Short-term momentum (3 days)
        if len(close_prices) >= 3:
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            short_momentum = 0
        eng.append(short_momentum)
        
        # 7. Medium-term momentum (7 days)
        if len(close_prices) >= 7:
            medium_momentum = close_prices[-1] / max(abs(close_prices[-7]), 1e-8) - 1
        else:
            medium_momentum = 0
        eng.append(medium_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: -1 = at/below lower band, 0 = at middle, 1 = at/above upper band
            bb_position = 2 * ((close_prices[-1] - lower_band) / denom) - 1
            # Clamp to [-1, 1] range
            bb_position = max(min(bb_position, 1), -1)
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Options Pressure Indicator - Combined options metrics
        # Combines put/call ratio with implied volatility to gauge market sentiment
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Higher values indicate bearish sentiment with high volatility
        options_pressure = (put_call_ratio - 1) * implied_vol
        # Normalize with tanh
        options_pressure = np.tanh(options_pressure)
        eng.append(options_pressure)
        
        # 10. Volume Spike Indicator - Detect unusual volume activity
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-3:])  # Average of last 3 days
            baseline_vol = np.mean(total_volume[-10:-3])  # Average of previous 7 days
            denom = max(abs(baseline_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = np.tanh(2 * vol_spike)
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 11. Price Trend Strength - Directional movement strength
        if len(close_prices) >= 10:
            # Calculate linear regression slope
            x = np.arange(10)
            y = close_prices[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope manually
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average price
            trend_strength = slope / (max(abs(mean_y), 1e-8))
            # Apply tanh to normalize
            trend_strength = np.tanh(5 * trend_strength)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 12. Short Volume to Price Correlation - Improved calculation
        if len(short_volume) >= 5 and len(close_prices) >= 6:
            # Calculate daily price changes
            price_changes = np.diff(close_prices[-6:])
            # Use short volume from the same days as price changes
            sv_subset = short_volume[-5:]
            
            # Calculate correlation coefficient manually to avoid instability
            price_mean = np.mean(price_changes)
            sv_mean = np.mean(sv_subset)
            
            price_dev = price_changes - price_mean
            sv_dev = sv_subset - sv_mean
            
            numerator = np.sum(price_dev * sv_dev)
            denom1 = max(abs(np.sqrt(np.sum(price_dev**2))), 1e-8)
            denom2 = max(abs(np.sqrt(np.sum(sv_dev**2))), 1e-8)
            
            correlation = numerator / (denom1 * denom2)
            # Bound to [-1, 1] range
            correlation = max(min(correlation, 1), -1)
        else:
            correlation = 0
        eng.append(correlation)
        
        # 13. Short Interest Velocity - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        # We approximate this using days to cover and volume metrics
        short_interest_velocity = days_to_cover * recent_svr - 1
        eng.append(short_interest_velocity)
        
        # 14. Gap Analysis - Improved focus on recent significant gaps
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = []
            for i in range(1, 5):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1])
            weighted_gap = np.sum(weights * np.array(gaps))
            # Apply tanh to normalize
            weighted_gap = np.tanh(5 * weighted_gap)
        else:
            weighted_gap = 0
        eng.append(weighted_gap)
        
        # 15. Market Sentiment Indicator - Combined price and volume sentiment
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Price trend
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            # Volume trend
            volume_change = total_volume[-1] / max(abs(np.mean(total_volume[-5:])), 1e-8) - 1
            
            # Positive when price and volume move together, negative when they diverge
            sentiment = price_change * np.sign(volume_change) * np.abs(volume_change)**0.5
            # Apply tanh to normalize
            market_sentiment = np.tanh(3 * sentiment)
        else:
            market_sentiment = 0
        eng.append(market_sentiment)
        
        # 16. MACD Signal - Moving Average Convergence Divergence
        if len(close_prices) >= 12:
            # Simple implementation with shorter windows due to data constraints
            ema_fast = np.mean(close_prices[-6:])  # Approximating 6-day EMA
            ema_slow = np.mean(close_prices[-12:])  # Approximating 12-day EMA
            
            macd = ema_fast - ema_slow
            # Normalize by the slow EMA
            denom = max(abs(ema_slow), 1e-8)
            macd_normalized = macd / denom
            # Apply tanh to normalize
            macd_signal = np.tanh(5 * macd_normalized)
        else:
            macd_signal = 0
        eng.append(macd_signal)
        
        # 17. Volatility Ratio - Compare recent volatility to historical
        if len(close_prices) >= 10:
            # Recent volatility (last 5 days)
            recent_returns = np.diff(close_prices[-6:]) / np.maximum(close_prices[-6:-1], 1e-8)
            recent_vol = np.std(recent_returns)
            
            # Historical volatility (previous 5 days)
            hist_returns = np.diff(close_prices[-11:-6]) / np.maximum(close_prices[-11:-6], 1e-8)
            hist_vol = np.std(hist_returns)
            
            # Volatility ratio
            denom = max(abs(hist_vol), 1e-8)
            vol_ratio = recent_vol / denom - 1
            # Apply tanh to normalize
            vol_ratio = np.tanh(2 * vol_ratio)
        else:
            vol_ratio = 0
        eng.append(vol_ratio)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - highest importance from previous iterations
            data[t, 1],  # average daily volume - consistently important
            data[t, 2],  # days to cover - key metric for short interest analysis
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the close price 5 days ago for trend analysis
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        # Improved: Use exponentially weighted volatility to emphasize recent price movements
        if len(close_prices) >= 5:
            returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-6:-1], 1e-8)
            # Apply exponential weights (more weight to recent volatility)
            weights = np.array([0.1, 0.15, 0.2, 0.25, 0.3])[:len(returns)]
            weights = weights / np.sum(weights)
            weighted_returns = returns * weights
            volatility = np.sqrt(np.sum(weighted_returns**2))
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short volume trend - Improved: Use exponential smoothing for trend detection
        if len(short_volume) >= 5:
            # Calculate exponentially weighted moving average
            alpha = 0.3  # Smoothing factor
            ewma = short_volume[-5]
            for i in range(-4, 0):
                ewma = alpha * short_volume[i] + (1 - alpha) * ewma
            
            # Calculate trend as percentage change from 5-day average
            avg_short_vol = np.mean(short_volume[-5:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_trend = (ewma / denom) - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 7. Price momentum - NEW: Improved momentum calculation with normalization
        if len(close_prices) >= 10:
            # Calculate momentum as ratio of recent prices to earlier prices
            recent_avg = np.mean(close_prices[-3:])
            earlier_avg = np.mean(close_prices[-10:-3])
            denom = max(abs(earlier_avg), 1e-8)
            price_momentum = (recent_avg / denom) - 1
            
            # Apply tanh transformation to normalize to [-1, 1] range
            price_momentum = np.tanh(2 * price_momentum)
        else:
            price_momentum = 0
        eng.append(price_momentum)
        
        # 8. Bollinger Band Position - Improved: Normalized position within bands
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Improved: Compare to historical average
        days_to_cover = data[t, 2]
        # Calculate historical average days to cover (assuming we have at least 3 timesteps)
        if t >= 3:
            hist_days_to_cover = np.mean([data[max(0, t-i), 2] for i in range(1, 4)])
            denom = max(abs(hist_days_to_cover), 1e-8)
            short_interest_momentum = days_to_cover / denom - 1
        else:
            short_interest_momentum = 0
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved: Weighted combination
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        synthetic_short_cost = data[t, 64]
        
        # Normalize each component
        norm_pcr = np.tanh(put_call_ratio - 1)  # Center around 0
        norm_iv = np.tanh(implied_vol / 0.3 - 1)  # Assuming 30% IV as baseline
        norm_cost = np.tanh(synthetic_short_cost - 0.02)  # Assuming 2% as baseline cost
        
        # Weighted combination (higher weight to put/call ratio)
        options_pressure = 0.5 * norm_pcr + 0.3 * norm_iv + 0.2 * norm_cost
        eng.append(options_pressure)
        
        # 11. Short Squeeze Potential - Improved: More comprehensive metric
        if short_interest > 0 and avg_volume > 0:
            # Components of squeeze potential:
            # 1. High short interest relative to float
            # 2. High days to cover
            # 3. Recent price momentum
            # 4. Increased volatility
            
            si_component = short_interest_to_float * 10  # Scale up for better weighting
            dtc_component = min(days_to_cover / 5, 2)  # Cap at 2x
            momentum_component = price_momentum if 'price_momentum' in locals() else 0
            vol_component = min(volatility * 10, 2)  # Cap at 2x
            
            # Combined metric
            squeeze_potential = (si_component * dtc_component) * (1 + momentum_component) * (1 + vol_component)
            
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential)
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 12. Volume Trend Divergence - NEW: Detect divergence between price and volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate price trend
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            
            # Calculate volume trend
            vol_change = total_volume[-1] / max(abs(np.mean(total_volume[-5:])), 1e-8) - 1
            
            # Divergence occurs when price and volume move in opposite directions
            # Positive divergence: price up, volume down (potential reversal)
            # Negative divergence: price down, volume up (potential reversal)
            divergence = price_change * (-vol_change)
            
            # Apply sigmoid-like transformation to emphasize strong divergences
            vol_price_divergence = np.tanh(3 * divergence)
        else:
            vol_price_divergence = 0
        eng.append(vol_price_divergence)
        
        # 13. Short Volume Acceleration - NEW: Rate of change in short volume
        if len(short_volume) >= 10:
            recent_short_vol = np.mean(short_volume[-3:])
            earlier_short_vol = np.mean(short_volume[-10:-3])
            denom = max(abs(earlier_short_vol), 1e-8)
            short_vol_acceleration = (recent_short_vol / denom) - 1
            
            # Normalize with tanh
            short_vol_acceleration = np.tanh(2 * short_vol_acceleration)
        else:
            short_vol_acceleration = 0
        eng.append(short_vol_acceleration)
        
        # 14. Price Gap Analysis - Improved: Focus on overnight gaps
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            # Calculate overnight gaps (today's open vs yesterday's close)
            gaps = []
            for i in range(1, 5):
                if i < len(open_prices) and i-1 < len(close_prices):
                    denom = max(abs(close_prices[-i-1]), 1e-8)
                    gap = open_prices[-i] / denom - 1
                    gaps.append(gap)
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1])[:len(gaps)]
            weights = weights / np.sum(weights)
            weighted_gap = np.sum(np.array(gaps) * weights) if gaps else 0
            
            # Apply sigmoid-like transformation
            gap_indicator = np.tanh(5 * weighted_gap)
        else:
            gap_indicator = 0
        eng.append(gap_indicator)
        
        # 15. Short Interest Efficiency - NEW: Relationship between short interest and price impact
        # Measures how much price movement is achieved per unit of short interest
        if t >= 1 and short_interest > 0:
            prev_short_interest = data[max(0, t-1), 0]
            denom = max(abs(prev_short_interest), 1e-8)
            si_change = short_interest / denom - 1
            
            if len(close_prices) >= 2:
                price_change = close_prices[-1] / max(abs(close_prices[-2]), 1e-8) - 1
                
                # Efficiency = price change per unit of short interest change
                # Negative values mean short interest is effective (price drops as SI increases)
                denom = max(abs(si_change), 1e-8)
                si_efficiency = price_change / denom
                
                # Normalize with tanh
                si_efficiency = np.tanh(2 * si_efficiency)
            else:
                si_efficiency = 0
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 16. Volatility-Adjusted Short Interest - NEW: SI normalized by volatility
        # Higher values indicate more short interest relative to natural price volatility
        if volatility > 0:
            vol_adjusted_si = short_interest_to_float / max(abs(volatility), 1e-8)
            # Normalize to reasonable range
            vol_adjusted_si = np.tanh(vol_adjusted_si / 2)
        else:
            vol_adjusted_si = 0
        eng.append(vol_adjusted_si)
        
        # 17. Short Volume Concentration - Improved: Measure of short volume clustering
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-5:]
            # Gini-like coefficient to measure concentration
            sorted_vol = np.sort(recent_short_vol)
            n = len(sorted_vol)
            indices = np.arange(1, n+1)
            concentration = np.sum((2 * indices - n - 1) * sorted_vol) / (n * np.sum(sorted_vol))
            
            # Scale to [0, 1] range
            short_vol_concentration = (concentration + 1) / 2
        else:
            short_vol_concentration = 0.5  # Default to middle value
        eng.append(short_vol_concentration)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 2/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        shares_outstanding = data[t, 66]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short volume trend - Exponentially weighted recent trend
        # Improved: Use exponential weighting for more emphasis on recent data
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Price Momentum - Improved: Rate of change in price over multiple timeframes
        if len(close_prices) >= 10:
            # Short-term momentum (3-day)
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
            # Medium-term momentum (5-day)
            medium_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            # Long-term momentum (10-day)
            long_momentum = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
            
            # Combined momentum indicator with more weight to recent momentum
            combined_momentum = 0.5 * short_momentum + 0.3 * medium_momentum + 0.2 * long_momentum
        else:
            combined_momentum = 0
        eng.append(combined_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - NEW: Improved options sentiment metric
        # Combines put/call ratio with implied volatility and normalizes better
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        # Normalize implied vol against its typical range (assuming 0.2-0.6 is typical)
        normalized_iv = (implied_vol - 0.4) / 0.2  # Center around 0
        # Combined indicator: positive = bearish pressure, negative = bullish
        options_pressure = normalized_pc_ratio * (1 + abs(normalized_iv))
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator - Detect unusual volume activity
        if len(total_volume) >= 10:
            recent_vol = total_volume[-1]
            avg_vol = np.mean(total_volume[-10:])
            denom = max(abs(avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Combined metric for squeeze likelihood
        # Improved: Better normalization and incorporation of price momentum
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential
            base_squeeze = (short_interest / (max(abs(shares_outstanding), 1e-8))) * days_to_cover
            
            # Incorporate volatility and recent price movement
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze potential
                momentum_factor = 1 + max(0, recent_return * 2)
            else:
                momentum_factor = 1
                
            squeeze_potential = base_squeeze * momentum_factor * (1 + volatility)
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential)
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. Price Trend Strength - Directional movement strength
        if len(close_prices) >= 10:
            # Calculate linear regression slope
            x = np.arange(10)
            y = close_prices[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope manually
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average price
            trend_strength = slope / (max(abs(mean_y), 1e-8))
            
            # Apply sigmoid-like transformation to emphasize strong trends
            trend_strength = np.tanh(3 * trend_strength)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 14. Short Volume Concentration - Measure of short volume clustering
        # Improved: Better normalization and focus on recent activity
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-5:]
            max_short_vol = np.max(recent_short_vol)
            min_short_vol = np.min(recent_short_vol)
            mean_short_vol = np.mean(recent_short_vol)
            denom = max(abs(mean_short_vol), 1e-8)
            # Higher values indicate more concentrated short volume
            short_vol_concentration = (max_short_vol - min_short_vol) / denom
            # Normalize to a more reasonable range
            short_vol_concentration = np.tanh(short_vol_concentration)
        else:
            short_vol_concentration = 0
        eng.append(short_vol_concentration)
        
        # 15. Market Sentiment Indicator - Combined price and volume sentiment
        # Improved: Better normalization and incorporation of short volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = close_prices[-1] / (max(abs(close_prices[-5]), 1e-8)) - 1
            volume_change = total_volume[-1] / (max(abs(np.mean(total_volume[-5:])), 1e-8)) - 1
            
            # Incorporate short volume ratio trend
            if len(short_volume_ratio) >= 5:
                sv_ratio_change = short_volume_ratio[-1] / (max(abs(np.mean(short_volume_ratio[-5:])), 1e-8)) - 1
                # Negative sv_ratio_change is bullish, positive is bearish
                sentiment = price_change * volume_change * (1 - sv_ratio_change)
            else:
                sentiment = price_change * volume_change
                
            # Apply sigmoid-like transformation
            market_sentiment = np.tanh(3 * sentiment)
        else:
            market_sentiment = 0
        eng.append(market_sentiment)
        
        # 16. MACD Signal - Moving Average Convergence Divergence
        # New feature: Popular technical indicator for trend changes
        if len(close_prices) >= 12:
            # Simple implementation with shorter windows due to limited data
            ema_fast = np.mean(close_prices[-6:])  # Approximating 6-day EMA
            ema_slow = np.mean(close_prices[-12:])  # Approximating 12-day EMA
            
            # MACD line
            macd_line = ema_fast - ema_slow
            
            # Normalize by average price
            avg_price = np.mean(close_prices[-12:])
            denom = max(abs(avg_price), 1e-8)
            macd_normalized = macd_line / denom
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 17. Short Volume Acceleration - Rate of change in short volume
        # New feature: Captures increasing or decreasing short pressure
        if len(short_volume) >= 5:
            recent_sv = short_volume[-3:]
            if len(recent_sv) >= 2:
                # Calculate first differences
                sv_diff = np.diff(recent_sv)
                # Average acceleration
                sv_accel = np.mean(sv_diff)
                # Normalize by average short volume
                avg_sv = np.mean(recent_sv)
                denom = max(abs(avg_sv), 1e-8)
                sv_accel_normalized = sv_accel / denom
            else:
                sv_accel_normalized = 0
        else:
            sv_accel_normalized = 0
        eng.append(sv_accel_normalized)
        
        # 18. Price Gap Analysis - Focus on significant gaps
        # Improved: Better normalization and focus on recent gaps
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = []
            for i in range(1, min(5, len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Only consider significant gaps (>0.5%)
            sig_gaps = [g for g in gaps if abs(g) > 0.005]
            avg_sig_gap = np.mean(sig_gaps) if sig_gaps else 0
            
            # Apply sigmoid-like transformation for better scaling
            avg_sig_gap = np.tanh(5 * avg_sig_gap)
        else:
            avg_sig_gap = 0
        eng.append(avg_sig_gap)
        
        # 19. Stochastic Oscillator - Momentum indicator
        # New feature: Popular technical indicator for overbought/oversold conditions
        if len(close_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5:
            recent_close = close_prices[-1]
            lowest_low = np.min(low_prices[-5:])
            highest_high = np.max(high_prices[-5:])
            
            # Avoid division by zero
            range_hl = max(abs(highest_high - lowest_low), 1e-8)
            
            # Calculate %K (current close relative to range)
            stoch_k = 100 * (recent_close - lowest_low) / range_hl
            
            # Normalize to [-1, 1] range
            stoch_normalized = (stoch_k / 50) - 1
        else:
            stoch_normalized = 0
        eng.append(stoch_normalized)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 143585.2606
RMSE: 200932.1976
MAPE: 8.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0003, rank=1
   2. Feature_0_t3: importance=0.0002, rank=2
   3. Feature_23_t1: importance=0.0002, rank=3
   4. Feature_12_t3: importance=0.0002, rank=4
   5. Feature_20_t2: importance=0.0002, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: +0.10%

📈 Current best MAPE: 8.48%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the close price 5 days ago
        # This allows us to directly capture medium-term price movement
        raw_keep.append(close_prices[-1])  # Most recent close price
        if len(close_prices) >= 5:
            raw_keep.append(close_prices[-5])  # Close price 5 days ago
        else:
            raw_keep.append(close_prices[0])  # Fallback if not enough data
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        # Improved: Focus on most recent 5 days with exponential weighting
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        if len(short_volume_ratio) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_svr = np.sum(weights * short_volume_ratio[-5:]) / np.sum(weights)
            eng.append(weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Use exponential moving average for smoother RSI
            alpha = 2 / (14 + 1)
            avg_gain = np.mean(gain[:13])
            avg_loss = np.mean(loss[:13])
            
            for i in range(13, len(delta)):
                avg_gain = (1 - alpha) * avg_gain + alpha * gain[i]
                avg_loss = (1 - alpha) * avg_loss + alpha * loss[i]
            
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
            
            # Normalize to [-1, 1] range
            rsi_normalized = (rsi / 50) - 1
        else:
            rsi_normalized = 0
        eng.append(rsi_normalized)
        
        # 5. Price volatility (standard deviation of normalized returns)
        # Improved: Use exponentially weighted volatility for more recent emphasis
        if len(close_prices) >= 10:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Exponential weights for more recent emphasis
            weights = np.exp(np.linspace(0, 1, len(returns)))
            weights = weights / np.sum(weights)
            
            # Weighted volatility calculation
            weighted_variance = np.sum(weights * (returns - np.mean(returns))**2)
            volatility = np.sqrt(weighted_variance)
            
            # Apply sigmoid-like transformation for better scaling
            volatility_normalized = np.tanh(5 * volatility)
        else:
            volatility_normalized = 0
        eng.append(volatility_normalized)
        
        # 6. Short Volume Trend - Improved with regression slope
        # This captures the direction and strength of short volume changes
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-5:]
            x = np.arange(len(recent_short_vol))
            
            # Calculate linear regression slope manually
            mean_x = np.mean(x)
            mean_y = np.mean(recent_short_vol)
            numerator = np.sum((x - mean_x) * (recent_short_vol - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average short volume
            denom = max(abs(mean_y), 1e-8)
            short_vol_trend = slope / denom
            
            # Apply sigmoid-like transformation
            short_vol_trend = np.tanh(3 * short_vol_trend)
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 7. Price Momentum - Improved with multiple timeframes and adaptive weighting
        if len(close_prices) >= 10:
            # Calculate returns over different timeframes
            ret_3d = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1 if len(close_prices) >= 3 else 0
            ret_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1 if len(close_prices) >= 5 else 0
            ret_10d = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1 if len(close_prices) >= 10 else 0
            
            # Adaptive weighting based on volatility
            if volatility_normalized > 0.5:
                # During high volatility, focus more on short-term momentum
                weights = [0.6, 0.3, 0.1]
            else:
                # During low volatility, give more weight to longer-term trends
                weights = [0.2, 0.3, 0.5]
                
            momentum = weights[0] * ret_3d + weights[1] * ret_5d + weights[2] * ret_10d
            
            # Apply sigmoid-like transformation
            momentum_normalized = np.tanh(3 * momentum)
        else:
            momentum_normalized = 0
        eng.append(momentum_normalized)
        
        # 8. Bollinger Band Width - Measure of volatility
        # New feature: Captures expanding/contracting volatility which often precedes significant moves
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            
            # Calculate band width relative to price
            denom = max(abs(sma), 1e-8)
            bb_width = (4 * std) / denom  # 4 * std = distance between upper and lower bands
            
            # Normalize with tanh
            bb_width_normalized = np.tanh(5 * bb_width)
        else:
            bb_width_normalized = 0
        eng.append(bb_width_normalized)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        # Improved: Incorporate days to cover for better context
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover * short_interest_to_volume
        
        # Normalize with tanh
        short_interest_momentum = np.tanh(short_interest_momentum)
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved options sentiment metric
        # Combines put/call ratio with implied volatility for better signal
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Log-transform put/call ratio to center around 0 (1.0 becomes 0)
        log_pc_ratio = np.log(max(put_call_ratio, 1e-8))
        
        # Scale implied vol to typical range
        scaled_iv = (implied_vol - 0.2) / 0.4  # Assuming 0.2-0.6 is typical range
        
        # Combined indicator: positive = bearish pressure, negative = bullish
        # Higher implied vol amplifies the signal
        options_pressure = log_pc_ratio * (1 + abs(scaled_iv))
        
        # Normalize with tanh
        options_pressure = np.tanh(options_pressure)
        eng.append(options_pressure)
        
        # 11. Volume Spike Detection - Improved with exponential smoothing
        # Better at detecting significant volume anomalies
        if len(total_volume) >= 10:
            # Calculate exponentially weighted moving average of volume
            alpha = 0.3  # Smoothing factor
            ema_vol = total_volume[-10]
            for i in range(-9, 0):
                ema_vol = (1 - alpha) * ema_vol + alpha * total_volume[i]
            
            # Calculate relative volume spike
            recent_vol = total_volume[-1]
            denom = max(abs(ema_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = np.tanh(3 * vol_spike)
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Improved composite metric
        # Combines multiple factors that contribute to short squeeze likelihood
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential factors
            si_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
            dtc = days_to_cover
            
            # Incorporate price momentum (positive momentum increases squeeze potential)
            price_momentum = momentum_normalized if 'momentum_normalized' in locals() else 0
            momentum_factor = 1 + max(0, price_momentum)
            
            # Incorporate volume (volume spikes increase squeeze potential)
            volume_factor = 1 + max(0, vol_spike_indicator)
            
            # Combine factors with appropriate weighting
            squeeze_potential = (si_ratio * 0.4 + dtc * 0.3) * momentum_factor * volume_factor
            
            # Normalize with tanh
            squeeze_potential = np.tanh(squeeze_potential * 3)
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. MACD Signal - Moving Average Convergence Divergence
        # Improved implementation with signal line crossover
        if len(close_prices) >= 12:
            # Calculate fast and slow EMAs
            fast_period = 6
            slow_period = 12
            signal_period = 3
            
            # Simple approximation of EMAs
            ema_fast = np.mean(close_prices[-fast_period:])
            ema_slow = np.mean(close_prices[-slow_period:])
            
            # MACD line
            macd_line = ema_fast - ema_slow
            
            # Signal line (EMA of MACD)
            if len(close_prices) >= slow_period + signal_period:
                # Approximate signal line with simple average
                macd_history = []
                for i in range(signal_period):
                    idx = -(i+1)
                    fast_ema = np.mean(close_prices[idx-fast_period:idx])
                    slow_ema = np.mean(close_prices[idx-slow_period:idx])
                    macd_history.append(fast_ema - slow_ema)
                signal_line = np.mean(macd_history)
                
                # MACD histogram (difference between MACD and signal line)
                macd_hist = macd_line - signal_line
                
                # Normalize by average price
                avg_price = np.mean(close_prices[-slow_period:])
                denom = max(abs(avg_price), 1e-8)
                macd_normalized = macd_hist / denom
            else:
                # If not enough data for signal line, just normalize MACD
                avg_price = np.mean(close_prices[-slow_period:])
                denom = max(abs(avg_price), 1e-8)
                macd_normalized = macd_line / denom
            
            # Apply sigmoid-like transformation
            macd_normalized = np.tanh(10 * macd_normalized)
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 14. Short Volume to Price Correlation - New feature
        # Measures relationship between short volume and price movements
        if len(short_volume) >= 5 and len(close_prices) >= 5:
            recent_short_vol = short_volume[-5:]
            recent_prices = close_prices[-5:]
            
            # Calculate correlation manually to avoid np.corrcoef instability
            mean_sv = np.mean(recent_short_vol)
            mean_price = np.mean(recent_prices)
            
            numerator = np.sum((recent_short_vol - mean_sv) * (recent_prices - mean_price))
            denom_sv = max(abs(np.sqrt(np.sum((recent_short_vol - mean_sv)**2))), 1e-8)
            denom_price = max(abs(np.sqrt(np.sum((recent_prices - mean_price)**2))), 1e-8)
            
            correlation = numerator / (denom_sv * denom_price)
            
            # Bound correlation to [-1, 1] range
            correlation = max(min(correlation, 1.0), -1.0)
        else:
            correlation = 0
        eng.append(correlation)
        
        # 15. Price Gap Analysis - Focus on overnight gaps
        # Improved to detect significant gaps that might signal reversals
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            # Calculate overnight gaps (today's open vs yesterday's close)
            gaps = []
            for i in range(1, min(5, len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1, 0.0])[:len(gaps)]
            weights = weights / np.sum(weights)
            
            weighted_gap = np.sum(gaps * weights)
            
            # Apply sigmoid-like transformation
            gap_indicator = np.tanh(10 * weighted_gap)
        else:
            gap_indicator = 0
        eng.append(gap_indicator)
        
        # 16. Stochastic Oscillator - Momentum indicator
        # Improved with smoother calculation and better normalization
        if len(close_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5:
            # Use 5-day stochastic for more responsiveness
            period = 5
            recent_close = close_prices[-1]
            lowest_low = np.min(low_prices[-period:])
            highest_high = np.max(high_prices[-period:])
            
            # Avoid division by zero
            range_hl = max(abs(highest_high - lowest_low), 1e-8)
            
            # Calculate %K (current close relative to range)
            stoch_k = 100 * (recent_close - lowest_low) / range_hl
            
            # Calculate %D (3-day SMA of %K)
            if len(close_prices) >= period + 2:
                stoch_k_history = []
                for i in range(3):
                    idx = -(i+1)
                    recent_k_close = close_prices[idx]
                    k_lowest_low = np.min(low_prices[idx-period+1:idx+1])
                    k_highest_high = np.max(high_prices[idx-period+1:idx+1])
                    k_range = max(abs(k_highest_high - k_lowest_low), 1e-8)
                    k_value = 100 * (recent_k_close - k_lowest_low) / k_range
                    stoch_k_history.append(k_value)
                stoch_d = np.mean(stoch_k_history)
                
                # Stochastic oscillator signal: difference between %K and %D
                stoch_signal = stoch_k - stoch_d
            else:
                stoch_signal = 0
            
            # Normalize to [-1, 1] range
            stoch_normalized = stoch_signal / 50
            stoch_normalized = max(min(stoch_normalized, 1.0), -1.0)
        else:
            stoch_normalized = 0
        eng.append(stoch_normalized)
        
        # 17. Average True Range (ATR) - Volatility indicator
        # New feature: Measures market volatility which affects short covering
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            true_ranges = []
            
            # Calculate true range for the most recent 5 days
            for i in range(1, min(5, len(high_prices), len(low_prices), len(close_prices))):
                # True range is the greatest of:
                # 1. Current high - current low
                # 2. |Current high - previous close|
                # 3. |Current low - previous close|
                tr1 = high_prices[-i] - low_prices[-i]
                tr2 = abs(high_prices[-i] - close_prices[-i-1])
                tr3 = abs(low_prices[-i] - close_prices[-i-1])
                true_range = max(tr1, tr2, tr3)
                true_ranges.append(true_range)
            
            # Calculate ATR (average of true ranges)
            atr = np.mean(true_ranges)
            
            # Normalize by average price
            avg_price = np.mean(close_prices[-5:])
            denom = max(abs(avg_price), 1e-8)
            atr_normalized = atr / denom
            
            # Apply sigmoid-like transformation
            atr_normalized = np.tanh(5 * atr_normalized)
        else:
            atr_normalized = 0
        eng.append(atr_normalized)
        
        # 18. Short Volume Intensity - New composite metric
        # Combines short volume with price action for better signal
        if len(short_volume) >= 5 and len(close_prices) >= 5:
            # Recent short volume ratio
            recent_svr = short_volume_ratio[-1] if len(short_volume_ratio) > 0 else 0
            
            # Recent price change
            recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1 if len(close_prices) >= 5 else 0
            
            # Short volume intensity increases when:
            # 1. High short volume ratio AND
            # 2. Price is falling (negative return)
            intensity = recent_svr * (1 - recent_return)
            
            # Apply sigmoid-like transformation
            short_intensity = np.tanh(3 * intensity)
        else:
            short_intensity = 0
        eng.append(short_intensity)
        
        # 19. Relative Short Interest - New feature
        # Compares current short interest to its recent history
        short_interest = data[t, 0]
        days_to_cover = data[t, 2]
        
        # Combine short interest with days to cover for a more comprehensive metric
        combined_si = short_interest * days_to_cover
        
        # Normalize with sigmoid-like transformation
        relative_si = np.tanh(0.1 * combined_si)
        eng.append(relative_si)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: zero-size array to reduction operation minimum which has no identity
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent open price
        raw_keep.append(close_prices[-1])  # Most recent close price
        raw_keep.append(open_prices[-1])   # Most recent open price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short volume trend - Exponentially weighted recent trend
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Price Momentum - Rate of change in price over multiple timeframes
        # Improved: Focus on short-term momentum which showed higher importance
        if len(close_prices) >= 5:
            # Short-term momentum (3-day)
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
            # Medium-term momentum (5-day)
            medium_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            
            # Combined momentum indicator with more weight to recent momentum
            combined_momentum = 0.7 * short_momentum + 0.3 * medium_momentum
        else:
            combined_momentum = 0
        eng.append(combined_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved options sentiment metric
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        # Normalize implied vol against its typical range
        normalized_iv = (implied_vol - 0.4) / max(0.2, 1e-8)  # Center around 0
        # Combined indicator: positive = bearish pressure, negative = bullish
        options_pressure = normalized_pc_ratio * (1 + abs(normalized_iv))
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator - Detect unusual volume activity
        if len(total_volume) >= 10:
            recent_vol = total_volume[-1]
            avg_vol = np.mean(total_volume[-10:])
            denom = max(abs(avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Combined metric for squeeze likelihood
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential
            base_squeeze = (short_interest / (max(abs(shares_outstanding), 1e-8))) * days_to_cover
            
            # Incorporate volatility and recent price movement
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze potential
                momentum_factor = 1 + max(0, recent_return * 2)
            else:
                momentum_factor = 1
                
            squeeze_potential = base_squeeze * momentum_factor * (1 + volatility)
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential)
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. Price Trend Strength - Directional movement strength
        # NEW: Improved with more robust calculation
        if len(close_prices) >= 10:
            # Calculate linear regression slope
            x = np.arange(10)
            y = close_prices[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope manually
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average price
            trend_strength = slope / (max(abs(mean_y), 1e-8))
            
            # Apply sigmoid-like transformation to emphasize strong trends
            trend_strength = np.tanh(3 * trend_strength)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 14. Short Volume Acceleration - Rate of change in short volume
        # Improved: More robust calculation with better normalization
        if len(short_volume) >= 5:
            recent_sv = short_volume[-5:]
            if len(recent_sv) >= 3:
                # Calculate first differences
                sv_diff = np.diff(recent_sv)
                # Average acceleration (second difference)
                sv_accel = np.diff(sv_diff) if len(sv_diff) >= 2 else np.array([0])
                # Normalize by average short volume
                avg_sv = np.mean(recent_sv)
                denom = max(abs(avg_sv), 1e-8)
                sv_accel_normalized = np.mean(sv_accel) / denom
            else:
                sv_accel_normalized = 0
        else:
            sv_accel_normalized = 0
        eng.append(sv_accel_normalized)
        
        # 15. Short Volume to Total Volume Ratio Trend
        # NEW: Captures the trend in the proportion of short selling
        if len(short_volume_ratio) >= 5:
            recent_ratio = short_volume_ratio[-5:]
            if len(recent_ratio) >= 2:
                # Calculate trend using simple linear regression
                x = np.arange(len(recent_ratio))
                y = recent_ratio
                mean_x = np.mean(x)
                mean_y = np.mean(y)
                
                numerator = np.sum((x - mean_x) * (y - mean_y))
                denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
                slope = numerator / denominator
                
                # Normalize the slope
                sv_ratio_trend = slope / max(abs(mean_y), 1e-8)
                sv_ratio_trend = np.tanh(5 * sv_ratio_trend)  # Constrain to [-1, 1]
            else:
                sv_ratio_trend = 0
        else:
            sv_ratio_trend = 0
        eng.append(sv_ratio_trend)
        
        # 16. Price Gap Analysis - Focus on significant gaps
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = []
            for i in range(1, min(5, len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Only consider significant gaps (>0.5%)
            sig_gaps = [g for g in gaps if abs(g) > 0.005]
            avg_sig_gap = np.mean(sig_gaps) if sig_gaps else 0
            
            # Apply sigmoid-like transformation for better scaling
            avg_sig_gap = np.tanh(5 * avg_sig_gap)
        else:
            avg_sig_gap = 0
        eng.append(avg_sig_gap)
        
        # 17. Stochastic Oscillator - Momentum indicator
        if len(close_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5:
            recent_close = close_prices[-1]
            lowest_low = np.min(low_prices[-5:])
            highest_high = np.max(high_prices[-5:])
            
            # Avoid division by zero
            range_hl = max(abs(highest_high - lowest_low), 1e-8)
            
            # Calculate %K (current close relative to range)
            stoch_k = 100 * (recent_close - lowest_low) / range_hl
            
            # Normalize to [-1, 1] range
            stoch_normalized = (stoch_k / 50) - 1
        else:
            stoch_normalized = 0
        eng.append(stoch_normalized)
        
        # 18. NEW: Short Interest Efficiency Ratio
        # Measures how efficiently short sellers are timing their positions
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price returns
            returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-6:-1], 1e-8)
            
            # Calculate short volume changes
            sv_changes = np.diff(short_volume[-5:]) / np.maximum(short_volume[-6:-1], 1e-8)
            
            # Correlation between short volume changes and negative returns
            # High positive correlation means shorts are increasing when price falls (efficient)
            # High negative correlation means shorts are increasing when price rises (contrarian)
            if len(returns) > 0 and len(sv_changes) > 0:
                # Use manual correlation calculation to avoid numerical issues
                neg_returns = -returns  # Negate returns so positive correlation means efficient shorting
                mean_neg_ret = np.mean(neg_returns)
                mean_sv_chg = np.mean(sv_changes)
                
                numerator = np.sum((neg_returns - mean_neg_ret) * (sv_changes - mean_sv_chg))
                denom1 = max(np.sqrt(np.sum((neg_returns - mean_neg_ret)**2)), 1e-8)
                denom2 = max(np.sqrt(np.sum((sv_changes - mean_sv_chg)**2)), 1e-8)
                
                efficiency_ratio = numerator / (denom1 * denom2)
                # Constrain to [-1, 1]
                efficiency_ratio = max(min(efficiency_ratio, 1), -1)
            else:
                efficiency_ratio = 0
        else:
            efficiency_ratio = 0
        eng.append(efficiency_ratio)
        
        # 19. NEW: Relative Short Interest Position
        # Compares current short interest to its recent range
        if t >= 2:  # Need at least 3 points to calculate a range
            # Get short interest values from previous timesteps
            si_values = [data[max(0, t-i), 0] for i in range(5)]
            
            if len(si_values) >= 3:
                si_min = min(si_values)
                si_max = max(si_values)
                si_range = max(abs(si_max - si_min), 1e-8)
                
                # Position of current SI within recent range (0 to 1)
                rel_si_position = (short_interest - si_min) / si_range
                
                # Normalize to [-1, 1] where 0 is the middle of the range
                rel_si_position = 2 * rel_si_position - 1
            else:
                rel_si_position = 0
        else:
            rel_si_position = 0
        eng.append(rel_si_position)
        
        # 20. NEW: Options-Adjusted Short Interest
        # Combines short interest with options data to get a more complete picture
        options_synthetic_short_cost = data[t, 64]
        put_call_ratio = data[t, 63]
        
        # Normalize options cost
        norm_options_cost = np.tanh(options_synthetic_short_cost * 5)
        
        # Adjust short interest based on options positioning
        # Higher put/call ratio and lower options cost suggest more bearish positioning
        options_adjusted_si = short_interest_to_float * (1 + (put_call_ratio - 1) * 0.5) * (1 - norm_options_cost * 0.3)
        eng.append(options_adjusted_si)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 2/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short volume trend - Exponentially weighted recent trend
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Price Momentum - Rate of change in price over multiple timeframes
        if len(close_prices) >= 10:
            # Short-term momentum (3-day)
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
            # Medium-term momentum (5-day)
            medium_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            # Long-term momentum (10-day)
            long_momentum = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
            
            # Combined momentum indicator with more weight to recent momentum
            combined_momentum = 0.5 * short_momentum + 0.3 * medium_momentum + 0.2 * long_momentum
        else:
            combined_momentum = 0
        eng.append(combined_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved options sentiment metric
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        # Normalize implied vol against its typical range (assuming 0.2-0.6 is typical)
        normalized_iv = (implied_vol - 0.4) / 0.2  # Center around 0
        # Combined indicator: positive = bearish pressure, negative = bullish
        options_pressure = normalized_pc_ratio * (1 + abs(normalized_iv))
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator - Detect unusual volume activity
        if len(total_volume) >= 10:
            recent_vol = total_volume[-1]
            avg_vol = np.mean(total_volume[-10:])
            denom = max(abs(avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Combined metric for squeeze likelihood
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential
            base_squeeze = (short_interest / (max(abs(shares_outstanding), 1e-8))) * days_to_cover
            
            # Incorporate volatility and recent price movement
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze potential
                momentum_factor = 1 + max(0, recent_return * 2)
            else:
                momentum_factor = 1
                
            squeeze_potential = base_squeeze * momentum_factor * (1 + volatility)
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential)
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. Price Trend Strength - Directional movement strength
        if len(close_prices) >= 10:
            # Calculate linear regression slope
            x = np.arange(10)
            y = close_prices[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope manually
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average price
            trend_strength = slope / (max(abs(mean_y), 1e-8))
            
            # Apply sigmoid-like transformation to emphasize strong trends
            trend_strength = np.tanh(3 * trend_strength)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 14. Short Volume Concentration - Measure of short volume clustering
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-5:]
            max_short_vol = np.max(recent_short_vol)
            min_short_vol = np.min(recent_short_vol)
            mean_short_vol = np.mean(recent_short_vol)
            denom = max(abs(mean_short_vol), 1e-8)
            # Higher values indicate more concentrated short volume
            short_vol_concentration = (max_short_vol - min_short_vol) / denom
            # Normalize to a more reasonable range
            short_vol_concentration = np.tanh(short_vol_concentration)
        else:
            short_vol_concentration = 0
        eng.append(short_vol_concentration)
        
        # 15. Market Sentiment Indicator - Combined price and volume sentiment
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = close_prices[-1] / (max(abs(close_prices[-5]), 1e-8)) - 1
            volume_change = total_volume[-1] / (max(abs(np.mean(total_volume[-5:])), 1e-8)) - 1
            
            # Incorporate short volume ratio trend
            if len(short_volume_ratio) >= 5:
                sv_ratio_change = short_volume_ratio[-1] / (max(abs(np.mean(short_volume_ratio[-5:])), 1e-8)) - 1
                # Negative sv_ratio_change is bullish, positive is bearish
                sentiment = price_change * volume_change * (1 - sv_ratio_change)
            else:
                sentiment = price_change * volume_change
                
            # Apply sigmoid-like transformation
            market_sentiment = np.tanh(3 * sentiment)
        else:
            market_sentiment = 0
        eng.append(market_sentiment)
        
        # 16. MACD Signal - Moving Average Convergence Divergence
        if len(close_prices) >= 12:
            # Simple implementation with shorter windows due to limited data
            ema_fast = np.mean(close_prices[-6:])  # Approximating 6-day EMA
            ema_slow = np.mean(close_prices[-12:])  # Approximating 12-day EMA
            
            # MACD line
            macd_line = ema_fast - ema_slow
            
            # Normalize by average price
            avg_price = np.mean(close_prices[-12:])
            denom = max(abs(avg_price), 1e-8)
            macd_normalized = macd_line / denom
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 17. Short Volume Acceleration - Rate of change in short volume
        if len(short_volume) >= 5:
            recent_sv = short_volume[-3:]
            if len(recent_sv) >= 2:
                # Calculate first differences
                sv_diff = np.diff(recent_sv)
                # Average acceleration
                sv_accel = np.mean(sv_diff)
                # Normalize by average short volume
                avg_sv = np.mean(recent_sv)
                denom = max(abs(avg_sv), 1e-8)
                sv_accel_normalized = sv_accel / denom
            else:
                sv_accel_normalized = 0
        else:
            sv_accel_normalized = 0
        eng.append(sv_accel_normalized)
        
        # 18. Price Gap Analysis - Focus on significant gaps
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = []
            for i in range(1, min(5, len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Only consider significant gaps (>0.5%)
            sig_gaps = [g for g in gaps if abs(g) > 0.005]
            avg_sig_gap = np.mean(sig_gaps) if sig_gaps else 0
            
            # Apply sigmoid-like transformation for better scaling
            avg_sig_gap = np.tanh(5 * avg_sig_gap)
        else:
            avg_sig_gap = 0
        eng.append(avg_sig_gap)
        
        # 19. Short Interest to Days to Cover Ratio - NEW
        # This combines two key metrics in a way that emphasizes their relationship
        si_to_dtc = short_interest / (max(abs(days_to_cover), 1e-8))
        # Normalize with log transformation to handle wide range of values
        si_to_dtc_normalized = np.tanh(si_to_dtc / 1000)  # Scaling factor to bring into reasonable range
        eng.append(si_to_dtc_normalized)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 144223.9863
RMSE: 202094.1189
MAPE: 8.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0004, rank=1
   2. Feature_15_t3: importance=0.0004, rank=2
   3. Feature_1_t3: importance=0.0003, rank=3
   4. Feature_0_t3: importance=0.0003, rank=4
   5. Feature_20_t2: importance=0.0002, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: +0.06%

📈 Current best MAPE: 8.48%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent open price
        # This allows us to calculate intraday movement
        raw_keep.append(close_prices[-1])  # Most recent close price
        raw_keep.append(open_prices[-1])   # Most recent open price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Volume Trend - Exponentially weighted recent trend
        # Improved with more emphasis on recent days
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Short-term Price Momentum (3-day)
        # Simplified to focus on short-term momentum which showed higher importance
        if len(close_prices) >= 3:
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            short_momentum = 0
        eng.append(short_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        # Improved with adaptive band width based on volatility
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            # Adjust band width based on volatility
            k = 2 + volatility  # Dynamic multiplier
            upper_band = sma + k * std
            lower_band = sma - k * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved options sentiment metric
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        # Normalize implied vol against its typical range (assuming 0.2-0.6 is typical)
        normalized_iv = (implied_vol - 0.4) / 0.2  # Center around 0
        # Combined indicator: positive = bearish pressure, negative = bullish
        options_pressure = normalized_pc_ratio * (1 + abs(normalized_iv))
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator - Detect unusual volume activity
        # Improved with exponential weighting for recent volume
        if len(total_volume) >= 10:
            # Exponential weights for recent volume
            weights = np.array([0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.15])
            weighted_avg_vol = np.sum(weights * total_volume[-10:]) / np.sum(weights)
            recent_vol = total_volume[-1]
            denom = max(abs(weighted_avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Combined metric for squeeze likelihood
        # Improved with more emphasis on days to cover and volatility
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential with more emphasis on days to cover
            base_squeeze = (short_interest / (max(abs(shares_outstanding), 1e-8))) * (days_to_cover ** 1.5)
            
            # Incorporate volatility and recent price movement
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze potential
                momentum_factor = 1 + max(0, recent_return * 3)  # Increased weight
            else:
                momentum_factor = 1
                
            squeeze_potential = base_squeeze * momentum_factor * (1 + volatility * 2)  # More weight to volatility
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential)
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. Price Trend Strength - Directional movement strength
        # Improved with adaptive window based on data availability
        if len(close_prices) >= 10:
            # Calculate linear regression slope
            x = np.arange(10)
            y = close_prices[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope manually
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average price
            trend_strength = slope / (max(abs(mean_y), 1e-8))
            
            # Apply sigmoid-like transformation to emphasize strong trends
            trend_strength = np.tanh(3 * trend_strength)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 14. Short Volume Concentration - Measure of short volume clustering
        # Improved with focus on recent days
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-5:]
            max_short_vol = np.max(recent_short_vol)
            min_short_vol = np.min(recent_short_vol)
            mean_short_vol = np.mean(recent_short_vol)
            denom = max(abs(mean_short_vol), 1e-8)
            # Higher values indicate more concentrated short volume
            short_vol_concentration = (max_short_vol - min_short_vol) / denom
            # Normalize to a more reasonable range
            short_vol_concentration = np.tanh(short_vol_concentration)
        else:
            short_vol_concentration = 0
        eng.append(short_vol_concentration)
        
        # 15. Intraday Price Range Ratio - NEW
        # Measures the volatility within each day relative to the price
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            # Calculate average daily range as percentage of price
            daily_ranges = []
            for i in range(min(5, len(high_prices), len(low_prices))):
                denom = max(abs(low_prices[-i-1]), 1e-8)
                daily_range = (high_prices[-i-1] - low_prices[-i-1]) / denom
                daily_ranges.append(daily_range)
            
            avg_range_ratio = np.mean(daily_ranges)
            # Normalize with tanh to handle outliers
            intraday_range_ratio = np.tanh(avg_range_ratio * 5)
        else:
            intraday_range_ratio = 0
        eng.append(intraday_range_ratio)
        
        # 16. Short Interest Acceleration - NEW
        # Second derivative of short interest to capture changing momentum
        if t >= 2:
            si_t = data[t, 0]
            si_t_1 = data[max(0, t-1), 0]
            si_t_2 = data[max(0, t-2), 0]
            
            # First differences
            si_diff_1 = si_t - si_t_1
            si_diff_2 = si_t_1 - si_t_2
            
            # Second difference (acceleration)
            si_accel = si_diff_1 - si_diff_2
            
            # Normalize by current short interest
            denom = max(abs(si_t), 1e-8)
            si_accel_norm = si_accel / denom
            
            # Apply sigmoid-like transformation
            si_acceleration = np.tanh(si_accel_norm * 3)
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # 17. Short Volume to Total Volume Ratio Trend - NEW
        # Measures the trend in short volume ratio over time
        if len(short_volume_ratio) >= 5:
            recent_ratio = short_volume_ratio[-1]
            avg_ratio = np.mean(short_volume_ratio[-5:])
            denom = max(abs(avg_ratio), 1e-8)
            sv_ratio_trend = recent_ratio / denom - 1
            
            # Apply sigmoid-like transformation
            sv_ratio_trend = np.tanh(sv_ratio_trend * 3)
        else:
            sv_ratio_trend = 0
        eng.append(sv_ratio_trend)
        
        # 18. Price Gap and Volume Correlation - NEW
        # Measures the relationship between price gaps and volume
        if len(open_prices) >= 5 and len(close_prices) >= 5 and len(total_volume) >= 5:
            gaps = []
            vols = []
            for i in range(1, min(5, len(open_prices), len(close_prices), len(total_volume))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(abs(gap))  # Use absolute gap size
                vols.append(total_volume[-i])
            
            # Calculate correlation-like measure manually
            if len(gaps) >= 2:
                mean_gap = np.mean(gaps)
                mean_vol = np.mean(vols)
                
                # Normalize gaps and volumes
                norm_gaps = [g - mean_gap for g in gaps]
                norm_vols = [v - mean_vol for v in vols]
                
                # Calculate dot product
                dot_product = sum(g * v for g, v in zip(norm_gaps, norm_vols))
                
                # Calculate magnitudes
                gap_mag = max(abs(sum(g * g for g in norm_gaps)), 1e-8)
                vol_mag = max(abs(sum(v * v for v in norm_vols)), 1e-8)
                
                # Calculate correlation-like measure
                gap_vol_corr = dot_product / (np.sqrt(gap_mag) * np.sqrt(vol_mag))
            else:
                gap_vol_corr = 0
        else:
            gap_vol_corr = 0
        eng.append(gap_vol_corr)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 144849.1542
RMSE: 201986.5200
MAPE: 8.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0003, rank=1
   2. Feature_13_t2: importance=0.0002, rank=2
   3. Feature_23_t3: importance=0.0002, rank=3
   4. Feature_15_t3: importance=0.0002, rank=4
   5. Feature_13_t1: importance=0.0002, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
📊 No significant improvement. Change: +0.04%

📈 Current best MAPE: 8.48%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 8
======================================================================
🤖 Calling Claude for iteration 8...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. RSI (Relative Strength Index) - 14 period
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. Price volatility (standard deviation of normalized returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns)
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Volume Trend - Exponentially weighted recent trend
        # Improved with more emphasis on recent days
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. Short-term Price Momentum (3-day)
        # Simplified to focus on short-term momentum which showed higher importance
        if len(close_prices) >= 3:
            short_momentum = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            short_momentum = 0
        eng.append(short_momentum)
        
        # 8. Bollinger Band Position - Position within the bands
        # Improved with adaptive band width based on volatility
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            # Adjust band width based on volatility
            k = 2 + volatility  # Dynamic multiplier
            upper_band = sma + k * std
            lower_band = sma - k * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        # This is a key indicator for predicting future short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. Options Pressure Indicator - Improved options sentiment metric
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        # Normalize implied vol against its typical range (assuming 0.2-0.6 is typical)
        normalized_iv = (implied_vol - 0.4) / 0.2  # Center around 0
        # Combined indicator: positive = bearish pressure, negative = bullish
        options_pressure = normalized_pc_ratio * (1 + abs(normalized_iv))
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator - Detect unusual volume activity
        # Improved with exponential weighting for recent volume
        if len(total_volume) >= 10:
            # Exponential weights for recent volume
            weights = np.array([0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.15])
            weighted_avg_vol = np.sum(weights * total_volume[-10:]) / np.sum(weights)
            recent_vol = total_volume[-1]
            denom = max(abs(weighted_avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
            # Apply sigmoid-like transformation to emphasize large spikes
            vol_spike_indicator = 2 / (1 + np.exp(-3 * vol_spike)) - 1
        else:
            vol_spike_indicator = 0
        eng.append(vol_spike_indicator)
        
        # 12. Short Squeeze Potential - Combined metric for squeeze likelihood
        # Improved with more emphasis on days to cover and volatility
        if short_interest > 0 and avg_volume > 0:
            # Base squeeze potential with more emphasis on days to cover
            base_squeeze = (short_interest / (max(abs(shares_outstanding), 1e-8))) * (days_to_cover ** 1.5)
            
            # Incorporate volatility and recent price movement
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze potential
                momentum_factor = 1 + max(0, recent_return * 3)  # Increased weight
            else:
                momentum_factor = 1
                
            squeeze_potential = base_squeeze * momentum_factor * (1 + volatility * 2)  # More weight to volatility
            # Normalize with tanh to keep in reasonable range
            squeeze_potential = np.tanh(squeeze_potential * 3)  # Increased scaling factor for better differentiation
        else:
            squeeze_potential = 0
        eng.append(squeeze_potential)
        
        # 13. NEW: MACD Signal - Moving Average Convergence Divergence
        # Trend-following momentum indicator showing relationship between two moving averages
        if len(close_prices) >= 12:  # Need at least 12 days for meaningful EMA calculation
            # Calculate 12-day EMA
            ema12 = close_prices[-1]
            alpha12 = 2 / (12 + 1)
            for i in range(2, min(12, len(close_prices))+1):
                ema12 = close_prices[-i] * alpha12 + ema12 * (1 - alpha12)
            
            # Calculate 26-day EMA (or as many days as available, minimum 12)
            ema26 = close_prices[-1]
            alpha26 = 2 / (26 + 1)
            for i in range(2, min(26, len(close_prices))+1):
                ema26 = close_prices[-i] * alpha26 + ema26 * (1 - alpha26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-12:])
            denom = max(abs(avg_price), 1e-8)
            macd_normalized = macd_line / denom
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 14. NEW: Short Volume Acceleration
        # Second derivative of short volume to capture changing momentum in shorting activity
        if len(short_volume) >= 3:
            # First differences
            diff1 = short_volume[-1] - short_volume[-2]
            diff2 = short_volume[-2] - short_volume[-3]
            
            # Second difference (acceleration)
            short_vol_accel = diff1 - diff2
            
            # Normalize by average short volume
            avg_short_vol = np.mean(short_volume[-3:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_accel_norm = short_vol_accel / denom
            
            # Apply sigmoid-like transformation
            short_vol_acceleration = np.tanh(short_vol_accel_norm * 2)
        else:
            short_vol_acceleration = 0
        eng.append(short_vol_acceleration)
        
        # 15. NEW: Short Interest to Options Implied Volatility Ratio
        # Relationship between short interest and market's expectation of volatility
        si_to_iv_ratio = short_interest / max(abs(implied_vol), 1e-8)
        # Normalize to a reasonable range
        si_to_iv_ratio = np.tanh(si_to_iv_ratio / 1000)  # Scale factor based on typical values
        eng.append(si_to_iv_ratio)
        
        # 16. NEW: Price Gap Analysis
        # Measures overnight gaps which can signal significant sentiment shifts
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            # Calculate overnight gaps
            gaps = []
            for i in range(1, min(5, len(open_prices), len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = open_prices[-i] / denom - 1
                gaps.append(gap)
            
            # Average recent gap size (absolute value)
            avg_gap_size = np.mean(np.abs(gaps))
            
            # Direction of most recent gap
            recent_gap_direction = np.sign(gaps[0]) if gaps else 0
            
            # Combined metric: magnitude * direction
            gap_indicator = avg_gap_size * recent_gap_direction
            
            # Apply sigmoid-like transformation
            gap_indicator = np.tanh(gap_indicator * 10)  # Scale to emphasize significant gaps
        else:
            gap_indicator = 0
        eng.append(gap_indicator)
        
        # 17. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short sellers are timing their positions
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price returns
            returns = []
            for i in range(1, 5):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                ret = close_prices[-i] / denom - 1
                returns.append(ret)
            
            # Calculate correlation-like measure between short volume and subsequent returns
            # Negative correlation means shorts are effective (shorting before price drops)
            short_vol_norm = short_volume[-5:-1] / np.mean(short_volume[-5:-1])
            returns_norm = np.array(returns)
            
            # Simple dot product as correlation proxy
            efficiency = -np.sum(short_vol_norm * returns_norm) / 4
            
            # Apply sigmoid-like transformation
            short_efficiency = np.tanh(efficiency * 3)
        else:
            short_efficiency = 0
        eng.append(short_efficiency)
        
        # 18. NEW: Intraday Range Volatility Trend
        # Measures the trend in daily price ranges, indicating changing volatility
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            # Calculate daily ranges as percentage of price
            ranges = []
            for i in range(5):
                denom = max(abs(low_prices[-i-1]), 1e-8)
                daily_range = (high_prices[-i-1] - low_prices[-i-1]) / denom
                ranges.append(daily_range)
            
            # Calculate trend in ranges (simple linear regression slope)
            x = np.arange(5)
            y = np.array(ranges)
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(abs(np.sum((x - mean_x) ** 2)), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average range
            denom = max(abs(mean_y), 1e-8)
            range_trend = slope / denom
            
            # Apply sigmoid-like transformation
            range_volatility_trend = np.tanh(range_trend * 10)
        else:
            range_volatility_trend = 0
        eng.append(range_volatility_trend)
        
        # 19. NEW: Short Volume to Price Momentum Divergence
        # Measures divergence between short selling activity and price momentum
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price momentum
            denom = max(abs(close_prices[-5]), 1e-8)
            price_momentum = close_prices[-1] / denom - 1
            
            # Calculate short volume momentum
            denom = max(abs(short_volume[-5]), 1e-8)
            short_vol_momentum = short_volume[-1] / denom - 1
            
            # Divergence: high when short volume increases but price also increases
            # or when short volume decreases but price also decreases
            divergence = short_vol_momentum * price_momentum
            
            # Apply sigmoid-like transformation
            short_price_divergence = np.tanh(divergence * 5)
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 8 (claude) (SVM)
==================================================
Training SVM model...

Iteration 8 (claude) Performance:
MAE: 143212.2947
RMSE: 203539.0189
MAPE: 8.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t2: importance=0.0003, rank=1
   2. Feature_22_t3: importance=0.0002, rank=2
   3. Feature_1_t3: importance=0.0002, rank=3
   4. Feature_6_t2: importance=0.0002, rank=4
   5. Feature_13_t2: importance=0.0002, rank=5
💾 Saved code for iteration 8 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.18%

📈 Current best MAPE: 8.30%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 9
======================================================================
🤖 Calling Claude for iteration 9...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. IMPROVED: RSI (Relative Strength Index) - 14 period with exponential weighting
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 2:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Apply exponential weights to emphasize recent price movements
            weights = np.exp(np.linspace(0, 1, len(gain)))
            weights = weights / np.sum(weights)
            
            avg_gain = np.sum(gain * weights) if len(gain) > 0 else 0
            avg_loss = np.sum(loss * weights) if len(loss) > 0 else 0
            
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 5. IMPROVED: Price volatility with adaptive lookback
        # Use shorter lookback for more recent volatility signal
        lookback = min(10, len(close_prices)-1)
        if lookback > 0:
            recent_prices = close_prices[-lookback:]
            returns = np.diff(recent_prices) / np.maximum(recent_prices[:-1], 1e-8)
            volatility = np.std(returns)
            
            # Apply log transformation to handle extreme values better
            volatility = np.log1p(volatility * 100) / 5  # Normalize to reasonable range
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Volume Trend - Exponentially weighted recent trend
        if len(short_volume) >= 5:
            # Exponential weights (more weight to recent days)
            weights = np.array([0.05, 0.1, 0.2, 0.3, 0.35])
            weighted_short_vol_trend = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            recent_avg = np.mean(short_volume[-5:])
            denom = max(abs(recent_avg), 1e-8)
            weighted_short_vol_trend = weighted_short_vol_trend / denom - 1
        else:
            weighted_short_vol_trend = 0
        eng.append(weighted_short_vol_trend)
        
        # 7. NEW: Adaptive Momentum Indicator
        # Combines multiple timeframes with dynamic weighting based on volatility
        if len(close_prices) >= 10:
            # Calculate momentum over different timeframes
            mom_1d = close_prices[-1] / max(abs(close_prices[-2]), 1e-8) - 1
            mom_3d = close_prices[-1] / max(abs(close_prices[-4]), 1e-8) - 1 if len(close_prices) >= 4 else 0
            mom_5d = close_prices[-1] / max(abs(close_prices[-6]), 1e-8) - 1 if len(close_prices) >= 6 else 0
            
            # Dynamic weighting based on volatility
            # Higher volatility = more weight to shorter timeframes
            vol_weight = min(0.8, volatility * 10)  # Cap at 0.8
            short_weight = 0.5 + vol_weight/2
            medium_weight = 0.3 - vol_weight/4
            long_weight = 0.2 - vol_weight/4
            
            # Ensure weights sum to 1
            total_weight = short_weight + medium_weight + long_weight
            short_weight /= total_weight
            medium_weight /= total_weight
            long_weight /= total_weight
            
            adaptive_momentum = (mom_1d * short_weight + 
                                mom_3d * medium_weight + 
                                mom_5d * long_weight)
            
            # Apply sigmoid-like transformation for better scaling
            adaptive_momentum = np.tanh(adaptive_momentum * 5)
        else:
            adaptive_momentum = 0
        eng.append(adaptive_momentum)
        
        # 8. IMPROVED: Bollinger Band Position with Dynamic Bands
        if len(close_prices) >= 10:
            # Use exponentially weighted moving average for more responsive signal
            weights = np.exp(np.linspace(0, 1, 10))
            weights = weights / np.sum(weights)
            
            sma = np.sum(close_prices[-10:] * weights)
            std = np.sqrt(np.sum(weights * (close_prices[-10:] - sma)**2))
            
            # Dynamic band width based on market regime
            # Wider bands in volatile markets, narrower in calm markets
            k = 2 + min(2, volatility * 10)  # Cap at 4
            
            upper_band = sma + k * std
            lower_band = sma - k * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
            
            # Apply sigmoid to handle outliers
            bb_position = np.tanh(bb_position * 1.5)
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum - Rate of change in short interest
        days_to_cover = data[t, 2]
        short_interest_momentum = days_to_cover / (max(abs(short_interest), 1e-8)) - 1
        eng.append(short_interest_momentum)
        
        # 10. IMPROVED: Options Pressure Indicator with Volatility Context
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        
        # Context-aware normalization of implied vol
        # Compare current IV to recent price volatility
        iv_to_realized_ratio = implied_vol / max(volatility, 1e-8)
        iv_premium = np.tanh((iv_to_realized_ratio - 1) * 2)  # Positive when IV > realized vol
        
        # Combined indicator with volatility context
        options_pressure = normalized_pc_ratio * (1 + abs(iv_premium))
        
        # Apply sigmoid-like transformation
        options_pressure = np.tanh(options_pressure * 1.5)
        eng.append(options_pressure)
        
        # 11. NEW: Short Squeeze Risk Score
        # Comprehensive metric combining multiple factors that contribute to squeeze risk
        if short_interest > 0 and avg_volume > 0:
            # Base factors
            si_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
            dtc = data[t, 2]  # days to cover
            
            # Recent price action
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze risk
                momentum_factor = 1 + max(0, recent_return * 3)
            else:
                momentum_factor = 1
            
            # Options market pressure
            options_factor = 1 - min(0.5, max(-0.5, normalized_pc_ratio)) * 0.5  # Lower P/C ratio increases risk
            
            # Volume dynamics
            if len(total_volume) >= 5:
                recent_vol_trend = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8) - 1
                volume_factor = 1 + max(0, recent_vol_trend)  # Increasing volume raises risk
            else:
                volume_factor = 1
            
            # Combined score with weighted components
            squeeze_risk = (
                (si_ratio * 0.3) * 
                (np.log1p(dtc) * 0.3) * 
                (momentum_factor * 0.2) * 
                (options_factor * 0.1) * 
                (volume_factor * 0.1) *
                (1 + volatility)
            )
            
            # Normalize with sigmoid
            squeeze_risk_score = np.tanh(squeeze_risk * 5)
        else:
            squeeze_risk_score = 0
        eng.append(squeeze_risk_score)
        
        # 12. NEW: Short Volume Concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_5d = np.sum(short_volume[-5:])
            previous_5d = np.sum(short_volume[-10:-5])
            
            denom = max(abs(previous_5d), 1e-8)
            concentration = recent_5d / denom - 1
            
            # Apply sigmoid-like transformation
            short_vol_concentration = np.tanh(concentration * 2)
        else:
            short_vol_concentration = 0
        eng.append(short_vol_concentration)
        
        # 13. NEW: Short Interest Efficiency with Price Impact
        # Measures how effectively short sellers are timing their positions
        # and their price impact
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price returns
            returns = []
            for i in range(1, 5):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                ret = close_prices[-i] / denom - 1
                returns.append(ret)
            
            # Calculate correlation-like measure between short volume and subsequent returns
            short_vol_norm = short_volume[-5:-1] / np.mean(short_volume[-5:-1])
            returns_norm = np.array(returns)
            
            # Timing efficiency (negative correlation means shorts are effective)
            timing_efficiency = -np.sum(short_vol_norm * returns_norm) / 4
            
            # Price impact (how much price moves on high short volume days)
            # Calculate absolute returns
            abs_returns = np.abs(returns_norm)
            impact_correlation = np.sum(short_vol_norm * abs_returns) / 4
            
            # Combined metric
            efficiency_score = timing_efficiency * (1 + impact_correlation)
            
            # Apply sigmoid-like transformation
            short_efficiency = np.tanh(efficiency_score * 3)
        else:
            short_efficiency = 0
        eng.append(short_efficiency)
        
        # 14. NEW: Volatility Regime Indicator
        # Identifies current market regime (low/high volatility) for adaptive strategies
        if len(close_prices) >= 15:
            # Calculate rolling volatility over different windows
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Short-term volatility (5 days)
            vol_5d = np.std(returns[-5:]) if len(returns) >= 5 else 0
            
            # Medium-term volatility (10 days)
            vol_10d = np.std(returns[-10:]) if len(returns) >= 10 else 0
            
            # Volatility ratio (short-term to medium-term)
            denom = max(abs(vol_10d), 1e-8)
            vol_ratio = vol_5d / denom
            
            # Regime indicator: >1 means increasing volatility, <1 means decreasing
            vol_regime = np.tanh((vol_ratio - 1) * 5)
        else:
            vol_regime = 0
        eng.append(vol_regime)
        
        # 15. NEW: Short Interest to Options Volume Ratio
        # Relationship between short interest and options activity
        options_volume_proxy = data[t, 63] * data[t, 65]  # P/C ratio * implied vol as proxy
        denom = max(abs(options_volume_proxy), 1e-8)
        si_to_options_ratio = short_interest / denom
        
        # Normalize to a reasonable range
        si_to_options_ratio = np.tanh(si_to_options_ratio / 100)
        eng.append(si_to_options_ratio)
        
        # 16. NEW: Price Trend Strength with Adaptive Lookback
        # Measures the strength and consistency of the current price trend
        if len(close_prices) >= 10:
            # Determine trend direction over different timeframes
            trend_1d = np.sign(close_prices[-1] - close_prices[-2])
            trend_3d = np.sign(close_prices[-1] - close_prices[-4]) if len(close_prices) >= 4 else 0
            trend_5d = np.sign(close_prices[-1] - close_prices[-6]) if len(close_prices) >= 6 else 0
            trend_10d = np.sign(close_prices[-1] - close_prices[-11]) if len(close_prices) >= 11 else 0
            
            # Count consistent trend signals
            trend_count = sum([
                trend_1d == trend_3d,
                trend_1d == trend_5d,
                trend_1d == trend_10d
            ])
            
            # Strength score: direction * consistency
            trend_strength = trend_1d * (trend_count / 3)
            
            # Adjust by volatility (stronger trends in low volatility are more significant)
            vol_adjustment = 1 / max(0.5, min(2, volatility * 10))
            trend_strength_adjusted = trend_strength * vol_adjustment
            
            # Apply sigmoid-like transformation
            trend_strength_score = np.tanh(trend_strength_adjusted * 2)
        else:
            trend_strength_score = 0
        eng.append(trend_strength_score)
        
        # 17. NEW: Short Volume Divergence from Price
        # Identifies when short selling activity diverges from price action
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Price trend
            denom = max(abs(close_prices[-5]), 1e-8)
            price_change = close_prices[-1] / denom - 1
            price_direction = np.sign(price_change)
            
            # Short volume trend
            denom = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_vol_change = short_volume[-1] / denom - 1
            short_vol_direction = np.sign(short_vol_change)
            
            # Divergence occurs when directions are the same
            # (price up + short volume up) or (price down + short volume down)
            divergence = price_direction * short_vol_direction
            
            # Magnitude of divergence
            magnitude = abs(price_change) * abs(short_vol_change) * 10
            
            # Signed divergence score
            divergence_score = divergence * magnitude
            
            # Apply sigmoid-like transformation
            short_price_divergence = np.tanh(divergence_score * 3)
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # 18. NEW: Market Sentiment Indicator
        # Combined metric of multiple sentiment factors
        if len(close_prices) >= 5:
            # Price momentum component
            denom = max(abs(close_prices[-5]), 1e-8)
            price_momentum = close_prices[-1] / denom - 1
            
            # Volatility component (normalized)
            vol_component = volatility / 0.2 - 1  # Centered around typical volatility of 0.2
            
            # Options sentiment (put/call ratio deviation from 1.0)
            options_sentiment = -(put_call_ratio - 1.0)  # Negative when puts dominate
            
            # Short interest component
            si_component = -short_interest_to_float  # Negative when short interest is high
            
            # Combined sentiment score with weights
            sentiment = (
                price_momentum * 0.4 +
                vol_component * (-0.2) +  # Higher volatility = negative sentiment
                options_sentiment * 0.2 +
                si_component * 0.2
            )
            
            # Apply sigmoid-like transformation
            market_sentiment = np.tanh(sentiment * 3)
        else:
            market_sentiment = 0
        eng.append(market_sentiment)
        
        # 19. NEW: Short Interest Acceleration
        # Second derivative of short interest to capture changing momentum
        # This is a key indicator for predicting future short interest
        if t >= 2:
            # Get short interest from previous timestamps
            si_current = data[t, 0]
            si_prev = data[t-1, 0] if t-1 >= 0 else si_current
            si_prev2 = data[t-2, 0] if t-2 >= 0 else si_prev
            
            # First differences
            diff1 = si_current - si_prev
            diff2 = si_prev - si_prev2
            
            # Second difference (acceleration)
            si_accel = diff1 - diff2
            
            # Normalize by average short interest
            avg_si = (si_current + si_prev + si_prev2) / 3
            denom = max(abs(avg_si), 1e-8)
            si_accel_norm = si_accel / denom
            
            # Apply sigmoid-like transformation
            si_acceleration = np.tanh(si_accel_norm * 5)
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 9 (claude) (SVM)
==================================================
Training SVM model...

Iteration 9 (claude) Performance:
MAE: 143301.2340
RMSE: 199521.8377
MAPE: 8.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0004, rank=1
   2. Feature_7_t3: importance=0.0002, rank=2
   3. Feature_21_t2: importance=0.0002, rank=3
   4. Feature_0_t3: importance=0.0002, rank=4
   5. Feature_12_t2: importance=0.0002, rank=5
💾 Saved code for iteration 9 to iteration_codes dictionary
📊 No significant improvement. Change: -0.04%

📈 Current best MAPE: 8.30%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 10
======================================================================
🤖 Calling Claude for iteration 10...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we keep the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - consistently high importance
            data[t, 1],  # average daily volume - high importance
            data[t, 2],  # days to cover - key metric for short squeeze potential
        ]
        
        # Get the OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was one of the more important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Exponentially weighted short volume ratio (more weight to recent days)
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            weighted_short_vol_ratio = np.sum(weights * short_volume_ratio[-5:])
            eng.append(weighted_short_vol_ratio)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 2. Short interest to float ratio - important relationship
        short_interest = data[t, 0]
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest to volume ratio - key metric for short squeeze potential
        avg_volume = data[t, 1]
        denom = max(abs(avg_volume), 1e-8)
        short_interest_to_volume = short_interest / denom
        eng.append(short_interest_to_volume)
        
        # 4. IMPROVED: RSI (Relative Strength Index) with adaptive lookback
        # Momentum indicator that can signal potential reversals
        if len(close_prices) >= 5:
            # Determine optimal lookback based on volatility
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
            
            # Shorter lookback in high volatility regimes
            lookback = max(2, min(10, int(10 / (1 + volatility * 20))))
            lookback = min(lookback, len(close_prices) - 1)
            
            delta = np.diff(close_prices[-lookback-1:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Apply exponential weights to emphasize recent price movements
            weights = np.exp(np.linspace(0, 1, len(gain)))
            weights = weights / np.sum(weights)
            
            avg_gain = np.sum(gain * weights) if len(gain) > 0 else 0
            avg_loss = np.sum(loss * weights) if len(loss) > 0 else 0
            
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
            
            # Normalize to [-1, 1] range and center around 0
            rsi_normalized = (rsi - 50) / 50
        else:
            rsi_normalized = 0
        eng.append(rsi_normalized)
        
        # 5. Price volatility with adaptive lookback
        # Use shorter lookback for more recent volatility signal
        if len(close_prices) >= 5:
            # Calculate returns
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Exponentially weight returns to emphasize recent volatility
            weights = np.exp(np.linspace(0, 1, len(returns)))
            weights = weights / np.sum(weights)
            
            # Calculate weighted volatility
            weighted_volatility = np.sqrt(np.sum(weights * (returns - np.mean(returns))**2))
            
            # Apply log transformation to handle extreme values better
            volatility = np.log1p(weighted_volatility * 100) / 5  # Normalize to reasonable range
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. NEW: Short Volume Acceleration
        # Measures the rate of change in short volume (second derivative)
        if len(short_volume) >= 3:
            # First differences
            diff1 = short_volume[-1] - short_volume[-2]
            diff2 = short_volume[-2] - short_volume[-3]
            
            # Second difference (acceleration)
            accel = diff1 - diff2
            
            # Normalize by average short volume
            avg_sv = np.mean(short_volume[-3:])
            denom = max(abs(avg_sv), 1e-8)
            short_vol_accel = accel / denom
            
            # Apply sigmoid-like transformation
            short_vol_accel = np.tanh(short_vol_accel * 3)
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 7. NEW: Short Interest Momentum with Lookback Optimization
        # Improved version that adapts to the data pattern
        if t >= 1:
            # Get short interest from previous timestamp
            si_current = data[t, 0]
            si_prev = data[t-1, 0]
            
            # Calculate momentum
            denom = max(abs(si_prev), 1e-8)
            si_momentum = (si_current / denom) - 1
            
            # Apply sigmoid-like transformation for better scaling
            si_momentum = np.tanh(si_momentum * 5)
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 8. IMPROVED: Bollinger Band Position with Dynamic Bands
        if len(close_prices) >= 10:
            # Use exponentially weighted moving average for more responsive signal
            weights = np.exp(np.linspace(0, 1, 10))
            weights = weights / np.sum(weights)
            
            sma = np.sum(close_prices[-10:] * weights)
            std = np.sqrt(np.sum(weights * (close_prices[-10:] - sma)**2))
            
            # Dynamic band width based on market regime
            # Wider bands in volatile markets, narrower in calm markets
            k = 2 + min(2, volatility * 10)  # Cap at 4
            
            upper_band = sma + k * std
            lower_band = sma - k * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            
            # Position within bands: 0 = at lower band, 0.5 = at middle, 1 = at upper band
            bb_position = (close_prices[-1] - lower_band) / denom
            
            # Normalize to [-1, 1] range where 0 is the middle
            bb_position = 2 * bb_position - 1
            
            # Apply sigmoid to handle outliers
            bb_position = np.tanh(bb_position * 1.5)
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short interest predicts price movements
        if t >= 1 and len(close_prices) >= 2:
            # Get short interest from previous timestamp
            si_current = data[t, 0]
            si_prev = data[t-1, 0] if t-1 >= 0 else si_current
            
            # Calculate price change
            price_current = close_prices[-1]
            price_prev = close_prices[-2]
            denom = max(abs(price_prev), 1e-8)
            price_change = (price_current / denom) - 1
            
            # Short interest change
            denom = max(abs(si_prev), 1e-8)
            si_change = (si_current / denom) - 1
            
            # Efficiency ratio: negative correlation between SI change and price change is efficient
            efficiency = -si_change * price_change
            
            # Apply sigmoid-like transformation
            si_efficiency = np.tanh(efficiency * 10)
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 10. NEW: Options Market Sentiment Index
        # Combines put/call ratio with implied volatility for a comprehensive options sentiment
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio around 1.0 (neutral)
        normalized_pc_ratio = put_call_ratio - 1.0
        
        # Combine with implied volatility (higher IV amplifies the signal)
        iv_factor = np.log1p(implied_vol) / 2  # Normalize IV
        options_sentiment = normalized_pc_ratio * (1 + iv_factor)
        
        # Apply sigmoid-like transformation
        options_sentiment = np.tanh(options_sentiment * 2)
        eng.append(options_sentiment)
        
        # 11. NEW: Short Squeeze Probability Score
        # Comprehensive metric combining multiple factors that contribute to squeeze risk
        if short_interest > 0 and avg_volume > 0:
            # Base factors
            si_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
            dtc = data[t, 2]  # days to cover
            
            # Recent price action
            if len(close_prices) >= 5:
                recent_return = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
                # Positive returns increase squeeze risk
                momentum_factor = 1 + max(0, recent_return * 5)
            else:
                momentum_factor = 1
            
            # Options market pressure (lower P/C ratio increases risk)
            options_factor = 1 - min(0.5, max(-0.5, normalized_pc_ratio)) * 0.5
            
            # Volume dynamics
            if len(total_volume) >= 5:
                recent_vol_trend = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8) - 1
                volume_factor = 1 + max(0, recent_vol_trend * 2)  # Increasing volume raises risk
            else:
                volume_factor = 1
            
            # Combined score with weighted components
            squeeze_risk = (
                (si_ratio * 0.4) * 
                (np.log1p(dtc) * 0.3) * 
                (momentum_factor * 0.2) * 
                (options_factor * 0.1) * 
                (volume_factor * 0.1) *
                (1 + volatility)
            )
            
            # Normalize with sigmoid
            squeeze_risk_score = np.tanh(squeeze_risk * 5)
        else:
            squeeze_risk_score = 0
        eng.append(squeeze_risk_score)
        
        # 12. NEW: Short Volume to Price Divergence
        # Identifies when short volume and price move in unexpected directions
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Price trend
            denom = max(abs(close_prices[-5]), 1e-8)
            price_change = close_prices[-1] / denom - 1
            price_direction = np.sign(price_change)
            
            # Short volume trend
            denom = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_vol_change = short_volume[-1] / denom - 1
            short_vol_direction = np.sign(short_vol_change)
            
            # Divergence occurs when directions are opposite
            # (price up + short volume up) or (price down + short volume down)
            divergence = price_direction * short_vol_direction
            
            # Magnitude of divergence
            magnitude = abs(price_change) * abs(short_vol_change) * 10
            
            # Signed divergence score
            divergence_score = divergence * magnitude
            
            # Apply sigmoid-like transformation
            short_price_divergence = np.tanh(divergence_score * 3)
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # 13. NEW: Short Interest Acceleration
        # Second derivative of short interest to capture changing momentum
        if t >= 2:
            # Get short interest from previous timestamps
            si_current = data[t, 0]
            si_prev = data[t-1, 0] if t-1 >= 0 else si_current
            si_prev2 = data[t-2, 0] if t-2 >= 0 else si_prev
            
            # First differences
            diff1 = si_current - si_prev
            diff2 = si_prev - si_prev2
            
            # Second difference (acceleration)
            si_accel = diff1 - diff2
            
            # Normalize by average short interest
            avg_si = (si_current + si_prev + si_prev2) / 3
            denom = max(abs(avg_si), 1e-8)
            si_accel_norm = si_accel / denom
            
            # Apply sigmoid-like transformation
            si_acceleration = np.tanh(si_accel_norm * 5)
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # 14. NEW: Short Interest to Options Implied Volatility Ratio
        # Relationship between short interest and market's expectation of volatility
        denom = max(abs(implied_vol), 1e-8)
        si_to_iv_ratio = short_interest / denom
        
        # Normalize to a reasonable range
        si_to_iv_ratio = np.tanh(si_to_iv_ratio / 1000)
        eng.append(si_to_iv_ratio)
        
        # 15. NEW: Short Volume Concentration Index
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_3d = np.sum(short_volume[-3:])
            previous_7d = np.sum(short_volume[-10:-3])
            
            denom = max(abs(previous_7d), 1e-8)
            concentration = (recent_3d / 3) / (previous_7d / 7)  # Compare daily averages
            
            # Apply log transformation for better scaling
            concentration = np.log(max(concentration, 1e-8))
            
            # Apply sigmoid-like transformation
            short_vol_concentration = np.tanh(concentration * 2)
        else:
            short_vol_concentration = 0
        eng.append(short_vol_concentration)
        
        # 16. NEW: Price Momentum with Volatility Adjustment
        # Price momentum that adapts to the current volatility regime
        if len(close_prices) >= 5:
            # Calculate momentum over different timeframes
            mom_1d = close_prices[-1] / max(abs(close_prices[-2]), 1e-8) - 1 if len(close_prices) >= 2 else 0
            mom_3d = close_prices[-1] / max(abs(close_prices[-4]), 1e-8) - 1 if len(close_prices) >= 4 else 0
            mom_5d = close_prices[-1] / max(abs(close_prices[-6]), 1e-8) - 1 if len(close_prices) >= 6 else 0
            
            # Adjust weights based on volatility
            # Higher volatility = more weight to shorter timeframes
            vol_weight = min(0.8, volatility * 10)  # Cap at 0.8
            short_weight = 0.5 + vol_weight/2
            medium_weight = 0.3 - vol_weight/4
            long_weight = 0.2 - vol_weight/4
            
            # Ensure weights sum to 1
            total_weight = short_weight + medium_weight + long_weight
            short_weight /= total_weight
            medium_weight /= total_weight
            long_weight /= total_weight
            
            # Weighted momentum
            vol_adj_momentum = (mom_1d * short_weight + 
                               mom_3d * medium_weight + 
                               mom_5d * long_weight)
            
            # Apply sigmoid-like transformation
            vol_adj_momentum = np.tanh(vol_adj_momentum * 5)
        else:
            vol_adj_momentum = 0
        eng.append(vol_adj_momentum)
        
        # 17. NEW: Short Interest Trend Strength
        # Measures the consistency and strength of the short interest trend
        if t >= 3:
            # Get short interest from previous timestamps
            si_values = []
            for i in range(min(4, t+1)):
                si_values.append(data[t-i, 0])
            
            # Calculate trend direction at different lookbacks
            trend_1 = np.sign(si_values[0] - si_values[1]) if len(si_values) > 1 else 0
            trend_2 = np.sign(si_values[0] - si_values[2]) if len(si_values) > 2 else 0
            trend_3 = np.sign(si_values[0] - si_values[3]) if len(si_values) > 3 else 0
            
            # Count consistent trend signals
            trend_count = sum([
                trend_1 != 0,  # Non-zero trend
                trend_1 == trend_2,
                trend_1 == trend_3
            ])
            
            # Strength score: direction * consistency
            trend_strength = trend_1 * (trend_count / 3)
            
            # Apply sigmoid-like transformation
            si_trend_strength = np.tanh(trend_strength * 2)
        else:
            si_trend_strength = 0
        eng.append(si_trend_strength)
        
        # 18. NEW: Short Volume Efficiency
        # Measures how effectively short volume predicts price movements
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price returns
            returns = []
            for i in range(1, min(5, len(close_prices))):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                ret = close_prices[-i] / denom - 1
                returns.append(ret)
            
            # Calculate correlation-like measure between short volume and subsequent returns
            short_vol_norm = short_volume[-5:-1] / np.mean(short_volume[-5:-1]) if len(short_volume) >= 5 else np.ones(4)
            returns_norm = np.array(returns)
            
            # Timing efficiency (negative correlation means shorts are effective)
            timing_efficiency = -np.sum(short_vol_norm[:len(returns_norm)] * returns_norm) / len(returns_norm)
            
            # Apply sigmoid-like transformation
            short_vol_efficiency = np.tanh(timing_efficiency * 5)
        else:
            short_vol_efficiency = 0
        eng.append(short_vol_efficiency)
        
        # 19. NEW: Adaptive Market Regime Indicator
        # Identifies current market regime for the stock
        if len(close_prices) >= 10:
            # Calculate returns
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Short-term volatility (5 days)
            vol_5d = np.std(returns[-5:]) if len(returns) >= 5 else 0
            
            # Medium-term volatility (10 days)
            vol_10d = np.std(returns[-10:]) if len(returns) >= 10 else 0
            
            # Recent trend
            trend_5d = close_prices[-1] / max(abs(close_prices[-6]), 1e-8) - 1 if len(close_prices) >= 6 else 0
            
            # Regime classification:
            # 1. Trending up with low volatility: +1
            # 2. Trending down with low volatility: -1
            # 3. Ranging with high volatility: near 0
            
            # Volatility ratio (short-term to medium-term)
            denom = max(abs(vol_10d), 1e-8)
            vol_ratio = vol_5d / denom
            
            # Combine trend and volatility
            # Strong trend * low volatility = strong regime signal
            regime = trend_5d * (2 - min(1.5, vol_ratio))
            
            # Apply sigmoid-like transformation
            market_regime = np.tanh(regime * 3)
        else:
            market_regime = 0
        eng.append(market_regime)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 10 (claude) (SVM)
==================================================
Training SVM model...

Iteration 10 (claude) Performance:
MAE: 147925.8600
RMSE: 206343.2654
MAPE: 8.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0003, rank=1
   2. Feature_16_t2: importance=0.0003, rank=2
   3. Feature_5_t2: importance=0.0002, rank=3
   4. Feature_21_t2: importance=0.0002, rank=4
   5. Feature_14_t2: importance=0.0002, rank=5
💾 Saved code for iteration 10 to iteration_codes dictionary
📊 No significant improvement. Change: -0.31%

📈 Current best MAPE: 8.30%
🔄 Iterations without improvement: 2/5

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 129751.4220
RMSE: 162121.3225
MAPE: 12.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 269
   • Highly important features (top 5%): 171

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0002, rank=1
   2. Feature_0_t3: importance=0.0002, rank=2
   3. Feature_0_t1: importance=0.0001, rank=3
   4. Feature_93_t3: importance=0.0001, rank=4
   5. Feature_83_t3: importance=0.0001, rank=5
   Baseline MAPE: 12.17%
   Baseline MAE: 129751.4220
   Baseline RMSE: 162121.3225

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 124357.1040
RMSE: 157076.2232
MAPE: 11.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 81

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t2: importance=0.0003, rank=1
   2. Feature_1_t3: importance=0.0003, rank=2
   3. Feature_14_t3: importance=0.0003, rank=3
   4. Feature_15_t1: importance=0.0002, rank=4
   5. Feature_4_t1: importance=0.0002, rank=5

📊 Best Model Test Set Performance:
   MAPE: 11.99%
   MAE: 124357.1040
   RMSE: 157076.2232

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 12.17%
   Best Model MAPE: 11.99%
   Absolute Improvement: 0.18%
   Relative Improvement: 1.5%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  8.74            N/A                 
1          Iteration 1               9.00            -0.26%              
2          Iteration 2               8.69            +0.05%              
3          Iteration 3               8.69            +0.05%              
4          Iteration 4               8.48            +0.26%              
5          Iteration 5               8.38            +0.10%              
6          Iteration 6               8.41            +0.06%              
7          Iteration 7               8.43            +0.04%              
8          Iteration 8               8.30            +0.18%              
9          Iteration 9               8.34            -0.04%              
10         Iteration 10              8.61            -0.31%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 8 - MAPE: 8.30%
✅ Saved ABCB results to cache/ABCB_iterative_results_enhanced.pkl
✅ Summary report saved for ABCB

🎉 Process completed successfully for ABCB!

================================================================================
PROCESSING TICKER 2/14: EIG
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for EIG
======================================================================
📊 Loading data from parquet file...
📊 Loading data for EIG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EIG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 50127.5666
RMSE: 66222.9395
MAPE: 15.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 355
   • Highly important features (top 5%): 251

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_74_t3: importance=0.0003, rank=1
   2. Feature_65_t3: importance=0.0003, rank=2
   3. Feature_64_t3: importance=0.0002, rank=3
   4. Feature_76_t3: importance=0.0002, rank=4
   5. Feature_2_t2: importance=0.0002, rank=5

📊 Baseline Performance: MAPE = 15.81%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)  # Short interest
        raw_keep.append(avg_volume)      # Average daily volume
        raw_keep.append(days_to_cover)   # Days to cover
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Options data (high importance in baseline)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)      # Options put/call volume ratio
        raw_keep.append(synthetic_short_cost) # Options synthetic short cost
        raw_keep.append(implied_volatility)   # Options avg implied volatility
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep only the most recent short volume and total volume
        raw_keep.append(short_volume[-1])  # Most recent short volume
        raw_keep.append(total_volume[-1])  # Most recent total volume
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Shares Outstanding Ratio
        si_to_shares_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares_ratio)
        
        # 3. Price momentum (5-day)
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # 4. Price momentum (10-day)
        if len(close_prices) >= 10:
            momentum_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
        else:
            momentum_10d = 0.0
        eng.append(momentum_10d)
        
        # 5. Volatility (standard deviation of returns)
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(np.abs(close_prices[:-1]), 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0.0
        else:
            volatility = 0.0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility indicator
        tr_values = []
        for i in range(1, len(high_prices)):
            high_low = high_prices[i] - low_prices[i]
            high_close_prev = abs(high_prices[i] - close_prices[i-1])
            low_close_prev = abs(low_prices[i] - close_prices[i-1])
            tr = max(high_low, high_close_prev, low_close_prev)
            tr_values.append(tr)
        
        atr = np.mean(tr_values) if tr_values else 0.0
        eng.append(atr)
        
        # 7. Relative Strength Index (RSI)
        if len(close_prices) >= 3:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50.0  # Default value
        eng.append(rsi)
        
        # 8. Short Interest Growth Rate
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
        else:
            si_growth = 0.0
        eng.append(si_growth)
        
        # 9. Short Volume Trend (slope of short volume over time)
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            slope = np.polyfit(x, y, 1)[0] if np.any(y != 0) else 0.0
            short_volume_trend = slope / max(abs(np.mean(y)), 1e-8)  # Normalized slope
        else:
            short_volume_trend = 0.0
        eng.append(short_volume_trend)
        
        # 10. Bollinger Band Width (volatility measure)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0.0
        eng.append(bb_width)
        
        # 11. Price to Volume Ratio
        price_to_volume = close_prices[-1] / max(abs(total_volume[-1]), 1e-8)
        eng.append(price_to_volume)
        
        # 12. Short Interest to Average Volume Ratio
        si_to_avg_volume = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(si_to_avg_volume)
        
        # 13. Implied Volatility to Historical Volatility Ratio
        iv_to_hv_ratio = implied_volatility / max(abs(volatility), 1e-8)
        eng.append(iv_to_hv_ratio)
        
        # 14. Short Cost Pressure (synthetic_short_cost * short_interest)
        short_cost_pressure = synthetic_short_cost * short_interest
        eng.append(short_cost_pressure)
        
        # 15. Short Squeeze Potential (combination of days to cover and short interest)
        short_squeeze_potential = days_to_cover * si_to_shares_ratio
        eng.append(short_squeeze_potential)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 48191.0244
RMSE: 63997.3322
MAPE: 15.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0005, rank=1
   2. Feature_13_t0: importance=0.0005, rank=2
   3. Feature_10_t2: importance=0.0003, rank=3
   4. Feature_22_t2: importance=0.0003, rank=4
   5. Feature_12_t2: importance=0.0003, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.68%

📈 Current best MAPE: 15.14%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep high-importance raw features based on previous iterations
        raw_keep.append(short_interest)  # Short interest
        raw_keep.append(avg_volume)      # Average daily volume
        raw_keep.append(days_to_cover)   # Days to cover
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price (more compact representation)
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)      # Options put/call volume ratio
        raw_keep.append(synthetic_short_cost) # Options synthetic short cost
        raw_keep.append(implied_volatility)   # Options avg implied volatility
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was a high-importance feature in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days) - more responsive to recent changes
        recent_short_volume_ratio = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else np.mean(short_volume_ratio)
        eng.append(recent_short_volume_ratio)
        
        # 2. Short Interest to Shares Outstanding Ratio - key metric for squeeze potential
        si_to_shares_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares_ratio)
        
        # 3. Short Interest Growth Rate - improved calculation with smoothing
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
        else:
            si_growth = 0.0
        eng.append(si_growth)
        
        # 4. Short Cost Pressure (synthetic_short_cost * short_interest)
        # High importance in previous iterations - measures cost pressure on shorts
        short_cost_pressure = synthetic_short_cost * short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(short_cost_pressure)
        
        # 5. Short Squeeze Potential (combination of days to cover and short interest)
        # Enhanced with put/call ratio influence
        short_squeeze_potential = days_to_cover * si_to_shares_ratio * (1 + put_call_ratio)
        eng.append(short_squeeze_potential)
        
        # 6. Implied Volatility to Price Ratio - normalized volatility expectation
        iv_price_ratio = implied_volatility / max(abs(close_prices[-1]), 1e-8)
        eng.append(iv_price_ratio)
        
        # 7. Price Momentum with Volume Weighting (5-day)
        # Improved momentum calculation that accounts for volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_changes = np.diff(close_prices[-5:])
            vol_weights = total_volume[-5:] / max(abs(np.sum(total_volume[-5:])), 1e-8)
            vol_weighted_momentum = np.sum(price_changes * vol_weights[:-1]) / max(abs(close_prices[-5]), 1e-8)
        else:
            vol_weighted_momentum = 0.0
        eng.append(vol_weighted_momentum)
        
        # 8. Short Volume Acceleration - rate of change in short volume
        if len(short_volume) >= 5:
            short_vol_diff = np.diff(short_volume[-5:])
            short_vol_accel = np.mean(short_vol_diff) / max(abs(np.mean(short_volume[-5:])), 1e-8)
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 9. Relative Strength Index (RSI) - improved calculation
        if len(close_prices) >= 5:
            delta = np.diff(close_prices[-5:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50.0  # Default value
        eng.append(rsi)
        
        # 10. Price Volatility Ratio - recent vs longer-term volatility
        if len(close_prices) >= 10:
            recent_volatility = np.std(close_prices[-5:]) / max(abs(np.mean(close_prices[-5:])), 1e-8)
            longer_volatility = np.std(close_prices[-10:]) / max(abs(np.mean(close_prices[-10:])), 1e-8)
            volatility_ratio = recent_volatility / max(abs(longer_volatility), 1e-8)
        else:
            volatility_ratio = 1.0
        eng.append(volatility_ratio)
        
        # 11. Short Interest to Float Ratio Normalized by Industry Average
        # Approximating industry average with a constant for simplicity
        industry_avg_si_ratio = 0.05  # Placeholder
        relative_si_ratio = si_to_shares_ratio / max(abs(industry_avg_si_ratio), 1e-8)
        eng.append(relative_si_ratio)
        
        # 12. Options Implied Move vs Historical Move
        # Comparing implied volatility to actual price movement
        if len(close_prices) >= 5:
            historical_move = np.std(np.diff(close_prices[-5:]) / close_prices[-5:-1]) * np.sqrt(252)
            implied_vs_historical = implied_volatility / max(abs(historical_move), 1e-8)
        else:
            implied_vs_historical = 1.0
        eng.append(implied_vs_historical)
        
        # 13. Short Volume Trend Strength - R² of linear fit to short volume
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            if np.std(y) > 1e-8:
                slope, intercept = np.polyfit(x, y, 1)
                y_pred = slope * x + intercept
                ss_total = np.sum((y - np.mean(y))**2)
                ss_residual = np.sum((y - y_pred)**2)
                r_squared = 1 - (ss_residual / max(abs(ss_total), 1e-8))
                trend_strength = r_squared * np.sign(slope)
            else:
                trend_strength = 0.0
        else:
            trend_strength = 0.0
        eng.append(trend_strength)
        
        # 14. Price to Short Volume Correlation
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_returns = np.diff(close_prices[-5:]) / close_prices[-5:-1]
            short_vol_changes = np.diff(short_volume[-5:]) / np.maximum(abs(short_volume[-5:-1]), 1e-8)
            if len(price_returns) > 1 and len(short_vol_changes) > 1 and np.std(price_returns) > 1e-8 and np.std(short_vol_changes) > 1e-8:
                correlation = np.corrcoef(price_returns, short_vol_changes)[0, 1]
                if np.isnan(correlation):
                    correlation = 0.0
            else:
                correlation = 0.0
        else:
            correlation = 0.0
        eng.append(correlation)
        
        # 15. Short Interest Concentration - ratio of short interest to average daily volume
        si_concentration = short_interest / max(abs(avg_volume * 5), 1e-8)  # 5-day equivalent
        eng.append(si_concentration)
        
        # 16. Synthetic Short Cost Trend
        if t > 0:
            short_cost_trend = (synthetic_short_cost / max(abs(data[t-1, 64]), 1e-8)) - 1.0
        else:
            short_cost_trend = 0.0
        eng.append(short_cost_trend)
        
        # 17. Put-Call Ratio Trend - indicates changing sentiment
        if t > 0:
            pc_ratio_trend = (put_call_ratio / max(abs(data[t-1, 63]), 1e-8)) - 1.0
        else:
            pc_ratio_trend = 0.0
        eng.append(pc_ratio_trend)
        
        # 18. Short Volume to Price Sensitivity
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_range = (np.max(close_prices[-5:]) - np.min(close_prices[-5:])) / max(abs(np.mean(close_prices[-5:])), 1e-8)
            short_vol_range = (np.max(short_volume[-5:]) - np.min(short_volume[-5:])) / max(abs(np.mean(short_volume[-5:])), 1e-8)
            sensitivity = price_range / max(abs(short_vol_range), 1e-8)
        else:
            sensitivity = 1.0
        eng.append(sensitivity)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 48315.4503
RMSE: 63029.7125
MAPE: 15.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 92

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0004, rank=1
   2. Feature_12_t0: importance=0.0004, rank=2
   3. Feature_20_t1: importance=0.0004, rank=3
   4. Feature_10_t1: importance=0.0003, rank=4
   5. Feature_13_t3: importance=0.0003, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -0.16%

📈 Current best MAPE: 15.14%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features based on previous iterations' importance
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)      # Options put/call volume ratio
        raw_keep.append(synthetic_short_cost) # Options synthetic short cost
        raw_keep.append(implied_volatility)   # Options avg implied volatility
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days) - more responsive to recent changes
        recent_short_volume_ratio = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else np.mean(short_volume_ratio)
        eng.append(recent_short_volume_ratio)
        
        # 2. Short Interest to Shares Outstanding Ratio - key metric for squeeze potential
        si_to_shares_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares_ratio)
        
        # 3. Short Interest Growth Rate - improved with exponential weighting
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            # Apply sigmoid transformation to handle extreme values better
            si_growth_transformed = 2.0 / (1.0 + np.exp(-5.0 * si_growth)) - 1.0
        else:
            si_growth_transformed = 0.0
        eng.append(si_growth_transformed)
        
        # 4. Short Cost Pressure (synthetic_short_cost * short_interest)
        # High importance in previous iterations - measures cost pressure on shorts
        short_cost_pressure = synthetic_short_cost * short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(short_cost_pressure)
        
        # 5. Short Squeeze Potential - enhanced with volatility component
        # Combines days to cover, short interest ratio, put/call ratio, and implied volatility
        short_squeeze_potential = days_to_cover * si_to_shares_ratio * (1 + put_call_ratio) * (1 + implied_volatility/100)
        eng.append(short_squeeze_potential)
        
        # 6. Price Momentum with Volume Weighting (5-day)
        # Improved momentum calculation that accounts for volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_changes = np.diff(close_prices[-5:])
            vol_weights = total_volume[-5:] / max(abs(np.sum(total_volume[-5:])), 1e-8)
            vol_weighted_momentum = np.sum(price_changes * vol_weights[:-1]) / max(abs(close_prices[-5]), 1e-8)
        else:
            vol_weighted_momentum = 0.0
        eng.append(vol_weighted_momentum)
        
        # 7. Short Volume Acceleration - rate of change in short volume
        # Enhanced with exponential weighting to emphasize recent changes
        if len(short_volume) >= 5:
            weights = np.exp(np.linspace(0, 1, 4))
            weights = weights / np.sum(weights)
            short_vol_diff = np.diff(short_volume[-5:])
            short_vol_accel = np.sum(short_vol_diff * weights) / max(abs(np.mean(short_volume[-5:])), 1e-8)
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 8. Relative Strength Index (RSI) - improved calculation
        if len(close_prices) >= 5:
            delta = np.diff(close_prices[-5:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            # Normalize to [-1, 1] range for better model compatibility
            rsi_normalized = (rsi - 50) / 50
        else:
            rsi_normalized = 0.0
        eng.append(rsi_normalized)
        
        # 9. Short Interest to Float Ratio Normalized by Industry Average
        # Using a dynamic approximation based on recent history
        if t > 0:
            prev_si_ratio = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            relative_si_ratio = si_to_shares_ratio / max(abs(prev_si_ratio), 1e-8)
        else:
            relative_si_ratio = 1.0
        eng.append(relative_si_ratio)
        
        # 10. Options Implied Move vs Historical Move
        # Comparing implied volatility to actual price movement
        if len(close_prices) >= 5:
            historical_move = np.std(np.diff(close_prices[-5:]) / close_prices[-5:-1]) * np.sqrt(252)
            implied_vs_historical = implied_volatility / max(abs(historical_move), 1e-8)
            # Apply log transformation to handle extreme values better
            implied_vs_historical = np.log1p(implied_vs_historical) if implied_vs_historical > 0 else 0
        else:
            implied_vs_historical = 0.0
        eng.append(implied_vs_historical)
        
        # 11. Short Volume Trend Strength - improved with robust linear regression
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            if np.std(y) > 1e-8:
                # Use median-based trend to reduce outlier impact
                slope = np.median([(y[i+1] - y[i]) for i in range(len(y)-1)])
                trend_direction = np.sign(slope)
                trend_magnitude = abs(slope) / max(abs(np.median(y)), 1e-8)
                trend_strength = trend_direction * trend_magnitude
            else:
                trend_strength = 0.0
        else:
            trend_strength = 0.0
        eng.append(trend_strength)
        
        # 12. Price to Short Volume Correlation - improved with rank correlation
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Use rank changes instead of percentage changes for robustness
            price_ranks = np.argsort(np.argsort(close_prices[-5:]))
            short_vol_ranks = np.argsort(np.argsort(short_volume[-5:]))
            
            # Calculate Spearman's rank correlation
            if np.std(price_ranks) > 1e-8 and np.std(short_vol_ranks) > 1e-8:
                rank_diff_squared = np.sum((price_ranks - short_vol_ranks)**2)
                n = len(price_ranks)
                rank_correlation = 1 - (6 * rank_diff_squared) / (n * (n**2 - 1))
            else:
                rank_correlation = 0.0
        else:
            rank_correlation = 0.0
        eng.append(rank_correlation)
        
        # 13. Short Interest Concentration - ratio of short interest to average daily volume
        si_concentration = short_interest / max(abs(avg_volume * 5), 1e-8)  # 5-day equivalent
        # Apply log transformation to handle extreme values
        si_concentration = np.log1p(si_concentration) if si_concentration > 0 else 0
        eng.append(si_concentration)
        
        # 14. Synthetic Short Cost Trend - improved with momentum
        if t > 1:
            # Calculate acceleration (second derivative)
            prev_cost = data[t-1, 64]
            prev_prev_cost = data[t-2, 64] if t > 1 else prev_cost
            
            cost_change = (synthetic_short_cost - prev_cost) / max(abs(prev_cost), 1e-8)
            prev_cost_change = (prev_cost - prev_prev_cost) / max(abs(prev_prev_cost), 1e-8)
            
            short_cost_momentum = cost_change - prev_cost_change
        else:
            short_cost_momentum = 0.0
        eng.append(short_cost_momentum)
        
        # 15. Put-Call Ratio Trend - indicates changing sentiment
        if t > 0:
            pc_ratio_trend = (put_call_ratio / max(abs(data[t-1, 63]), 1e-8)) - 1.0
        else:
            pc_ratio_trend = 0.0
        eng.append(pc_ratio_trend)
        
        # 16. Volatility-Adjusted Short Interest - new feature combining volatility and short interest
        vol_adjusted_si = short_interest * implied_volatility / max(abs(shares_outstanding * 100), 1e-8)
        eng.append(vol_adjusted_si)
        
        # 17. Price Trend Reversal Signal - new feature to detect potential reversals
        if len(close_prices) >= 10:
            short_trend = np.mean(np.diff(close_prices[-5:]))
            long_trend = np.mean(np.diff(close_prices[-10:]))
            
            # Reversal signal: short-term trend differs from long-term trend
            reversal_signal = -1 * np.sign(short_trend) * np.sign(long_trend) if np.sign(short_trend) != np.sign(long_trend) else 0
            reversal_magnitude = abs(short_trend - long_trend) / max(abs(close_prices[-1]), 1e-8)
            reversal_indicator = reversal_signal * reversal_magnitude
        else:
            reversal_indicator = 0.0
        eng.append(reversal_indicator)
        
        # 18. Short Volume to Price Elasticity - improved calculation
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate percentage changes
            price_pct_change = np.diff(close_prices[-5:]) / close_prices[-5:-1]
            short_vol_pct_change = np.diff(short_volume[-5:]) / np.maximum(short_volume[-5:-1], 1e-8)
            
            # Calculate elasticity as ratio of average percentage changes
            avg_price_change = np.mean(abs(price_pct_change))
            avg_short_vol_change = np.mean(abs(short_vol_pct_change))
            
            elasticity = avg_price_change / max(abs(avg_short_vol_change), 1e-8)
            # Apply sigmoid transformation to handle extreme values
            elasticity = 2.0 / (1.0 + np.exp(-0.5 * elasticity)) - 1.0
        else:
            elasticity = 0.0
        eng.append(elasticity)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 47008.5570
RMSE: 62355.3991
MAPE: 14.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 88

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t3: importance=0.0004, rank=1
   2. Feature_12_t0: importance=0.0004, rank=2
   3. Feature_14_t1: importance=0.0004, rank=3
   4. Feature_23_t3: importance=0.0004, rank=4
   5. Feature_24_t2: importance=0.0003, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.33%

📈 Current best MAPE: 14.81%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features based on previous iterations' importance
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price and the most recent high-low range
        # (reducing from 60 OHLC values to just 2 key metrics)
        raw_keep.append(close_prices[-1])  # Most recent close price
        recent_hl_range = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
        raw_keep.append(recent_hl_range)  # Recent volatility indicator
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)      # Options put/call volume ratio
        raw_keep.append(synthetic_short_cost) # Options synthetic short cost
        raw_keep.append(implied_volatility)   # Options avg implied volatility
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with exponential weighting (emphasizing recent days)
        # This was a high-importance feature in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Apply exponential weighting to emphasize recent days
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_weighted_svr = np.sum(short_volume_ratio[-5:] * weights)
        else:
            exp_weighted_svr = np.mean(short_volume_ratio)
        eng.append(exp_weighted_svr)
        
        # 2. Short Interest to Float Ratio - key metric for squeeze potential
        si_to_float_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_float_ratio)
        
        # 3. Short Interest Growth Rate with improved smoothing
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            # Apply tanh transformation for better handling of extreme values
            si_growth_transformed = np.tanh(si_growth * 2)  # tanh provides smoother bounds than sigmoid
        else:
            si_growth_transformed = 0.0
        eng.append(si_growth_transformed)
        
        # 4. Short Cost Pressure (synthetic_short_cost * short_interest / float)
        # High importance in previous iterations - measures cost pressure on shorts
        short_cost_pressure = synthetic_short_cost * si_to_float_ratio
        # Apply log1p transformation to handle extreme values better
        short_cost_pressure = np.log1p(max(short_cost_pressure, 0))
        eng.append(short_cost_pressure)
        
        # 5. Enhanced Short Squeeze Potential
        # Combines days to cover, short interest ratio, put/call ratio, implied volatility, and recent price action
        price_momentum = 0.0
        if len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        
        # Squeeze potential increases with positive momentum (shorts getting squeezed)
        momentum_factor = 1.0 + max(price_momentum, 0) * 2
        
        short_squeeze_potential = days_to_cover * si_to_float_ratio * (1 + put_call_ratio/2) * (1 + implied_volatility/100) * momentum_factor
        # Apply log transformation to handle extreme values
        short_squeeze_potential = np.log1p(max(short_squeeze_potential, 0))
        eng.append(short_squeeze_potential)
        
        # 6. Volume-Weighted Price Momentum with Directional Emphasis
        # Improved momentum calculation that accounts for volume and direction
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate returns
            returns = np.diff(close_prices[-5:]) / close_prices[-5:-1]
            
            # Weight by volume but emphasize direction
            vol_weights = total_volume[-5:] / max(abs(np.sum(total_volume[-5:])), 1e-8)
            
            # Emphasize consecutive moves in the same direction
            direction_consistency = 0
            for i in range(1, len(returns)):
                if np.sign(returns[i]) == np.sign(returns[i-1]):
                    direction_consistency += 1
            
            direction_factor = 1.0 + (direction_consistency / max(len(returns)-1, 1))
            vol_weighted_momentum = np.sum(returns * vol_weights[:-1]) * direction_factor
        else:
            vol_weighted_momentum = 0.0
        eng.append(vol_weighted_momentum)
        
        # 7. Short Volume Trend Strength with Robust Estimation
        if len(short_volume) >= 5:
            # Use Theil-Sen estimator approach (median of slopes) for robustness
            slopes = []
            for i in range(len(short_volume)-1):
                for j in range(i+1, len(short_volume)):
                    if j > i:
                        # Calculate pairwise slopes
                        slope = (short_volume[j] - short_volume[i]) / (j - i)
                        slopes.append(slope)
            
            if slopes:
                # Get median slope for robustness against outliers
                median_slope = np.median(slopes)
                # Normalize by average short volume
                trend_strength = median_slope / max(abs(np.median(short_volume)), 1e-8)
            else:
                trend_strength = 0.0
        else:
            trend_strength = 0.0
        eng.append(trend_strength)
        
        # 8. Improved RSI with Volume Weighting
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            delta = np.diff(close_prices[-10:])
            volume_weights = total_volume[-10:-1] / max(abs(np.sum(total_volume[-10:-1])), 1e-8)
            
            # Apply volume weighting to gains and losses
            gain = np.where(delta > 0, delta * volume_weights, 0)
            loss = np.where(delta < 0, -delta * volume_weights, 0)
            
            avg_gain = np.sum(gain)
            avg_loss = np.sum(loss)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            # Normalize to [-1, 1] range for better model compatibility
            rsi_normalized = (rsi - 50) / 50
        else:
            rsi_normalized = 0.0
        eng.append(rsi_normalized)
        
        # 9. Options Market Sentiment Indicator
        # Combines put/call ratio with implied volatility and synthetic short cost
        options_sentiment = put_call_ratio * (1 + implied_volatility/100) * (1 + synthetic_short_cost)
        # Normalize with log transformation
        options_sentiment = np.log1p(options_sentiment) if options_sentiment > 0 else 0
        eng.append(options_sentiment)
        
        # 10. Short Interest Concentration Relative to Trading Activity
        # Ratio of short interest to recent trading volume, indicating how many days of
        # current trading would be needed to cover all short positions
        if len(total_volume) >= 5:
            recent_avg_volume = np.mean(total_volume[-5:])
            si_concentration = short_interest / max(abs(recent_avg_volume * 5), 1e-8)
            # Apply log transformation to handle extreme values
            si_concentration = np.log1p(si_concentration) if si_concentration > 0 else 0
        else:
            si_concentration = 0.0
        eng.append(si_concentration)
        
        # 11. Short Volume Acceleration with Smoothing
        # Second derivative of short volume with smoothing to reduce noise
        if len(short_volume) >= 7:
            # Use 3-day moving averages to smooth the data
            smooth_short_vol = [np.mean(short_volume[i:i+3]) for i in range(len(short_volume)-2)]
            
            # Calculate first differences (velocity)
            velocity = np.diff(smooth_short_vol)
            
            # Calculate second differences (acceleration)
            acceleration = np.diff(velocity)
            
            # Normalize by average short volume
            short_vol_accel = np.mean(acceleration) / max(abs(np.mean(short_volume)), 1e-8)
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 12. Price-Volume Divergence Indicator
        # Detects when price and volume move in opposite directions (potential reversal signal)
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            volume_change = (total_volume[-1] / max(abs(np.mean(total_volume[-5:-1])), 1e-8)) - 1.0
            
            # Divergence occurs when signs are opposite
            divergence = -1 * np.sign(price_change) * np.sign(volume_change) if np.sign(price_change) != np.sign(volume_change) else 0
            divergence_magnitude = abs(price_change) * abs(volume_change)
            
            price_vol_divergence = divergence * divergence_magnitude
        else:
            price_vol_divergence = 0.0
        eng.append(price_vol_divergence)
        
        # 13. Bollinger Band Position with Short Interest Context
        # Where is the current price relative to Bollinger Bands, weighted by short interest
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std_dev = np.std(close_prices[-10:])
            
            upper_band = sma + 2 * std_dev
            lower_band = sma - 2 * std_dev
            
            # Calculate position within bands (-1 to +1 range)
            if upper_band > lower_band:
                bb_position = (close_prices[-1] - sma) / max(abs(upper_band - sma), 1e-8)
                # Clip to [-1, 1] range
                bb_position = max(min(bb_position, 1.0), -1.0)
            else:
                bb_position = 0.0
                
            # Weight by short interest ratio - higher short interest makes band breaks more significant
            bb_position_weighted = bb_position * (1 + si_to_float_ratio)
        else:
            bb_position_weighted = 0.0
        eng.append(bb_position_weighted)
        
        # 14. Short Interest to Options Volume Ratio
        # Relates short interest to options activity - indicates whether shorts are hedging with options
        if put_call_ratio > 0:
            si_to_options_ratio = si_to_float_ratio / max(abs(put_call_ratio), 1e-8)
            # Apply log transformation
            si_to_options_ratio = np.log1p(si_to_options_ratio) if si_to_options_ratio > 0 else 0
        else:
            si_to_options_ratio = 0.0
        eng.append(si_to_options_ratio)
        
        # 15. Volatility-Adjusted Short Interest Change
        # Short interest change normalized by implied volatility
        if t > 0 and implied_volatility > 0:
            si_change = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            vol_adjusted_si_change = si_change / max(abs(implied_volatility/100), 1e-8)
        else:
            vol_adjusted_si_change = 0.0
        eng.append(vol_adjusted_si_change)
        
        # 16. Short Volume to Price Elasticity with Improved Calculation
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate log returns for better statistical properties
            price_returns = np.diff(np.log(np.maximum(close_prices[-5:], 1e-8)))
            
            # Calculate percentage changes in short volume with log for consistency
            short_vol_returns = np.diff(np.log(np.maximum(short_volume[-5:], 1e-8)))
            
            # Calculate elasticity using standard deviations for robustness
            price_volatility = np.std(price_returns) if len(price_returns) > 1 else 0
            short_vol_volatility = np.std(short_vol_returns) if len(short_vol_returns) > 1 else 1e-8
            
            elasticity = price_volatility / max(abs(short_vol_volatility), 1e-8)
            # Apply tanh transformation to handle extreme values
            elasticity = np.tanh(elasticity)
        else:
            elasticity = 0.0
        eng.append(elasticity)
        
        # 17. Synthetic Short Cost Momentum
        # Rate of change in synthetic short cost, indicating changing pressure on shorts
        if t > 1:
            prev_cost = data[t-1, 64]
            prev_prev_cost = data[t-2, 64]
            
            # Calculate momentum with smoothing
            cost_momentum = (synthetic_short_cost - prev_cost) / max(abs((prev_cost + prev_prev_cost)/2), 1e-8)
            # Apply tanh for better scaling
            cost_momentum = np.tanh(cost_momentum * 3)
        else:
            cost_momentum = 0.0
        eng.append(cost_momentum)
        
        # 18. Short Interest Seasonality Detector
        # Detect if current short interest aligns with historical patterns (if available)
        if t >= 4:  # Need at least 4 previous points for a basic pattern
            # Look at short interest with 2-period lag (assuming bi-weekly reporting)
            si_pattern = []
            for i in range(min(5, t+1)):
                lag_idx = t - i
                if lag_idx >= 0:
                    si_pattern.append(data[lag_idx, 0])
            
            if len(si_pattern) >= 3:
                # Check if current SI is following the pattern from previous periods
                current_change = (si_pattern[0] / max(abs(si_pattern[1]), 1e-8)) - 1.0
                previous_change = (si_pattern[2] / max(abs(si_pattern[3]), 1e-8)) - 1.0
                
                # Similarity in direction and magnitude
                pattern_similarity = np.sign(current_change) * np.sign(previous_change) * min(abs(current_change), abs(previous_change)) / max(abs(max(current_change, previous_change)), 1e-8)
            else:
                pattern_similarity = 0.0
        else:
            pattern_similarity = 0.0
        eng.append(pattern_similarity)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 50078.5622
RMSE: 64813.9735
MAPE: 15.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t0: importance=0.0004, rank=1
   2. Feature_7_t0: importance=0.0004, rank=2
   3. Feature_17_t0: importance=0.0004, rank=3
   4. Feature_21_t0: importance=0.0004, rank=4
   5. Feature_16_t1: importance=0.0004, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -1.10%

📈 Current best MAPE: 14.81%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)      # Options put/call volume ratio
        raw_keep.append(synthetic_short_cost) # Options synthetic short cost
        raw_keep.append(implied_volatility)   # Options avg implied volatility
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with exponential weighting (high importance in previous iterations)
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Apply exponential weighting to emphasize recent days
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_weighted_svr = np.sum(short_volume_ratio[-5:] * weights)
        else:
            exp_weighted_svr = np.mean(short_volume_ratio)
        eng.append(exp_weighted_svr)
        
        # 2. Short Interest to Float Ratio - key metric for squeeze potential
        si_to_float_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_float_ratio)
        
        # 3. Short Interest Growth Rate (improved with smoothing)
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            # Apply tanh transformation for better handling of extreme values
            si_growth_transformed = np.tanh(si_growth * 2)
        else:
            si_growth_transformed = 0.0
        eng.append(si_growth_transformed)
        
        # 4. Enhanced Short Squeeze Potential (combining multiple factors)
        price_momentum = 0.0
        if len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        
        # Squeeze potential increases with positive momentum (shorts getting squeezed)
        momentum_factor = 1.0 + max(price_momentum, 0) * 2
        
        short_squeeze_potential = days_to_cover * si_to_float_ratio * (1 + implied_volatility/100) * momentum_factor
        # Apply log transformation to handle extreme values
        short_squeeze_potential = np.log1p(max(short_squeeze_potential, 0))
        eng.append(short_squeeze_potential)
        
        # 5. Price Volatility (normalized high-low range)
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            recent_hl_ranges = (high_prices[-5:] - low_prices[-5:]) / np.maximum(np.abs(close_prices[-5:]), 1e-8)
            price_volatility = np.mean(recent_hl_ranges)
        else:
            price_volatility = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
        eng.append(price_volatility)
        
        # 6. Short Volume Trend with Robust Estimation
        if len(short_volume) >= 7:
            # Use linear regression slope for trend estimation
            x = np.arange(7)
            y = short_volume[-7:]
            n = len(x)
            slope = (n * np.sum(x * y) - np.sum(x) * np.sum(y)) / max(n * np.sum(x**2) - np.sum(x)**2, 1e-8)
            # Normalize by average short volume
            short_vol_trend = slope / max(abs(np.mean(short_volume[-7:])), 1e-8)
            # Apply tanh for better scaling
            short_vol_trend = np.tanh(short_vol_trend * 5)
        else:
            short_vol_trend = 0.0
        eng.append(short_vol_trend)
        
        # 7. Volume-Weighted Price Momentum
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate returns
            returns = np.zeros(4)
            for i in range(4):
                returns[i] = (close_prices[-i-1] / max(abs(close_prices[-i-2]), 1e-8)) - 1.0
            
            # Weight by volume
            vol_weights = total_volume[-5:-1] / max(abs(np.sum(total_volume[-5:-1])), 1e-8)
            vol_weighted_momentum = np.sum(returns * vol_weights)
            # Apply tanh for better scaling
            vol_weighted_momentum = np.tanh(vol_weighted_momentum * 10)
        else:
            vol_weighted_momentum = 0.0
        eng.append(vol_weighted_momentum)
        
        # 8. Short Interest Concentration (relative to trading activity)
        if len(total_volume) >= 5:
            recent_avg_volume = np.mean(total_volume[-5:])
            si_concentration = short_interest / max(abs(recent_avg_volume * 5), 1e-8)
            # Apply log transformation
            si_concentration = np.log1p(si_concentration) if si_concentration > 0 else 0
        else:
            si_concentration = 0.0
        eng.append(si_concentration)
        
        # 9. Options Market Pressure (combining put/call ratio with implied volatility)
        options_pressure = put_call_ratio * (1 + implied_volatility/100)
        # Apply log transformation
        options_pressure = np.log1p(options_pressure) if options_pressure > 0 else 0
        eng.append(options_pressure)
        
        # 10. Short Cost Intensity (synthetic_short_cost * short_interest / float)
        short_cost_intensity = synthetic_short_cost * si_to_float_ratio
        # Apply log transformation
        short_cost_intensity = np.log1p(max(short_cost_intensity, 0))
        eng.append(short_cost_intensity)
        
        # 11. Relative Strength Index (RSI) with Volume Weighting
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-14:])
            volume_weights = total_volume[-14:-1] / max(abs(np.sum(total_volume[-14:-1])), 1e-8)
            
            gain = np.where(delta > 0, delta * volume_weights, 0)
            loss = np.where(delta < 0, -delta * volume_weights, 0)
            
            avg_gain = np.sum(gain)
            avg_loss = np.sum(loss)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            # Normalize to [-1, 1] range
            rsi_normalized = (rsi - 50) / 50
        else:
            rsi_normalized = 0.0
        eng.append(rsi_normalized)
        
        # 12. Price-Volume Divergence (potential reversal signal)
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            volume_change = (total_volume[-1] / max(abs(np.mean(total_volume[-5:-1])), 1e-8)) - 1.0
            
            # Divergence occurs when signs are opposite
            divergence = -1 * np.sign(price_change) * np.sign(volume_change) if np.sign(price_change) != np.sign(volume_change) else 0
            divergence_magnitude = abs(price_change) * abs(volume_change)
            
            price_vol_divergence = divergence * divergence_magnitude
        else:
            price_vol_divergence = 0.0
        eng.append(price_vol_divergence)
        
        # 13. Bollinger Band Position (price relative to volatility bands)
        if len(close_prices) >= 20:
            sma = np.mean(close_prices[-20:])
            std_dev = np.std(close_prices[-20:])
            
            upper_band = sma + 2 * std_dev
            lower_band = sma - 2 * std_dev
            
            # Calculate position within bands (-1 to +1 range)
            if upper_band > lower_band:
                bb_position = (close_prices[-1] - sma) / max(abs(upper_band - sma), 1e-8)
                # Clip to [-1, 1] range
                bb_position = max(min(bb_position, 1.0), -1.0)
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 14. Short Volume Acceleration (second derivative of short volume)
        if len(short_volume) >= 7:
            # Use 3-day moving averages to smooth the data
            smooth_short_vol = np.zeros(len(short_volume)-2)
            for i in range(len(short_volume)-2):
                smooth_short_vol[i] = np.mean(short_volume[i:i+3])
            
            # Calculate first differences (velocity)
            velocity = np.diff(smooth_short_vol)
            
            # Calculate second differences (acceleration)
            acceleration = np.diff(velocity)
            
            # Normalize by average short volume
            short_vol_accel = np.mean(acceleration) / max(abs(np.mean(short_volume)), 1e-8)
            # Apply tanh for better scaling
            short_vol_accel = np.tanh(short_vol_accel * 5)
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 15. MACD Signal (Moving Average Convergence Divergence)
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA calculation
            ema26 = np.mean(close_prices[-26:])
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price
            macd_normalized = macd_line / max(abs(close_prices[-1]), 1e-8)
        else:
            macd_normalized = 0.0
        eng.append(macd_normalized)
        
        # 16. Short Interest to Options Volume Ratio
        if put_call_ratio > 0:
            si_to_options_ratio = si_to_float_ratio / max(abs(put_call_ratio), 1e-8)
            # Apply log transformation
            si_to_options_ratio = np.log1p(si_to_options_ratio) if si_to_options_ratio > 0 else 0
        else:
            si_to_options_ratio = 0.0
        eng.append(si_to_options_ratio)
        
        # 17. Volatility-Adjusted Short Interest Change
        if t > 0 and implied_volatility > 0:
            si_change = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            vol_adjusted_si_change = si_change / max(abs(implied_volatility/100), 1e-8)
            # Apply tanh for better scaling
            vol_adjusted_si_change = np.tanh(vol_adjusted_si_change * 2)
        else:
            vol_adjusted_si_change = 0.0
        eng.append(vol_adjusted_si_change)
        
        # 18. Synthetic Short Cost Momentum
        if t > 1:
            prev_cost = data[t-1, 64]
            prev_prev_cost = data[t-2, 64]
            
            # Calculate momentum with smoothing
            cost_momentum = (synthetic_short_cost - prev_cost) / max(abs((prev_cost + prev_prev_cost)/2), 1e-8)
            # Apply tanh for better scaling
            cost_momentum = np.tanh(cost_momentum * 3)
        else:
            cost_momentum = 0.0
        eng.append(cost_momentum)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 48242.1882
RMSE: 63361.6136
MAPE: 15.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0007, rank=1
   2. Feature_5_t2: importance=0.0005, rank=2
   3. Feature_23_t0: importance=0.0004, rank=3
   4. Feature_6_t3: importance=0.0004, rank=4
   5. Feature_6_t0: importance=0.0004, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.42%

📈 Current best MAPE: 14.81%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price - high importance in previous iterations
        raw_keep.append(close_prices[-1])
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)
        raw_keep.append(synthetic_short_cost)
        raw_keep.append(implied_volatility)
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with exponential weighting (high importance in previous iterations)
        # Improved with more aggressive weighting to emphasize most recent days
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Apply stronger exponential weighting to emphasize recent days
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 2, 5))  # Increased exponent from 1 to 2
            weights = weights / np.sum(weights)
            exp_weighted_svr = np.sum(short_volume_ratio[-5:] * weights)
        else:
            exp_weighted_svr = np.mean(short_volume_ratio)
        eng.append(exp_weighted_svr)
        
        # 2. Short Interest to Float Ratio - key metric for squeeze potential
        si_to_float_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_float_ratio)
        
        # 3. Short Interest Growth Rate with improved smoothing
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            # Apply sigmoid-like transformation for better handling of extreme values
            si_growth_transformed = 2.0 / (1.0 + np.exp(-3.0 * si_growth)) - 1.0
        else:
            si_growth_transformed = 0.0
        eng.append(si_growth_transformed)
        
        # 4. Enhanced Short Squeeze Potential (combining multiple factors)
        # Improved with better momentum calculation and non-linear scaling
        price_momentum = 0.0
        if len(close_prices) >= 5:
            # Use exponential weighting for price momentum calculation
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            weighted_prices = close_prices[-5:] * weights
            price_momentum = (weighted_prices[-1] / max(abs(weighted_prices[0]), 1e-8)) - 1.0
        
        # Non-linear scaling of momentum factor
        momentum_factor = 1.0 + np.tanh(max(price_momentum, 0) * 3) * 2
        
        # Combine factors with improved weighting
        short_squeeze_potential = (days_to_cover**1.5) * (si_to_float_ratio**0.8) * (1 + implied_volatility/100) * momentum_factor
        # Apply log transformation to handle extreme values
        short_squeeze_potential = np.log1p(max(short_squeeze_potential, 0))
        eng.append(short_squeeze_potential)
        
        # 5. Improved Price Volatility with Parkinson's estimator
        # More accurate volatility estimation using high-low range
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            # Parkinson's volatility estimator
            hl_ratio = np.log(high_prices[-5:] / np.maximum(low_prices[-5:], 1e-8))
            parkinson_vol = np.sqrt(np.sum(hl_ratio**2) / (4 * np.log(2) * 5))
            # Normalize by price level
            price_volatility = parkinson_vol / max(abs(np.mean(close_prices[-5:])), 1e-8)
        else:
            price_volatility = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
        eng.append(price_volatility)
        
        # 6. Short Volume Trend with Theil-Sen estimator (more robust than OLS)
        if len(short_volume) >= 7:
            # Use median of slopes for robustness (Theil-Sen estimator)
            x = np.arange(7)
            slopes = []
            for i in range(6):
                for j in range(i+1, 7):
                    if abs(x[j] - x[i]) > 1e-8:
                        slope = (short_volume[-7+j] - short_volume[-7+i]) / (x[j] - x[i])
                        slopes.append(slope)
            
            if slopes:
                short_vol_trend = np.median(slopes) / max(abs(np.median(short_volume[-7:])), 1e-8)
                # Apply tanh for better scaling
                short_vol_trend = np.tanh(short_vol_trend * 5)
            else:
                short_vol_trend = 0.0
        else:
            short_vol_trend = 0.0
        eng.append(short_vol_trend)
        
        # 7. Volume-Weighted Average Price (VWAP) Deviation
        # New feature: price deviation from VWAP (better than simple momentum)
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(abs(np.sum(total_volume[-5:])), 1e-8)
            vwap_deviation = (close_prices[-1] / max(abs(vwap), 1e-8)) - 1.0
            # Apply tanh for better scaling
            vwap_deviation = np.tanh(vwap_deviation * 10)
        else:
            vwap_deviation = 0.0
        eng.append(vwap_deviation)
        
        # 8. Short Interest Concentration (relative to trading activity)
        # Improved with exponential weighting of volume
        if len(total_volume) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            weighted_volume = np.sum(total_volume[-5:] * weights)
            si_concentration = short_interest / max(abs(weighted_volume * 5), 1e-8)
            # Apply log transformation with better scaling
            si_concentration = np.log1p(si_concentration) if si_concentration > 0 else 0
        else:
            si_concentration = 0.0
        eng.append(si_concentration)
        
        # 9. Options Market Pressure with volatility skew consideration
        # Enhanced to better capture market sentiment
        options_pressure = put_call_ratio * (1 + implied_volatility/100)
        # Apply sigmoid transformation for better scaling
        options_pressure = 2.0 / (1.0 + np.exp(-options_pressure)) - 1.0
        eng.append(options_pressure)
        
        # 10. Short Cost Intensity with improved scaling
        short_cost_intensity = synthetic_short_cost * si_to_float_ratio
        # Apply log transformation with better scaling
        short_cost_intensity = np.log1p(max(short_cost_intensity, 0)) / max(1.0 + np.log1p(synthetic_short_cost), 1e-8)
        eng.append(short_cost_intensity)
        
        # 11. Improved RSI with Cutler's modifications
        # More stable RSI calculation with better handling of edge cases
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-14:])
            
            # Use Cutler's modification: scale by price level
            price_levels = close_prices[-14:-1]
            scaled_delta = delta / np.maximum(abs(price_levels), 1e-8)
            
            gain = np.where(scaled_delta > 0, scaled_delta, 0)
            loss = np.where(scaled_delta < 0, -scaled_delta, 0)
            
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            # Normalize to [-1, 1] range with sigmoid-like transformation
            rsi_normalized = 2.0 * ((rsi / 100.0) - 0.5)
        else:
            rsi_normalized = 0.0
        eng.append(rsi_normalized)
        
        # 12. Short Volume to Price Correlation
        # New feature: correlation between short volume and price changes
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_changes = np.diff(close_prices[-5:]) / np.maximum(abs(close_prices[-5:-1]), 1e-8)
            short_vol_changes = np.diff(short_volume[-5:]) / np.maximum(abs(short_volume[-5:-1]), 1e-8)
            
            # Calculate correlation using a stable method
            if np.std(price_changes) > 1e-8 and np.std(short_vol_changes) > 1e-8:
                # Normalize data
                price_changes_norm = (price_changes - np.mean(price_changes)) / max(np.std(price_changes), 1e-8)
                short_vol_changes_norm = (short_vol_changes - np.mean(short_vol_changes)) / max(np.std(short_vol_changes), 1e-8)
                
                # Calculate correlation
                corr = np.mean(price_changes_norm * short_vol_changes_norm)
                # Bound correlation to [-1, 1]
                corr = max(min(corr, 1.0), -1.0)
            else:
                corr = 0.0
        else:
            corr = 0.0
        eng.append(corr)
        
        # 13. Bollinger Band Position with adaptive bands
        # Improved with adaptive band width based on volatility regime
        if len(close_prices) >= 20:
            sma = np.mean(close_prices[-20:])
            std_dev = np.std(close_prices[-20:])
            
            # Adaptive band width based on volatility regime
            recent_vol = np.std(close_prices[-5:]) / max(abs(np.mean(close_prices[-5:])), 1e-8)
            long_vol = std_dev / max(abs(sma), 1e-8)
            
            # Adjust band width based on volatility ratio
            vol_ratio = recent_vol / max(long_vol, 1e-8)
            band_width = 2.0 * np.tanh(vol_ratio)
            
            upper_band = sma + band_width * std_dev
            lower_band = sma - band_width * std_dev
            
            # Calculate position within bands with improved scaling
            band_range = max(abs(upper_band - lower_band), 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_range - 0.5
            # Clip to [-1, 1] range
            bb_position = max(min(bb_position * 2.0, 1.0), -1.0)
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 14. Short Volume Acceleration with Kalman smoothing
        # More stable acceleration calculation
        if len(short_volume) >= 9:
            # Simple Kalman-like smoothing
            alpha = 0.3  # Smoothing factor
            smooth_short_vol = np.zeros(len(short_volume)-2)
            
            # Initialize with first value
            smooth_short_vol[0] = short_volume[0]
            
            # Apply smoothing
            for i in range(1, len(short_volume)-2):
                smooth_short_vol[i] = alpha * short_volume[i] + (1-alpha) * smooth_short_vol[i-1]
            
            # Calculate first differences (velocity)
            velocity = np.diff(smooth_short_vol)
            
            # Calculate second differences (acceleration)
            acceleration = np.diff(velocity)
            
            # Normalize by average short volume and apply sigmoid-like scaling
            short_vol_accel = np.mean(acceleration[-3:]) / max(abs(np.mean(short_volume[-9:])), 1e-8)
            short_vol_accel = np.tanh(short_vol_accel * 7)  # Increased sensitivity
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 15. Improved MACD Signal with proper EMA calculation
        if len(close_prices) >= 26:
            # Calculate proper EMAs
            ema12 = close_prices[-12:]
            ema26 = close_prices[-26:]
            
            alpha12 = 2.0 / (12 + 1)
            alpha26 = 2.0 / (26 + 1)
            
            # Simple EMA approximation
            ema12_val = close_prices[-12]
            for i in range(1, 12):
                ema12_val = alpha12 * close_prices[-12+i] + (1-alpha12) * ema12_val
                
            ema26_val = close_prices[-26]
            for i in range(1, 26):
                ema26_val = alpha26 * close_prices[-26+i] + (1-alpha26) * ema26_val
            
            # MACD Line
            macd_line = ema12_val - ema26_val
            
            # Signal Line (9-period EMA of MACD)
            # Simplified for stability
            
            # Normalize by price and apply tanh for better scaling
            macd_normalized = macd_line / max(abs(close_prices[-1]), 1e-8)
            macd_normalized = np.tanh(macd_normalized * 10)
        else:
            macd_normalized = 0.0
        eng.append(macd_normalized)
        
        # 16. Short Interest to Options Volume Ratio with improved scaling
        if put_call_ratio > 0:
            si_to_options_ratio = si_to_float_ratio / max(abs(put_call_ratio), 1e-8)
            # Apply sigmoid-like transformation for better scaling
            si_to_options_ratio = 2.0 / (1.0 + np.exp(-si_to_options_ratio)) - 1.0
        else:
            si_to_options_ratio = 0.0
        eng.append(si_to_options_ratio)
        
        # 17. Volatility-Adjusted Short Interest Change with improved normalization
        if t > 0 and implied_volatility > 0:
            si_change = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            # Normalize by log of implied volatility for better scaling
            vol_adjusted_si_change = si_change / max(np.log1p(implied_volatility/100), 1e-8)
            # Apply sigmoid-like transformation
            vol_adjusted_si_change = 2.0 / (1.0 + np.exp(-2.0 * vol_adjusted_si_change)) - 1.0
        else:
            vol_adjusted_si_change = 0.0
        eng.append(vol_adjusted_si_change)
        
        # 18. NEW: Short Interest Utilization Rate
        # Measures how much of the available float is being used for short positions
        si_utilization = short_interest / max(abs(shares_outstanding - short_interest), 1e-8)
        # Apply log transformation with better scaling
        si_utilization = np.log1p(si_utilization) / max(np.log1p(10.0), 1e-8)  # Normalize to typical range
        eng.append(si_utilization)
        
        # 19. NEW: Short Volume Ratio Divergence
        # Measures divergence between short volume ratio and price movement
        if len(close_prices) >= 5 and len(short_volume_ratio) >= 5:
            price_change = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            svr_change = (short_volume_ratio[-1] / max(abs(np.mean(short_volume_ratio[-5:-1])), 1e-8)) - 1.0
            
            # Positive divergence: price up, short volume ratio up (unusual)
            # Negative divergence: price down, short volume ratio down (unusual)
            divergence = np.sign(price_change) * np.sign(svr_change) * abs(price_change) * abs(svr_change)
            # Apply tanh for better scaling
            divergence = np.tanh(divergence * 5)
        else:
            divergence = 0.0
        eng.append(divergence)
        
        # 20. NEW: Synthetic Short Cost Momentum with Volatility Adjustment
        if t > 1 and implied_volatility > 0:
            prev_cost = data[t-1, 64]
            prev_prev_cost = data[t-2, 64]
            
            # Calculate momentum with volatility adjustment
            cost_momentum = (synthetic_short_cost - prev_cost) / max(abs((prev_cost + prev_prev_cost)/2), 1e-8)
            vol_adjusted_cost_momentum = cost_momentum / max(np.sqrt(implied_volatility/100), 1e-8)
            # Apply sigmoid-like transformation
            vol_adjusted_cost_momentum = 2.0 / (1.0 + np.exp(-3.0 * vol_adjusted_cost_momentum)) - 1.0
        else:
            vol_adjusted_cost_momentum = 0.0
        eng.append(vol_adjusted_cost_momentum)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 49019.9801
RMSE: 64300.1381
MAPE: 15.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t2: importance=0.0005, rank=1
   2. Feature_5_t3: importance=0.0005, rank=2
   3. Feature_4_t1: importance=0.0004, rank=3
   4. Feature_5_t2: importance=0.0004, rank=4
   5. Feature_6_t3: importance=0.0004, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -0.70%

📈 Current best MAPE: 14.81%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features (based on high importance in previous iterations)
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price - high importance in previous iterations
        raw_keep.append(close_prices[-1])
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)
        raw_keep.append(synthetic_short_cost)
        raw_keep.append(implied_volatility)
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Improved Short Volume Ratio with adaptive weighting
        # Weights recent days more heavily when volatility is high
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Calculate recent volatility to adjust weighting
        if len(close_prices) >= 5:
            recent_returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-5:-1], 1e-8)
            vol_factor = min(3.0, max(1.0, 1.0 + np.std(recent_returns) * 10))
            weights = np.exp(np.linspace(0, vol_factor, min(5, len(short_volume_ratio))))
            weights = weights / np.sum(weights)
            adaptive_weighted_svr = np.sum(short_volume_ratio[-min(5, len(short_volume_ratio)):] * weights)
        else:
            adaptive_weighted_svr = np.mean(short_volume_ratio)
        eng.append(adaptive_weighted_svr)
        
        # 2. Short Interest to Float Ratio with market cap normalization
        # Improved by considering market capitalization context
        si_to_float_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        
        # Normalize by price level to account for market cap differences
        if close_prices[-1] > 1e-8:
            market_cap_factor = np.log1p(close_prices[-1] * shares_outstanding / 1e6) / 10
            market_cap_factor = max(0.5, min(2.0, market_cap_factor))
            si_to_float_ratio_normalized = si_to_float_ratio * market_cap_factor
        else:
            si_to_float_ratio_normalized = si_to_float_ratio
        eng.append(si_to_float_ratio_normalized)
        
        # 3. Short Interest Growth Rate with momentum adjustment
        # Improved by incorporating momentum effects
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            
            # Add momentum adjustment
            if t > 1 and abs(data[t-2, 0]) > 1e-8:
                prev_growth = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1.0
                # Acceleration component with dampening for stability
                acceleration = (si_growth - prev_growth) * 0.5
                si_growth_momentum = si_growth + acceleration
            else:
                si_growth_momentum = si_growth
                
            # Apply bounded transformation for better handling of extreme values
            si_growth_transformed = np.tanh(si_growth_momentum * 2.0)
        else:
            si_growth_transformed = 0.0
        eng.append(si_growth_transformed)
        
        # 4. Enhanced Short Squeeze Potential with liquidity stress factor
        # Improved by incorporating liquidity stress indicators
        if len(total_volume) >= 10:
            # Calculate liquidity trend (declining volume increases squeeze potential)
            recent_vol_trend = np.mean(total_volume[-5:]) / max(np.mean(total_volume[-10:-5]), 1e-8)
            liquidity_stress = np.exp(-recent_vol_trend + 1)  # Higher when volume declining
            liquidity_stress = min(3.0, max(0.5, liquidity_stress))
        else:
            liquidity_stress = 1.0
            
        # Calculate price momentum with improved stability
        price_momentum = 0.0
        if len(close_prices) >= 5:
            # Use median-based momentum for robustness
            price_momentum = (close_prices[-1] / max(np.median(close_prices[-5:-1]), 1e-8)) - 1.0
        
        # Combine factors with improved weighting and liquidity stress
        squeeze_intensity = (days_to_cover**1.2) * (si_to_float_ratio**0.7) * (1 + implied_volatility/100) 
        squeeze_intensity *= (1 + max(0, price_momentum)) * liquidity_stress
        
        # Apply log transformation with better scaling
        short_squeeze_potential = np.log1p(max(squeeze_intensity, 0)) / 3.0  # Normalize to typical range
        eng.append(short_squeeze_potential)
        
        # 5. Improved Price Volatility with regime detection
        # More accurate volatility estimation with regime detection
        if len(close_prices) >= 10:
            # Calculate returns
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-10:-1], 1e-8)
            
            # Detect volatility regime using EWMA
            alpha = 0.4  # Weighting factor
            ewma_vol = 0
            for i in range(len(returns)):
                ewma_vol = alpha * abs(returns[i]) + (1-alpha) * ewma_vol
            
            # Calculate relative volatility (current vs historical)
            if len(returns) >= 5:
                recent_vol = np.std(returns[-min(5, len(returns)):])
                longer_vol = np.std(returns)
                vol_regime = recent_vol / max(longer_vol, 1e-8)
                
                # Combine EWMA and regime detection
                price_volatility = ewma_vol * np.tanh(vol_regime)
            else:
                price_volatility = ewma_vol
        else:
            # Fallback to simple high-low range
            price_volatility = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
        eng.append(price_volatility)
        
        # 6. Short Volume Trend with Hodrick-Prescott inspired smoothing
        # More robust trend extraction with HP-inspired smoothing
        if len(short_volume) >= 7:
            # Simple HP-inspired smoothing (lambda=1.5)
            y = short_volume[-7:].copy()
            n = len(y)
            
            # Identity matrix
            I = np.eye(n)
            
            # Second difference matrix
            D = np.zeros((n-2, n))
            for i in range(n-2):
                D[i, i] = 1
                D[i, i+1] = -2
                D[i, i+2] = 1
            
            # Smoothing parameter
            lam = 1.5
            
            # Simplified smoothing (avoiding matrix inversion for stability)
            # Use iterative smoothing instead
            trend = y.copy()
            for _ in range(3):  # Few iterations for approximation
                # Calculate second differences
                diff2 = np.zeros(n)
                diff2[1:-1] = trend[:-2] - 2*trend[1:-1] + trend[2:]
                
                # Update trend
                trend = y - lam * diff2
            
            # Calculate trend slope using robust method
            if n >= 3:
                # Use last 3 points for final slope
                slope = (trend[-1] - trend[-3]) / 2
                short_vol_trend = slope / max(abs(np.mean(trend)), 1e-8)
                # Apply tanh for better scaling
                short_vol_trend = np.tanh(short_vol_trend * 3)
            else:
                short_vol_trend = 0.0
        else:
            short_vol_trend = 0.0
        eng.append(short_vol_trend)
        
        # 7. Volume-Weighted Average Price (VWAP) Deviation with adaptive bands
        # Improved by adding adaptive bands based on volatility
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(abs(np.sum(total_volume[-5:])), 1e-8)
            
            # Calculate price volatility around VWAP
            vwap_distances = close_prices[-5:] - vwap
            vwap_vol = np.std(vwap_distances) / max(abs(vwap), 1e-8)
            
            # Current deviation with adaptive normalization
            current_deviation = (close_prices[-1] - vwap) / max(abs(vwap), 1e-8)
            
            # Normalize by adaptive bands
            band_width = max(0.01, vwap_vol * 2)
            vwap_deviation = current_deviation / max(band_width, 1e-8)
            
            # Apply bounded transformation
            vwap_deviation = np.tanh(vwap_deviation * 2)
        else:
            vwap_deviation = 0.0
        eng.append(vwap_deviation)
        
        # 8. Short Interest Concentration with volume pattern recognition
        # Improved by recognizing volume patterns that indicate accumulation/distribution
        if len(total_volume) >= 10:
            # Detect volume pattern: rising prices on rising volume is bullish
            # Falling prices on rising volume is bearish (distribution)
            price_direction = np.sign(close_prices[-1] - close_prices[-min(10, len(close_prices))])
            
            # Calculate volume trend
            vol_trend = np.mean(total_volume[-3:]) / max(np.mean(total_volume[-10:-3]), 1e-8) - 1
            
            # Pattern recognition factor
            pattern_factor = 1.0
            if abs(price_direction) > 0 and abs(vol_trend) > 0.1:
                # If price and volume moving in same direction, reduce concentration impact
                # If price and volume moving in opposite direction, increase concentration impact
                pattern_factor = 1.0 - 0.5 * np.sign(price_direction) * np.sign(vol_trend)
            
            # Calculate concentration with pattern adjustment
            si_concentration = (short_interest / max(np.sum(total_volume[-10:]), 1e-8)) * pattern_factor
            
            # Apply log transformation with better scaling
            si_concentration = np.log1p(si_concentration * 10) / 3.0
        else:
            si_concentration = short_interest / max(np.sum(total_volume), 1e-8)
            si_concentration = np.log1p(si_concentration * 10) / 3.0
        eng.append(si_concentration)
        
        # 9. Options Market Pressure with volatility skew and term structure
        # Enhanced to better capture market sentiment and volatility term structure
        options_pressure = put_call_ratio * (1 + implied_volatility/100)
        
        # Add term structure approximation using synthetic short cost trend
        if t > 0:
            cost_trend = synthetic_short_cost / max(data[t-1, 64], 1e-8) - 1.0
            # Rising costs with high put/call ratio indicates stronger bearish sentiment
            if cost_trend > 0 and put_call_ratio > 1.0:
                options_pressure *= (1 + min(cost_trend, 0.5))
        
        # Apply sigmoid transformation for better scaling
        options_pressure = 2.0 / (1.0 + np.exp(-options_pressure)) - 1.0
        eng.append(options_pressure)
        
        # 10. Short Cost Intensity with market impact modeling
        # Improved by modeling market impact of short covering
        short_cost_intensity = synthetic_short_cost * si_to_float_ratio
        
        # Add market impact factor - higher when short interest is high relative to volume
        market_impact = short_interest / max(avg_volume * 5, 1e-8)
        market_impact = min(3.0, market_impact)  # Cap for stability
        
        # Combine with non-linear scaling
        short_cost_pressure = short_cost_intensity * (1 + np.log1p(market_impact))
        
        # Apply log transformation with better scaling
        short_cost_pressure = np.log1p(max(short_cost_pressure, 0)) / max(1.0 + np.log1p(synthetic_short_cost), 1e-8)
        eng.append(short_cost_pressure)
        
        # 11. Improved RSI with volume weighting and mean reversion potential
        # More predictive RSI calculation with volume weighting and mean reversion signals
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            delta = np.diff(close_prices[-14:])
            volume = total_volume[-14+1:]  # Align with delta
            
            # Volume-weighted delta
            vol_weighted_delta = delta * volume
            
            gain = np.where(vol_weighted_delta > 0, vol_weighted_delta, 0)
            loss = np.where(vol_weighted_delta < 0, -vol_weighted_delta, 0)
            
            avg_gain = np.sum(gain) / max(np.sum(volume), 1e-8)
            avg_loss = np.sum(loss) / max(np.sum(volume), 1e-8)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            
            # Calculate mean reversion potential
            # Extreme RSI values tend to revert - add this signal
            mean_reversion = 0.0
            if rsi > 70:
                mean_reversion = -0.3 * (rsi - 70) / 30  # Bearish signal
            elif rsi < 30:
                mean_reversion = 0.3 * (30 - rsi) / 30   # Bullish signal
                
            # Combine RSI and mean reversion potential
            rsi_normalized = 2.0 * ((rsi / 100.0) - 0.5) + mean_reversion
            rsi_normalized = max(-1.0, min(1.0, rsi_normalized))  # Bound to [-1, 1]
        else:
            rsi_normalized = 0.0
        eng.append(rsi_normalized)
        
        # 12. Short Volume to Price Correlation with regime detection
        # Improved correlation with regime detection
        if len(close_prices) >= 7 and len(short_volume) >= 7:
            # Calculate returns and short volume changes
            price_changes = np.diff(close_prices[-7:]) / np.maximum(close_prices[-7:-1], 1e-8)
            short_vol_changes = np.diff(short_volume[-7:]) / np.maximum(short_volume[-7:-1], 1e-8)
            
            # Calculate correlation using a stable method
            if np.std(price_changes) > 1e-8 and np.std(short_vol_changes) > 1e-8:
                # Normalize data
                price_changes_norm = (price_changes - np.mean(price_changes)) / max(np.std(price_changes), 1e-8)
                short_vol_changes_norm = (short_vol_changes - np.mean(short_vol_changes)) / max(np.std(short_vol_changes), 1e-8)
                
                # Calculate rolling correlations with different windows
                if len(price_changes_norm) >= 5:
                    # Recent correlation (more weight)
                    recent_corr = np.mean(price_changes_norm[-3:] * short_vol_changes_norm[-3:])
                    # Full correlation
                    full_corr = np.mean(price_changes_norm * short_vol_changes_norm)
                    
                    # Detect regime change - correlation sign flip is significant
                    regime_change = 0.0
                    if np.sign(recent_corr) != np.sign(full_corr) and abs(recent_corr) > 0.3:
                        regime_change = np.sign(recent_corr) * 0.3
                    
                    # Combine with regime change signal
                    corr = recent_corr * 0.7 + full_corr * 0.3 + regime_change
                else:
                    corr = np.mean(price_changes_norm * short_vol_changes_norm)
                
                # Bound correlation to [-1, 1]
                corr = max(min(corr, 1.0), -1.0)
            else:
                corr = 0.0
        else:
            corr = 0.0
        eng.append(corr)
        
        # 13. Bollinger Band Position with volume confirmation
        # Improved with volume confirmation for stronger signals
        if len(close_prices) >= 20 and len(total_volume) >= 20:
            sma = np.mean(close_prices[-20:])
            std_dev = np.std(close_prices[-20:])
            
            # Standard Bollinger Bands
            upper_band = sma + 2.0 * std_dev
            lower_band = sma - 2.0 * std_dev
            
            # Calculate position within bands
            band_range = max(abs(upper_band - lower_band), 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_range - 0.5
            
            # Volume confirmation
            # High volume near bands increases signal strength
            vol_ratio = total_volume[-1] / max(np.mean(total_volume[-20:]), 1e-8)
            
            # Increase signal strength when volume confirms
            if abs(bb_position) > 0.4 and vol_ratio > 1.2:
                bb_position *= min(1.5, vol_ratio / 1.2)
            
            # Clip to [-1, 1] range
            bb_position = max(min(bb_position * 2.0, 1.0), -1.0)
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 14. Short Volume Acceleration with adaptive smoothing
        # More stable acceleration calculation with adaptive smoothing
        if len(short_volume) >= 9:
            # Calculate volatility of short volume
            vol_std = np.std(short_volume[-9:]) / max(np.mean(short_volume[-9:]), 1e-8)
            
            # Adaptive smoothing - more smoothing when volatile
            alpha = max(0.1, min(0.5, 0.3 / max(vol_std, 0.1)))
            
            # Apply adaptive EMA
            smooth_short_vol = np.zeros(len(short_volume[-9:]))
            smooth_short_vol[0] = short_volume[-9]
            
            for i in range(1, len(short_volume[-9:])):
                smooth_short_vol[i] = alpha * short_volume[-9+i] + (1-alpha) * smooth_short_vol[i-1]
            
            # Calculate first differences (velocity)
            if len(smooth_short_vol) >= 3:
                velocity = np.diff(smooth_short_vol[-3:])
                
                # Calculate acceleration (change in velocity)
                if len(velocity) >= 2:
                    acceleration = velocity[1] - velocity[0]
                    
                    # Normalize by average short volume and apply sigmoid-like scaling
                    short_vol_accel = acceleration / max(abs(np.mean(short_volume[-9:])), 1e-8)
                    short_vol_accel = np.tanh(short_vol_accel * 5)
                else:
                    short_vol_accel = 0.0
            else:
                short_vol_accel = 0.0
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 15. NEW: Short Interest Momentum Oscillator
        # Combines multiple timeframes of short interest changes for momentum signals
        if t >= 2:
            # Short-term momentum (most recent change)
            if abs(data[t-1, 0]) > 1e-8:
                short_term = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            else:
                short_term = 0.0
                
            # Medium-term momentum
            if t >= 3 and abs(data[t-3, 0]) > 1e-8:
                medium_term = (short_interest / max(abs(data[t-3, 0]), 1e-8)) - 1.0
            else:
                medium_term = short_term
            
            # Combine with more weight on recent changes
            momentum_oscillator = short_term * 0.7 + medium_term * 0.3
            
            # Apply sigmoid-like transformation
            momentum_oscillator = np.tanh(momentum_oscillator * 3)
        else:
            momentum_oscillator = 0.0
        eng.append(momentum_oscillator)
        
        # 16. NEW: Short Interest Utilization Rate with liquidity adjustment
        # Measures how much of the available float is being used for short positions
        # Adjusted for liquidity conditions
        si_utilization = short_interest / max(abs(shares_outstanding - short_interest), 1e-8)
        
        # Adjust for liquidity conditions
        if avg_volume > 1e-8:
            liquidity_factor = np.log1p(shares_outstanding / max(avg_volume * 20, 1e-8)) / 5
            liquidity_factor = max(0.5, min(2.0, liquidity_factor))
            si_utilization_adjusted = si_utilization * liquidity_factor
        else:
            si_utilization_adjusted = si_utilization
            
        # Apply log transformation with better scaling
        si_utilization_adjusted = np.log1p(si_utilization_adjusted) / max(np.log1p(5.0), 1e-8)
        eng.append(si_utilization_adjusted)
        
        # 17. NEW: Short Squeeze Vulnerability Index
        # Comprehensive metric combining multiple factors that contribute to squeeze risk
        
        # 1. Days to cover component
        dtc_component = np.tanh(days_to_cover / 10)
        
        # 2. Short interest concentration
        si_concentration_component = np.tanh(short_interest / max(shares_outstanding * 0.05, 1e-8))
        
        # 3. Cost to borrow pressure
        cost_pressure = np.tanh(synthetic_short_cost / 5)
        
        # 4. Price momentum component (positive momentum increases squeeze risk)
        momentum_component = 0.0
        if len(close_prices) >= 5:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1.0
            momentum_component = np.tanh(max(0, price_change * 5))
        
        # 5. Volatility component
        vol_component = np.tanh(implied_volatility / 50)
        
        # Combine components with empirical weights
        squeeze_vulnerability = (
            dtc_component * 0.25 +
            si_concentration_component * 0.25 +
            cost_pressure * 0.2 +
            momentum_component * 0.15 +
            vol_component * 0.15
        )
        
        # Scale to [0, 1] range and then to [-1, 1] for consistency
        squeeze_vulnerability = squeeze_vulnerability * 2 - 1
        eng.append(squeeze_vulnerability)
        
        # 18. NEW: Options-Implied Short Pressure
        # Combines options data to estimate synthetic short pressure
        options_short_pressure = 0.0
        
        # 1. Put-call imbalance component
        put_call_component = np.tanh((put_call_ratio - 1.0) * 2)
        
        # 2. Implied volatility component (higher IV often correlates with short pressure)
        iv_component = np.tanh((implied_volatility - 30) / 30) if implied_volatility > 0 else 0.0
        
        # 3. Synthetic short cost trend
        cost_trend_component = 0.0
        if t > 0 and abs(data[t-1, 64]) > 1e-8:
            cost_trend = (synthetic_short_cost / max(abs(data[t-1, 64]), 1e-8)) - 1.0
            cost_trend_component = np.tanh(cost_trend * 3)
        
        # Combine components with empirical weights
        options_short_pressure = (
            put_call_component * 0.4 +
            iv_component * 0.3 +
            cost_trend_component * 0.3
        )
        eng.append(options_short_pressure)
        
        # 19. NEW: Short Interest to Price Elasticity
        # Measures how price responds to changes in short interest
        if t > 1 and abs(data[t-2, 0]) > 1e-8 and len(close_prices) >= 3:
            # Calculate short interest change
            si_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1.0
            
            # Calculate corresponding price change
            price_change = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            
            # Calculate elasticity (price change / short interest change)
            if abs(si_change) > 0.01:  # Only calculate if there's meaningful SI change
                elasticity = price_change / max(abs(si_change), 1e-8)
                # Apply bounded transformation
                elasticity = np.tanh(elasticity)
            else:
                elasticity = 0.0
        else:
            elasticity = 0.0
        eng.append(elasticity)
        
        # 20. NEW: Short Volume Divergence Signal
        # Identifies divergences between price action and short volume
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            # Calculate price trend
            price_trend = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1.0
            
            # Calculate short volume trend
            short_vol_trend = (np.mean(short_volume[-2:]) / max(np.mean(short_volume[-5:-2]), 1e-8)) - 1.0
            
            # Identify divergence: price up + short volume up = bearish divergence
            #                      price down + short volume down = bullish divergence
            divergence = np.sign(price_trend) * np.sign(short_vol_trend) * min(abs(price_trend), abs(short_vol_trend)) * 3
            
            # Apply bounded transformation
            divergence = np.tanh(divergence)
        else:
            divergence = 0.0
        eng.append(divergence)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 49328.3229
RMSE: 64555.3014
MAPE: 15.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t2: importance=0.0005, rank=1
   2. Feature_13_t2: importance=0.0005, rank=2
   3. Feature_5_t2: importance=0.0005, rank=3
   4. Feature_6_t3: importance=0.0004, rank=4
   5. Feature_17_t3: importance=0.0004, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
📊 No significant improvement. Change: -0.71%

📈 Current best MAPE: 14.81%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 8
======================================================================
🤖 Calling Claude for iteration 8...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Construct features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep essential raw features (based on high importance in previous iterations)
        raw_keep.append(short_interest)  # Short interest - core target variable
        raw_keep.append(avg_volume)      # Average daily volume - key liquidity indicator
        raw_keep.append(days_to_cover)   # Days to cover - critical short squeeze metric
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price - high importance in previous iterations
        raw_keep.append(close_prices[-1])
        
        # Options data (high importance in previous iterations)
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        
        raw_keep.append(put_call_ratio)
        raw_keep.append(synthetic_short_cost)
        raw_keep.append(implied_volatility)
        
        # Shares outstanding
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with exponential weighting
        # Weights recent days more heavily for better predictive power
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Apply exponential weighting to emphasize recent data
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1.5, 5))
            weights = weights / np.sum(weights)
            weighted_svr = np.sum(short_volume_ratio[-5:] * weights)
        else:
            weighted_svr = np.mean(short_volume_ratio)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio with market cap context
        si_to_float_ratio = short_interest / max(abs(shares_outstanding), 1e-8)
        
        # Add market cap context for better normalization across different stocks
        if close_prices[-1] > 1e-8:
            market_cap_factor = np.log1p(close_prices[-1] * shares_outstanding / 1e6) / 10
            market_cap_factor = max(0.5, min(2.0, market_cap_factor))
            si_to_float_ratio = si_to_float_ratio * market_cap_factor
        eng.append(si_to_float_ratio)
        
        # 3. Short Interest Growth Rate with acceleration component
        # Improved by adding acceleration for trend detection
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            
            # Add acceleration component
            if t > 1 and abs(data[t-2, 0]) > 1e-8:
                prev_growth = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1.0
                acceleration = (si_growth - prev_growth) * 0.7  # Increased weight for acceleration
                si_growth = si_growth + acceleration
            
            # Apply bounded transformation
            si_growth = np.tanh(si_growth * 2.5)  # Increased scaling factor
        else:
            si_growth = 0.0
        eng.append(si_growth)
        
        # 4. Short Squeeze Potential with improved liquidity stress factor
        # Calculate liquidity trend (declining volume increases squeeze potential)
        liquidity_stress = 1.0
        if len(total_volume) >= 10:
            recent_vol_trend = np.mean(total_volume[-5:]) / max(np.mean(total_volume[-10:-5]), 1e-8)
            liquidity_stress = np.exp(-recent_vol_trend + 1)  # Higher when volume declining
            liquidity_stress = min(3.0, max(0.5, liquidity_stress))
        
        # Calculate price momentum
        price_momentum = 0.0
        if len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(np.median(close_prices[-5:-1]), 1e-8)) - 1.0
        
        # Combine factors with improved weighting
        squeeze_intensity = (days_to_cover**1.3) * (si_to_float_ratio**0.8) * (1 + implied_volatility/100)
        squeeze_intensity *= (1 + max(0, price_momentum * 1.5)) * liquidity_stress
        
        # Apply log transformation with better scaling
        short_squeeze_potential = np.log1p(max(squeeze_intensity, 0)) / 3.0
        eng.append(short_squeeze_potential)
        
        # 5. Price Volatility with regime detection
        # More accurate volatility estimation with regime detection
        if len(close_prices) >= 10:
            # Calculate returns
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-10:-1], 1e-8)
            
            # Detect volatility regime
            if len(returns) >= 5:
                recent_vol = np.std(returns[-5:])
                longer_vol = np.std(returns)
                vol_regime = recent_vol / max(longer_vol, 1e-8)
                
                # Combine with absolute volatility
                price_volatility = recent_vol * np.tanh(vol_regime * 1.5)
            else:
                price_volatility = np.std(returns)
        else:
            # Fallback to simple high-low range
            price_volatility = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
        eng.append(price_volatility)
        
        # 6. VWAP Deviation with adaptive bands
        # Improved by adding adaptive bands based on volatility
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(abs(np.sum(total_volume[-5:])), 1e-8)
            
            # Calculate price volatility around VWAP
            vwap_distances = close_prices[-5:] - vwap
            vwap_vol = np.std(vwap_distances) / max(abs(vwap), 1e-8)
            
            # Current deviation with adaptive normalization
            current_deviation = (close_prices[-1] - vwap) / max(abs(vwap), 1e-8)
            
            # Normalize by adaptive bands
            band_width = max(0.01, vwap_vol * 2)
            vwap_deviation = current_deviation / max(band_width, 1e-8)
            
            # Apply bounded transformation
            vwap_deviation = np.tanh(vwap_deviation * 2.5)  # Increased scaling
        else:
            vwap_deviation = 0.0
        eng.append(vwap_deviation)
        
        # 7. Options Market Pressure with volatility skew
        # Enhanced to better capture market sentiment
        options_pressure = put_call_ratio * (1 + implied_volatility/100)
        
        # Add term structure approximation using synthetic short cost trend
        if t > 0:
            cost_trend = synthetic_short_cost / max(data[t-1, 64], 1e-8) - 1.0
            # Rising costs with high put/call ratio indicates stronger bearish sentiment
            if cost_trend > 0 and put_call_ratio > 1.0:
                options_pressure *= (1 + min(cost_trend, 0.5))
        
        # Apply sigmoid transformation for better scaling
        options_pressure = 2.0 / (1.0 + np.exp(-options_pressure)) - 1.0
        eng.append(options_pressure)
        
        # 8. Short Cost Intensity with market impact modeling
        # Improved by modeling market impact of short covering
        short_cost_intensity = synthetic_short_cost * si_to_float_ratio
        
        # Add market impact factor - higher when short interest is high relative to volume
        market_impact = short_interest / max(avg_volume * 5, 1e-8)
        market_impact = min(3.0, market_impact)  # Cap for stability
        
        # Combine with non-linear scaling
        short_cost_pressure = short_cost_intensity * (1 + np.log1p(market_impact))
        
        # Apply log transformation with better scaling
        short_cost_pressure = np.log1p(max(short_cost_pressure, 0)) / max(1.0 + np.log1p(synthetic_short_cost), 1e-8)
        eng.append(short_cost_pressure)
        
        # 9. Short Interest Momentum Oscillator with improved weighting
        # Combines multiple timeframes of short interest changes for momentum signals
        if t >= 2:
            # Short-term momentum (most recent change)
            if abs(data[t-1, 0]) > 1e-8:
                short_term = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
            else:
                short_term = 0.0
                
            # Medium-term momentum
            if t >= 3 and abs(data[t-3, 0]) > 1e-8:
                medium_term = (short_interest / max(abs(data[t-3, 0]), 1e-8)) - 1.0
            else:
                medium_term = short_term
            
            # Combine with more weight on recent changes
            momentum_oscillator = short_term * 0.8 + medium_term * 0.2  # Increased weight on short-term
            
            # Apply sigmoid-like transformation with increased scaling
            momentum_oscillator = np.tanh(momentum_oscillator * 3.5)
        else:
            momentum_oscillator = 0.0
        eng.append(momentum_oscillator)
        
        # 10. Short Interest Utilization Rate with liquidity adjustment
        # Measures how much of the available float is being used for short positions
        si_utilization = short_interest / max(abs(shares_outstanding - short_interest), 1e-8)
        
        # Adjust for liquidity conditions
        if avg_volume > 1e-8:
            liquidity_factor = np.log1p(shares_outstanding / max(avg_volume * 20, 1e-8)) / 5
            liquidity_factor = max(0.5, min(2.0, liquidity_factor))
            si_utilization = si_utilization * liquidity_factor
        
        # Apply log transformation with better scaling
        si_utilization = np.log1p(si_utilization) / max(np.log1p(5.0), 1e-8)
        eng.append(si_utilization)
        
        # 11. Short Squeeze Vulnerability Index with improved weighting
        # Comprehensive metric combining multiple factors that contribute to squeeze risk
        
        # Days to cover component
        dtc_component = np.tanh(days_to_cover / 10)
        
        # Short interest concentration
        si_concentration = np.tanh(short_interest / max(shares_outstanding * 0.05, 1e-8))
        
        # Cost to borrow pressure
        cost_pressure = np.tanh(synthetic_short_cost / 5)
        
        # Price momentum component (positive momentum increases squeeze risk)
        momentum_component = 0.0
        if len(close_prices) >= 5:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1.0
            momentum_component = np.tanh(max(0, price_change * 5))
        
        # Volatility component
        vol_component = np.tanh(implied_volatility / 50)
        
        # Combine components with improved empirical weights
        squeeze_vulnerability = (
            dtc_component * 0.3 +           # Increased weight
            si_concentration * 0.25 +
            cost_pressure * 0.2 +
            momentum_component * 0.15 +
            vol_component * 0.1
        )
        
        # Scale to [-1, 1] range for consistency
        squeeze_vulnerability = squeeze_vulnerability * 2 - 1
        eng.append(squeeze_vulnerability)
        
        # 12. NEW: Relative Short Interest Position
        # Compares current short interest to its historical range
        if t >= 5:
            # Get historical short interest values
            hist_si = np.array([data[max(0, t-i), 0] for i in range(5)])
            
            # Calculate min and max
            si_min = np.min(hist_si)
            si_max = np.max(hist_si)
            
            # Calculate relative position
            si_range = max(abs(si_max - si_min), 1e-8)
            rel_si_position = (short_interest - si_min) / si_range
            
            # Scale to [-1, 1] range
            rel_si_position = rel_si_position * 2 - 1
        else:
            rel_si_position = 0.0
        eng.append(rel_si_position)
        
        # 13. NEW: Short Volume Trend Strength
        # Measures the strength and consistency of the short volume trend
        if len(short_volume) >= 10:
            # Calculate short volume changes
            sv_changes = np.diff(short_volume[-10:]) / np.maximum(short_volume[-10:-1], 1e-8)
            
            # Calculate trend direction (positive = increasing short volume)
            trend_direction = np.sign(np.mean(sv_changes))
            
            # Calculate trend consistency (how many changes align with the trend)
            trend_consistency = np.mean(np.sign(sv_changes) == trend_direction)
            
            # Calculate trend magnitude (average absolute change)
            trend_magnitude = np.mean(np.abs(sv_changes))
            
            # Combine into trend strength metric
            trend_strength = trend_direction * trend_consistency * np.tanh(trend_magnitude * 5)
        else:
            trend_strength = 0.0
        eng.append(trend_strength)
        
        # 14. NEW: Short Interest to Price Sensitivity
        # Measures how price responds to changes in short interest
        price_sensitivity = 0.0
        if t >= 3 and len(close_prices) >= 5:
            # Calculate short interest changes
            if abs(data[t-2, 0]) > 1e-8:
                si_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1.0
            else:
                si_change = 0.0
                
            # Calculate price changes
            if abs(close_prices[-3]) > 1e-8:
                price_change = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                price_change = 0.0
                
            # Calculate sensitivity (price change / short interest change)
            if abs(si_change) > 0.01:  # Only calculate if there's meaningful SI change
                price_sensitivity = price_change / max(abs(si_change), 1e-8)
                # Apply bounded transformation
                price_sensitivity = np.tanh(price_sensitivity * 2)
        eng.append(price_sensitivity)
        
        # 15. NEW: Short Interest Acceleration
        # Measures the rate of change in short interest growth
        si_acceleration = 0.0
        if t >= 3:
            # Calculate first-order changes
            if abs(data[t-2, 0]) > 1e-8 and abs(data[t-1, 0]) > 1e-8:
                change_t1 = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1.0
                change_t0 = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1.0
                
                # Calculate acceleration (change in change)
                si_acceleration = change_t0 - change_t1
                
                # Apply bounded transformation
                si_acceleration = np.tanh(si_acceleration * 3)
        eng.append(si_acceleration)
        
        # 16. NEW: Implied Volatility Change
        # Measures changes in implied volatility which can signal changing market expectations
        iv_change = 0.0
        if t > 0 and abs(data[t-1, 65]) > 1e-8:
            iv_change = (implied_volatility / max(abs(data[t-1, 65]), 1e-8)) - 1.0
            
            # Apply bounded transformation
            iv_change = np.tanh(iv_change * 3)
        eng.append(iv_change)
        
        # 17. NEW: Short Volume Intensity
        # Measures the intensity of short selling relative to historical patterns
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            # Calculate recent short volume ratio
            recent_sv_ratio = np.sum(short_volume[-3:]) / max(np.sum(total_volume[-3:]), 1e-8)
            
            # Calculate historical short volume ratio
            hist_sv_ratio = np.sum(short_volume[-10:-3]) / max(np.sum(total_volume[-10:-3]), 1e-8)
            
            # Calculate relative intensity
            if abs(hist_sv_ratio) > 1e-8:
                sv_intensity = (recent_sv_ratio / hist_sv_ratio) - 1.0
            else:
                sv_intensity = 0.0
                
            # Apply bounded transformation
            sv_intensity = np.tanh(sv_intensity * 2.5)
        else:
            sv_intensity = 0.0
        eng.append(sv_intensity)
        
        # 18. NEW: Price-Volume Divergence
        # Identifies divergences between price and volume which can signal reversals
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate price trend
            price_trend = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1.0
            
            # Calculate volume trend
            volume_trend = (np.mean(total_volume[-3:]) / max(np.mean(total_volume[-10:-3]), 1e-8)) - 1.0
            
            # Calculate divergence (opposite signs = divergence)
            divergence = -1 * np.sign(price_trend) * np.sign(volume_trend) * min(abs(price_trend), abs(volume_trend)) * 2
            
            # Only consider significant divergences
            if abs(price_trend) < 0.02 or abs(volume_trend) < 0.05:
                divergence = 0.0
                
            # Apply bounded transformation
            divergence = np.tanh(divergence * 2)
        else:
            divergence = 0.0
        eng.append(divergence)
        
        # 19. NEW: Short Interest Efficiency Ratio
        # Measures how efficiently short sellers are timing their positions
        if t >= 3 and len(close_prices) >= 5:
            # Calculate short interest change
            if abs(data[t-3, 0]) > 1e-8:
                si_change = (short_interest / max(abs(data[t-3, 0]), 1e-8)) - 1.0
            else:
                si_change = 0.0
                
            # Calculate price change (opposite direction for efficiency)
            if abs(close_prices[-5]) > 1e-8:
                price_change = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            else:
                price_change = 0.0
                
            # Calculate efficiency (negative correlation = efficient)
            # Short interest up + price down = efficient = positive score
            efficiency = -1 * np.sign(si_change) * np.sign(price_change) * min(abs(si_change), abs(price_change)) * 3
            
            # Apply bounded transformation
            efficiency = np.tanh(efficiency * 2)
        else:
            efficiency = 0.0
        eng.append(efficiency)
        
        # 20. NEW: Options-Implied Direction
        # Uses options data to predict likely price direction
        # Combines put-call ratio, implied volatility, and synthetic short cost
        
        # 1. Put-call direction component (higher ratio = bearish)
        put_call_direction = np.tanh((put_call_ratio - 1.0) * 2)
        
        # 2. Implied volatility trend component
        iv_direction = 0.0
        if t > 0 and abs(data[t-1, 65]) > 1e-8:
            iv_change = (implied_volatility / max(abs(data[t-1, 65]), 1e-8)) - 1.0
            iv_direction = np.sign(iv_change) * min(abs(iv_change) * 2, 1.0)
        
        # 3. Synthetic short cost component
        cost_direction = 0.0
        if t > 0 and abs(data[t-1, 64]) > 1e-8:
            cost_change = (synthetic_short_cost / max(abs(data[t-1, 64]), 1e-8)) - 1.0
            cost_direction = np.sign(cost_change) * min(abs(cost_change) * 2, 1.0)
        
        # Combine components with empirical weights
        options_direction = (
            put_call_direction * 0.5 +
            iv_direction * 0.3 +
            cost_direction * 0.2
        )
        eng.append(options_direction)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 8 (claude) (SVM)
==================================================
Training SVM model...

Iteration 8 (claude) Performance:
MAE: 47946.4360
RMSE: 62440.9480
MAPE: 15.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0005, rank=1
   2. Feature_24_t2: importance=0.0004, rank=2
   3. Feature_5_t2: importance=0.0004, rank=3
   4. Feature_1_t1: importance=0.0004, rank=4
   5. Feature_18_t2: importance=0.0003, rank=5
💾 Saved code for iteration 8 to iteration_codes dictionary
📊 No significant improvement. Change: -0.37%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 56505.4862
RMSE: 73103.6878
MAPE: 15.07%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 265
   • Highly important features (top 5%): 133

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_91_t0: importance=0.0005, rank=1
   2. Feature_92_t0: importance=0.0005, rank=2
   3. Feature_63_t2: importance=0.0004, rank=3
   4. Feature_74_t3: importance=0.0003, rank=4
   5. Feature_2_t2: importance=0.0003, rank=5
   Baseline MAPE: 15.07%
   Baseline MAE: 56505.4862
   Baseline RMSE: 73103.6878

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 58344.3188
RMSE: 73019.0210
MAPE: 15.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t1: importance=0.0010, rank=1
   2. Feature_10_t1: importance=0.0010, rank=2
   3. Feature_14_t1: importance=0.0007, rank=3
   4. Feature_13_t0: importance=0.0006, rank=4
   5. Feature_6_t0: importance=0.0005, rank=5

📊 Best Model Test Set Performance:
   MAPE: 15.91%
   MAE: 58344.3188
   RMSE: 73019.0210

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 15.07%
   Best Model MAPE: 15.91%
   Absolute Improvement: -0.84%
   Relative Improvement: -5.6%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  15.81           N/A                 
1          Iteration 1               15.14           +0.68%              
2          Iteration 2               15.30           -0.16%              
3          Iteration 3               14.81           +0.33%              
4          Iteration 4               15.91           -1.10%              
5          Iteration 5               15.23           -0.42%              
6          Iteration 6               15.51           -0.70%              
7          Iteration 7               15.52           -0.71%              
8          Iteration 8               15.18           -0.37%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 3 - MAPE: 14.81%
✅ Saved EIG results to cache/EIG_iterative_results_enhanced.pkl
✅ Summary report saved for EIG

🎉 Process completed successfully for EIG!

================================================================================
PROCESSING TICKER 3/14: EYE
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for EYE
======================================================================
📊 Loading data from parquet file...
📊 Loading data for EYE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error processing EYE: 'EYE'
⚠️ Skipping EYE and continuing with next ticker...

================================================================================
PROCESSING TICKER 4/14: AAP
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for AAP
======================================================================
📊 Loading data from parquet file...
📊 Loading data for AAP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error processing AAP: 'AAP'
⚠️ Skipping AAP and continuing with next ticker...

================================================================================
PROCESSING TICKER 5/14: FSS
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for FSS
======================================================================
📊 Loading data from parquet file...
📊 Loading data for FSS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FSS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 83229.6548
RMSE: 110982.5317
MAPE: 11.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 287
   • Highly important features (top 5%): 160

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t2: importance=0.0010, rank=1
   2. Feature_74_t3: importance=0.0008, rank=2
   3. Feature_83_t1: importance=0.0008, rank=3
   4. Feature_76_t0: importance=0.0008, rank=4
   5. Feature_72_t0: importance=0.0007, rank=5

📊 Baseline Performance: MAPE = 11.08%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values instead of all 60 values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which likely has predictive power for short interest
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep shares outstanding (important for relative measures)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This is a key indicator of short selling pressure
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days average)
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else 0
        eng.append(recent_svr)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Price momentum features
        # 5-day price return
        price_return_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1) if len(close_prices) >= 5 else 0
        eng.append(price_return_5d)
        
        # 10-day price return
        price_return_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1) if len(close_prices) >= 10 else 0
        eng.append(price_return_10d)
        
        # 4. Volatility measures
        # Calculate daily returns
        daily_returns = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        
        # Volatility (standard deviation of returns)
        volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 5. Price range relative to average true range
        # Calculate true range
        tr = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            high_low = high_prices[i] - low_prices[i]
            high_close = abs(high_prices[i] - close_prices[i-1])
            low_close = abs(low_prices[i] - close_prices[i-1])
            tr[i-1] = max(high_low, high_close, low_close)
        
        # Average true range (ATR)
        atr = np.mean(tr) if len(tr) > 0 else 0
        eng.append(atr)
        
        # 6. Short volume trend
        # Calculate the trend in short volume over the last 5 days
        if len(short_volume) >= 5:
            short_vol_trend = (short_volume[-1] / max(abs(np.mean(short_volume[-5:-1])), 1e-8)) - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 7. Options-based features
        # Put-call ratio change
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 8. Volume spike detection
        # Detect abnormal volume compared to recent average
        recent_vol_avg = np.mean(total_volume[:-1]) if len(total_volume) > 1 else total_volume[-1]
        vol_spike = total_volume[-1] / max(abs(recent_vol_avg), 1e-8) - 1
        eng.append(vol_spike)
        
        # 9. Short volume to average volume ratio
        # Compare recent short volume to historical average volume
        recent_short_vol = np.mean(short_volume[-3:]) if len(short_volume) >= 3 else (short_volume[-1] if len(short_volume) > 0 else 0)
        short_to_avg_vol = recent_short_vol / max(abs(data[t, 1]), 1e-8)
        eng.append(short_to_avg_vol)
        
        # 10. Price to volatility ratio
        # How much price movement relative to volatility
        price_vol_ratio = close_prices[-1] / max(abs(volatility), 1e-8) if volatility > 0 else 0
        eng.append(price_vol_ratio)
        
        # 11. RSI (Relative Strength Index)
        # Calculate gains and losses
        gains = np.zeros(len(daily_returns))
        losses = np.zeros(len(daily_returns))
        for i in range(len(daily_returns)):
            if daily_returns[i] > 0:
                gains[i] = daily_returns[i]
            else:
                losses[i] = abs(daily_returns[i])
        
        # Calculate RSI
        avg_gain = np.mean(gains) if len(gains) > 0 else 0
        avg_loss = np.mean(losses) if len(losses) > 0 else 0
        
        if avg_loss > 0:
            rs = avg_gain / max(abs(avg_loss), 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 100 if avg_gain > 0 else 50
        
        eng.append(rsi)
        
        # 12. Short interest change rate
        # If we have previous data point, calculate change rate
        si_change = 0
        if t > 0 and data[t-1, 0] > 0:
            si_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_change)
        
        # 13. Short interest to volume ratio
        si_to_volume = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_volume)
        
        # 14. Bollinger Band position
        # Calculate where current price is within Bollinger Bands
        sma = np.mean(close_prices) if len(close_prices) > 0 else close_prices[-1]
        std = np.std(close_prices) if len(close_prices) > 1 else 0
        
        if std > 0:
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            bb_position = (close_prices[-1] - lower_band) / max(abs(upper_band - lower_band), 1e-8)
        else:
            bb_position = 0.5
        
        eng.append(bb_position)
        
        # 15. Implied volatility to historical volatility ratio
        iv_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8) if volatility > 0 else 0
        eng.append(iv_hv_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 87255.2465
RMSE: 113769.1874
MAPE: 12.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_8_t0: importance=0.0024, rank=1
   2. Feature_20_t3: importance=0.0018, rank=2
   3. Feature_16_t3: importance=0.0017, rank=3
   4. Feature_19_t2: importance=0.0016, rank=4
   5. Feature_20_t2: importance=0.0016, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
📊 No significant improvement. Change: -1.03%

📈 Current best MAPE: 11.08%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep only the most recent close price (Feature_8_t0 had high importance)
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep options data which likely has predictive power for short interest
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding (important for relative measures)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This is a key indicator of short selling pressure
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days average)
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else 0
        eng.append(recent_svr)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Price momentum features - Feature_20 had high importance
        # 5-day price return
        price_return_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1) if len(close_prices) >= 5 else 0
        eng.append(price_return_5d)
        
        # 4. Short volume trend - Focus on short volume features which showed high importance
        # Calculate the trend in short volume over the last 5 days
        if len(short_volume) >= 5:
            short_vol_trend = (short_volume[-1] / max(abs(np.mean(short_volume[-5:-1])), 1e-8)) - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 5. Short interest change rate
        # If we have previous data point, calculate change rate
        si_change = 0
        if t > 0 and data[t-1, 0] > 0:
            si_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_change)
        
        # 6. Short interest to volume ratio
        si_to_volume = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_volume)
        
        # 7. Volatility measures - Feature_16 had high importance
        # Calculate daily returns
        daily_returns = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        
        # Volatility (standard deviation of returns)
        volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 8. Implied volatility to historical volatility ratio
        iv_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8) if volatility > 0 else 0
        eng.append(iv_hv_ratio)
        
        # 9. Short volume acceleration (second derivative)
        # Captures the rate of change in short volume trend
        short_vol_accel = 0
        if len(short_volume) >= 10:
            recent_trend = (short_volume[-1] / max(abs(short_volume[-5]), 1e-8)) - 1
            prev_trend = (short_volume[-6] / max(abs(short_volume[-10]), 1e-8)) - 1
            short_vol_accel = recent_trend - prev_trend
        eng.append(short_vol_accel)
        
        # 10. Short interest to days to cover ratio
        # Relates short interest to the time needed to cover
        si_to_dtc = data[t, 0] / max(abs(data[t, 2]), 1e-8)
        eng.append(si_to_dtc)
        
        # 11. Price to short volume ratio
        # How much short volume relative to price
        price_to_short = close_prices[-1] / max(abs(np.mean(short_volume[-5:])), 1e-8) if len(short_volume) >= 5 else 0
        eng.append(price_to_short)
        
        # 12. RSI (Relative Strength Index) - Feature_19 had high importance
        # Calculate gains and losses
        gains = np.zeros(len(daily_returns))
        losses = np.zeros(len(daily_returns))
        for i in range(len(daily_returns)):
            if daily_returns[i] > 0:
                gains[i] = daily_returns[i]
            else:
                losses[i] = abs(daily_returns[i])
        
        # Calculate RSI
        avg_gain = np.mean(gains) if len(gains) > 0 else 0
        avg_loss = np.mean(losses) if len(losses) > 0 else 0
        
        if avg_loss > 0:
            rs = avg_gain / max(abs(avg_loss), 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 100 if avg_gain > 0 else 50
        
        eng.append(rsi)
        
        # 13. Short volume concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_5d_short = np.sum(short_volume[-5:])
            prev_5d_short = np.sum(short_volume[-10:-5])
            short_concentration = recent_5d_short / max(abs(prev_5d_short), 1e-8)
        else:
            short_concentration = 1.0
        eng.append(short_concentration)
        
        # 14. Price volatility ratio
        # Compares recent price volatility to longer-term volatility
        if len(close_prices) >= 10:
            recent_vol = np.std(close_prices[-5:])
            longer_vol = np.std(close_prices[-10:])
            price_vol_ratio = recent_vol / max(abs(longer_vol), 1e-8)
        else:
            price_vol_ratio = 1.0
        eng.append(price_vol_ratio)
        
        # 15. Short volume to price volatility ratio
        # Relates short selling activity to price volatility
        if volatility > 0 and len(short_volume) >= 5:
            short_vol_to_price_vol = np.mean(short_volume[-5:]) / max(abs(volatility * close_prices[-1]), 1e-8)
        else:
            short_vol_to_price_vol = 0
        eng.append(short_vol_to_price_vol)
        
        # 16. Options synthetic short cost to short interest ratio
        # Relates the cost of synthetic shorts to actual short interest
        synthetic_cost_to_si = data[t, 64] / max(abs(data[t, 0]), 1e-8)
        eng.append(synthetic_cost_to_si)
        
        # 17. Short interest momentum
        # Measures acceleration in short interest changes
        si_momentum = 0
        if t >= 2 and data[t-2, 0] > 0:
            recent_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            prev_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_momentum = recent_change - prev_change
        eng.append(si_momentum)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 88970.4013
RMSE: 113976.4595
MAPE: 12.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0018, rank=1
   2. Feature_12_t3: importance=0.0016, rank=2
   3. Feature_22_t3: importance=0.0014, rank=3
   4. Feature_24_t2: importance=0.0013, rank=4
   5. Feature_15_t2: importance=0.0012, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -1.09%

📈 Current best MAPE: 11.08%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep most recent close price (high importance in previous iterations)
        raw_keep.append(close_prices[-1])
        
        # Keep options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding (important for normalization)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was a key indicator in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days average)
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else 0
        eng.append(recent_svr)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Price momentum - 5-day return
        # Feature_4_t1 had high importance in iteration 2
        price_return_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1) if len(close_prices) >= 5 else 0
        eng.append(price_return_5d)
        
        # 4. Short volume trend - 5-day change
        # Focus on short volume which showed high importance
        if len(short_volume) >= 5:
            short_vol_trend = (short_volume[-1] / max(abs(np.mean(short_volume[-5:-1])), 1e-8)) - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 5. Short interest change rate
        # If we have previous data point, calculate change rate
        si_change = 0
        if t > 0 and data[t-1, 0] > 0:
            si_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_change)
        
        # 6. Volatility (standard deviation of returns)
        # Feature_12_t3 had high importance in iteration 2
        daily_returns = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        
        volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 7. RSI (Relative Strength Index)
        # Feature_22_t3 had high importance in iteration 2
        gains = np.zeros(len(daily_returns))
        losses = np.zeros(len(daily_returns))
        for i in range(len(daily_returns)):
            if daily_returns[i] > 0:
                gains[i] = daily_returns[i]
            else:
                losses[i] = abs(daily_returns[i])
        
        avg_gain = np.mean(gains) if len(gains) > 0 else 0
        avg_loss = np.mean(losses) if len(losses) > 0 else 0
        
        if avg_loss > 0:
            rs = avg_gain / max(abs(avg_loss), 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 100 if avg_gain > 0 else 50
        
        eng.append(rsi)
        
        # 8. Short volume to total volume ratio trend
        # Captures the change in short selling pressure
        svr_trend = 0
        if len(short_volume_ratio) >= 10:
            recent_svr = np.mean(short_volume_ratio[-5:])
            prev_svr = np.mean(short_volume_ratio[-10:-5])
            svr_trend = (recent_svr / max(abs(prev_svr), 1e-8)) - 1
        eng.append(svr_trend)
        
        # 9. Price channel breakout indicator
        # Identifies potential trend reversals
        if len(close_prices) >= 10:
            upper_channel = np.max(close_prices[-10:-1])
            lower_channel = np.min(close_prices[-10:-1])
            channel_width = upper_channel - lower_channel
            if channel_width > 0:
                breakout = (close_prices[-1] - lower_channel) / max(abs(channel_width), 1e-8)
            else:
                breakout = 0.5
        else:
            breakout = 0.5
        eng.append(breakout)
        
        # 10. Bollinger Band position
        # Feature_24_t2 had high importance in iteration 2
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            if std > 0:
                bb_position = (close_prices[-1] - sma) / max(abs(std), 1e-8)
            else:
                bb_position = 0
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 11. Short interest to days to cover ratio
        # Relates short interest to the time needed to cover
        si_to_dtc = data[t, 0] / max(abs(data[t, 2]), 1e-8)
        eng.append(si_to_dtc)
        
        # 12. Options implied volatility to historical volatility ratio
        # Feature_15_t2 had high importance in iteration 2
        iv_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8) if volatility > 0 else 0
        eng.append(iv_hv_ratio)
        
        # 13. Short interest momentum
        # Measures acceleration in short interest changes
        si_momentum = 0
        if t >= 2 and data[t-2, 0] > 0:
            recent_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            prev_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_momentum = recent_change - prev_change
        eng.append(si_momentum)
        
        # 14. MACD-like indicator (difference between short and long EMAs)
        # Captures momentum and trend direction
        if len(close_prices) >= 12:
            # Simple implementation of EMA
            ema_short = np.mean(close_prices[-5:])
            ema_long = np.mean(close_prices[-12:])
            macd = (ema_short / max(abs(ema_long), 1e-8)) - 1
        else:
            macd = 0
        eng.append(macd)
        
        # 15. Short volume concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_5d_short = np.sum(short_volume[-5:])
            prev_5d_short = np.sum(short_volume[-10:-5])
            short_concentration = recent_5d_short / max(abs(prev_5d_short), 1e-8)
        else:
            short_concentration = 1.0
        eng.append(short_concentration)
        
        # 16. Put-call ratio trend
        # Captures changes in options sentiment
        put_call_trend = 0
        if t > 0 and data[t-1, 63] > 0:
            put_call_trend = (data[t, 63] / max(abs(data[t-1, 63]), 1e-8)) - 1
        eng.append(put_call_trend)
        
        # 17. Average True Range (ATR) - volatility measure
        # Captures price volatility including gaps
        atr = 0
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, min(10, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                true_ranges.append(max(high_low, high_close, low_close))
            atr = np.mean(true_ranges) if true_ranges else 0
        eng.append(atr)
        
        # 18. Normalized ATR (ATR / Close price)
        # Volatility relative to price level
        norm_atr = atr / max(abs(close_prices[-1]), 1e-8) if len(close_prices) > 0 else 0
        eng.append(norm_atr)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 84992.2248
RMSE: 111139.7088
MAPE: 11.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0016, rank=1
   2. Feature_15_t2: importance=0.0015, rank=2
   3. Feature_8_t0: importance=0.0015, rank=3
   4. Feature_12_t2: importance=0.0014, rank=4
   5. Feature_7_t3: importance=0.0013, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -0.61%

📈 Current best MAPE: 11.08%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep most recent close price
        raw_keep.append(close_prices[-1])
        
        # Keep options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding (important for normalization)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # Compute for all days and then use in multiple features
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days average)
        # This was a top performer in previous iterations
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else 0
        eng.append(recent_svr)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Short interest change rate
        # If we have previous data point, calculate change rate
        si_change = 0
        if t > 0 and data[t-1, 0] > 0:
            si_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_change)
        
        # 4. Short interest momentum (acceleration)
        # Measures acceleration in short interest changes
        si_momentum = 0
        if t >= 2 and data[t-2, 0] > 0:
            recent_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            prev_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_momentum = recent_change - prev_change
        eng.append(si_momentum)
        
        # 5. Short interest to days to cover ratio
        # Relates short interest to the time needed to cover
        si_to_dtc = data[t, 0] / max(abs(data[t, 2]), 1e-8)
        eng.append(si_to_dtc)
        
        # 6. Volatility (standard deviation of returns)
        # Calculate daily returns first for use in multiple features
        daily_returns = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        
        volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 7. Options implied volatility to historical volatility ratio
        # Feature_15_t2 had high importance in previous iterations
        iv_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8) if volatility > 0 else 1
        eng.append(iv_hv_ratio)
        
        # 8. RSI (Relative Strength Index)
        # Feature_22_t3 had high importance in previous iterations
        if len(daily_returns) > 0:
            up_returns = np.where(daily_returns > 0, daily_returns, 0)
            down_returns = np.where(daily_returns < 0, -daily_returns, 0)
            avg_up = np.mean(up_returns) if len(up_returns) > 0 else 0
            avg_down = np.mean(down_returns) if len(down_returns) > 0 else 0
            
            if avg_down > 0:
                rs = avg_up / max(abs(avg_down), 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if avg_up > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # 9. Short volume trend - ratio of recent to previous
        # Captures if short selling is accelerating or decelerating
        if len(short_volume) >= 10:
            recent_short = np.sum(short_volume[-5:])
            prev_short = np.sum(short_volume[-10:-5])
            short_vol_trend = recent_short / max(abs(prev_short), 1e-8)
        else:
            short_vol_trend = 1.0
        eng.append(short_vol_trend)
        
        # 10. Short volume ratio trend
        # Captures the change in short selling pressure relative to total volume
        svr_trend = 0
        if len(short_volume_ratio) >= 10:
            recent_svr = np.mean(short_volume_ratio[-5:])
            prev_svr = np.mean(short_volume_ratio[-10:-5])
            svr_trend = recent_svr / max(abs(prev_svr), 1e-8)
        else:
            svr_trend = 1.0
        eng.append(svr_trend)
        
        # 11. Bollinger Band position
        # Feature_24_t2 had high importance in previous iterations
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            if std > 0:
                bb_position = (close_prices[-1] - sma) / max(abs(std * 2), 1e-8)  # Normalized to typical -1 to 1 range
                bb_position = max(min(bb_position, 1.0), -1.0)  # Clamp to -1 to 1
            else:
                bb_position = 0
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 12. Price momentum - 5-day return
        # Feature_4_t1 had high importance in previous iterations
        if len(close_prices) >= 5:
            price_return_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1
        else:
            price_return_5d = 0
        eng.append(price_return_5d)
        
        # 13. Average True Range (ATR) - normalized by price
        # Better volatility measure that accounts for gaps
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, min(10, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                true_ranges.append(max(high_low, high_close, low_close))
            
            atr = np.mean(true_ranges) if true_ranges else 0
            norm_atr = atr / max(abs(close_prices[-1]), 1e-8)
        else:
            norm_atr = 0
        eng.append(norm_atr)
        
        # 14. Put-call ratio trend
        # Captures changes in options sentiment
        put_call_trend = 0
        if t > 0 and data[t-1, 63] > 0:
            put_call_trend = (data[t, 63] / max(abs(data[t-1, 63]), 1e-8)) - 1
        eng.append(put_call_trend)
        
        # 15. Short interest relative to historical range
        # Percentile position of current SI in its recent range
        si_percentile = 0.5  # Default to middle
        if t >= 5:
            historical_si = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(historical_si)
            si_max = max(historical_si)
            si_range = si_max - si_min
            if si_range > 0:
                si_percentile = (data[t, 0] - si_min) / max(abs(si_range), 1e-8)
                si_percentile = max(min(si_percentile, 1.0), 0.0)  # Clamp to 0-1
        eng.append(si_percentile)
        
        # 16. Volume surge indicator
        # Detects unusual volume that might signal major market events
        vol_surge = 0
        if len(total_volume) >= 10:
            recent_vol = total_volume[-1]
            avg_vol = np.mean(total_volume[-10:-1])
            vol_surge = recent_vol / max(abs(avg_vol), 1e-8)
        eng.append(vol_surge)
        
        # 17. Short interest to volume ratio
        # Relates short interest to trading liquidity
        si_to_vol = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_vol)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 87091.2732
RMSE: 112280.5983
MAPE: 11.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0020, rank=1
   2. Feature_8_t0: importance=0.0018, rank=2
   3. Feature_15_t0: importance=0.0015, rank=3
   4. Feature_11_t2: importance=0.0015, rank=4
   5. Feature_10_t3: importance=0.0014, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.91%

📈 Current best MAPE: 11.08%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep most recent close price (important for normalization)
        raw_keep.append(close_prices[-1])
        
        # Keep options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Keep shares outstanding (important for normalization)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Calculate daily returns for use in multiple features
        daily_returns = np.zeros(len(close_prices)-1)
        for i in range(1, len(close_prices)):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was a top performer in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (last 5 days average)
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else 0
        eng.append(recent_svr)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Short interest change rate (momentum)
        # If we have previous data point, calculate change rate
        si_change = 0
        if t > 0 and data[t-1, 0] > 0:
            si_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_change)
        
        # 4. Short interest acceleration (2nd derivative)
        # Measures acceleration in short interest changes
        si_accel = 0
        if t >= 2 and data[t-2, 0] > 0:
            recent_change = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            prev_change = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_accel = recent_change - prev_change
        eng.append(si_accel)
        
        # 5. Volatility (standard deviation of returns)
        # Important for risk assessment and option pricing
        volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 6. Options implied volatility to historical volatility ratio
        # Feature_15_t2 had high importance in previous iterations
        iv_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8) if volatility > 0 else 1
        eng.append(iv_hv_ratio)
        
        # 7. RSI (Relative Strength Index)
        # Feature_22_t3 had high importance in previous iterations
        if len(daily_returns) >= 5:
            up_returns = np.where(daily_returns[-5:] > 0, daily_returns[-5:], 0)
            down_returns = np.where(daily_returns[-5:] < 0, -daily_returns[-5:], 0)
            avg_up = np.mean(up_returns) if len(up_returns) > 0 else 0
            avg_down = np.mean(down_returns) if len(down_returns) > 0 else 0
            
            if avg_down > 0:
                rs = avg_up / max(abs(avg_down), 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if avg_up > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # 8. Short volume trend - ratio of recent to previous
        # Captures if short selling is accelerating or decelerating
        if len(short_volume) >= 10:
            recent_short = np.sum(short_volume[-5:])
            prev_short = np.sum(short_volume[-10:-5])
            short_vol_trend = recent_short / max(abs(prev_short), 1e-8)
        else:
            short_vol_trend = 1.0
        eng.append(short_vol_trend)
        
        # 9. Bollinger Band position
        # Feature_24_t2 had high importance in previous iterations
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            if std > 0:
                bb_position = (close_prices[-1] - sma) / max(abs(std * 2), 1e-8)
                bb_position = max(min(bb_position, 1.0), -1.0)  # Clamp to -1 to 1
            else:
                bb_position = 0
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 10. Price momentum - 5-day return
        # Feature_4_t1 had high importance in previous iterations
        if len(close_prices) >= 5:
            price_return_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1
        else:
            price_return_5d = 0
        eng.append(price_return_5d)
        
        # 11. Average True Range (ATR) - normalized by price
        # Better volatility measure that accounts for gaps
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, min(10, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                true_ranges.append(max(high_low, high_close, low_close))
            
            atr = np.mean(true_ranges) if true_ranges else 0
            norm_atr = atr / max(abs(close_prices[-1]), 1e-8)
        else:
            norm_atr = 0
        eng.append(norm_atr)
        
        # 12. Put-call ratio trend
        # Captures changes in options sentiment
        put_call_trend = 0
        if t > 0 and data[t-1, 63] > 0:
            put_call_trend = (data[t, 63] / max(abs(data[t-1, 63]), 1e-8)) - 1
        eng.append(put_call_trend)
        
        # 13. Short interest relative to historical range
        # Percentile position of current SI in its recent range
        si_percentile = 0.5  # Default to middle
        if t >= 5:
            historical_si = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(historical_si)
            si_max = max(historical_si)
            si_range = si_max - si_min
            if si_range > 0:
                si_percentile = (data[t, 0] - si_min) / max(abs(si_range), 1e-8)
                si_percentile = max(min(si_percentile, 1.0), 0.0)  # Clamp to 0-1
        eng.append(si_percentile)
        
        # 14. Short interest to volume ratio
        # Relates short interest to trading liquidity
        si_to_vol = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_vol)
        
        # 15. MACD Signal Line Crossover
        # Momentum indicator that can signal trend changes
        if len(close_prices) >= 12:
            ema12 = np.mean(close_prices[-12:])  # Simple approximation of EMA
            ema26 = np.mean(close_prices)  # Use all available data for longer EMA
            macd = ema12 - ema26
            
            # Signal line (9-period EMA of MACD)
            if t >= 1 and len(data[t-1, 3:63].reshape(15, 4)[:, 3]) >= 12:
                prev_close = data[t-1, 3:63].reshape(15, 4)[:, 3]
                prev_ema12 = np.mean(prev_close[-12:])
                prev_ema26 = np.mean(prev_close)
                prev_macd = prev_ema12 - prev_ema26
                
                # MACD momentum (change in MACD)
                macd_momentum = macd - prev_macd
            else:
                macd_momentum = 0
        else:
            macd_momentum = 0
        eng.append(macd_momentum)
        
        # 16. Short Interest to Days to Cover Ratio Change
        # Tracks changes in the relationship between SI and DTC
        si_dtc_ratio = data[t, 0] / max(abs(data[t, 2]), 1e-8)
        si_dtc_change = 0
        if t > 0:
            prev_si_dtc = data[t-1, 0] / max(abs(data[t-1, 2]), 1e-8)
            si_dtc_change = (si_dtc_ratio / max(abs(prev_si_dtc), 1e-8)) - 1
        eng.append(si_dtc_change)
        
        # 17. Short Volume Intensity
        # Ratio of short volume to average daily volume
        short_vol_intensity = np.mean(short_volume[-5:]) / max(abs(data[t, 1]), 1e-8) if len(short_volume) >= 5 else 0
        eng.append(short_vol_intensity)
        
        # 18. Synthetic Short Cost Change
        # Track changes in the cost of creating synthetic shorts
        syn_short_change = 0
        if t > 0 and data[t-1, 64] > 0:
            syn_short_change = (data[t, 64] / max(abs(data[t-1, 64]), 1e-8)) - 1
        eng.append(syn_short_change)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 90576.5292
RMSE: 115834.7146
MAPE: 12.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0016, rank=1
   2. Feature_22_t1: importance=0.0014, rank=2
   3. Feature_8_t0: importance=0.0013, rank=3
   4. Feature_19_t1: importance=0.0013, rank=4
   5. Feature_10_t3: importance=0.0013, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -1.50%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 256206.1973
RMSE: 343577.1491
MAPE: 13.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 231
   • Highly important features (top 5%): 109

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t0: importance=0.0009, rank=1
   2. Feature_78_t2: importance=0.0009, rank=2
   3. Feature_72_t2: importance=0.0007, rank=3
   4. Feature_69_t0: importance=0.0007, rank=4
   5. Feature_72_t3: importance=0.0007, rank=5
   Baseline MAPE: 13.81%
   Baseline MAE: 256206.1973
   Baseline RMSE: 343577.1491

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 245330.7837
RMSE: 334027.5984
MAPE: 13.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t3: importance=0.0015, rank=1
   2. Feature_14_t2: importance=0.0012, rank=2
   3. Feature_16_t2: importance=0.0012, rank=3
   4. Feature_8_t0: importance=0.0011, rank=4
   5. Feature_20_t3: importance=0.0010, rank=5

📊 Best Model Test Set Performance:
   MAPE: 13.75%
   MAE: 245330.7837
   RMSE: 334027.5984

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 13.81%
   Best Model MAPE: 13.75%
   Absolute Improvement: 0.06%
   Relative Improvement: 0.4%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  11.08           N/A                 
1          Iteration 1               12.11           -1.03%              
2          Iteration 2               12.17           -1.09%              
3          Iteration 3               11.69           -0.61%              
4          Iteration 4               11.99           -0.91%              
5          Iteration 5               12.58           -1.50%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 3 - MAPE: 11.69%
✅ Saved FSS results to cache/FSS_iterative_results_enhanced.pkl
✅ Summary report saved for FSS

🎉 Process completed successfully for FSS!

================================================================================
PROCESSING TICKER 6/14: ABM
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for ABM
======================================================================
📊 Loading data from parquet file...
📊 Loading data for ABM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ABM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 211435.4276
RMSE: 268102.6762
MAPE: 15.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 225
   • Highly important features (top 5%): 153

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0005, rank=1
   2. Feature_65_t2: importance=0.0003, rank=2
   3. Feature_63_t1: importance=0.0002, rank=3
   4. Feature_80_t1: importance=0.0002, rank=4
   5. Feature_68_t3: importance=0.0002, rank=5

📊 Baseline Performance: MAPE = 15.91%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep high importance features from previous iteration
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio (Feature_63)
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility (Feature_65)
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep shares outstanding (important for relative measures)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This measures the proportion of daily trading that is short selling
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Interest to Float Ratio
        # Measures short interest relative to shares outstanding (float)
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Recent price momentum (5-day)
        # Captures recent price trend which can influence short covering
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # 4. Recent price momentum (10-day)
        # Longer-term price trend
        if len(close_prices) >= 10:
            momentum_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
        else:
            momentum_10d = 0.0
        eng.append(momentum_10d)
        
        # 5. Price volatility (standard deviation of returns)
        # Higher volatility may correlate with short interest changes
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(np.abs(close_prices[:-1]), 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0.0
        else:
            volatility = 0.0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility indicator
        # Measures market volatility which can affect short interest
        atr_sum = 0.0
        if len(close_prices) >= 2:
            for i in range(1, min(15, len(close_prices))):
                tr1 = high_prices[i] - low_prices[i]
                tr2 = abs(high_prices[i] - close_prices[i-1])
                tr3 = abs(low_prices[i] - close_prices[i-1])
                true_range = max(tr1, tr2, tr3)
                atr_sum += true_range
            atr = atr_sum / max(min(14, len(close_prices)-1), 1)
        else:
            atr = 0.0
        eng.append(atr)
        
        # 7. Short volume trend
        # Measures if short volume is increasing or decreasing
        if len(short_volume) >= 5:
            short_volume_trend = (np.mean(short_volume[-3:]) / max(abs(np.mean(short_volume[-5:-2])), 1e-8)) - 1.0
        else:
            short_volume_trend = 0.0
        eng.append(short_volume_trend)
        
        # 8. Options synthetic short cost to implied volatility ratio
        # Relationship between shorting cost and market expectations
        implied_vol = max(abs(data[t, 65]), 1e-8)
        synthetic_short_cost_to_iv = data[t, 64] / implied_vol
        eng.append(synthetic_short_cost_to_iv)
        
        # 9. RSI (Relative Strength Index)
        # Momentum oscillator that measures speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            
            if avg_loss == 0:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            rsi = 50.0  # Neutral value when not enough data
        eng.append(rsi)
        
        # 10. Short interest to average volume ratio
        # How many days of average volume the short interest represents
        avg_volume = max(abs(data[t, 1]), 1e-8)
        short_interest_to_avg_volume = data[t, 0] / avg_volume
        eng.append(short_interest_to_avg_volume)
        
        # 11. Price to moving average ratio
        # Indicates if price is above/below recent average (trend indicator)
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(abs(ma10), 1e-8)
        else:
            price_to_ma = 1.0
        eng.append(price_to_ma)
        
        # 12. Short volume acceleration
        # Second derivative of short volume - rate of change of short volume trend
        if len(short_volume) >= 10:
            short_vol_5d_1 = np.mean(short_volume[-5:])
            short_vol_5d_2 = np.mean(short_volume[-10:-5])
            short_vol_trend_1 = short_vol_5d_1 / max(abs(short_vol_5d_2), 1e-8) - 1.0
            
            short_vol_5d_3 = np.mean(short_volume[-15:-10]) if len(short_volume) >= 15 else short_vol_5d_2
            short_vol_trend_2 = short_vol_5d_2 / max(abs(short_vol_5d_3), 1e-8) - 1.0
            
            short_vol_accel = short_vol_trend_1 - short_vol_trend_2
        else:
            short_vol_accel = 0.0
        eng.append(short_vol_accel)
        
        # 13. OHLC price range relative to close
        # Measures recent price volatility relative to price level
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            recent_close = close_prices[-1]
            price_range_ratio = (recent_high - recent_low) / max(abs(recent_close), 1e-8)
        else:
            price_range_ratio = 0.0
        eng.append(price_range_ratio)
        
        # 14. Put-call ratio trend
        # Change in options sentiment which may predict short interest changes
        if t > 0:
            put_call_ratio_change = data[t, 63] / max(abs(data[t-1, 63]), 1e-8) - 1.0
        else:
            put_call_ratio_change = 0.0
        eng.append(put_call_ratio_change)
        
        # 15. Short interest to days to cover ratio
        # Relationship between short interest and the time to cover
        days_to_cover = max(abs(data[t, 2]), 1e-8)
        si_to_dtc_ratio = data[t, 0] / days_to_cover
        eng.append(si_to_dtc_ratio)
        
        # 16. Bollinger Band Width
        # Measures volatility which can affect short interest
        if len(close_prices) >= 10:
            ma20 = np.mean(close_prices[-10:])
            std20 = np.std(close_prices[-10:])
            bb_width = (2 * std20) / max(abs(ma20), 1e-8)
        else:
            bb_width = 0.0
        eng.append(bb_width)
        
        # 17. Short volume to total volume ratio trend
        # Change in proportion of short selling activity
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_sv_ratio = np.mean(short_volume[-5:]) / max(abs(np.mean(total_volume[-5:])), 1e-8)
            older_sv_ratio = np.mean(short_volume[-10:-5]) / max(abs(np.mean(total_volume[-10:-5])), 1e-8)
            sv_ratio_trend = recent_sv_ratio / max(abs(older_sv_ratio), 1e-8) - 1.0
        else:
            sv_ratio_trend = 0.0
        eng.append(sv_ratio_trend)
        
        # 18. Implied volatility to historical volatility ratio
        # Compares market expectations to realized volatility
        if volatility > 0:
            iv_to_hv_ratio = data[t, 65] / max(abs(volatility), 1e-8)
        else:
            iv_to_hv_ratio = 1.0
        eng.append(iv_to_hv_ratio)
        
        # 19. Short interest momentum
        # Rate of change in short interest
        if t > 0:
            si_momentum = data[t, 0] / max(abs(data[t-1, 0]), 1e-8) - 1.0
        else:
            si_momentum = 0.0
        eng.append(si_momentum)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 194304.4179
RMSE: 241780.2336
MAPE: 14.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0015, rank=1
   2. Feature_24_t1: importance=0.0007, rank=2
   3. Feature_14_t0: importance=0.0006, rank=3
   4. Feature_4_t2: importance=0.0006, rank=4
   5. Feature_17_t0: importance=0.0004, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 1.47%

📈 Current best MAPE: 14.44%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This measures the proportion of daily trading that is short selling
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days - high importance in previous iteration
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Interest to Float Ratio
        # Measures short interest relative to shares outstanding (float)
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Recent price momentum (5-day) - high importance in previous iteration
        # Captures recent price trend which can influence short covering
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # 4. Price volatility (standard deviation of returns)
        # Higher volatility may correlate with short interest changes
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(np.abs(close_prices[:-1]), 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0.0
        else:
            volatility = 0.0
        eng.append(volatility)
        
        # 5. RSI (Relative Strength Index) - high importance in previous iteration
        # Momentum oscillator that measures speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            
            if avg_loss == 0:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            rsi = 50.0  # Neutral value when not enough data
        eng.append(rsi)
        
        # 6. Short interest to average volume ratio
        # How many days of average volume the short interest represents
        avg_volume = max(abs(data[t, 1]), 1e-8)
        short_interest_to_avg_volume = data[t, 0] / avg_volume
        eng.append(short_interest_to_avg_volume)
        
        # 7. Price to moving average ratio - high importance in previous iteration
        # Indicates if price is above/below recent average (trend indicator)
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(abs(ma10), 1e-8)
        else:
            price_to_ma = 1.0
        eng.append(price_to_ma)
        
        # 8. Short interest momentum
        # Rate of change in short interest
        if t > 0:
            si_momentum = data[t, 0] / max(abs(data[t-1, 0]), 1e-8) - 1.0
        else:
            si_momentum = 0.0
        eng.append(si_momentum)
        
        # 9. MACD Signal - New feature
        # Moving Average Convergence Divergence - trend-following momentum indicator
        if len(close_prices) >= 26:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA calculation
            ema26 = np.mean(close_prices[-26:])
            macd = ema12 - ema26
            
            # Signal line (9-day EMA of MACD)
            if t >= 9:
                macd_hist = []
                for i in range(9):
                    if t-i >= 0 and len(data[t-i, 3:63].reshape(15, 4)[:, 3]) >= 26:
                        prev_close = data[t-i, 3:63].reshape(15, 4)[:, 3]
                        prev_ema12 = np.mean(prev_close[-12:])
                        prev_ema26 = np.mean(prev_close[-26:])
                        macd_hist.append(prev_ema12 - prev_ema26)
                
                if macd_hist:
                    signal = np.mean(macd_hist)
                    macd_histogram = macd - signal
                else:
                    macd_histogram = 0.0
            else:
                macd_histogram = 0.0
        else:
            macd_histogram = 0.0
        eng.append(macd_histogram)
        
        # 10. Short Volume Trend Strength - New feature
        # Measures the consistency and strength of the short volume trend
        if len(short_volume) >= 10:
            short_vol_trend = np.polyfit(np.arange(10), short_volume[-10:], 1)[0]
            # Normalize by average short volume to get relative trend strength
            avg_short_vol = np.mean(short_volume[-10:])
            short_vol_trend_strength = short_vol_trend / max(abs(avg_short_vol), 1e-8)
        else:
            short_vol_trend_strength = 0.0
        eng.append(short_vol_trend_strength)
        
        # 11. Options Implied Volatility to Short Interest Ratio - New feature
        # Relationship between market uncertainty and short interest
        si = max(abs(data[t, 0]), 1e-8)
        iv_to_si_ratio = data[t, 65] / si
        eng.append(iv_to_si_ratio)
        
        # 12. Short Interest Acceleration - New feature
        # Second derivative of short interest - rate of change of short interest momentum
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            si_acceleration = mom_t - mom_t1
        else:
            si_acceleration = 0.0
        eng.append(si_acceleration)
        
        # 13. Bollinger Band Position - New feature
        # Position of price within Bollinger Bands (normalized -1 to 1)
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            upper_band = ma20 + (2 * std20)
            lower_band = ma20 - (2 * std20)
            
            # Normalize position between bands from -1 (lower) to 1 (upper)
            band_width = upper_band - lower_band
            if band_width > 0:
                bb_position = 2 * ((close_prices[-1] - lower_band) / band_width) - 1
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 14. Short Volume to Price Correlation - New feature
        # Correlation between short volume and price movements
        if len(close_prices) >= 10 and len(short_volume) >= 10:
            # Calculate price returns
            price_returns = np.diff(close_prices[-11:]) / np.maximum(np.abs(close_prices[-11:-1]), 1e-8)
            
            # Calculate short volume changes
            sv_changes = np.diff(short_volume[-11:]) / np.maximum(np.abs(short_volume[-11:-1]), 1e-8)
            
            # Calculate correlation safely
            if len(price_returns) == len(sv_changes) and len(price_returns) > 1:
                # Use a more stable correlation calculation
                mean_pr = np.mean(price_returns)
                mean_sv = np.mean(sv_changes)
                
                num = np.sum((price_returns - mean_pr) * (sv_changes - mean_sv))
                den1 = np.sqrt(np.sum((price_returns - mean_pr)**2))
                den2 = np.sqrt(np.sum((sv_changes - mean_sv)**2))
                
                if den1 > 1e-8 and den2 > 1e-8:
                    corr = num / (den1 * den2)
                else:
                    corr = 0.0
            else:
                corr = 0.0
        else:
            corr = 0.0
        eng.append(corr)
        
        # 15. Options Put-Call Ratio Change Rate - New feature
        # Rate of change in options sentiment
        if t >= 2:
            pc_ratio_t = data[t, 63]
            pc_ratio_t1 = data[t-1, 63]
            pc_ratio_t2 = data[t-2, 63]
            
            change_t = pc_ratio_t / max(abs(pc_ratio_t1), 1e-8) - 1.0
            change_t1 = pc_ratio_t1 / max(abs(pc_ratio_t2), 1e-8) - 1.0
            
            pc_ratio_change_rate = change_t / max(abs(change_t1), 1e-8) - 1.0 if change_t1 != 0 else 0.0
        else:
            pc_ratio_change_rate = 0.0
        eng.append(pc_ratio_change_rate)
        
        # 16. Short Interest Volatility - New feature
        # Measures the stability/volatility of short interest over time
        if t >= 5:
            si_values = []
            for i in range(5):
                if t-i >= 0:
                    si_values.append(data[t-i, 0])
            
            if si_values:
                si_volatility = np.std(si_values) / max(abs(np.mean(si_values)), 1e-8)
            else:
                si_volatility = 0.0
        else:
            si_volatility = 0.0
        eng.append(si_volatility)
        
        # 17. Relative Volume Indicator - New feature
        # Current volume relative to historical average
        if len(total_volume) >= 10:
            avg_vol_10d = np.mean(total_volume[-10:])
            current_vol = total_volume[-1]
            rel_volume = current_vol / max(abs(avg_vol_10d), 1e-8)
        else:
            rel_volume = 1.0
        eng.append(rel_volume)
        
        # 18. Short Interest to Implied Volatility Ratio - New feature
        # Relationship between short interest and market uncertainty
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        eng.append(si_to_iv_ratio)
        
        # 19. Stochastic Oscillator - New feature
        # Momentum indicator comparing closing price to price range over time
        if len(close_prices) >= 14:
            lowest_low = np.min(low_prices[-14:])
            highest_high = np.max(high_prices[-14:])
            
            range_diff = highest_high - lowest_low
            if range_diff > 0:
                stoch_k = 100 * (close_prices[-1] - lowest_low) / range_diff
            else:
                stoch_k = 50.0
        else:
            stoch_k = 50.0
        eng.append(stoch_k)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 185553.7450
RMSE: 230777.0261
MAPE: 14.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0010, rank=1
   2. Feature_19_t1: importance=0.0005, rank=2
   3. Feature_17_t3: importance=0.0004, rank=3
   4. Feature_15_t1: importance=0.0004, rank=4
   5. Feature_20_t2: importance=0.0004, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: +0.08%

📈 Current best MAPE: 14.44%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently important
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently important
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations - measures proportion of daily trading that is short selling
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Interest to Float Ratio
        # Measures short interest relative to shares outstanding (float)
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Recent price momentum (5-day)
        # Captures recent price trend which can influence short covering
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # 4. RSI (Relative Strength Index)
        # Momentum oscillator that measures speed and change of price movements
        # High importance in previous iterations
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            rsi = 50.0  # Neutral value when not enough data
        eng.append(rsi)
        
        # 5. Price to moving average ratio
        # Indicates if price is above/below recent average (trend indicator)
        # High importance in previous iterations
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(abs(ma10), 1e-8)
        else:
            price_to_ma = 1.0
        eng.append(price_to_ma)
        
        # 6. Short interest momentum
        # Rate of change in short interest
        if t > 0:
            si_momentum = data[t, 0] / max(abs(data[t-1, 0]), 1e-8) - 1.0
        else:
            si_momentum = 0.0
        eng.append(si_momentum)
        
        # 7. Bollinger Band Position
        # Position of price within Bollinger Bands (normalized -1 to 1)
        # High importance in previous iteration
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            upper_band = ma20 + (2 * std20)
            lower_band = ma20 - (2 * std20)
            
            # Normalize position between bands from -1 (lower) to 1 (upper)
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = 2 * ((close_prices[-1] - lower_band) / band_width) - 1
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 8. Stochastic Oscillator
        # Momentum indicator comparing closing price to price range over time
        # High importance in previous iteration
        if len(close_prices) >= 14:
            lowest_low = np.min(low_prices[-14:])
            highest_high = np.max(high_prices[-14:])
            
            range_diff = highest_high - lowest_low
            if range_diff > 1e-8:
                stoch_k = 100 * (close_prices[-1] - lowest_low) / range_diff
            else:
                stoch_k = 50.0
        else:
            stoch_k = 50.0
        eng.append(stoch_k)
        
        # 9. Short Interest Acceleration - Second derivative of short interest
        # Rate of change of short interest momentum
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            si_acceleration = mom_t - mom_t1
        else:
            si_acceleration = 0.0
        eng.append(si_acceleration)
        
        # 10. Relative Volume Indicator
        # Current volume relative to historical average
        # High importance in previous iteration
        if len(total_volume) >= 10:
            avg_vol_10d = np.mean(total_volume[-10:])
            current_vol = total_volume[-1]
            rel_volume = current_vol / max(abs(avg_vol_10d), 1e-8)
        else:
            rel_volume = 1.0
        eng.append(rel_volume)
        
        # 11. Short Interest to Implied Volatility Ratio
        # Relationship between short interest and market uncertainty
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        eng.append(si_to_iv_ratio)
        
        # 12. NEW: Exponential Moving Average (EMA) Crossover Signal
        # Measures trend direction and potential reversals
        if len(close_prices) >= 26:
            # Calculate simple EMA approximations
            ema12 = np.mean(close_prices[-12:] * np.linspace(1, 2, 12))  # Weight recent prices more
            ema12 /= np.mean(np.linspace(1, 2, 12))  # Normalize weights
            
            ema26 = np.mean(close_prices[-26:] * np.linspace(1, 2, 26))
            ema26 /= np.mean(np.linspace(1, 2, 26))
            
            # EMA crossover signal: positive when short-term EMA > long-term EMA
            ema_crossover = ema12 / max(abs(ema26), 1e-8) - 1.0
        else:
            ema_crossover = 0.0
        eng.append(ema_crossover)
        
        # 13. NEW: Short Volume Trend Strength with Exponential Weighting
        # Improved version that weights recent short volume changes more heavily
        if len(short_volume) >= 10:
            # Calculate weighted trend using exponential weights
            weights = np.exp(np.linspace(0, 1, 10))
            weights = weights / np.sum(weights)  # Normalize weights
            
            # Calculate weighted average of short volume changes
            sv_changes = np.diff(np.concatenate(([short_volume[-10]], short_volume[-10:])))
            weighted_sv_trend = np.sum(sv_changes * weights)
            
            # Normalize by average short volume
            avg_short_vol = np.mean(short_volume[-10:])
            short_vol_trend_strength = weighted_sv_trend / max(abs(avg_short_vol), 1e-8)
        else:
            short_vol_trend_strength = 0.0
        eng.append(short_vol_trend_strength)
        
        # 14. NEW: Average True Range (ATR) - Volatility indicator
        # Measures market volatility which can affect short interest decisions
        if len(close_prices) >= 14:
            tr_values = []
            for i in range(1, min(14, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            atr = np.mean(tr_values) if tr_values else 0.0
            # Normalize by current price
            norm_atr = atr / max(abs(close_prices[-1]), 1e-8)
        else:
            norm_atr = 0.0
        eng.append(norm_atr)
        
        # 15. NEW: Short Interest Ratio Change vs Price Change Correlation
        # Measures how short interest changes correlate with price movements
        if t >= 5:
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]  # Last close price
                    close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                    price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                    
                    si_changes.append(si_change)
                    price_changes.append(price_change)
            
            # Calculate correlation safely
            if len(si_changes) >= 3 and len(price_changes) >= 3:
                # Use a more stable correlation calculation
                mean_si = np.mean(si_changes)
                mean_price = np.mean(price_changes)
                
                num = np.sum((np.array(si_changes) - mean_si) * (np.array(price_changes) - mean_price))
                den1 = np.sqrt(np.sum((np.array(si_changes) - mean_si)**2))
                den2 = np.sqrt(np.sum((np.array(price_changes) - mean_price)**2))
                
                if den1 > 1e-8 and den2 > 1e-8:
                    si_price_corr = num / (den1 * den2)
                else:
                    si_price_corr = 0.0
            else:
                si_price_corr = 0.0
        else:
            si_price_corr = 0.0
        eng.append(si_price_corr)
        
        # 16. NEW: Options Synthetic Short Cost to Short Interest Ratio
        # Relationship between cost of synthetic shorts and actual short interest
        synth_short_cost = max(abs(data[t, 64]), 1e-8)
        si = max(abs(data[t, 0]), 1e-8)
        synth_cost_to_si = data[t, 64] / si
        eng.append(synth_cost_to_si)
        
        # 17. NEW: Short Interest Volatility with Exponential Weighting
        # Improved measure of short interest stability over time
        if t >= 5:
            si_values = []
            weights = np.exp(np.linspace(0, 1, min(5, t+1)))
            weights = weights / np.sum(weights)  # Normalize weights
            
            for i in range(min(5, t+1)):
                if t-i >= 0:
                    si_values.append(data[t-i, 0])
            
            if len(si_values) >= 3:
                # Calculate weighted standard deviation
                weighted_mean = np.sum(np.array(si_values) * weights[:len(si_values)])
                weighted_var = np.sum(weights[:len(si_values)] * (np.array(si_values) - weighted_mean)**2)
                weighted_std = np.sqrt(weighted_var)
                
                si_volatility = weighted_std / max(abs(weighted_mean), 1e-8)
            else:
                si_volatility = 0.0
        else:
            si_volatility = 0.0
        eng.append(si_volatility)
        
        # 18. NEW: Money Flow Index (MFI)
        # Volume-weighted RSI that measures buying and selling pressure
        if len(close_prices) >= 14:
            typical_prices = (high_prices + low_prices + close_prices) / 3
            money_flow = typical_prices * total_volume
            
            delta = np.diff(typical_prices)
            pos_flow = np.sum(money_flow[1:][delta > 0])
            neg_flow = np.sum(money_flow[1:][delta < 0])
            
            if neg_flow < 1e-8:
                mfi = 100.0
            else:
                money_ratio = pos_flow / max(neg_flow, 1e-8)
                mfi = 100.0 - (100.0 / (1.0 + money_ratio))
        else:
            mfi = 50.0
        eng.append(mfi)
        
        # 19. NEW: Short Interest Efficiency Ratio
        # Measures how efficiently short interest is being deployed relative to price movement
        if t >= 3:
            si_changes = []
            price_moves = []
            
            for i in range(1, min(4, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    si_change = abs(data[t-i+1, 0] - data[t-i, 0])
                    
                    close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                    close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                    price_move = abs(close_t - close_t_prev)
                    
                    si_changes.append(si_change)
                    price_moves.append(price_move)
            
            if len(si_changes) > 0 and len(price_moves) > 0:
                total_si_change = np.sum(si_changes)
                total_price_move = np.sum(price_moves)
                
                if total_price_move > 1e-8:
                    efficiency_ratio = total_si_change / max(total_price_move, 1e-8)
                else:
                    efficiency_ratio = 0.0
            else:
                efficiency_ratio = 0.0
        else:
            efficiency_ratio = 0.0
        eng.append(efficiency_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 185593.6142
RMSE: 232027.6819
MAPE: 14.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0008, rank=1
   2. Feature_23_t0: importance=0.0006, rank=2
   3. Feature_3_t2: importance=0.0005, rank=3
   4. Feature_11_t3: importance=0.0004, rank=4
   5. Feature_5_t0: importance=0.0004, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.22%

📈 Current best MAPE: 14.22%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations - measures proportion of daily trading that is short selling
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponentially weighted average to emphasize recent short volume ratio
        weights = np.exp(np.linspace(0, 1, 15))
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio
        # Measures short interest relative to shares outstanding (float)
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Recent price momentum (5-day)
        # Captures recent price trend which can influence short covering
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # 4. RSI (Relative Strength Index) - High importance in previous iterations
        # Momentum oscillator that measures speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            rsi = 50.0  # Neutral value when not enough data
        eng.append(rsi)
        
        # 5. Price to moving average ratio - High importance in previous iterations
        # Indicates if price is above/below recent average (trend indicator)
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(abs(ma10), 1e-8)
        else:
            price_to_ma = 1.0
        eng.append(price_to_ma)
        
        # 6. Short interest momentum - Rate of change in short interest
        if t > 0:
            si_momentum = data[t, 0] / max(abs(data[t-1, 0]), 1e-8) - 1.0
        else:
            si_momentum = 0.0
        eng.append(si_momentum)
        
        # 7. Bollinger Band Position - High importance in previous iteration
        # Position of price within Bollinger Bands (normalized -1 to 1)
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            upper_band = ma20 + (2 * std20)
            lower_band = ma20 - (2 * std20)
            
            # Normalize position between bands from -1 (lower) to 1 (upper)
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = 2 * ((close_prices[-1] - lower_band) / band_width) - 1
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 8. NEW: Improved Short Interest Acceleration - Second derivative of short interest
        # Rate of change of short interest momentum with exponential smoothing
        if t >= 2:
            # Get last 3 short interest values
            si_values = [data[max(0, t-i), 0] for i in range(3)]
            
            # Calculate first differences (momentum)
            mom_values = []
            for i in range(1, len(si_values)):
                mom = si_values[i-1] / max(abs(si_values[i]), 1e-8) - 1.0
                mom_values.append(mom)
            
            # Calculate second difference (acceleration)
            if len(mom_values) >= 2:
                si_acceleration = mom_values[0] - mom_values[1]
                
                # Apply exponential smoothing if we have previous acceleration
                if t >= 3:
                    prev_si_values = [data[max(0, t-i-1), 0] for i in range(3)]
                    prev_mom_values = []
                    for i in range(1, len(prev_si_values)):
                        prev_mom = prev_si_values[i-1] / max(abs(prev_si_values[i]), 1e-8) - 1.0
                        prev_mom_values.append(prev_mom)
                    
                    if len(prev_mom_values) >= 2:
                        prev_acceleration = prev_mom_values[0] - prev_mom_values[1]
                        # Exponential smoothing with 0.7 weight to current value
                        si_acceleration = 0.7 * si_acceleration + 0.3 * prev_acceleration
            else:
                si_acceleration = 0.0
        else:
            si_acceleration = 0.0
        eng.append(si_acceleration)
        
        # 9. NEW: Relative Volume Trend - Improved version of relative volume
        # Measures recent volume trend relative to longer-term average
        if len(total_volume) >= 15:
            recent_vol_avg = np.mean(total_volume[-5:])  # Last 5 days
            longer_vol_avg = np.mean(total_volume)  # All 15 days
            
            rel_vol_trend = recent_vol_avg / max(abs(longer_vol_avg), 1e-8)
        else:
            rel_vol_trend = 1.0
        eng.append(rel_vol_trend)
        
        # 10. Short Interest to Implied Volatility Ratio - Relationship between short interest and market uncertainty
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        eng.append(si_to_iv_ratio)
        
        # 11. NEW: Improved EMA Crossover Signal with Triple Crossover
        # Measures trend direction and potential reversals using 3 EMAs
        if len(close_prices) >= 26:
            # Calculate weighted moving averages as EMA approximations
            weights_short = np.exp(np.linspace(0, 2, 8))
            weights_short = weights_short / np.sum(weights_short)
            ema8 = np.sum(close_prices[-8:] * weights_short)
            
            weights_med = np.exp(np.linspace(0, 2, 13))
            weights_med = weights_med / np.sum(weights_med)
            ema13 = np.sum(close_prices[-13:] * weights_med)
            
            weights_long = np.exp(np.linspace(0, 2, 26))
            weights_long = weights_long / np.sum(weights_long)
            ema26 = np.sum(close_prices[-26:] * weights_long)
            
            # Triple EMA crossover signal: combines short-term and long-term crossovers
            short_cross = ema8 / max(abs(ema13), 1e-8) - 1.0
            long_cross = ema13 / max(abs(ema26), 1e-8) - 1.0
            
            # Weighted combination gives more importance to short-term signal
            ema_crossover = 0.6 * short_cross + 0.4 * long_cross
        else:
            ema_crossover = 0.0
        eng.append(ema_crossover)
        
        # 12. NEW: Improved Average True Range (ATR) Ratio
        # Measures current volatility relative to historical volatility
        if len(close_prices) >= 14:
            tr_values = []
            for i in range(1, min(14, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)] if i+1 < len(close_prices) else 0)
                low_close = abs(low_prices[-i] - close_prices[-(i+1)] if i+1 < len(close_prices) else 0)
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            if tr_values:
                # Calculate recent ATR (last 5 days) and compare to longer ATR
                recent_atr = np.mean(tr_values[:5]) if len(tr_values) >= 5 else np.mean(tr_values)
                full_atr = np.mean(tr_values)
                
                # ATR ratio shows if volatility is increasing or decreasing
                atr_ratio = recent_atr / max(abs(full_atr), 1e-8)
            else:
                atr_ratio = 1.0
        else:
            atr_ratio = 1.0
        eng.append(atr_ratio)
        
        # 13. NEW: Short Interest Efficiency Ratio with Volatility Adjustment
        # Measures how efficiently short interest is being deployed relative to price movement
        # Adjusted for market volatility
        if t >= 3:
            si_changes = []
            price_moves = []
            
            for i in range(1, min(4, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    si_change = abs(data[t-i+1, 0] - data[t-i, 0])
                    
                    close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                    close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                    price_move = abs(close_t - close_t_prev)
                    
                    # Get volatility for adjustment
                    ohlc_t = data[t-i+1, 3:63].reshape(15, 4)
                    high_t, low_t = ohlc_t[-1, 1], ohlc_t[-1, 2]
                    day_range = (high_t - low_t) / max(abs(close_t), 1e-8)
                    
                    # Adjust price move by daily range to normalize for volatility
                    adj_price_move = price_move / max(day_range, 1e-8)
                    
                    si_changes.append(si_change)
                    price_moves.append(adj_price_move)
            
            if len(si_changes) > 0 and len(price_moves) > 0:
                total_si_change = np.sum(si_changes)
                total_price_move = np.sum(price_moves)
                
                if total_price_move > 1e-8:
                    efficiency_ratio = total_si_change / max(total_price_move, 1e-8)
                else:
                    efficiency_ratio = 0.0
            else:
                efficiency_ratio = 0.0
        else:
            efficiency_ratio = 0.0
        eng.append(efficiency_ratio)
        
        # 14. NEW: Short Volume Concentration Index
        # Measures how concentrated short volume is in specific days
        if len(short_volume) >= 5:
            # Calculate Gini-like concentration measure
            sorted_sv = np.sort(short_volume[-5:])
            n = len(sorted_sv)
            
            # Calculate Lorenz curve points
            lorenz_points = np.zeros(n)
            for i in range(n):
                lorenz_points[i] = np.sum(sorted_sv[:i+1]) / max(np.sum(sorted_sv), 1e-8)
            
            # Calculate area under Lorenz curve
            area = np.sum(lorenz_points) / n
            
            # Concentration index (0 = perfectly distributed, 1 = completely concentrated)
            concentration_index = 1 - 2 * area
        else:
            concentration_index = 0.0
        eng.append(concentration_index)
        
        # 15. NEW: Short Interest to Options Volume Ratio
        # Measures relationship between short interest and options activity
        options_volume_ratio = max(abs(data[t, 63]), 1e-8)  # put/call ratio
        si_to_options_ratio = data[t, 0] / options_volume_ratio
        eng.append(si_to_options_ratio)
        
        # 16. NEW: Price Trend Strength Indicator
        # Measures the strength and consistency of recent price trend
        if len(close_prices) >= 10:
            # Calculate price changes
            price_changes = np.diff(close_prices[-10:])
            
            # Count positive and negative days
            pos_days = np.sum(price_changes > 0)
            neg_days = np.sum(price_changes < 0)
            
            # Calculate directional strength (ranges from -1 to 1)
            if pos_days + neg_days > 0:
                trend_strength = (pos_days - neg_days) / (pos_days + neg_days)
            else:
                trend_strength = 0.0
            
            # Adjust by magnitude of changes
            avg_up = np.mean(price_changes[price_changes > 0]) if np.any(price_changes > 0) else 0
            avg_down = np.mean(np.abs(price_changes[price_changes < 0])) if np.any(price_changes < 0) else 0
            
            # Magnitude ratio (>1 means up moves are larger than down moves)
            if avg_down > 1e-8:
                magnitude_ratio = avg_up / avg_down
            else:
                magnitude_ratio = 1.0 if avg_up > 0 else 0.0
            
            # Combine directional and magnitude components
            adjusted_trend_strength = trend_strength * (magnitude_ratio / (1 + magnitude_ratio))
        else:
            adjusted_trend_strength = 0.0
        eng.append(adjusted_trend_strength)
        
        # 17. NEW: Short Interest Reversal Signal
        # Detects potential short squeeze conditions
        if t >= 2:
            # Get recent short interest values
            si_current = data[t, 0]
            si_prev = data[t-1, 0] if t-1 >= 0 else si_current
            si_prev2 = data[t-2, 0] if t-2 >= 0 else si_prev
            
            # Calculate short interest changes
            si_change_current = si_current / max(abs(si_prev), 1e-8) - 1.0
            si_change_prev = si_prev / max(abs(si_prev2), 1e-8) - 1.0
            
            # Get recent price data
            current_close = close_prices[-1] if len(close_prices) > 0 else 0
            prev_close = close_prices[-2] if len(close_prices) > 1 else current_close
            
            # Calculate price change
            price_change = current_close / max(abs(prev_close), 1e-8) - 1.0
            
            # Reversal signal: short interest decreasing while price increasing
            # Stronger signal when both changes are larger
            if si_change_current < 0 and price_change > 0:
                reversal_signal = abs(si_change_current) * price_change
            else:
                reversal_signal = 0.0
                
            # Adjust based on previous short interest trend
            if si_change_prev > 0:  # Previous buildup of shorts
                reversal_signal *= (1 + si_change_prev)
        else:
            reversal_signal = 0.0
        eng.append(reversal_signal)
        
        # 18. NEW: Synthetic Short Cost Trend
        # Measures the trend in the cost of creating synthetic short positions
        if t >= 2:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64] if t-1 >= 0 else current_cost
            prev_cost2 = data[t-2, 64] if t-2 >= 0 else prev_cost
            
            # Calculate cost changes
            cost_change_current = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            cost_change_prev = prev_cost / max(abs(prev_cost2), 1e-8) - 1.0
            
            # Exponentially weighted trend
            synth_cost_trend = 0.7 * cost_change_current + 0.3 * cost_change_prev
        else:
            synth_cost_trend = 0.0
        eng.append(synth_cost_trend)
        
        # 19. NEW: Implied Volatility Skew
        # Approximation of volatility skew using available data
        iv = data[t, 65]  # Average implied volatility
        put_call_ratio = data[t, 63]  # Put/call volume ratio
        
        # Higher put/call ratio with high IV suggests negative skew
        iv_skew_proxy = iv * (put_call_ratio - 1.0) if put_call_ratio > 1.0 else 0.0
        eng.append(iv_skew_proxy)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 188193.9099
RMSE: 230597.2671
MAPE: 14.36%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0009, rank=1
   2. Feature_9_t0: importance=0.0008, rank=2
   3. Feature_4_t2: importance=0.0008, rank=3
   4. Feature_5_t0: importance=0.0004, rank=4
   5. Feature_5_t1: importance=0.0004, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.14%

📈 Current best MAPE: 14.22%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with Exponential Weighting
        # High importance in previous iterations - measures proportion of daily trading that is short selling
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponentially weighted average to emphasize recent short volume ratio
        weights = np.exp(np.linspace(0, 1.5, 15))  # Increased exponential factor for more recency bias
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio
        # Measures short interest relative to shares outstanding (float)
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Improved Price Momentum with Volatility Adjustment
        # Captures recent price trend adjusted for volatility
        if len(close_prices) >= 5:
            # Calculate price momentum
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            
            # Calculate volatility over the same period
            returns = np.diff(close_prices[-5:]) / close_prices[-6:-1]
            volatility = np.std(returns) if len(returns) > 0 else 1e-8
            
            # Adjust momentum by volatility - higher signal-to-noise ratio
            vol_adjusted_momentum = momentum_5d / max(volatility, 1e-8)
        else:
            vol_adjusted_momentum = 0.0
        eng.append(vol_adjusted_momentum)
        
        # 4. Enhanced RSI with Volume Weighting
        # Momentum oscillator weighted by volume to capture conviction behind moves
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            delta = np.diff(close_prices[-14:])
            volume_last_14 = total_volume[-14:]
            volume_weighted_delta = delta * volume_last_14[1:]  # Align volumes with price changes
            
            gain = np.where(volume_weighted_delta > 0, volume_weighted_delta, 0)
            loss = np.where(volume_weighted_delta < 0, -volume_weighted_delta, 0)
            
            avg_gain = np.sum(gain) / max(np.sum(volume_last_14[1:]), 1e-8)
            avg_loss = np.sum(loss) / max(np.sum(volume_last_14[1:]), 1e-8)
            
            if avg_loss < 1e-8:
                vol_weighted_rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                vol_weighted_rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            vol_weighted_rsi = 50.0  # Neutral value when not enough data
        eng.append(vol_weighted_rsi)
        
        # 5. Adaptive Price to Moving Average Ratio
        # Uses adaptive lookback based on volatility
        if len(close_prices) >= 10:
            # Calculate recent volatility
            returns = np.diff(close_prices[-10:]) / close_prices[-11:-1]
            volatility = np.std(returns) if len(returns) > 0 else 0.01
            
            # Adaptive lookback - shorter when volatility is high
            lookback = max(3, min(10, int(10 * (1 - volatility * 10))))
            lookback = min(lookback, len(close_prices))
            
            # Calculate adaptive MA
            adaptive_ma = np.mean(close_prices[-lookback:])
            adaptive_price_to_ma = close_prices[-1] / max(abs(adaptive_ma), 1e-8)
        else:
            adaptive_price_to_ma = 1.0
        eng.append(adaptive_price_to_ma)
        
        # 6. Short Interest Momentum with Trend Detection
        # Improved version that detects acceleration/deceleration in short interest changes
        if t > 1:
            si_current = data[t, 0]
            si_prev = data[t-1, 0]
            si_prev2 = data[t-2, 0] if t-2 >= 0 else si_prev
            
            # Calculate momentum and its change
            si_momentum = si_current / max(abs(si_prev), 1e-8) - 1.0
            prev_momentum = si_prev / max(abs(si_prev2), 1e-8) - 1.0
            
            # Detect trend in momentum (acceleration/deceleration)
            momentum_change = si_momentum - prev_momentum
            
            # Combine current momentum with trend direction
            trend_adjusted_momentum = si_momentum * (1 + np.sign(momentum_change) * min(abs(momentum_change), 0.5))
        else:
            trend_adjusted_momentum = 0.0
        eng.append(trend_adjusted_momentum)
        
        # 7. Bollinger Band Squeeze Indicator
        # Measures contraction/expansion of volatility - predictor of large moves
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            # Calculate current band width
            band_width = (2 * std20) / max(abs(ma20), 1e-8)
            
            # Calculate historical band width (previous period)
            if len(close_prices) >= 40:
                prev_std = np.std(close_prices[-40:-20])
                prev_band_width = (2 * prev_std) / max(abs(np.mean(close_prices[-40:-20])), 1e-8)
                
                # Squeeze indicator: ratio of current to previous band width
                # Values < 1 indicate contraction (potential for breakout)
                bb_squeeze = band_width / max(abs(prev_band_width), 1e-8)
            else:
                bb_squeeze = 1.0
        else:
            bb_squeeze = 1.0
        eng.append(bb_squeeze)
        
        # 8. Short Interest Acceleration with Mean Reversion Component
        # Improved version that accounts for mean reversion tendency in short interest
        if t >= 2:
            # Get last 3 short interest values
            si_values = [data[max(0, t-i), 0] for i in range(3)]
            
            # Calculate first differences (momentum)
            mom_values = []
            for i in range(1, len(si_values)):
                mom = si_values[i-1] / max(abs(si_values[i]), 1e-8) - 1.0
                mom_values.append(mom)
            
            # Calculate second difference (acceleration)
            if len(mom_values) >= 2:
                si_acceleration = mom_values[0] - mom_values[1]
                
                # Add mean reversion component
                # Calculate z-score of current short interest relative to recent history
                if t >= 5:
                    si_history = [data[max(0, t-i), 0] for i in range(5)]
                    si_mean = np.mean(si_history)
                    si_std = np.std(si_history) if len(si_history) > 1 else 1e-8
                    si_zscore = (si_values[0] - si_mean) / max(si_std, 1e-8)
                    
                    # Mean reversion pressure increases with extreme z-scores
                    mean_reversion = -np.sign(si_zscore) * min(abs(si_zscore), 3) / 3
                    
                    # Combine acceleration with mean reversion component
                    si_acceleration = si_acceleration * (1 + mean_reversion)
            else:
                si_acceleration = 0.0
        else:
            si_acceleration = 0.0
        eng.append(si_acceleration)
        
        # 9. Volume Trend Divergence Indicator
        # Detects divergences between price and volume trends
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate price trend
            price_change = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            
            # Calculate volume trend
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            vol_trend = recent_vol_avg / max(abs(older_vol_avg), 1e-8) - 1.0
            
            # Divergence occurs when price and volume move in opposite directions
            # Stronger signal when both moves are larger
            divergence = -1 * np.sign(price_change) * np.sign(vol_trend) * abs(price_change) * abs(vol_trend)
            
            # Only consider actual divergences (negative values)
            vol_price_divergence = min(divergence, 0)
        else:
            vol_price_divergence = 0.0
        eng.append(vol_price_divergence)
        
        # 10. Short Interest to Implied Volatility Ratio with Trend
        # Improved version that incorporates trend in this relationship
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Add trend component if we have history
        if t > 0:
            prev_iv = max(abs(data[t-1, 65]), 1e-8)
            prev_si_to_iv_ratio = data[t-1, 0] / prev_iv
            
            # Trend in the ratio
            ratio_trend = si_to_iv_ratio / max(abs(prev_si_to_iv_ratio), 1e-8) - 1.0
            
            # Combine current ratio with trend
            trend_adjusted_si_iv = si_to_iv_ratio * (1 + ratio_trend)
        else:
            trend_adjusted_si_iv = si_to_iv_ratio
        eng.append(trend_adjusted_si_iv)
        
        # 11. MACD Signal with Volume Confirmation
        # Combines MACD with volume trend for stronger signal
        if len(close_prices) >= 26:
            # Calculate EMA approximations
            weights_short = np.exp(np.linspace(0, 2, 12))
            weights_short = weights_short / np.sum(weights_short)
            ema12 = np.sum(close_prices[-12:] * weights_short)
            
            weights_long = np.exp(np.linspace(0, 2, 26))
            weights_long = weights_long / np.sum(weights_long)
            ema26 = np.sum(close_prices[-26:] * weights_long)
            
            # MACD line
            macd = ema12 - ema26
            
            # Calculate signal line (9-period EMA of MACD)
            if len(close_prices) >= 35:  # Need 26 + 9 periods
                # Approximate historical MACD values
                macd_history = []
                for i in range(9):
                    idx = -26-i
                    if abs(idx) < len(close_prices):
                        ema12_hist = np.sum(close_prices[idx-12+1:idx+1] * weights_short)
                        ema26_hist = np.sum(close_prices[idx-26+1:idx+1] * weights_long)
                        macd_history.append(ema12_hist - ema26_hist)
                
                # Calculate signal line
                if macd_history:
                    weights_signal = np.exp(np.linspace(0, 2, len(macd_history)))
                    weights_signal = weights_signal / np.sum(weights_signal)
                    signal = np.sum(np.array(macd_history) * weights_signal)
                    
                    # MACD histogram
                    histogram = macd - signal
                else:
                    histogram = 0
            else:
                histogram = 0
            
            # Volume confirmation
            if len(total_volume) >= 10:
                recent_vol = np.mean(total_volume[-5:])
                older_vol = np.mean(total_volume[-10:-5])
                vol_trend = recent_vol / max(abs(older_vol), 1e-8) - 1.0
                
                # Stronger signal when volume confirms direction
                volume_confirmed_macd = histogram * (1 + np.sign(histogram) * np.sign(vol_trend) * min(abs(vol_trend), 0.5))
            else:
                volume_confirmed_macd = histogram
        else:
            volume_confirmed_macd = 0.0
        eng.append(volume_confirmed_macd)
        
        # 12. Volatility-Adjusted ATR Ratio
        # Improved version that normalizes by price level
        if len(close_prices) >= 14:
            tr_values = []
            for i in range(1, min(14, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)] if i+1 < len(close_prices) else 0)
                low_close = abs(low_prices[-i] - close_prices[-(i+1)] if i+1 < len(close_prices) else 0)
                tr = max(high_low, high_close, low_close)
                
                # Normalize by price level
                price_level = close_prices[-i]
                normalized_tr = tr / max(abs(price_level), 1e-8)
                tr_values.append(normalized_tr)
            
            if tr_values:
                # Calculate recent normalized ATR and compare to longer normalized ATR
                recent_norm_atr = np.mean(tr_values[:5]) if len(tr_values) >= 5 else np.mean(tr_values)
                full_norm_atr = np.mean(tr_values)
                
                # Normalized ATR ratio
                norm_atr_ratio = recent_norm_atr / max(abs(full_norm_atr), 1e-8)
            else:
                norm_atr_ratio = 1.0
        else:
            norm_atr_ratio = 1.0
        eng.append(norm_atr_ratio)
        
        # 13. Short Interest Efficiency with Price Momentum
        # Measures how efficiently short interest changes with price momentum
        if t >= 3 and len(close_prices) >= 3:
            si_changes = []
            price_momentums = []
            
            for i in range(1, min(4, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Short interest change
                    si_change = data[t-i+1, 0] / max(abs(data[t-i, 0]), 1e-8) - 1.0
                    si_changes.append(si_change)
                    
                    # Get corresponding price data
                    close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                    close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                    
                    # Price momentum
                    price_momentum = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                    price_momentums.append(price_momentum)
            
            if si_changes and price_momentums:
                # Calculate correlation-like measure between SI changes and price momentum
                si_direction = np.sign(np.mean(si_changes))
                price_direction = np.sign(np.mean(price_momentums))
                
                # Efficiency is high when SI and price move in expected opposite directions
                # (shorts increase when price falls, decrease when price rises)
                expected_relationship = -1 * si_direction * price_direction
                
                # Magnitude of relationship
                si_magnitude = abs(np.mean(si_changes))
                price_magnitude = abs(np.mean(price_momentums))
                
                efficiency = expected_relationship * si_magnitude * price_magnitude
            else:
                efficiency = 0.0
        else:
            efficiency = 0.0
        eng.append(efficiency)
        
        # 14. Short Volume Distribution Skewness
        # Measures asymmetry in short volume distribution
        if len(short_volume) >= 5:
            recent_sv = short_volume[-5:]
            
            # Calculate mean and median
            sv_mean = np.mean(recent_sv)
            sv_median = np.median(recent_sv)
            
            # Skewness approximation using mean-median difference
            # Normalized by mean to make it scale-invariant
            sv_skewness = (sv_mean - sv_median) / max(abs(sv_mean), 1e-8)
        else:
            sv_skewness = 0.0
        eng.append(sv_skewness)
        
        # 15. Options Market Sentiment Indicator
        # Combines put/call ratio with implied volatility trend
        put_call_ratio = data[t, 63]
        iv = data[t, 65]
        
        # Calculate IV trend if history available
        if t > 0:
            prev_iv = data[t-1, 65]
            iv_trend = iv / max(abs(prev_iv), 1e-8) - 1.0
        else:
            iv_trend = 0.0
        
        # Combine: higher values indicate more bearish sentiment
        # Put/call > 1 is bearish, rising IV is often bearish
        options_sentiment = (put_call_ratio - 1.0) + iv_trend
        eng.append(options_sentiment)
        
        # 16. Price Trend Consistency with Volume Support
        # Measures consistency of price trend with volume confirmation
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate daily returns
            returns = np.diff(close_prices[-10:]) / close_prices[-11:-1]
            
            # Count consistent days (same direction as overall trend)
            trend_direction = np.sign(close_prices[-1] - close_prices[-10])
            consistent_days = np.sum(np.sign(returns) == trend_direction)
            
            # Normalize to [-1, 1] range
            consistency = (consistent_days / len(returns) * 2) - 1
            
            # Volume support: higher volume on trend-supporting days
            trend_supporting_vol = 0
            trend_opposing_vol = 0
            
            for i in range(len(returns)):
                if np.sign(returns[i]) == trend_direction:
                    trend_supporting_vol += total_volume[-10+i+1]
                else:
                    trend_opposing_vol += total_volume[-10+i+1]
            
            # Volume ratio (supporting vs opposing)
            if trend_opposing_vol > 0:
                vol_support = trend_supporting_vol / max(trend_opposing_vol, 1e-8)
            else:
                vol_support = 2.0 if trend_supporting_vol > 0 else 1.0
            
            # Normalize volume support
            vol_support = min(vol_support, 3.0) / 3.0
            
            # Combine consistency with volume support
            trend_consistency = consistency * (1 + vol_support)
        else:
            trend_consistency = 0.0
        eng.append(trend_consistency)
        
        # 17. Short Squeeze Probability Indicator
        # Comprehensive indicator combining multiple factors that predict short squeezes
        if t >= 2 and len(close_prices) >= 5:
            # Factor 1: High short interest to float ratio
            si_float_ratio = short_interest_to_float  # Reuse from feature 2
            si_float_factor = min(si_float_ratio / 0.2, 1.0)  # Normalize with 0.2 (20%) as high
            
            # Factor 2: Recent price momentum
            price_momentum = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            momentum_factor = max(0, price_momentum * 10)  # Positive momentum only, scaled
            
            # Factor 3: Decreasing short interest (covering)
            si_current = data[t, 0]
            si_prev = data[t-1, 0]
            si_change = si_current / max(abs(si_prev), 1e-8) - 1.0
            covering_factor = max(0, -si_change * 5)  # Negative change (covering) only, scaled
            
            # Factor 4: Increasing volume
            if len(total_volume) >= 5:
                recent_vol = np.mean(total_volume[-2:])
                older_vol = np.mean(total_volume[-5:-2])
                vol_increase = recent_vol / max(abs(older_vol), 1e-8) - 1.0
                volume_factor = max(0, vol_increase * 2)  # Positive increase only, scaled
            else:
                volume_factor = 0.0
            
            # Combine factors with weights
            squeeze_probability = (0.4 * si_float_factor + 
                                  0.3 * momentum_factor + 
                                  0.2 * covering_factor + 
                                  0.1 * volume_factor)
        else:
            squeeze_probability = 0.0
        eng.append(squeeze_probability)
        
        # 18. Synthetic Short Cost Momentum
        # Improved version that captures acceleration in synthetic short costs
        if t >= 2:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64]
            prev_cost2 = data[t-2, 64] if t-2 >= 0 else prev_cost
            
            # Calculate cost momentum
            cost_momentum = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            prev_momentum = prev_cost / max(abs(prev_cost2), 1e-8) - 1.0
            
            # Cost acceleration (change in momentum)
            cost_acceleration = cost_momentum - prev_momentum
            
            # Combine with current level - higher costs with increasing acceleration
            # are stronger signals
            synth_cost_signal = cost_momentum * (1 + np.sign(cost_acceleration) * min(abs(cost_acceleration), 0.5))
        else:
            synth_cost_signal = 0.0
        eng.append(synth_cost_signal)
        
        # 19. Implied Volatility Term Structure Proxy
        # Approximates volatility term structure using available data
        iv = data[t, 65]  # Average implied volatility
        
        # Calculate IV trend if history available
        if t > 0:
            prev_iv = data[t-1, 65]
            iv_trend = iv / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine with put/call ratio to approximate term structure
            # Upward sloping term structure: rising IV with put/call > 1
            # Downward sloping: falling IV with put/call < 1
            put_call_ratio = data[t, 63]
            term_structure = iv_trend * (put_call_ratio - 1.0)
        else:
            term_structure = 0.0
        eng.append(term_structure)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with exponential weighting (high importance in previous iterations)
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponentially weighted average to emphasize recent short volume ratio
        weights = np.exp(np.linspace(0, 2, 15))  # Increased exponential factor for stronger recency bias
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio - Normalized measure of short interest
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Recent price momentum (5-day) - Captures recent price trend
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # 4. RSI (Relative Strength Index) - High importance in previous iterations
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
            avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            rsi = 50.0  # Neutral value when not enough data
        eng.append(rsi)
        
        # 5. Price to moving average ratio - Trend indicator with high importance
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(abs(ma10), 1e-8)
        else:
            price_to_ma = 1.0
        eng.append(price_to_ma)
        
        # 6. Short interest momentum - Rate of change in short interest
        if t > 0:
            si_momentum = data[t, 0] / max(abs(data[t-1, 0]), 1e-8) - 1.0
        else:
            si_momentum = 0.0
        eng.append(si_momentum)
        
        # 7. Bollinger Band Position - Position of price within volatility bands
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            upper_band = ma20 + (2 * std20)
            lower_band = ma20 - (2 * std20)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = 2 * ((close_prices[-1] - lower_band) / band_width) - 1
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 8. Short Interest Acceleration - Second derivative of short interest
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First differences (momentum)
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_acceleration = mom_t - mom_t1
            
            # Apply exponential smoothing if we have previous acceleration
            if t >= 3:
                si_t3 = data[t-3, 0]
                mom_t2 = si_t2 / max(abs(si_t3), 1e-8) - 1.0
                prev_acceleration = mom_t1 - mom_t2
                # Exponential smoothing with 0.7 weight to current value
                si_acceleration = 0.7 * si_acceleration + 0.3 * prev_acceleration
        else:
            si_acceleration = 0.0
        eng.append(si_acceleration)
        
        # 9. Relative Volume Trend - Measures recent volume trend relative to longer-term average
        if len(total_volume) >= 15:
            recent_vol_avg = np.mean(total_volume[-5:])  # Last 5 days
            longer_vol_avg = np.mean(total_volume)  # All 15 days
            
            rel_vol_trend = recent_vol_avg / max(abs(longer_vol_avg), 1e-8)
        else:
            rel_vol_trend = 1.0
        eng.append(rel_vol_trend)
        
        # 10. Short Interest to Implied Volatility Ratio - Relationship between short interest and market uncertainty
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        eng.append(si_to_iv_ratio)
        
        # 11. EMA Crossover Signal - Trend direction and potential reversals
        if len(close_prices) >= 26:
            # Calculate weighted moving averages as EMA approximations
            weights_short = np.exp(np.linspace(0, 2, 8))
            weights_short = weights_short / np.sum(weights_short)
            ema8 = np.sum(close_prices[-8:] * weights_short)
            
            weights_med = np.exp(np.linspace(0, 2, 13))
            weights_med = weights_med / np.sum(weights_med)
            ema13 = np.sum(close_prices[-13:] * weights_med)
            
            weights_long = np.exp(np.linspace(0, 2, 26))
            weights_long = weights_long / np.sum(weights_long)
            ema26 = np.sum(close_prices[-26:] * weights_long)
            
            # Triple EMA crossover signal
            short_cross = ema8 / max(abs(ema13), 1e-8) - 1.0
            long_cross = ema13 / max(abs(ema26), 1e-8) - 1.0
            
            # Weighted combination gives more importance to short-term signal
            ema_crossover = 0.6 * short_cross + 0.4 * long_cross
        else:
            ema_crossover = 0.0
        eng.append(ema_crossover)
        
        # 12. Average True Range (ATR) Ratio - Volatility measure
        if len(close_prices) >= 14:
            tr_values = []
            for i in range(1, min(14, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)] if i+1 < len(close_prices) else 0)
                low_close = abs(low_prices[-i] - close_prices[-(i+1)] if i+1 < len(close_prices) else 0)
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            if tr_values:
                # Calculate recent ATR (last 5 days) and compare to longer ATR
                recent_atr = np.mean(tr_values[:5]) if len(tr_values) >= 5 else np.mean(tr_values)
                full_atr = np.mean(tr_values)
                
                # ATR ratio shows if volatility is increasing or decreasing
                atr_ratio = recent_atr / max(abs(full_atr), 1e-8)
            else:
                atr_ratio = 1.0
        else:
            atr_ratio = 1.0
        eng.append(atr_ratio)
        
        # 13. Short Interest Reversal Signal - Detects potential short squeeze conditions
        if t >= 2:
            # Get recent short interest values
            si_current = data[t, 0]
            si_prev = data[t-1, 0] if t-1 >= 0 else si_current
            si_prev2 = data[t-2, 0] if t-2 >= 0 else si_prev
            
            # Calculate short interest changes
            si_change_current = si_current / max(abs(si_prev), 1e-8) - 1.0
            si_change_prev = si_prev / max(abs(si_prev2), 1e-8) - 1.0
            
            # Get recent price data
            current_close = close_prices[-1] if len(close_prices) > 0 else 0
            prev_close = close_prices[-2] if len(close_prices) > 1 else current_close
            
            # Calculate price change
            price_change = current_close / max(abs(prev_close), 1e-8) - 1.0
            
            # Reversal signal: short interest decreasing while price increasing
            if si_change_current < 0 and price_change > 0:
                reversal_signal = abs(si_change_current) * price_change
            else:
                reversal_signal = 0.0
                
            # Adjust based on previous short interest trend
            if si_change_prev > 0:  # Previous buildup of shorts
                reversal_signal *= (1 + si_change_prev)
        else:
            reversal_signal = 0.0
        eng.append(reversal_signal)
        
        # 14. NEW: MACD Signal Line - Momentum indicator with signal line crossover
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26
            weights_12 = np.exp(np.linspace(0, 2, 12))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-12:] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 2, 26))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-26:] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Signal Line (9-day EMA of MACD)
            # Since we don't have historical MACD values, we'll approximate
            # using the current MACD and price momentum as a proxy
            if len(close_prices) >= 35:  # Need extra history for approximation
                # Calculate historical MACD points (approximation)
                hist_macd = []
                for i in range(9):
                    idx = -9 + i
                    if abs(idx) < len(close_prices):
                        # Calculate historical EMAs
                        hist_ema12 = np.sum(close_prices[max(0, idx-12+1):idx+1] * 
                                          weights_12[-min(12, idx+1):])
                        hist_ema26 = np.sum(close_prices[max(0, idx-26+1):idx+1] * 
                                          weights_26[-min(26, idx+1):])
                        hist_macd.append(hist_ema12 - hist_ema26)
                
                if hist_macd:
                    # Calculate signal line as EMA of MACD values
                    weights_9 = np.exp(np.linspace(0, 2, len(hist_macd)))
                    weights_9 = weights_9 / np.sum(weights_9)
                    signal_line = np.sum(np.array(hist_macd) * weights_9)
                    
                    # MACD histogram (difference between MACD and signal line)
                    macd_hist = macd_line - signal_line
                else:
                    macd_hist = 0.0
            else:
                # Simplified approximation when history is limited
                macd_hist = macd_line
            
            # Normalize by recent price to make comparable across stocks
            avg_price = np.mean(close_prices[-26:])
            norm_macd_hist = macd_hist / max(abs(avg_price), 1e-8)
        else:
            norm_macd_hist = 0.0
        eng.append(norm_macd_hist)
        
        # 15. NEW: Short Volume Momentum - Rate of change in short volume
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            
            short_vol_momentum = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1.0
        else:
            short_vol_momentum = 0.0
        eng.append(short_vol_momentum)
        
        # 16. NEW: Volatility-Adjusted Price Momentum - Price momentum normalized by volatility
        if len(close_prices) >= 10:
            # Calculate price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Calculate price volatility (standard deviation)
            price_volatility = np.std(close_prices[-10:])
            avg_price = np.mean(close_prices[-10:])
            rel_volatility = price_volatility / max(abs(avg_price), 1e-8)
            
            # Adjust momentum by volatility
            if rel_volatility > 1e-8:
                vol_adj_momentum = price_momentum / rel_volatility
            else:
                vol_adj_momentum = price_momentum
        else:
            vol_adj_momentum = 0.0
        eng.append(vol_adj_momentum)
        
        # 17. NEW: Short Interest Efficiency - Measures how effectively short interest predicts price moves
        if t >= 3:
            price_changes = []
            si_changes = []
            
            for i in range(1, min(4, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                    close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                    price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                    
                    si_changes.append(si_change)
                    price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate correlation-like measure between SI changes and price changes
                # Negative correlation is expected (higher SI → lower prices)
                product_sum = 0
                for i in range(len(si_changes)):
                    product_sum += si_changes[i] * price_changes[i]
                
                # Normalize by number of samples
                si_efficiency = -product_sum / len(si_changes)
            else:
                si_efficiency = 0.0
        else:
            si_efficiency = 0.0
        eng.append(si_efficiency)
        
        # 18. NEW: Synthetic Short Cost Change - Rate of change in synthetic short cost
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64] if t-1 >= 0 else current_cost
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
        else:
            synth_cost_change = 0.0
        eng.append(synth_cost_change)
        
        # 19. NEW: Improved Price Trend Strength with Volume Confirmation
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate price changes
            price_changes = np.diff(close_prices[-10:])
            
            # Count positive and negative days
            pos_days = np.sum(price_changes > 0)
            neg_days = np.sum(price_changes < 0)
            
            # Calculate directional strength (ranges from -1 to 1)
            if pos_days + neg_days > 0:
                trend_strength = (pos_days - neg_days) / (pos_days + neg_days)
            else:
                trend_strength = 0.0
            
            # Volume confirmation - check if volume increases on trend days
            volume_trend = []
            for i in range(1, min(10, len(total_volume))):
                vol_change = total_volume[-i] - total_volume[-(i+1)]
                price_change = close_prices[-i] - close_prices[-(i+1)]
                
                # Volume confirms trend if it increases on trend days
                if (price_change > 0 and vol_change > 0) or (price_change < 0 and vol_change > 0):
                    volume_trend.append(1)
                else:
                    volume_trend.append(0)
            
            # Volume confirmation ratio
            vol_confirm_ratio = np.mean(volume_trend) if volume_trend else 0.5
            
            # Adjust trend strength by volume confirmation
            vol_confirmed_trend = trend_strength * (0.5 + vol_confirm_ratio)
        else:
            vol_confirmed_trend = 0.0
        eng.append(vol_confirmed_trend)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 185933.6181
RMSE: 230962.8240
MAPE: 14.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_18_t3: importance=0.0009, rank=1
   2. Feature_4_t2: importance=0.0008, rank=2
   3. Feature_9_t0: importance=0.0005, rank=3
   4. Feature_24_t1: importance=0.0005, rank=4
   5. Feature_11_t1: importance=0.0004, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.06%

📈 Current best MAPE: 14.22%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Improved Short Volume Ratio with adaptive weighting
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use adaptive weighting based on volatility of short volume ratio
        svr_std = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0.01
        svr_std = max(svr_std, 0.01)  # Ensure minimum volatility
        
        # Higher volatility = stronger recency bias
        exp_factor = 1 + (svr_std * 10)  # Scale volatility to reasonable range
        weights = np.exp(np.linspace(0, exp_factor, 15))
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio with trend adjustment
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Adjust based on recent trend if available
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            # Amplify signal when trend is strong
            short_interest_to_float *= (1 + 0.5 * abs(si_float_trend) * np.sign(si_float_trend))
        eng.append(short_interest_to_float)
        
        # 3. Multi-timeframe Price Momentum Composite
        # Combines multiple timeframes with adaptive weighting
        momentum_signals = []
        
        if len(close_prices) >= 10:
            # Short-term momentum (3-day)
            mom_3d = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            momentum_signals.append((mom_3d, 0.4))  # 40% weight
            
            # Medium-term momentum (5-day)
            mom_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            momentum_signals.append((mom_5d, 0.35))  # 35% weight
            
            # Longer-term momentum (10-day)
            mom_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            momentum_signals.append((mom_10d, 0.25))  # 25% weight
            
            # Combine signals with weights
            composite_momentum = sum(signal * weight for signal, weight in momentum_signals)
        else:
            # Use what's available
            if len(close_prices) >= 3:
                composite_momentum = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                composite_momentum = 0.0
        eng.append(composite_momentum)
        
        # 4. Enhanced RSI with volume weighting
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
                
            # Normalize RSI to [-1, 1] range for better gradient properties
            norm_rsi = (rsi / 50.0) - 1.0
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 5. Adaptive Price to Moving Average Ratio
        # Uses volatility to determine optimal lookback period
        if len(close_prices) >= 5:
            # Calculate price volatility to determine optimal MA period
            rolling_std = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            
            # Higher volatility = shorter MA period (more responsive)
            # Lower volatility = longer MA period (more stable)
            if rolling_std > 0.03:  # High volatility
                ma_period = min(5, len(close_prices))
            elif rolling_std > 0.01:  # Medium volatility
                ma_period = min(10, len(close_prices))
            else:  # Low volatility
                ma_period = min(15, len(close_prices))
                
            ma = np.mean(close_prices[-ma_period:])
            price_to_ma = close_prices[-1] / max(abs(ma), 1e-8)
            
            # Apply non-linear transformation to amplify deviations
            price_to_ma_signal = np.sign(price_to_ma - 1.0) * np.sqrt(abs(price_to_ma - 1.0))
        else:
            price_to_ma_signal = 0.0
        eng.append(price_to_ma_signal)
        
        # 6. Short Interest Momentum with Acceleration
        # Combines momentum and acceleration with adaptive smoothing
        if t > 0:
            si_current = data[t, 0]
            si_prev = data[t-1, 0]
            
            # Calculate momentum (first derivative)
            si_momentum = si_current / max(abs(si_prev), 1e-8) - 1.0
            
            # Add acceleration component if available
            if t > 1:
                si_prev2 = data[t-2, 0]
                prev_momentum = si_prev / max(abs(si_prev2), 1e-8) - 1.0
                
                # Calculate acceleration (second derivative)
                si_accel = si_momentum - prev_momentum
                
                # Adaptive smoothing based on acceleration magnitude
                accel_weight = min(0.7, 0.3 + abs(si_accel))
                si_momentum = (1 - accel_weight) * si_momentum + accel_weight * prev_momentum
                
                # Add non-linear amplification for strong signals
                if abs(si_momentum) > 0.05:
                    si_momentum *= (1 + 0.5 * abs(si_momentum))
            
            # Apply tanh to bound extreme values while preserving sign
            si_momentum_signal = np.tanh(si_momentum * 3)
        else:
            si_momentum_signal = 0.0
        eng.append(si_momentum_signal)
        
        # 7. Bollinger Band Position with Volume Confirmation
        if len(close_prices) >= 20:
            ma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            upper_band = ma20 + (2 * std20)
            lower_band = ma20 - (2 * std20)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Volume confirmation - check if volume supports the position
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify signal when volume confirms extreme positions
                    if (bb_position > 0.5 and vol_ratio > 1.2) or (bb_position < -0.5 and vol_ratio > 1.2):
                        bb_position *= vol_ratio
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 8. Short Interest Acceleration with Mean Reversion Component
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First differences (momentum)
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_acceleration = mom_t - mom_t1
            
            # Add mean reversion component
            if t >= 5:
                # Calculate average short interest over last 5 periods
                si_avg = np.mean([data[t-i, 0] for i in range(5)])
                
                # Calculate deviation from mean
                si_deviation = si_t / max(abs(si_avg), 1e-8) - 1.0
                
                # Mean reversion signal (stronger when deviation is large)
                mean_rev = -si_deviation * abs(si_deviation)
                
                # Combine acceleration and mean reversion
                si_accel_signal = 0.7 * si_acceleration + 0.3 * mean_rev
            else:
                si_accel_signal = si_acceleration
            
            # Apply sigmoid-like function to bound values
            si_accel_signal = si_accel_signal / max(1.0, abs(si_accel_signal) * 2)
        else:
            si_accel_signal = 0.0
        eng.append(si_accel_signal)
        
        # 9. Volume Trend with Price Confirmation
        if len(total_volume) >= 10:
            # Calculate recent volume trend
            recent_vol = np.mean(total_volume[-3:])
            older_vol = np.mean(total_volume[-10:-3])
            vol_trend = recent_vol / max(older_vol, 1e-8) - 1.0
            
            # Price confirmation
            if len(close_prices) >= 10:
                recent_price = np.mean(close_prices[-3:])
                older_price = np.mean(close_prices[-10:-3])
                price_trend = recent_price / max(older_price, 1e-8) - 1.0
                
                # Volume is more significant when it confirms price direction
                # or when it contradicts (potential reversal signal)
                if np.sign(vol_trend) == np.sign(price_trend):
                    # Confirming trend - amplify
                    vol_signal = vol_trend * (1 + abs(price_trend))
                else:
                    # Contradicting trend - potential reversal
                    vol_signal = vol_trend * (1 + 0.5 * abs(price_trend))
            else:
                vol_signal = vol_trend
            
            # Bound the signal
            vol_signal = np.tanh(vol_signal * 2)
        else:
            vol_signal = 0.0
        eng.append(vol_signal)
        
        # 10. Short Interest to Implied Volatility Ratio with Trend
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_iv = max(abs(data[t-i, 65]), 1e-8)
                    hist_ratios.append(data[t-i, 0] / hist_iv)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_iv_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        
        # Apply non-linear transformation to emphasize extremes
        si_iv_signal = np.sign(si_iv_signal) * np.sqrt(abs(si_iv_signal))
        eng.append(si_iv_signal)
        
        # 11. Enhanced MACD Signal with Volume Validation
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26 (approximated with weighted averages)
            weights_12 = np.exp(np.linspace(0, 3, min(12, len(close_prices))))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-min(12, len(close_prices)):] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 3, min(26, len(close_prices))))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-min(26, len(close_prices)):] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-min(26, len(close_prices)):])
            norm_macd = macd_line / max(abs(avg_price), 1e-8)
            
            # Volume validation
            if len(total_volume) >= 5:
                recent_vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
                
                # Amplify MACD when volume is high (more significant signal)
                if recent_vol_ratio > 1.2:
                    norm_macd *= np.sqrt(recent_vol_ratio)
                elif recent_vol_ratio < 0.8:
                    norm_macd *= np.sqrt(recent_vol_ratio)
            
            # Bound the signal
            macd_signal = np.tanh(norm_macd * 10)
        else:
            macd_signal = 0.0
        eng.append(macd_signal)
        
        # 12. Short Volume Trend with Acceleration
        if len(short_volume) >= 10:
            # Calculate short volume trend
            recent_short_vol = np.mean(short_volume[-3:])
            older_short_vol = np.mean(short_volume[-10:-3])
            sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Add acceleration component if possible
            if len(short_volume) >= 15:
                oldest_short_vol = np.mean(short_volume[:5])
                older_trend = older_short_vol / max(oldest_short_vol, 1e-8) - 1.0
                sv_accel = sv_trend - older_trend
                
                # Combine trend and acceleration
                sv_signal = 0.7 * sv_trend + 0.3 * sv_accel
            else:
                sv_signal = sv_trend
            
            # Apply non-linear transformation
            sv_signal = np.sign(sv_signal) * np.sqrt(abs(sv_signal))
        else:
            sv_signal = 0.0
        eng.append(sv_signal)
        
        # 13. Volatility-Adjusted Price Momentum with Mean Reversion
        if len(close_prices) >= 10:
            # Calculate recent price momentum
            recent_momentum = close_prices[-1] / max(close_prices[-5], 1e-8) - 1.0
            
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust momentum by volatility
            vol_adj_momentum = recent_momentum / max(rel_volatility, 0.01)
            
            # Add mean reversion component
            price_deviation = close_prices[-1] / max(price_mean, 1e-8) - 1.0
            mean_rev_signal = -price_deviation * abs(price_deviation)
            
            # Combine signals based on volatility regime
            if rel_volatility > 0.03:  # High volatility - favor mean reversion
                combined_signal = 0.4 * vol_adj_momentum + 0.6 * mean_rev_signal
            else:  # Low volatility - favor momentum
                combined_signal = 0.7 * vol_adj_momentum + 0.3 * mean_rev_signal
            
            # Bound the signal
            vol_adj_signal = np.tanh(combined_signal * 2)
        else:
            vol_adj_signal = 0.0
        eng.append(vol_adj_signal)
        
        # 14. Short Interest Efficiency with Adaptive Learning
        if t >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate weighted correlation-like measure
                # More recent points get higher weights
                weights = np.exp(np.linspace(0, 1, len(si_changes)))
                weights = weights / np.sum(weights)
                
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
                
                # Apply non-linear transformation to emphasize strong relationships
                si_efficiency_signal = np.sign(si_efficiency) * np.sqrt(abs(si_efficiency))
            else:
                si_efficiency_signal = 0.0
        else:
            si_efficiency_signal = 0.0
        eng.append(si_efficiency_signal)
        
        # 15. Synthetic Short Cost Change with Implied Volatility Context
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64] if t-1 >= 0 else current_cost
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            
            # Add context from implied volatility
            current_iv = data[t, 65]
            prev_iv = data[t-1, 65] if t-1 >= 0 else current_iv
            iv_change = current_iv / max(abs(prev_iv), 1e-8) - 1.0
            
            # Adjust cost change by IV context
            # Cost changes are more significant when they diverge from IV changes
            if np.sign(synth_cost_change) != np.sign(iv_change):
                # Divergence - amplify signal
                cost_signal = synth_cost_change * (1 + 0.5 * abs(iv_change))
            else:
                # Convergence - reduce signal
                cost_signal = synth_cost_change * (1 - 0.3 * abs(iv_change))
            
            # Bound the signal
            cost_signal = np.tanh(cost_signal * 3)
        else:
            cost_signal = 0.0
        eng.append(cost_signal)
        
        # 16. Price Trend Strength with Volume Profile Analysis
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate price changes
            price_changes = np.diff(close_prices[-10:])
            
            # Count positive and negative days
            pos_days = np.sum(price_changes > 0)
            neg_days = np.sum(price_changes < 0)
            
            # Calculate directional strength (ranges from -1 to 1)
            if pos_days + neg_days > 0:
                trend_strength = (pos_days - neg_days) / (pos_days + neg_days)
            else:
                trend_strength = 0.0
            
            # Enhanced volume profile analysis
            up_vol_sum = 0
            down_vol_sum = 0
            
            for i in range(1, min(10, len(total_volume))):
                if i < len(price_changes) + 1:
                    if price_changes[i-1] > 0:
                        up_vol_sum += total_volume[-i]
                    elif price_changes[i-1] < 0:
                        down_vol_sum += total_volume[-i]
            
            # Calculate volume strength ratio
            if up_vol_sum + down_vol_sum > 0:
                vol_strength = (up_vol_sum - down_vol_sum) / (up_vol_sum + down_vol_sum)
            else:
                vol_strength = 0.0
            
            # Combine price trend and volume strength
            # Higher weight to volume when they disagree (potential reversal)
            if np.sign(trend_strength) == np.sign(vol_strength):
                combined_trend = 0.6 * trend_strength + 0.4 * vol_strength
            else:
                combined_trend = 0.4 * trend_strength + 0.6 * vol_strength
        else:
            combined_trend = 0.0
        eng.append(combined_trend)
        
        # 17. Options Market Sentiment Indicator
        # Combines put/call ratio with implied volatility changes
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine signals - higher weight to put/call when IV is rising
            if iv_change > 0:
                options_sentiment = 0.7 * norm_pc_ratio + 0.3 * iv_change
            else:
                options_sentiment = 0.5 * norm_pc_ratio + 0.5 * iv_change
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal
        options_sentiment = np.tanh(options_sentiment * 2)
        eng.append(options_sentiment)
        
        # 18. Short Squeeze Potential Indicator
        # Combines short interest, price momentum, and volume
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Short squeeze conditions:
            # 1. High short interest
            # 2. Positive price momentum
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            
            squeeze_score = 0.0
            
            # High short interest base score
            if si_level > 0.1:  # More than 10% of float
                squeeze_score += 0.3 * min(si_level / 0.2, 1.0)  # Cap at 20% of float
            
            # Add momentum component (only positive momentum contributes)
            if price_momentum > 0:
                squeeze_score += 0.3 * min(price_momentum / 0.05, 1.0)  # Cap at 5% price increase
            
            # Add volume component
            if vol_surge > 0:
                squeeze_score += 0.2 * min(vol_surge / 0.5, 1.0)  # Cap at 50% volume increase
            
            # Add short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.2 * min(abs(si_change) / 0.05, 1.0)  # Cap at 5% SI reduction
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 19. Volatility Regime Indicator
        if len(close_prices) >= 20:
            # Calculate short-term and long-term volatility
            short_vol = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            long_vol = np.std(close_prices[-20:]) / max(np.mean(close_prices[-20:]), 1e-8)
            
            # Volatility regime (>1 means increasing volatility)
            vol_regime = short_vol / max(long_vol, 1e-8)
            
            # Normalize to a reasonable range
            vol_regime_signal = (vol_regime - 1.0) * 2
            
            # Bound the signal
            vol_regime_signal = np.tanh(vol_regime_signal)
        else:
            vol_regime_signal = 0.0
        eng.append(vol_regime_signal)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 177650.9078
RMSE: 227181.6480
MAPE: 13.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0007, rank=1
   2. Feature_9_t0: importance=0.0005, rank=2
   3. Feature_6_t1: importance=0.0004, rank=3
   4. Feature_13_t3: importance=0.0004, rank=4
   5. Feature_10_t2: importance=0.0004, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.64%

📈 Current best MAPE: 13.58%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Improved Short Volume Ratio with Exponential Weighting
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponential weighting to emphasize recent days
        weights = np.exp(np.linspace(0, 2, 15))  # Stronger recency bias
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio with Trend Adjustment
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Adjust based on recent trend if available
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            # Amplify signal when trend is strong
            short_interest_to_float *= (1 + 0.7 * abs(si_float_trend) * np.sign(si_float_trend))
        eng.append(short_interest_to_float)
        
        # 3. Multi-timeframe Price Momentum with Volatility Adjustment
        # Combines multiple timeframes with volatility-based weighting
        if len(close_prices) >= 10:
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Short-term momentum (3-day)
            mom_3d = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            
            # Medium-term momentum (5-day)
            mom_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            
            # Longer-term momentum (10-day)
            mom_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            
            # Adjust weights based on volatility regime
            if rel_volatility > 0.03:  # High volatility - favor short-term
                weights = [0.5, 0.3, 0.2]
            elif rel_volatility > 0.01:  # Medium volatility
                weights = [0.4, 0.4, 0.2]
            else:  # Low volatility - favor longer-term
                weights = [0.2, 0.4, 0.4]
                
            # Combine signals with adaptive weights
            composite_momentum = mom_3d * weights[0] + mom_5d * weights[1] + mom_10d * weights[2]
            
            # Apply non-linear transformation to amplify strong signals
            composite_momentum = np.sign(composite_momentum) * np.sqrt(abs(composite_momentum))
        else:
            # Use what's available
            if len(close_prices) >= 3:
                composite_momentum = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                composite_momentum = 0.0
        eng.append(composite_momentum)
        
        # 4. Enhanced RSI with Volume and Volatility Adjustment
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            
            # Further adjust RSI by volatility
            if len(close_prices) >= 10:
                price_std = np.std(close_prices[-10:])
                price_mean = np.mean(close_prices[-10:])
                rel_volatility = price_std / max(price_mean, 1e-8)
                
                # In high volatility regimes, move RSI closer to neutral (50)
                if rel_volatility > 0.03:  # High volatility
                    rsi = 50.0 + 0.7 * (rsi - 50.0)  # Dampen extreme values
            
            # Normalize RSI to [-1, 1] range for better gradient properties
            norm_rsi = (rsi / 50.0) - 1.0
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 5. Bollinger Band Position with Volume and Volatility Context
        if len(close_prices) >= 20:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                bb_period = 10
            elif rel_volatility > 0.01:  # Medium volatility
                bb_period = 15
            else:  # Low volatility - longer period
                bb_period = 20
                
            bb_period = min(bb_period, len(close_prices))
            
            ma = np.mean(close_prices[-bb_period:])
            std = np.std(close_prices[-bb_period:])
            
            upper_band = ma + (2 * std)
            lower_band = ma - (2 * std)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Volume confirmation - check if volume supports the position
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify signal when volume confirms extreme positions
                    if (bb_position > 0.5 and vol_ratio > 1.2) or (bb_position < -0.5 and vol_ratio > 1.2):
                        bb_position *= vol_ratio
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 6. Short Interest Momentum with Acceleration and Mean Reversion
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First differences (momentum)
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_acceleration = mom_t - mom_t1
            
            # Add mean reversion component
            if t >= 5:
                # Calculate average short interest over last 5 periods
                si_avg = np.mean([data[t-i, 0] for i in range(5)])
                
                # Calculate deviation from mean
                si_deviation = si_t / max(abs(si_avg), 1e-8) - 1.0
                
                # Mean reversion signal (stronger when deviation is large)
                mean_rev = -si_deviation * abs(si_deviation)
                
                # Combine acceleration and mean reversion with adaptive weighting
                # When acceleration and mean reversion agree, amplify the signal
                if np.sign(si_acceleration) == np.sign(mean_rev):
                    si_accel_signal = 0.7 * si_acceleration + 0.5 * mean_rev  # Amplify
                else:
                    # When they disagree, use more balanced weights
                    si_accel_signal = 0.6 * si_acceleration + 0.4 * mean_rev
            else:
                si_accel_signal = si_acceleration
            
            # Apply sigmoid-like function to bound values
            si_accel_signal = si_accel_signal / max(1.0, abs(si_accel_signal) * 2)
        else:
            si_accel_signal = 0.0
        eng.append(si_accel_signal)
        
        # 7. Enhanced Short Squeeze Potential Indicator
        # Combines short interest, price momentum, volume, and options data
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Options data - put/call ratio change
            put_call_ratio = data[t, 63]
            if t > 0:
                prev_pc_ratio = data[t-1, 63]
                pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            else:
                pc_ratio_change = 0.0
            
            # Short squeeze conditions:
            # 1. High short interest
            # 2. Positive price momentum
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            # 5. Decreasing put/call ratio (bullish options sentiment)
            
            squeeze_score = 0.0
            
            # High short interest base score - more weight than before
            if si_level > 0.1:  # More than 10% of float
                squeeze_score += 0.35 * min(si_level / 0.2, 1.0)  # Cap at 20% of float
            
            # Add momentum component (only positive momentum contributes)
            if price_momentum > 0:
                squeeze_score += 0.25 * min(price_momentum / 0.05, 1.0)  # Cap at 5% price increase
            
            # Add volume component
            if vol_surge > 0:
                squeeze_score += 0.15 * min(vol_surge / 0.5, 1.0)  # Cap at 50% volume increase
            
            # Add short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.15 * min(abs(si_change) / 0.05, 1.0)  # Cap at 5% SI reduction
            
            # Add options sentiment component
            if pc_ratio_change < 0:  # Decreasing put/call ratio (bullish)
                squeeze_score += 0.1 * min(abs(pc_ratio_change) / 0.1, 1.0)  # Cap at 10% reduction
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 8. Options Market Sentiment with Implied Volatility Context
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            # When IV is rising and put/call ratio is high = strong bearish signal
            # When IV is rising and put/call ratio is low = potential volatility breakout
            if iv_change > 0 and norm_pc_ratio > 0:
                options_sentiment = 0.8 * norm_pc_ratio + 0.4 * iv_change  # Strong bearish
            elif iv_change > 0 and norm_pc_ratio < 0:
                options_sentiment = 0.6 * norm_pc_ratio + 0.2 * iv_change  # Mixed signal
            elif iv_change < 0 and norm_pc_ratio > 0:
                options_sentiment = 0.5 * norm_pc_ratio + 0.3 * iv_change  # Mixed signal
            else:
                options_sentiment = 0.7 * norm_pc_ratio + 0.2 * iv_change  # Bullish
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal
        options_sentiment = np.tanh(options_sentiment * 2)
        eng.append(options_sentiment)
        
        # 9. Short Interest to Implied Volatility Ratio with Trend
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_iv = max(abs(data[t-i, 65]), 1e-8)
                    hist_ratios.append(data[t-i, 0] / hist_iv)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
                
                # Apply non-linear transformation to emphasize extremes
                si_iv_signal = np.sign(si_iv_signal) * np.power(abs(si_iv_signal), 0.7)  # Less aggressive power
            else:
                si_iv_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        eng.append(si_iv_signal)
        
        # 10. Short Volume Trend with Price Confirmation
        if len(short_volume) >= 10 and len(close_prices) >= 10:
            # Calculate short volume trend
            recent_short_vol = np.mean(short_volume[-3:])
            older_short_vol = np.mean(short_volume[-10:-3])
            sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Calculate price trend
            recent_price = np.mean(close_prices[-3:])
            older_price = np.mean(close_prices[-10:-3])
            price_trend = recent_price / max(older_price, 1e-8) - 1.0
            
            # Combine signals based on confirmation/contradiction
            # When short volume increases and price decreases = bearish confirmation
            # When short volume increases and price increases = potential short squeeze
            if sv_trend > 0 and price_trend < 0:
                sv_price_signal = 0.7 * sv_trend - 0.3 * price_trend  # Bearish confirmation
            elif sv_trend > 0 and price_trend > 0:
                sv_price_signal = 0.5 * sv_trend + 0.5 * price_trend  # Potential squeeze
            elif sv_trend < 0 and price_trend > 0:
                sv_price_signal = -0.6 * sv_trend + 0.4 * price_trend  # Bullish confirmation
            else:
                sv_price_signal = -0.5 * sv_trend - 0.5 * price_trend  # Potential reversal
            
            # Bound the signal
            sv_price_signal = np.tanh(sv_price_signal * 2)
        else:
            sv_price_signal = 0.0
        eng.append(sv_price_signal)
        
        # 11. Synthetic Short Cost Change with Options Context
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64]
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            
            # Add context from options data
            put_call_ratio = data[t, 63]
            prev_pc_ratio = data[t-1, 63] if t-1 >= 0 else put_call_ratio
            pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            # When synthetic short cost increases with put/call ratio = stronger signal
            if np.sign(synth_cost_change) == np.sign(pc_ratio_change):
                cost_signal = 0.7 * synth_cost_change + 0.3 * pc_ratio_change  # Amplify
            else:
                cost_signal = 0.6 * synth_cost_change + 0.2 * pc_ratio_change  # More weight to cost
            
            # Apply non-linear transformation
            cost_signal = np.sign(cost_signal) * np.sqrt(abs(cost_signal))
        else:
            cost_signal = 0.0
        eng.append(cost_signal)
        
        # 12. Volatility-Adjusted Price Momentum with Mean Reversion
        if len(close_prices) >= 10:
            # Calculate recent price momentum
            recent_momentum = close_prices[-1] / max(close_prices[-5], 1e-8) - 1.0
            
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust momentum by volatility
            vol_adj_momentum = recent_momentum / max(rel_volatility, 0.01)
            
            # Add mean reversion component
            price_deviation = close_prices[-1] / max(price_mean, 1e-8) - 1.0
            mean_rev_signal = -price_deviation * abs(price_deviation)
            
            # Combine signals based on volatility regime and momentum strength
            if rel_volatility > 0.03:  # High volatility
                if abs(recent_momentum) > 0.03:  # Strong momentum
                    combined_signal = 0.6 * vol_adj_momentum + 0.4 * mean_rev_signal
                else:  # Weak momentum - favor mean reversion
                    combined_signal = 0.3 * vol_adj_momentum + 0.7 * mean_rev_signal
            else:  # Low volatility
                if abs(recent_momentum) > 0.02:  # Strong momentum
                    combined_signal = 0.8 * vol_adj_momentum + 0.2 * mean_rev_signal
                else:  # Weak momentum
                    combined_signal = 0.5 * vol_adj_momentum + 0.5 * mean_rev_signal
            
            # Bound the signal
            vol_adj_signal = np.tanh(combined_signal * 2)
        else:
            vol_adj_signal = 0.0
        eng.append(vol_adj_signal)
        
        # 13. Short Interest Efficiency Ratio
        # Measures how effectively short interest predicts price movements
        if t >= 5 and len(close_prices) >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate weighted correlation-like measure with stronger recency bias
                weights = np.exp(np.linspace(0, 2, len(si_changes)))  # Stronger exponential weights
                weights = weights / np.sum(weights)
                
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
                
                # Apply non-linear transformation to emphasize strong relationships
                si_efficiency_signal = np.sign(si_efficiency) * np.power(abs(si_efficiency), 0.7)
            else:
                si_efficiency_signal = 0.0
        else:
            si_efficiency_signal = 0.0
        eng.append(si_efficiency_signal)
        
        # 14. Enhanced MACD Signal with Volume and Volatility Context
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26 (approximated with weighted averages)
            weights_12 = np.exp(np.linspace(0, 3, min(12, len(close_prices))))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-min(12, len(close_prices)):] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 3, min(26, len(close_prices))))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-min(26, len(close_prices)):] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-min(26, len(close_prices)):])
            norm_macd = macd_line / max(abs(avg_price), 1e-8)
            
            # Add volatility context
            if len(close_prices) >= 10:
                price_std = np.std(close_prices[-10:])
                price_mean = np.mean(close_prices[-10:])
                rel_volatility = price_std / max(price_mean, 1e-8)
                
                # Adjust MACD by volatility - less weight in high volatility
                if rel_volatility > 0.03:  # High volatility
                    norm_macd *= 0.7  # Reduce signal in high volatility
                
            # Volume validation
            if len(total_volume) >= 5:
                recent_vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
                
                # Amplify MACD when volume confirms direction
                if (norm_macd > 0 and recent_vol_ratio > 1.2) or (norm_macd < 0 and recent_vol_ratio > 1.2):
                    norm_macd *= np.sqrt(recent_vol_ratio)
            
            # Bound the signal
            macd_signal = np.tanh(norm_macd * 10)
        else:
            macd_signal = 0.0
        eng.append(macd_signal)
        
        # 15. Adaptive Price Channel Breakout
        if len(close_prices) >= 10:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                channel_period = 5
            elif rel_volatility > 0.01:  # Medium volatility
                channel_period = 10
            else:  # Low volatility - longer period
                channel_period = 15
                
            channel_period = min(channel_period, len(close_prices))
            
            # Calculate upper and lower channels
            upper_channel = np.max(close_prices[-channel_period:-1])
            lower_channel = np.min(close_prices[-channel_period:-1])
            
            # Calculate breakout signal
            channel_width = upper_channel - lower_channel
            if channel_width > 1e-8:
                # Normalize to [-1, 1] range where:
                # +1 = strong upside breakout
                # -1 = strong downside breakout
                # 0 = in the middle of the channel
                breakout_signal = 2 * ((close_prices[-1] - lower_channel) / channel_width) - 1
                
                # Add volume confirmation
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify breakouts with high volume
                    if abs(breakout_signal) > 0.7 and vol_ratio > 1.2:
                        breakout_signal *= np.sqrt(vol_ratio)
                
                # Bound the signal
                breakout_signal = max(-1.0, min(1.0, breakout_signal))
            else:
                breakout_signal = 0.0
        else:
            breakout_signal = 0.0
        eng.append(breakout_signal)
        
        # 16. Short Interest to Days-to-Cover Ratio
        # Combines short interest with days to cover for a more complete picture
        si = data[t, 0]
        dtc = max(abs(data[t, 2]), 1e-8)
        si_dtc_ratio = si / dtc
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_si = data[t-i, 0]
                    hist_dtc = max(abs(data[t-i, 2]), 1e-8)
                    hist_ratios.append(hist_si / hist_dtc)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_dtc_signal = si_dtc_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_dtc_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_dtc_signal = si_dtc_ratio * 0.01  # Scale to reasonable range
        
        # Apply non-linear transformation
        si_dtc_signal = np.sign(si_dtc_signal) * np.sqrt(abs(si_dtc_signal))
        eng.append(si_dtc_signal)
        
        # 17. Volume-Weighted Average Price (VWAP) Deviation
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate VWAP over the last 5 days
            vwap_sum = 0
            volume_sum = 0
            
            for i in range(1, min(6, len(close_prices) + 1)):
                vwap_sum += close_prices[-i] * total_volume[-i]
                volume_sum += total_volume[-i]
            
            if volume_sum > 1e-8:
                vwap = vwap_sum / max(volume_sum, 1e-8)
                
                # Calculate deviation from VWAP
                vwap_deviation = close_prices[-1] / max(vwap, 1e-8) - 1.0
                
                # Apply non-linear transformation to emphasize significant deviations
                vwap_signal = np.sign(vwap_deviation) * np.sqrt(abs(vwap_deviation))
            else:
                vwap_signal = 0.0
        else:
            vwap_signal = 0.0
        eng.append(vwap_signal)
        
        # 18. Short Interest Concentration Index
        # Measures how concentrated short interest is relative to trading volume
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            # Calculate daily short interest concentration
            daily_concentration = []
            for i in range(min(10, len(short_volume))):
                concentration = short_volume[-i-1] / max(total_volume[-i-1], 1e-8)
                daily_concentration.append(concentration)
            
            # Calculate concentration variability
            if len(daily_concentration) >= 3:
                concentration_std = np.std(daily_concentration)
                concentration_mean = np.mean(daily_concentration)
                
                # Normalize
                concentration_cv = concentration_std / max(concentration_mean, 1e-8)
                
                # Recent trend in concentration
                recent_conc = np.mean(daily_concentration[:3])
                older_conc = np.mean(daily_concentration[3:]) if len(daily_concentration) > 3 else recent_conc
                conc_trend = recent_conc / max(older_conc, 1e-8) - 1.0
                
                # Combine variability and trend
                # High variability + increasing concentration = stronger signal
                if conc_trend > 0:
                    concentration_signal = concentration_cv * (1 + conc_trend)
                else:
                    concentration_signal = concentration_cv * (1 + 0.5 * conc_trend)
                
                # Bound the signal
                concentration_signal = np.tanh(concentration_signal * 3)
            else:
                concentration_signal = 0.0
        else:
            concentration_signal = 0.0
        eng.append(concentration_signal)
        
        # 19. Adaptive Market Regime Indicator
        # Combines volatility, momentum, and volume to identify market regime
        if len(close_prices) >= 15 and len(total_volume) >= 15:
            # Calculate volatility component
            recent_vol = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            older_vol = np.std(close_prices[-15:-5]) / max(np.mean(close_prices[-15:-5]), 1e-8)
            vol_ratio = recent_vol / max(older_vol, 1e-8)
            
            # Calculate momentum component
            recent_mom = close_prices[-1] / max(close_prices[-5], 1e-8) - 1.0
            older_mom = close_prices[-5] / max(close_prices[-15], 1e-8) - 1.0
            mom_ratio = 1.0 + recent_mom - older_mom
            
            # Calculate volume component
            recent_volume = np.mean(total_volume[-5:])
            older_volume = np.mean(total_volume[-15:-5])
            volume_ratio = recent_volume / max(older_volume, 1e-8)
            
            # Combine components to identify regime
            # High volatility + strong momentum + high volume = trending regime
            # High volatility + weak momentum + high volume = reversal regime
            # Low volatility + weak momentum + low volume = range-bound regime
            
            if vol_ratio > 1.2:  # Increasing volatility
                if abs(recent_mom) > 0.02 and volume_ratio > 1.1:
                    # Trending regime - positive or negative based on momentum
                    regime_signal = np.sign(recent_mom) * 0.8
                else:
                    # Potential reversal regime
                    regime_signal = -np.sign(recent_mom) * 0.5
            else:  # Stable or decreasing volatility
                if abs(recent_mom) < 0.01 and volume_ratio < 0.9:
                    # Range-bound regime
                    regime_signal = 0.0
                else:
                    # Weak trend continuation
                    regime_signal = np.sign(recent_mom) * 0.3
        else:
            regime_signal = 0.0
        eng.append(regime_signal)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 191083.0545
RMSE: 239872.2756
MAPE: 14.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 75
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t0: importance=0.0008, rank=1
   2. Feature_4_t2: importance=0.0006, rank=2
   3. Feature_24_t1: importance=0.0004, rank=3
   4. Feature_11_t3: importance=0.0004, rank=4
   5. Feature_6_t1: importance=0.0004, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
📊 No significant improvement. Change: -0.43%

📈 Current best MAPE: 13.58%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 8
======================================================================
🤖 Calling Claude for iteration 8...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Improved Short Volume Ratio with Exponential Weighting
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponential weighting to emphasize recent days
        weights = np.exp(np.linspace(0, 2.5, 15))  # Stronger recency bias
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 2. Short Interest to Float Ratio with Trend Adjustment
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Adjust based on recent trend if available
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            # Amplify signal when trend is strong
            short_interest_to_float *= (1 + 0.8 * abs(si_float_trend) * np.sign(si_float_trend))
        eng.append(short_interest_to_float)
        
        # 3. Multi-timeframe Price Momentum with Volatility Adjustment
        # Combines multiple timeframes with volatility-based weighting
        if len(close_prices) >= 10:
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Short-term momentum (3-day)
            mom_3d = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            
            # Medium-term momentum (5-day)
            mom_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            
            # Longer-term momentum (10-day)
            mom_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            
            # Adjust weights based on volatility regime
            if rel_volatility > 0.03:  # High volatility - favor short-term
                weights = [0.6, 0.3, 0.1]
            elif rel_volatility > 0.01:  # Medium volatility
                weights = [0.4, 0.4, 0.2]
            else:  # Low volatility - favor longer-term
                weights = [0.2, 0.4, 0.4]
                
            # Combine signals with adaptive weights
            composite_momentum = mom_3d * weights[0] + mom_5d * weights[1] + mom_10d * weights[2]
            
            # Apply non-linear transformation to amplify strong signals
            composite_momentum = np.sign(composite_momentum) * np.sqrt(abs(composite_momentum))
        else:
            # Use what's available
            if len(close_prices) >= 3:
                composite_momentum = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                composite_momentum = 0.0
        eng.append(composite_momentum)
        
        # 4. Enhanced RSI with Volume and Volatility Adjustment
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            
            # Further adjust RSI by volatility
            if len(close_prices) >= 10:
                price_std = np.std(close_prices[-10:])
                price_mean = np.mean(close_prices[-10:])
                rel_volatility = price_std / max(price_mean, 1e-8)
                
                # In high volatility regimes, move RSI closer to neutral (50)
                if rel_volatility > 0.03:  # High volatility
                    rsi = 50.0 + 0.7 * (rsi - 50.0)  # Dampen extreme values
            
            # Normalize RSI to [-1, 1] range for better gradient properties
            norm_rsi = (rsi / 50.0) - 1.0
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 5. Enhanced Short Squeeze Potential Indicator
        # Combines short interest, price momentum, volume, and options data
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Options data - put/call ratio change
            put_call_ratio = data[t, 63]
            if t > 0:
                prev_pc_ratio = data[t-1, 63]
                pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            else:
                pc_ratio_change = 0.0
            
            # Short squeeze conditions:
            # 1. High short interest
            # 2. Positive price momentum
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            # 5. Decreasing put/call ratio (bullish options sentiment)
            
            squeeze_score = 0.0
            
            # High short interest base score - more weight than before
            if si_level > 0.1:  # More than 10% of float
                squeeze_score += 0.4 * min(si_level / 0.2, 1.0)  # Cap at 20% of float
            
            # Add momentum component (only positive momentum contributes)
            if price_momentum > 0:
                squeeze_score += 0.25 * min(price_momentum / 0.05, 1.0)  # Cap at 5% price increase
            
            # Add volume component
            if vol_surge > 0:
                squeeze_score += 0.15 * min(vol_surge / 0.5, 1.0)  # Cap at 50% volume increase
            
            # Add short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.15 * min(abs(si_change) / 0.05, 1.0)  # Cap at 5% SI reduction
            
            # Add options sentiment component
            if pc_ratio_change < 0:  # Decreasing put/call ratio (bullish)
                squeeze_score += 0.1 * min(abs(pc_ratio_change) / 0.1, 1.0)  # Cap at 10% reduction
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 6. Options Market Sentiment with Implied Volatility Context
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            # When IV is rising and put/call ratio is high = strong bearish signal
            # When IV is rising and put/call ratio is low = potential volatility breakout
            if iv_change > 0 and norm_pc_ratio > 0:
                options_sentiment = 0.8 * norm_pc_ratio + 0.4 * iv_change  # Strong bearish
            elif iv_change > 0 and norm_pc_ratio < 0:
                options_sentiment = 0.6 * norm_pc_ratio + 0.2 * iv_change  # Mixed signal
            elif iv_change < 0 and norm_pc_ratio > 0:
                options_sentiment = 0.5 * norm_pc_ratio + 0.3 * iv_change  # Mixed signal
            else:
                options_sentiment = 0.7 * norm_pc_ratio + 0.2 * iv_change  # Bullish
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal
        options_sentiment = np.tanh(options_sentiment * 2)
        eng.append(options_sentiment)
        
        # 7. Short Interest Momentum with Acceleration and Mean Reversion
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First differences (momentum)
            mom_t = si_t / max(abs(si_t1), 1e-8) - 1.0
            mom_t1 = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_acceleration = mom_t - mom_t1
            
            # Add mean reversion component
            if t >= 5:
                # Calculate average short interest over last 5 periods
                si_avg = np.mean([data[t-i, 0] for i in range(5)])
                
                # Calculate deviation from mean
                si_deviation = si_t / max(abs(si_avg), 1e-8) - 1.0
                
                # Mean reversion signal (stronger when deviation is large)
                mean_rev = -si_deviation * abs(si_deviation)
                
                # Combine acceleration and mean reversion with adaptive weighting
                # When acceleration and mean reversion agree, amplify the signal
                if np.sign(si_acceleration) == np.sign(mean_rev):
                    si_accel_signal = 0.7 * si_acceleration + 0.5 * mean_rev  # Amplify
                else:
                    # When they disagree, use more balanced weights
                    si_accel_signal = 0.6 * si_acceleration + 0.4 * mean_rev
            else:
                si_accel_signal = si_acceleration
            
            # Apply sigmoid-like function to bound values
            si_accel_signal = si_accel_signal / max(1.0, abs(si_accel_signal) * 2)
        else:
            si_accel_signal = 0.0
        eng.append(si_accel_signal)
        
        # 8. Short Interest to Implied Volatility Ratio with Trend
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_iv = max(abs(data[t-i, 65]), 1e-8)
                    hist_ratios.append(data[t-i, 0] / hist_iv)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
                
                # Apply non-linear transformation to emphasize extremes
                si_iv_signal = np.sign(si_iv_signal) * np.power(abs(si_iv_signal), 0.7)  # Less aggressive power
            else:
                si_iv_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        eng.append(si_iv_signal)
        
        # 9. Short Volume Trend with Price Confirmation
        if len(short_volume) >= 10 and len(close_prices) >= 10:
            # Calculate short volume trend
            recent_short_vol = np.mean(short_volume[-3:])
            older_short_vol = np.mean(short_volume[-10:-3])
            sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Calculate price trend
            recent_price = np.mean(close_prices[-3:])
            older_price = np.mean(close_prices[-10:-3])
            price_trend = recent_price / max(older_price, 1e-8) - 1.0
            
            # Combine signals based on confirmation/contradiction
            # When short volume increases and price decreases = bearish confirmation
            # When short volume increases and price increases = potential short squeeze
            if sv_trend > 0 and price_trend < 0:
                sv_price_signal = 0.7 * sv_trend - 0.3 * price_trend  # Bearish confirmation
            elif sv_trend > 0 and price_trend > 0:
                sv_price_signal = 0.5 * sv_trend + 0.5 * price_trend  # Potential squeeze
            elif sv_trend < 0 and price_trend > 0:
                sv_price_signal = -0.6 * sv_trend + 0.4 * price_trend  # Bullish confirmation
            else:
                sv_price_signal = -0.5 * sv_trend - 0.5 * price_trend  # Potential reversal
            
            # Bound the signal
            sv_price_signal = np.tanh(sv_price_signal * 2)
        else:
            sv_price_signal = 0.0
        eng.append(sv_price_signal)
        
        # 10. Synthetic Short Cost Change with Options Context
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64]
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            
            # Add context from options data
            put_call_ratio = data[t, 63]
            prev_pc_ratio = data[t-1, 63] if t-1 >= 0 else put_call_ratio
            pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            # When synthetic short cost increases with put/call ratio = stronger signal
            if np.sign(synth_cost_change) == np.sign(pc_ratio_change):
                cost_signal = 0.7 * synth_cost_change + 0.3 * pc_ratio_change  # Amplify
            else:
                cost_signal = 0.6 * synth_cost_change + 0.2 * pc_ratio_change  # More weight to cost
            
            # Apply non-linear transformation
            cost_signal = np.sign(cost_signal) * np.sqrt(abs(cost_signal))
        else:
            cost_signal = 0.0
        eng.append(cost_signal)
        
        # 11. Short Interest to Days-to-Cover Ratio
        # Combines short interest with days to cover for a more complete picture
        si = data[t, 0]
        dtc = max(abs(data[t, 2]), 1e-8)
        si_dtc_ratio = si / dtc
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_si = data[t-i, 0]
                    hist_dtc = max(abs(data[t-i, 2]), 1e-8)
                    hist_ratios.append(hist_si / hist_dtc)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_dtc_signal = si_dtc_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_dtc_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_dtc_signal = si_dtc_ratio * 0.01  # Scale to reasonable range
        
        # Apply non-linear transformation
        si_dtc_signal = np.sign(si_dtc_signal) * np.sqrt(abs(si_dtc_signal))
        eng.append(si_dtc_signal)
        
        # 12. Volume-Weighted Average Price (VWAP) Deviation
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate VWAP over the last 5 days
            vwap_sum = 0
            volume_sum = 0
            
            for i in range(1, min(6, len(close_prices) + 1)):
                vwap_sum += close_prices[-i] * total_volume[-i]
                volume_sum += total_volume[-i]
            
            if volume_sum > 1e-8:
                vwap = vwap_sum / max(volume_sum, 1e-8)
                
                # Calculate deviation from VWAP
                vwap_deviation = close_prices[-1] / max(vwap, 1e-8) - 1.0
                
                # Apply non-linear transformation to emphasize significant deviations
                vwap_signal = np.sign(vwap_deviation) * np.sqrt(abs(vwap_deviation))
            else:
                vwap_signal = 0.0
        else:
            vwap_signal = 0.0
        eng.append(vwap_signal)
        
        # 13. Short Interest Efficiency Ratio
        # Measures how effectively short interest predicts price movements
        if t >= 5 and len(close_prices) >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate weighted correlation-like measure with stronger recency bias
                weights = np.exp(np.linspace(0, 2, len(si_changes)))  # Stronger exponential weights
                weights = weights / np.sum(weights)
                
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
                
                # Apply non-linear transformation to emphasize strong relationships
                si_efficiency_signal = np.sign(si_efficiency) * np.power(abs(si_efficiency), 0.7)
            else:
                si_efficiency_signal = 0.0
        else:
            si_efficiency_signal = 0.0
        eng.append(si_efficiency_signal)
        
        # 14. Short Interest Concentration Index
        # Measures how concentrated short interest is relative to trading volume
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            # Calculate daily short interest concentration
            daily_concentration = []
            for i in range(min(10, len(short_volume))):
                concentration = short_volume[-i-1] / max(total_volume[-i-1], 1e-8)
                daily_concentration.append(concentration)
            
            # Calculate concentration variability
            if len(daily_concentration) >= 3:
                concentration_std = np.std(daily_concentration)
                concentration_mean = np.mean(daily_concentration)
                
                # Normalize
                concentration_cv = concentration_std / max(concentration_mean, 1e-8)
                
                # Recent trend in concentration
                recent_conc = np.mean(daily_concentration[:3])
                older_conc = np.mean(daily_concentration[3:]) if len(daily_concentration) > 3 else recent_conc
                conc_trend = recent_conc / max(older_conc, 1e-8) - 1.0
                
                # Combine variability and trend
                # High variability + increasing concentration = stronger signal
                if conc_trend > 0:
                    concentration_signal = concentration_cv * (1 + conc_trend)
                else:
                    concentration_signal = concentration_cv * (1 + 0.5 * conc_trend)
                
                # Bound the signal
                concentration_signal = np.tanh(concentration_signal * 3)
            else:
                concentration_signal = 0.0
        else:
            concentration_signal = 0.0
        eng.append(concentration_signal)
        
        # 15. Bollinger Band Position with Volume and Volatility Context
        if len(close_prices) >= 20:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                bb_period = 10
            elif rel_volatility > 0.01:  # Medium volatility
                bb_period = 15
            else:  # Low volatility - longer period
                bb_period = 20
                
            bb_period = min(bb_period, len(close_prices))
            
            ma = np.mean(close_prices[-bb_period:])
            std = np.std(close_prices[-bb_period:])
            
            upper_band = ma + (2 * std)
            lower_band = ma - (2 * std)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Volume confirmation - check if volume supports the position
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify signal when volume confirms extreme positions
                    if (bb_position > 0.5 and vol_ratio > 1.2) or (bb_position < -0.5 and vol_ratio > 1.2):
                        bb_position *= vol_ratio
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 16. Enhanced MACD Signal with Volume and Volatility Context
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26 (approximated with weighted averages)
            weights_12 = np.exp(np.linspace(0, 3, min(12, len(close_prices))))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-min(12, len(close_prices)):] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 3, min(26, len(close_prices))))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-min(26, len(close_prices)):] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-min(26, len(close_prices)):])
            norm_macd = macd_line / max(abs(avg_price), 1e-8)
            
            # Add volatility context
            if len(close_prices) >= 10:
                price_std = np.std(close_prices[-10:])
                price_mean = np.mean(close_prices[-10:])
                rel_volatility = price_std / max(price_mean, 1e-8)
                
                # Adjust MACD by volatility - less weight in high volatility
                if rel_volatility > 0.03:  # High volatility
                    norm_macd *= 0.7  # Reduce signal in high volatility
                
            # Volume validation
            if len(total_volume) >= 5:
                recent_vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
                
                # Amplify MACD when volume confirms direction
                if (norm_macd > 0 and recent_vol_ratio > 1.2) or (norm_macd < 0 and recent_vol_ratio > 1.2):
                    norm_macd *= np.sqrt(recent_vol_ratio)
            
            # Bound the signal
            macd_signal = np.tanh(norm_macd * 10)
        else:
            macd_signal = 0.0
        eng.append(macd_signal)
        
        # 17. Adaptive Price Channel Breakout
        if len(close_prices) >= 10:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                channel_period = 5
            elif rel_volatility > 0.01:  # Medium volatility
                channel_period = 10
            else:  # Low volatility - longer period
                channel_period = 15
                
            channel_period = min(channel_period, len(close_prices))
            
            # Calculate upper and lower channels
            upper_channel = np.max(close_prices[-channel_period:-1])
            lower_channel = np.min(close_prices[-channel_period:-1])
            
            # Calculate breakout signal
            channel_width = upper_channel - lower_channel
            if channel_width > 1e-8:
                # Normalize to [-1, 1] range where:
                # +1 = strong upside breakout
                # -1 = strong downside breakout
                # 0 = in the middle of the channel
                breakout_signal = 2 * ((close_prices[-1] - lower_channel) / channel_width) - 1
                
                # Add volume confirmation
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify breakouts with high volume
                    if abs(breakout_signal) > 0.7 and vol_ratio > 1.2:
                        breakout_signal *= np.sqrt(vol_ratio)
                
                # Bound the signal
                breakout_signal = max(-1.0, min(1.0, breakout_signal))
            else:
                breakout_signal = 0.0
        else:
            breakout_signal = 0.0
        eng.append(breakout_signal)
        
        # 18. Volatility-Adjusted Price Momentum with Mean Reversion
        if len(close_prices) >= 10:
            # Calculate recent price momentum
            recent_momentum = close_prices[-1] / max(close_prices[-5], 1e-8) - 1.0
            
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust momentum by volatility
            vol_adj_momentum = recent_momentum / max(rel_volatility, 0.01)
            
            # Add mean reversion component
            price_deviation = close_prices[-1] / max(price_mean, 1e-8) - 1.0
            mean_rev_signal = -price_deviation * abs(price_deviation)
            
            # Combine signals based on volatility regime and momentum strength
            if rel_volatility > 0.03:  # High volatility
                if abs(recent_momentum) > 0.03:  # Strong momentum
                    combined_signal = 0.6 * vol_adj_momentum + 0.4 * mean_rev_signal
                else:  # Weak momentum - favor mean reversion
                    combined_signal = 0.3 * vol_adj_momentum + 0.7 * mean_rev_signal
            else:  # Low volatility
                if abs(recent_momentum) > 0.02:  # Strong momentum
                    combined_signal = 0.8 * vol_adj_momentum + 0.2 * mean_rev_signal
                else:  # Weak momentum
                    combined_signal = 0.5 * vol_adj_momentum + 0.5 * mean_rev_signal
            
            # Bound the signal
            vol_adj_signal = np.tanh(combined_signal * 2)
        else:
            vol_adj_signal = 0.0
        eng.append(vol_adj_signal)
        
        # 19. Improved Short Interest Prediction Signal
        # This feature combines multiple signals that have shown high importance in previous iterations
        if t >= 2 and len(close_prices) >= 10:
            # 1. Short interest momentum
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            si_mom = si_t / max(abs(si_t1), 1e-8) - 1.0
            si_mom_prev = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # 2. Price momentum
            price_mom = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # 3. Options sentiment
            put_call_ratio = data[t, 63]
            if t > 0:
                prev_pc_ratio = data[t-1, 63]
                pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            else:
                pc_ratio_change = 0.0
            
            # 4. Short volume trend
            if len(short_volume) >= 5:
                recent_short_vol = np.mean(short_volume[-3:])
                older_short_vol = np.mean(short_volume[-5:])
                sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            else:
                sv_trend = 0.0
            
            # Combine signals with weights based on previous importance
            combined_signal = (
                0.35 * si_mom +                # Short interest momentum (highest importance)
                0.25 * -price_mom +            # Inverse price momentum (negative correlation)
                0.20 * pc_ratio_change +       # Options sentiment change
                0.20 * sv_trend                # Short volume trend
            )
            
            # Apply non-linear transformation to emphasize strong signals
            prediction_signal = np.sign(combined_signal) * np.sqrt(abs(combined_signal))
            
            # Bound the signal
            prediction_signal = np.tanh(prediction_signal * 2)
        else:
            prediction_signal = 0.0
        eng.append(prediction_signal)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 8 (claude) (SVM)
==================================================
Training SVM model...

Iteration 8 (claude) Performance:
MAE: 193590.6900
RMSE: 242123.2763
MAPE: 14.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0007, rank=1
   2. Feature_22_t0: importance=0.0004, rank=2
   3. Feature_12_t3: importance=0.0003, rank=3
   4. Feature_16_t1: importance=0.0003, rank=4
   5. Feature_15_t2: importance=0.0003, rank=5
💾 Saved code for iteration 8 to iteration_codes dictionary
📊 No significant improvement. Change: -0.64%

📈 Current best MAPE: 13.58%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 9
======================================================================
🤖 Calling Claude for iteration 9...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Improved Short Interest to Float Ratio with Trend
        # This feature normalizes short interest by shares outstanding and adds trend context
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Add trend context if available
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            
            # Amplify signal when trend is strong but with more balanced weighting
            short_interest_to_float_signal = short_interest_to_float * (1 + 0.5 * np.sign(si_float_trend) * min(abs(si_float_trend), 0.5))
        else:
            short_interest_to_float_signal = short_interest_to_float
        eng.append(short_interest_to_float_signal)
        
        # 2. Enhanced Short Volume Ratio with Exponential Weighting
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponential weighting to emphasize recent days
        weights = np.exp(np.linspace(0, 2, 15))  # Moderate recency bias
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        
        # Add volatility context to the signal
        if len(close_prices) >= 10:
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Amplify signal in high volatility regimes
            if rel_volatility > 0.02:  # High volatility
                weighted_svr *= (1 + 0.3 * rel_volatility)
        eng.append(weighted_svr)
        
        # 3. Short Interest Momentum with Acceleration
        # Captures both the rate of change and acceleration in short interest
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First difference (momentum)
            si_mom = si_t / max(abs(si_t1), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_mom_prev = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            si_accel = si_mom - si_mom_prev
            
            # Combine momentum and acceleration with adaptive weighting
            # When acceleration confirms momentum, amplify the signal
            if np.sign(si_mom) == np.sign(si_accel):
                si_signal = 0.7 * si_mom + 0.3 * si_accel
            else:
                si_signal = 0.8 * si_mom + 0.2 * si_accel  # More weight to momentum when conflicting
            
            # Apply non-linear transformation to emphasize strong signals
            si_signal = np.sign(si_signal) * np.sqrt(abs(si_signal))
        else:
            si_signal = 0.0
        eng.append(si_signal)
        
        # 4. Options Market Sentiment Indicator
        # Combines put/call ratio with implied volatility for a more complete options market view
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            if iv_change > 0 and norm_pc_ratio > 0:
                options_sentiment = 0.7 * norm_pc_ratio + 0.3 * iv_change  # Strong bearish
            elif iv_change > 0 and norm_pc_ratio < 0:
                options_sentiment = 0.6 * norm_pc_ratio + 0.2 * iv_change  # Mixed signal
            elif iv_change < 0 and norm_pc_ratio > 0:
                options_sentiment = 0.5 * norm_pc_ratio + 0.3 * iv_change  # Mixed signal
            else:
                options_sentiment = 0.7 * norm_pc_ratio + 0.2 * iv_change  # Bullish
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal
        options_sentiment = np.tanh(options_sentiment * 1.5)  # Less aggressive bounding
        eng.append(options_sentiment)
        
        # 5. Enhanced Short Squeeze Potential Indicator
        # Combines short interest, price momentum, volume, and options data
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Options data - put/call ratio change
            put_call_ratio = data[t, 63]
            if t > 0:
                prev_pc_ratio = data[t-1, 63]
                pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            else:
                pc_ratio_change = 0.0
            
            # Short squeeze conditions:
            # 1. High short interest
            # 2. Positive price momentum
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            # 5. Decreasing put/call ratio (bullish options sentiment)
            
            squeeze_score = 0.0
            
            # High short interest base score
            if si_level > 0.1:  # More than 10% of float
                squeeze_score += 0.35 * min(si_level / 0.2, 1.0)  # Cap at 20% of float
            
            # Add momentum component (only positive momentum contributes)
            if price_momentum > 0:
                squeeze_score += 0.25 * min(price_momentum / 0.05, 1.0)  # Cap at 5% price increase
            
            # Add volume component
            if vol_surge > 0:
                squeeze_score += 0.15 * min(vol_surge / 0.5, 1.0)  # Cap at 50% volume increase
            
            # Add short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.15 * min(abs(si_change) / 0.05, 1.0)  # Cap at 5% SI reduction
            
            # Add options sentiment component
            if pc_ratio_change < 0:  # Decreasing put/call ratio (bullish)
                squeeze_score += 0.1 * min(abs(pc_ratio_change) / 0.1, 1.0)  # Cap at 10% reduction
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 6. Volatility-Adjusted Price Momentum
        # Normalizes price momentum by volatility for more consistent signals across volatility regimes
        if len(close_prices) >= 10:
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Short-term momentum (3-day)
            if len(close_prices) >= 3:
                mom_3d = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                mom_3d = 0.0
            
            # Medium-term momentum (5-day)
            if len(close_prices) >= 5:
                mom_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            else:
                mom_5d = 0.0
            
            # Longer-term momentum (10-day)
            if len(close_prices) >= 10:
                mom_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            else:
                mom_10d = 0.0
            
            # Adjust weights based on volatility regime
            if rel_volatility > 0.03:  # High volatility - favor short-term
                weights = [0.6, 0.3, 0.1]
            elif rel_volatility > 0.01:  # Medium volatility
                weights = [0.4, 0.4, 0.2]
            else:  # Low volatility - favor longer-term
                weights = [0.2, 0.4, 0.4]
                
            # Combine signals with adaptive weights
            composite_momentum = mom_3d * weights[0] + mom_5d * weights[1] + mom_10d * weights[2]
            
            # Normalize by volatility
            vol_adj_momentum = composite_momentum / max(rel_volatility, 0.01)
            
            # Apply non-linear transformation to amplify strong signals
            vol_adj_momentum = np.sign(vol_adj_momentum) * np.sqrt(abs(vol_adj_momentum))
        else:
            vol_adj_momentum = 0.0
        eng.append(vol_adj_momentum)
        
        # 7. Enhanced RSI with Volume Weighting
        # RSI modified to incorporate trading volume for stronger signals
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            
            # Normalize RSI to [-1, 1] range for better gradient properties
            norm_rsi = (rsi / 50.0) - 1.0
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 8. Short Interest to Days-to-Cover Ratio
        # Combines short interest with days to cover for a more complete picture
        si = data[t, 0]
        dtc = max(abs(data[t, 2]), 1e-8)
        si_dtc_ratio = si / dtc
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_si = data[t-i, 0]
                    hist_dtc = max(abs(data[t-i, 2]), 1e-8)
                    hist_ratios.append(hist_si / hist_dtc)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_dtc_signal = si_dtc_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_dtc_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_dtc_signal = si_dtc_ratio * 0.01  # Scale to reasonable range
        
        # Apply non-linear transformation
        si_dtc_signal = np.sign(si_dtc_signal) * np.sqrt(abs(si_dtc_signal))
        eng.append(si_dtc_signal)
        
        # 9. Short Volume Trend with Price Confirmation
        # Analyzes short volume trend in context of price movement
        if len(short_volume) >= 10 and len(close_prices) >= 10:
            # Calculate short volume trend
            recent_short_vol = np.mean(short_volume[-3:])
            older_short_vol = np.mean(short_volume[-10:-3])
            sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Calculate price trend
            recent_price = np.mean(close_prices[-3:])
            older_price = np.mean(close_prices[-10:-3])
            price_trend = recent_price / max(older_price, 1e-8) - 1.0
            
            # Combine signals based on confirmation/contradiction
            # When short volume increases and price decreases = bearish confirmation
            # When short volume increases and price increases = potential short squeeze
            if sv_trend > 0 and price_trend < 0:
                sv_price_signal = 0.7 * sv_trend - 0.3 * price_trend  # Bearish confirmation
            elif sv_trend > 0 and price_trend > 0:
                sv_price_signal = 0.5 * sv_trend + 0.5 * price_trend  # Potential squeeze
            elif sv_trend < 0 and price_trend > 0:
                sv_price_signal = -0.6 * sv_trend + 0.4 * price_trend  # Bullish confirmation
            else:
                sv_price_signal = -0.5 * sv_trend - 0.5 * price_trend  # Potential reversal
            
            # Bound the signal
            sv_price_signal = np.tanh(sv_price_signal * 1.5)  # Less aggressive bounding
        else:
            sv_price_signal = 0.0
        eng.append(sv_price_signal)
        
        # 10. Short Interest Efficiency Ratio
        # Measures how effectively short interest predicts price movements
        if t >= 5 and len(close_prices) >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate weighted correlation-like measure with recency bias
                weights = np.exp(np.linspace(0, 1.5, len(si_changes)))  # Moderate exponential weights
                weights = weights / np.sum(weights)
                
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
                
                # Apply non-linear transformation to emphasize strong relationships
                si_efficiency_signal = np.sign(si_efficiency) * np.power(abs(si_efficiency), 0.7)
            else:
                si_efficiency_signal = 0.0
        else:
            si_efficiency_signal = 0.0
        eng.append(si_efficiency_signal)
        
        # 11. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations of volatility
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_iv = max(abs(data[t-i, 65]), 1e-8)
                    hist_ratios.append(data[t-i, 0] / hist_iv)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
                
                # Apply non-linear transformation to emphasize extremes
                si_iv_signal = np.sign(si_iv_signal) * np.power(abs(si_iv_signal), 0.7)
            else:
                si_iv_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        eng.append(si_iv_signal)
        
        # 12. Bollinger Band Position with Volume Context
        # Measures price position within volatility bands with volume confirmation
        if len(close_prices) >= 20:
            # Calculate standard Bollinger Bands (20-period, 2 standard deviations)
            ma = np.mean(close_prices[-20:])
            std = np.std(close_prices[-20:])
            
            upper_band = ma + (2 * std)
            lower_band = ma - (2 * std)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Volume confirmation - check if volume supports the position
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify signal when volume confirms extreme positions
                    if (bb_position > 0.5 and vol_ratio > 1.2) or (bb_position < -0.5 and vol_ratio > 1.2):
                        bb_position *= min(vol_ratio, 1.5)  # Cap amplification
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 13. Short Interest Concentration Index
        # Measures how concentrated short interest is relative to trading volume
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            # Calculate daily short interest concentration
            daily_concentration = []
            for i in range(min(10, len(short_volume))):
                concentration = short_volume[-i-1] / max(total_volume[-i-1], 1e-8)
                daily_concentration.append(concentration)
            
            # Calculate concentration variability
            if len(daily_concentration) >= 3:
                concentration_std = np.std(daily_concentration)
                concentration_mean = np.mean(daily_concentration)
                
                # Normalize
                concentration_cv = concentration_std / max(concentration_mean, 1e-8)
                
                # Recent trend in concentration
                recent_conc = np.mean(daily_concentration[:3])
                older_conc = np.mean(daily_concentration[3:]) if len(daily_concentration) > 3 else recent_conc
                conc_trend = recent_conc / max(older_conc, 1e-8) - 1.0
                
                # Combine variability and trend
                # High variability + increasing concentration = stronger signal
                if conc_trend > 0:
                    concentration_signal = concentration_cv * (1 + 0.7 * conc_trend)
                else:
                    concentration_signal = concentration_cv * (1 + 0.3 * conc_trend)
                
                # Bound the signal
                concentration_signal = np.tanh(concentration_signal * 2.5)
            else:
                concentration_signal = 0.0
        else:
            concentration_signal = 0.0
        eng.append(concentration_signal)
        
        # 14. Adaptive Price Channel Breakout
        # Identifies price breakouts with volatility-adjusted lookback periods
        if len(close_prices) >= 10:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                channel_period = 5
            elif rel_volatility > 0.01:  # Medium volatility
                channel_period = 10
            else:  # Low volatility - longer period
                channel_period = 15
                
            channel_period = min(channel_period, len(close_prices))
            
            # Calculate upper and lower channels
            upper_channel = np.max(close_prices[-channel_period:-1])
            lower_channel = np.min(close_prices[-channel_period:-1])
            
            # Calculate breakout signal
            channel_width = upper_channel - lower_channel
            if channel_width > 1e-8:
                # Normalize to [-1, 1] range where:
                # +1 = strong upside breakout
                # -1 = strong downside breakout
                # 0 = in the middle of the channel
                breakout_signal = 2 * ((close_prices[-1] - lower_channel) / channel_width) - 1
                
                # Add volume confirmation
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify breakouts with high volume
                    if abs(breakout_signal) > 0.7 and vol_ratio > 1.2:
                        breakout_signal *= min(np.sqrt(vol_ratio), 1.3)  # Cap amplification
                
                # Bound the signal
                breakout_signal = max(-1.0, min(1.0, breakout_signal))
            else:
                breakout_signal = 0.0
        else:
            breakout_signal = 0.0
        eng.append(breakout_signal)
        
        # 15. Synthetic Short Cost Change
        # Tracks changes in the cost of creating synthetic short positions
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64]
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            
            # Add context from options data
            put_call_ratio = data[t, 63]
            prev_pc_ratio = data[t-1, 63] if t-1 >= 0 else put_call_ratio
            pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            # When synthetic short cost increases with put/call ratio = stronger signal
            if np.sign(synth_cost_change) == np.sign(pc_ratio_change):
                cost_signal = 0.7 * synth_cost_change + 0.3 * pc_ratio_change  # Amplify
            else:
                cost_signal = 0.6 * synth_cost_change + 0.2 * pc_ratio_change  # More weight to cost
            
            # Apply non-linear transformation
            cost_signal = np.sign(cost_signal) * np.sqrt(abs(cost_signal))
        else:
            cost_signal = 0.0
        eng.append(cost_signal)
        
        # 16. Volume-Weighted Average Price (VWAP) Deviation
        # Measures price deviation from volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate VWAP over the last 5 days
            vwap_sum = 0
            volume_sum = 0
            
            for i in range(1, min(6, len(close_prices) + 1)):
                vwap_sum += close_prices[-i] * total_volume[-i]
                volume_sum += total_volume[-i]
            
            if volume_sum > 1e-8:
                vwap = vwap_sum / max(volume_sum, 1e-8)
                
                # Calculate deviation from VWAP
                vwap_deviation = close_prices[-1] / max(vwap, 1e-8) - 1.0
                
                # Apply non-linear transformation to emphasize significant deviations
                vwap_signal = np.sign(vwap_deviation) * np.sqrt(abs(vwap_deviation))
            else:
                vwap_signal = 0.0
        else:
            vwap_signal = 0.0
        eng.append(vwap_signal)
        
        # 17. Enhanced MACD Signal with Volume Context
        # MACD modified to incorporate trading volume for stronger signals
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26 (approximated with weighted averages)
            weights_12 = np.exp(np.linspace(0, 2.5, min(12, len(close_prices))))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-min(12, len(close_prices)):] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 2.5, min(26, len(close_prices))))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-min(26, len(close_prices)):] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-min(26, len(close_prices)):])
            norm_macd = macd_line / max(abs(avg_price), 1e-8)
            
            # Volume validation
            if len(total_volume) >= 5:
                recent_vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
                
                # Amplify MACD when volume confirms direction
                if (norm_macd > 0 and recent_vol_ratio > 1.2) or (norm_macd < 0 and recent_vol_ratio > 1.2):
                    norm_macd *= min(np.sqrt(recent_vol_ratio), 1.3)  # Cap amplification
            
            # Bound the signal
            macd_signal = np.tanh(norm_macd * 8)  # Less aggressive bounding
        else:
            macd_signal = 0.0
        eng.append(macd_signal)
        
        # 18. Improved Short Interest Prediction Signal
        # Combines multiple signals that have shown high importance in previous iterations
        if t >= 2 and len(close_prices) >= 10:
            # 1. Short interest momentum
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            si_mom = si_t / max(abs(si_t1), 1e-8) - 1.0
            si_mom_prev = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # 2. Price momentum
            price_mom = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # 3. Options sentiment
            put_call_ratio = data[t, 63]
            if t > 0:
                prev_pc_ratio = data[t-1, 63]
                pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            else:
                pc_ratio_change = 0.0
            
            # 4. Short volume trend
            if len(short_volume) >= 5:
                recent_short_vol = np.mean(short_volume[-3:])
                older_short_vol = np.mean(short_volume[-5:])
                sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            else:
                sv_trend = 0.0
            
            # Combine signals with weights based on previous importance
            combined_signal = (
                0.35 * si_mom +                # Short interest momentum (highest importance)
                0.25 * -price_mom +            # Inverse price momentum (negative correlation)
                0.20 * pc_ratio_change +       # Options sentiment change
                0.20 * sv_trend                # Short volume trend
            )
            
            # Apply non-linear transformation to emphasize strong signals
            prediction_signal = np.sign(combined_signal) * np.sqrt(abs(combined_signal))
            
            # Bound the signal
            prediction_signal = np.tanh(prediction_signal * 1.5)  # Less aggressive bounding
        else:
            prediction_signal = 0.0
        eng.append(prediction_signal)
        
        # 19. Price Volatility Regime Indicator
        # Identifies current volatility regime relative to historical context
        if len(close_prices) >= 15:
            # Calculate recent volatility (5-day)
            recent_std = np.std(close_prices[-5:])
            recent_mean = np.mean(close_prices[-5:])
            recent_vol = recent_std / max(recent_mean, 1e-8)
            
            # Calculate longer-term volatility (15-day)
            longer_std = np.std(close_prices[-15:])
            longer_mean = np.mean(close_prices[-15:])
            longer_vol = longer_std / max(longer_mean, 1e-8)
            
            # Volatility regime change
            vol_regime = recent_vol / max(longer_vol, 1e-8) - 1.0
            
            # Apply non-linear transformation to emphasize significant changes
            vol_regime_signal = np.sign(vol_regime) * np.sqrt(abs(vol_regime))
        else:
            vol_regime_signal = 0.0
        eng.append(vol_regime_signal)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 9 (claude) (SVM)
==================================================
Training SVM model...

Iteration 9 (claude) Performance:
MAE: 200853.6539
RMSE: 246567.2471
MAPE: 14.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0007, rank=1
   2. Feature_8_t3: importance=0.0005, rank=2
   3. Feature_18_t2: importance=0.0005, rank=3
   4. Feature_24_t1: importance=0.0004, rank=4
   5. Feature_14_t3: importance=0.0004, rank=5
💾 Saved code for iteration 9 to iteration_codes dictionary
📊 No significant improvement. Change: -1.16%

📈 Current best MAPE: 13.58%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 10
======================================================================
🤖 Calling Claude for iteration 10...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest to Float Ratio with Adaptive Trend Weighting
        # Normalizes short interest by shares outstanding with dynamic trend weighting
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Add trend context with adaptive weighting based on trend strength
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            
            # Adaptive weighting: stronger trends get more weight
            trend_weight = min(0.7, 0.3 + 0.4 * abs(si_float_trend))
            short_interest_to_float_signal = (1 - trend_weight) * short_interest_to_float + trend_weight * (short_interest_to_float * (1 + np.sign(si_float_trend) * min(abs(si_float_trend), 0.5)))
        else:
            short_interest_to_float_signal = short_interest_to_float
        eng.append(short_interest_to_float_signal)
        
        # 2. Short Volume Ratio with Exponential Decay and Volume Surge Detection
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponential weighting with stronger recency bias
        weights = np.exp(np.linspace(0, 2.5, 15))  # Increased recency bias
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        
        # Detect volume surges in the most recent days (stronger signal)
        if len(total_volume) >= 5:
            recent_vol = np.mean(total_volume[-3:])
            older_vol = np.mean(total_volume[-15:])
            vol_surge = recent_vol / max(older_vol, 1e-8) - 1.0
            
            # Amplify signal when volume is surging
            if vol_surge > 0.2:  # Significant volume increase
                weighted_svr *= (1 + 0.4 * min(vol_surge, 1.0))
        eng.append(weighted_svr)
        
        # 3. Short Interest Momentum with Acceleration and Volatility Context
        # Captures rate of change, acceleration, and volatility context in short interest
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First difference (momentum)
            si_mom = si_t / max(abs(si_t1), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_mom_prev = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            si_accel = si_mom - si_mom_prev
            
            # Add volatility context if available
            if len(close_prices) >= 10:
                price_std = np.std(close_prices[-10:])
                price_mean = np.mean(close_prices[-10:])
                rel_volatility = price_std / max(price_mean, 1e-8)
                
                # Adjust weights based on volatility regime
                if rel_volatility > 0.03:  # High volatility - favor acceleration
                    mom_weight, accel_weight = 0.6, 0.4
                elif rel_volatility > 0.01:  # Medium volatility
                    mom_weight, accel_weight = 0.7, 0.3
                else:  # Low volatility - favor momentum
                    mom_weight, accel_weight = 0.8, 0.2
                    
                si_signal = mom_weight * si_mom + accel_weight * si_accel
            else:
                # Default weights without volatility context
                si_signal = 0.7 * si_mom + 0.3 * si_accel
            
            # Apply non-linear transformation to emphasize strong signals
            si_signal = np.sign(si_signal) * np.sqrt(abs(si_signal))
        else:
            si_signal = 0.0
        eng.append(si_signal)
        
        # 4. Options Market Sentiment with Implied Volatility Trend
        # Combines put/call ratio with implied volatility trend for a more complete options market view
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility trend context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Calculate longer-term IV trend if available
            if t >= 5:
                iv_5ago = data[t-5, 65]
                iv_trend_5d = implied_vol / max(abs(iv_5ago), 1e-8) - 1.0
                
                # Combine short and longer-term IV trends
                iv_trend = 0.7 * iv_change + 0.3 * iv_trend_5d
            else:
                iv_trend = iv_change
            
            # Combine signals with adaptive weighting based on trend alignment
            if np.sign(norm_pc_ratio) == np.sign(iv_trend):
                # Aligned signals - stronger indication
                options_sentiment = 0.6 * norm_pc_ratio + 0.4 * iv_trend
            else:
                # Conflicting signals - more weight to put/call ratio
                options_sentiment = 0.8 * norm_pc_ratio + 0.2 * iv_trend
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal with less aggressive bounding
        options_sentiment = np.tanh(options_sentiment * 1.2)
        eng.append(options_sentiment)
        
        # 5. Enhanced Short Squeeze Potential with Price Momentum Confirmation
        # Combines short interest, price momentum, volume, and options data with price confirmation
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum with multiple timeframes
            price_mom_1d = close_prices[-1] / max(abs(close_prices[-2]), 1e-8) - 1.0 if len(close_prices) >= 2 else 0.0
            price_mom_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Combine price momentum with adaptive weighting
            # Recent momentum gets more weight in high SI situations
            if si_level > 0.15:  # Very high short interest
                price_mom = 0.7 * price_mom_1d + 0.3 * price_mom_5d
            else:
                price_mom = 0.4 * price_mom_1d + 0.6 * price_mom_5d
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Options data - put/call ratio change
            put_call_ratio = data[t, 63]
            prev_pc_ratio = data[t-1, 63]
            pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            
            # Short squeeze conditions with adaptive scoring:
            # 1. High short interest
            # 2. Positive price momentum (especially recent)
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            # 5. Decreasing put/call ratio (bullish options sentiment)
            
            squeeze_score = 0.0
            
            # High short interest base score with progressive scaling
            if si_level > 0.05:  # More than 5% of float
                squeeze_score += 0.3 * min(si_level / 0.2, 1.0) * (1 + 0.5 * (si_level > 0.15))  # Extra boost for very high SI
            
            # Price momentum component with confirmation bonus
            if price_mom > 0:
                momentum_score = 0.25 * min(price_mom / 0.05, 1.0)
                # Add confirmation bonus when recent momentum is stronger
                if price_mom_1d > price_mom_5d and price_mom_1d > 0:
                    momentum_score *= 1.3
                squeeze_score += momentum_score
            
            # Volume component with threshold effect
            if vol_surge > 0.2:  # Significant volume increase
                squeeze_score += 0.2 * min(vol_surge / 0.5, 1.0)
            
            # Short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.15 * min(abs(si_change) / 0.05, 1.0)
            
            # Options sentiment component
            if pc_ratio_change < 0:  # Decreasing put/call ratio (bullish)
                squeeze_score += 0.1 * min(abs(pc_ratio_change) / 0.1, 1.0)
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 6. Volatility-Adjusted Price Momentum with Regime Detection
        # Normalizes price momentum by volatility with adaptive timeframes based on volatility regime
        if len(close_prices) >= 10:
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Detect volatility regime
            if t >= 10:
                # Compare current volatility to historical
                hist_vol = []
                for i in range(1, min(6, t+1)):
                    if t-i >= 0:
                        hist_prices = data[t-i, 3:63].reshape(15, 4)[:, 3]  # Close prices
                        if len(hist_prices) >= 10:
                            hist_std = np.std(hist_prices[-10:])
                            hist_mean = np.mean(hist_prices[-10:])
                            hist_vol.append(hist_std / max(hist_mean, 1e-8))
                
                if hist_vol:
                    avg_hist_vol = np.mean(hist_vol)
                    vol_regime = rel_volatility / max(avg_hist_vol, 1e-8)
                else:
                    vol_regime = 1.0
            else:
                vol_regime = 1.0
            
            # Adjust momentum timeframes based on volatility regime
            if vol_regime > 1.5:  # Much higher volatility than normal
                # Use shorter timeframes in high volatility
                if len(close_prices) >= 3:
                    mom = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1.0
                else:
                    mom = 0.0
            elif vol_regime > 1.2:  # Moderately higher volatility
                if len(close_prices) >= 5:
                    mom = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
                else:
                    mom = 0.0
            else:  # Normal or low volatility
                if len(close_prices) >= 10:
                    mom = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1.0
                else:
                    mom = 0.0
            
            # Normalize by volatility with adaptive scaling
            vol_adj_momentum = mom / max(rel_volatility, 0.01)
            
            # Apply non-linear transformation with adaptive scaling based on regime
            if vol_regime > 1.5:
                # More aggressive scaling in high volatility regimes
                vol_adj_momentum = np.sign(vol_adj_momentum) * np.power(abs(vol_adj_momentum), 0.6)
            else:
                vol_adj_momentum = np.sign(vol_adj_momentum) * np.sqrt(abs(vol_adj_momentum))
        else:
            vol_adj_momentum = 0.0
        eng.append(vol_adj_momentum)
        
        # 7. Enhanced RSI with Volume and Volatility Weighting
        # RSI modified to incorporate both trading volume and volatility for stronger signals
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume if available
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                # Add volatility context if available
                if len(close_prices) >= 20:
                    # Calculate rolling volatility
                    rolling_std = []
                    for i in range(len(delta)):
                        if i >= 5:
                            window_std = np.std(close_prices[i-5:i+1])
                            window_mean = np.mean(close_prices[i-5:i+1])
                            rolling_std.append(window_std / max(window_mean, 1e-8))
                        else:
                            rolling_std.append(0.01)  # Default for early points
                    
                    # Normalize volatility weights
                    vol_std_weights = np.array(rolling_std) / max(np.mean(rolling_std), 1e-8)
                    
                    # Apply volatility weighting - higher weight to high volatility periods
                    vol_weighted_gain = vol_weighted_gain * vol_std_weights
                    vol_weighted_loss = vol_weighted_loss * vol_std_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            
            # Normalize RSI to [-1, 1] range with adaptive scaling
            # More extreme scaling for values near boundaries
            if rsi > 70:
                norm_rsi = 0.5 + 0.5 * ((rsi - 70) / 30)
            elif rsi < 30:
                norm_rsi = -0.5 - 0.5 * ((30 - rsi) / 30)
            else:
                norm_rsi = (rsi - 50) / 40  # Linear scaling in the middle range
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 8. Short Interest to Days-to-Cover Ratio with Historical Context
        # Combines short interest with days to cover with improved historical normalization
        si = data[t, 0]
        dtc = max(abs(data[t, 2]), 1e-8)
        si_dtc_ratio = si / dtc
        
        # Normalize by historical context with exponential weighting if available
        if t >= 5:
            hist_ratios = []
            weights = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_si = data[t-i, 0]
                    hist_dtc = max(abs(data[t-i, 2]), 1e-8)
                    hist_ratios.append(hist_si / hist_dtc)
                    weights.append(np.exp(-0.5 * i))  # Exponential decay weights
            
            if hist_ratios:
                weights = np.array(weights) / max(np.sum(weights), 1e-8)
                weighted_avg_ratio = np.sum(np.array(hist_ratios) * weights)
                si_dtc_signal = si_dtc_ratio / max(weighted_avg_ratio, 1e-8) - 1.0
                
                # Apply non-linear transformation with adaptive scaling
                if abs(si_dtc_signal) > 0.5:
                    # More aggressive scaling for large deviations
                    si_dtc_signal = np.sign(si_dtc_signal) * np.power(abs(si_dtc_signal), 0.7)
                else:
                    si_dtc_signal = np.sign(si_dtc_signal) * np.sqrt(abs(si_dtc_signal))
            else:
                si_dtc_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_dtc_signal = si_dtc_ratio * 0.01  # Scale to reasonable range
        eng.append(si_dtc_signal)
        
        # 9. Short Volume Trend with Price Confirmation and Momentum
        # Analyzes short volume trend in context of price movement with momentum confirmation
        if len(short_volume) >= 10 and len(close_prices) >= 10:
            # Calculate short volume trend with multiple timeframes
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-7:-3]) if len(short_volume) >= 7 else recent_short_vol
            older_short_vol = np.mean(short_volume[-10:]) if len(short_volume) >= 10 else mid_short_vol
            
            # Calculate short-term and medium-term trends
            sv_trend_st = recent_short_vol / max(mid_short_vol, 1e-8) - 1.0
            sv_trend_mt = mid_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Calculate price trends with matching timeframes
            recent_price = np.mean(close_prices[-3:])
            mid_price = np.mean(close_prices[-7:-3]) if len(close_prices) >= 7 else recent_price
            older_price = np.mean(close_prices[-10:]) if len(close_prices) >= 10 else mid_price
            
            price_trend_st = recent_price / max(mid_price, 1e-8) - 1.0
            price_trend_mt = mid_price / max(older_price, 1e-8) - 1.0
            
            # Calculate momentum confirmation
            sv_momentum = sv_trend_st - sv_trend_mt  # Acceleration in short volume
            price_momentum = price_trend_st - price_trend_mt  # Acceleration in price
            
            # Combine signals with adaptive weighting based on trend and momentum alignment
            # Case 1: Short volume increasing and price decreasing = bearish confirmation
            if sv_trend_st > 0 and price_trend_st < 0:
                if sv_momentum > 0 and price_momentum < 0:  # Strong confirmation with momentum
                    sv_price_signal = 0.8 * sv_trend_st - 0.4 * price_trend_st
                else:  # Basic confirmation
                    sv_price_signal = 0.6 * sv_trend_st - 0.3 * price_trend_st
            # Case 2: Short volume increasing and price increasing = potential short squeeze
            elif sv_trend_st > 0 and price_trend_st > 0:
                if sv_momentum < 0 and price_momentum > 0:  # Strong squeeze potential
                    sv_price_signal = 0.4 * sv_trend_st + 0.6 * price_trend_st
                else:  # Basic squeeze potential
                    sv_price_signal = 0.5 * sv_trend_st + 0.5 * price_trend_st
            # Case 3: Short volume decreasing and price increasing = bullish confirmation
            elif sv_trend_st < 0 and price_trend_st > 0:
                if sv_momentum < 0 and price_momentum > 0:  # Strong confirmation
                    sv_price_signal = -0.7 * sv_trend_st + 0.5 * price_trend_st
                else:  # Basic confirmation
                    sv_price_signal = -0.6 * sv_trend_st + 0.4 * price_trend_st
            # Case 4: Short volume decreasing and price decreasing = potential reversal
            else:
                if sv_momentum < 0 and price_momentum < 0:  # Strong reversal potential
                    sv_price_signal = -0.6 * sv_trend_st - 0.4 * price_trend_st
                else:  # Basic reversal potential
                    sv_price_signal = -0.5 * sv_trend_st - 0.5 * price_trend_st
            
            # Bound the signal with less aggressive bounding
            sv_price_signal = np.tanh(sv_price_signal * 1.2)
        else:
            sv_price_signal = 0.0
        eng.append(sv_price_signal)
        
        # 10. Short Interest Efficiency Ratio with Adaptive Timeframes
        # Measures how effectively short interest predicts price movements with adaptive timeframes
        if t >= 5 and len(close_prices) >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            timeframes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
                        timeframes.append(i)
            
            if si_changes and price_changes:
                # Calculate adaptive timeframe weights based on correlation strength
                weights = np.ones(len(si_changes))
                
                # Calculate individual correlations and adjust weights
                for j in range(len(si_changes)):
                    # Simple correlation proxy (product of changes)
                    corr_proxy = -si_changes[j] * price_changes[j]  # Negative expected relationship
                    
                    # Adjust weight based on correlation strength and recency
                    recency_factor = np.exp(-0.3 * timeframes[j])
                    if corr_proxy > 0:  # Confirming the expected negative relationship
                        weights[j] = (1 + 0.5 * corr_proxy) * recency_factor
                    else:  # Not confirming
                        weights[j] = (1 - 0.3 * abs(corr_proxy)) * recency_factor
                
                # Normalize weights
                weights = weights / max(np.sum(weights), 1e-8)
                
                # Calculate weighted efficiency measure
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
                
                # Apply non-linear transformation with adaptive scaling
                si_efficiency_signal = np.sign(si_efficiency) * np.power(abs(si_efficiency), 0.65)
            else:
                si_efficiency_signal = 0.0
        else:
            si_efficiency_signal = 0.0
        eng.append(si_efficiency_signal)
        
        # 11. Short Interest to Implied Volatility Ratio with Trend Analysis
        # Relates short interest to market expectations of volatility with trend context
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Add trend context if available
        if t >= 1:
            prev_iv = max(abs(data[t-1, 65]), 1e-8)
            prev_si = data[t-1, 0]
            prev_ratio = prev_si / prev_iv
            
            ratio_change = si_to_iv_ratio / max(prev_ratio, 1e-8) - 1.0
            
            # Calculate IV trend
            iv_trend = iv / max(prev_iv, 1e-8) - 1.0
            
            # Combine ratio and trends with adaptive weighting
            if abs(iv_trend) > 0.1:  # Significant IV change
                # When IV is changing rapidly, give more weight to the trend
                si_iv_signal = 0.6 * ratio_change + 0.4 * np.sign(ratio_change) * iv_trend
            else:
                # Otherwise, focus more on the ratio change
                si_iv_signal = 0.8 * ratio_change + 0.2 * np.sign(ratio_change) * iv_trend
            
            # Apply non-linear transformation with adaptive scaling
            if abs(si_iv_signal) > 0.3:
                # More aggressive scaling for large signals
                si_iv_signal = np.sign(si_iv_signal) * np.power(abs(si_iv_signal), 0.65)
            else:
                si_iv_signal = np.sign(si_iv_signal) * np.sqrt(abs(si_iv_signal))
        else:
            # Without trend context, use normalized ratio
            if t >= 5:
                # Use historical context if available
                hist_ratios = []
                for i in range(1, min(6, t+1)):
                    if t-i >= 0:
                        hist_iv = max(abs(data[t-i, 65]), 1e-8)
                        hist_ratios.append(data[t-i, 0] / hist_iv)
                
                if hist_ratios:
                    avg_ratio = np.mean(hist_ratios)
                    si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
                else:
                    si_iv_signal = 0.0
            else:
                # Without history, use raw ratio scaled down
                si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        eng.append(si_iv_signal)
        
        # 12. Bollinger Band Position with Volume and Volatility Context
        # Measures price position within volatility bands with volume and volatility confirmation
        if len(close_prices) >= 20:
            # Calculate standard Bollinger Bands (20-period, 2 standard deviations)
            ma = np.mean(close_prices[-20:])
            std = np.std(close_prices[-20:])
            
            upper_band = ma + (2 * std)
            lower_band = ma - (2 * std)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                # Calculate raw position
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Add volume context if available
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Calculate volatility context
                    recent_std = np.std(close_prices[-5:])
                    longer_std = std
                    vol_context = recent_std / max(longer_std, 1e-8)
                    
                    # Amplify signal when volume and volatility confirm extreme positions
                    if abs(bb_position) > 0.7:  # Near band edges
                        if vol_ratio > 1.2 and vol_context > 1.1:  # High volume and increasing volatility
                            # Strong confirmation - amplify signal
                            bb_position *= min(1.3, 1 + 0.2 * vol_ratio + 0.1 * vol_context)
                        elif vol_ratio > 1.2 or vol_context > 1.1:  # Partial confirmation
                            # Moderate confirmation - slight amplification
                            bb_position *= min(1.15, 1 + 0.1 * vol_ratio + 0.05 * vol_context)
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 13. Short Interest Concentration Index with Temporal Pattern Recognition
        # Measures how concentrated short interest is with pattern recognition
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            # Calculate daily short interest concentration
            daily_concentration = []
            for i in range(min(10, len(short_volume))):
                concentration = short_volume[-i-1] / max(total_volume[-i-1], 1e-8)
                daily_concentration.append(concentration)
            
            # Detect patterns in concentration
            if len(daily_concentration) >= 5:
                # Calculate first differences (day-to-day changes)
                concentration_changes = np.diff(daily_concentration[:5])
                
                # Count consecutive increases/decreases
                consecutive_increases = 0
                consecutive_decreases = 0
                
                for change in concentration_changes:
                    if change > 0:
                        consecutive_increases += 1
                        consecutive_decreases = 0
                    elif change < 0:
                        consecutive_decreases += 1
                        consecutive_increases = 0
                
                # Calculate pattern strength
                pattern_strength = 0.0
                
                if consecutive_increases >= 3:
                    # Strong increasing pattern
                    pattern_strength = 0.3 + 0.2 * consecutive_increases
                elif consecutive_decreases >= 3:
                    # Strong decreasing pattern
                    pattern_strength = -0.3 - 0.2 * consecutive_decreases
                
                # Calculate concentration variability
                concentration_std = np.std(daily_concentration)
                concentration_mean = np.mean(daily_concentration)
                
                # Normalize
                concentration_cv = concentration_std / max(concentration_mean, 1e-8)
                
                # Recent trend in concentration
                recent_conc = np.mean(daily_concentration[:3])
                older_conc = np.mean(daily_concentration[3:])
                conc_trend = recent_conc / max(older_conc, 1e-8) - 1.0
                
                # Combine variability, trend and pattern recognition
                if abs(pattern_strength) > 0.5:
                    # Strong pattern detected - give it more weight
                    concentration_signal = 0.5 * concentration_cv * np.sign(conc_trend) + 0.5 * pattern_strength
                else:
                    # No strong pattern - focus on variability and trend
                    concentration_signal = 0.7 * concentration_cv * np.sign(conc_trend) + 0.3 * pattern_strength
                
                # Apply non-linear transformation
                concentration_signal = np.sign(concentration_signal) * np.sqrt(abs(concentration_signal))
            else:
                concentration_signal = 0.0
        else:
            concentration_signal = 0.0
        eng.append(concentration_signal)
        
        # 14. Adaptive Price Channel Breakout with Volume Profile
        # Identifies price breakouts with volatility-adjusted lookback and volume profile
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                channel_period = 5
            elif rel_volatility > 0.01:  # Medium volatility
                channel_period = 10
            else:  # Low volatility - longer period
                channel_period = 15
                
            channel_period = min(channel_period, len(close_prices))
            
            # Calculate upper and lower channels
            upper_channel = np.max(close_prices[-channel_period:-1])
            lower_channel = np.min(close_prices[-channel_period:-1])
            
            # Calculate volume profile
            volume_profile = []
            price_levels = []
            
            # Create simple volume profile
            for i in range(min(channel_period, len(close_prices)-1)):
                volume_profile.append(total_volume[-i-2])
                price_levels.append(close_prices[-i-2])
            
            # Find high volume price levels
            if volume_profile and price_levels:
                # Calculate volume-weighted average price
                vwap = np.sum(np.array(price_levels) * np.array(volume_profile)) / max(np.sum(volume_profile), 1e-8)
                
                # Calculate breakout signal
                channel_width = upper_channel - lower_channel
                if channel_width > 1e-8:
                    # Raw breakout signal
                    raw_breakout = 2 * ((close_prices[-1] - lower_channel) / channel_width) - 1
                    
                    # Calculate distance from VWAP
                    vwap_distance = (close_prices[-1] - vwap) / max(channel_width, 1e-8)
                    
                    # Add volume confirmation
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-channel_period:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Combine signals with adaptive weighting
                    if abs(raw_breakout) > 0.7 and abs(vwap_distance) > 
--------------------------------------------------
❌ Error executing generated code: invalid syntax (<string>, line 697)
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest - fundamental target variable
        raw_keep.append(data[t, 1])  # average daily volume - critical for liquidity context
        raw_keep.append(data[t, 2])  # days to cover - high importance in previous iterations
        
        # Keep high importance features from previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio - consistently high importance
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility - consistently high importance
        raw_keep.append(data[t, 66])  # shares_outstanding - needed for normalization
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Normalized Short Interest to Float Ratio
        # This feature normalizes short interest by shares outstanding
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        
        # Add trend context if available
        if t > 0:
            prev_si_float = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_float_trend = short_interest_to_float / max(abs(prev_si_float), 1e-8) - 1.0
            
            # Amplify signal when trend is strong
            short_interest_to_float_signal = short_interest_to_float * (1 + 0.3 * np.sign(si_float_trend) * min(abs(si_float_trend), 0.3))
        else:
            short_interest_to_float_signal = short_interest_to_float
        eng.append(short_interest_to_float_signal)
        
        # 2. Short Volume Ratio with Exponential Weighting
        # Measures proportion of daily trading that is short selling with emphasis on recent days
        short_volume_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Use exponential weighting to emphasize recent days
        weights = np.exp(np.linspace(0, 2, 15))
        weights = weights / np.sum(weights)
        weighted_svr = np.sum(short_volume_ratio * weights)
        eng.append(weighted_svr)
        
        # 3. Short Interest Momentum with Acceleration
        # Captures both the rate of change and acceleration in short interest
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            # First difference (momentum)
            si_mom = si_t / max(abs(si_t1), 1e-8) - 1.0
            
            # Second difference (acceleration)
            si_mom_prev = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            si_accel = si_mom - si_mom_prev
            
            # Combine momentum and acceleration with adaptive weighting
            # When acceleration confirms momentum, amplify the signal
            if np.sign(si_mom) == np.sign(si_accel):
                si_signal = 0.7 * si_mom + 0.3 * si_accel
            else:
                si_signal = 0.8 * si_mom + 0.2 * si_accel
        else:
            si_signal = 0.0
        eng.append(si_signal)
        
        # 4. Options Market Sentiment Indicator
        # Combines put/call ratio with implied volatility for a more complete options market view
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typically ranges from 0.5 to 2.0)
        norm_pc_ratio = (put_call_ratio - 1.0) / max(0.5, abs(put_call_ratio - 1.0))
        
        # Add implied volatility context
        if t >= 1:
            prev_iv = data[t-1, 65]
            iv_change = implied_vol / max(abs(prev_iv), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            if iv_change > 0 and norm_pc_ratio > 0:
                options_sentiment = 0.7 * norm_pc_ratio + 0.3 * iv_change  # Strong bearish
            elif iv_change > 0 and norm_pc_ratio < 0:
                options_sentiment = 0.6 * norm_pc_ratio + 0.2 * iv_change  # Mixed signal
            elif iv_change < 0 and norm_pc_ratio > 0:
                options_sentiment = 0.5 * norm_pc_ratio + 0.3 * iv_change  # Mixed signal
            else:
                options_sentiment = 0.7 * norm_pc_ratio + 0.2 * iv_change  # Bullish
        else:
            options_sentiment = norm_pc_ratio
        
        # Bound the signal
        options_sentiment = np.tanh(options_sentiment * 1.5)
        eng.append(options_sentiment)
        
        # 5. Short Squeeze Potential Indicator
        # Combines short interest, price momentum, volume, and options data
        if len(close_prices) >= 5 and t >= 1:
            # Short interest level and change
            si_level = data[t, 0] / max(abs(data[t, 66]), 1e-8)  # Normalized by shares outstanding
            si_prev = data[t-1, 0] / max(abs(data[t-1, 66]), 1e-8)
            si_change = si_level / max(abs(si_prev), 1e-8) - 1.0
            
            # Recent price momentum
            price_momentum = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # Volume surge
            if len(total_volume) >= 5:
                recent_vol = total_volume[-1]
                avg_vol = np.mean(total_volume[-5:])
                vol_surge = recent_vol / max(abs(avg_vol), 1e-8) - 1.0
            else:
                vol_surge = 0.0
            
            # Options data - put/call ratio change
            put_call_ratio = data[t, 63]
            prev_pc_ratio = data[t-1, 63]
            pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            
            # Short squeeze conditions:
            # 1. High short interest
            # 2. Positive price momentum
            # 3. Volume surge
            # 4. Recent decrease in short interest (shorts covering)
            # 5. Decreasing put/call ratio (bullish options sentiment)
            
            squeeze_score = 0.0
            
            # High short interest base score
            if si_level > 0.1:  # More than 10% of float
                squeeze_score += 0.35 * min(si_level / 0.2, 1.0)  # Cap at 20% of float
            
            # Add momentum component (only positive momentum contributes)
            if price_momentum > 0:
                squeeze_score += 0.25 * min(price_momentum / 0.05, 1.0)  # Cap at 5% price increase
            
            # Add volume component
            if vol_surge > 0:
                squeeze_score += 0.15 * min(vol_surge / 0.5, 1.0)  # Cap at 50% volume increase
            
            # Add short interest reduction component (shorts covering)
            if si_change < 0:
                squeeze_score += 0.15 * min(abs(si_change) / 0.05, 1.0)  # Cap at 5% SI reduction
            
            # Add options sentiment component
            if pc_ratio_change < 0:  # Decreasing put/call ratio (bullish)
                squeeze_score += 0.1 * min(abs(pc_ratio_change) / 0.1, 1.0)  # Cap at 10% reduction
            
            # Bound the score
            squeeze_score = min(1.0, squeeze_score)
        else:
            squeeze_score = 0.0
        eng.append(squeeze_score)
        
        # 6. Volatility-Adjusted Price Momentum
        # Normalizes price momentum by volatility for more consistent signals across volatility regimes
        if len(close_prices) >= 10:
            # Calculate price volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Short-term momentum (3-day)
            if len(close_prices) >= 3:
                mom_3d = (close_prices[-1] / max(abs(close_prices[-3]), 1e-8)) - 1.0
            else:
                mom_3d = 0.0
            
            # Medium-term momentum (5-day)
            if len(close_prices) >= 5:
                mom_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            else:
                mom_5d = 0.0
            
            # Longer-term momentum (10-day)
            if len(close_prices) >= 10:
                mom_10d = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1.0
            else:
                mom_10d = 0.0
            
            # Adjust weights based on volatility regime
            if rel_volatility > 0.03:  # High volatility - favor short-term
                weights = [0.6, 0.3, 0.1]
            elif rel_volatility > 0.01:  # Medium volatility
                weights = [0.4, 0.4, 0.2]
            else:  # Low volatility - favor longer-term
                weights = [0.2, 0.4, 0.4]
                
            # Combine signals with adaptive weights
            composite_momentum = mom_3d * weights[0] + mom_5d * weights[1] + mom_10d * weights[2]
            
            # Normalize by volatility
            vol_adj_momentum = composite_momentum / max(rel_volatility, 0.01)
        else:
            vol_adj_momentum = 0.0
        eng.append(vol_adj_momentum)
        
        # 7. Enhanced RSI with Volume Weighting
        # RSI modified to incorporate trading volume for stronger signals
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight gains and losses by relative volume
            if len(total_volume) >= 15:
                vol_weights = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
                vol_weighted_gain = gain * vol_weights
                vol_weighted_loss = loss * vol_weights
                
                avg_gain = np.mean(vol_weighted_gain[-14:]) if len(vol_weighted_gain) >= 14 else np.mean(vol_weighted_gain)
                avg_loss = np.mean(vol_weighted_loss[-14:]) if len(vol_weighted_loss) >= 14 else np.mean(vol_weighted_loss)
            else:
                avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
                avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            
            # Normalize RSI to [-1, 1] range for better gradient properties
            norm_rsi = (rsi / 50.0) - 1.0
        else:
            norm_rsi = 0.0  # Neutral value when not enough data
        eng.append(norm_rsi)
        
        # 8. Short Interest to Days-to-Cover Ratio
        # Combines short interest with days to cover for a more complete picture
        si = data[t, 0]
        dtc = max(abs(data[t, 2]), 1e-8)
        si_dtc_ratio = si / dtc
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_si = data[t-i, 0]
                    hist_dtc = max(abs(data[t-i, 2]), 1e-8)
                    hist_ratios.append(hist_si / hist_dtc)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_dtc_signal = si_dtc_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_dtc_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_dtc_signal = si_dtc_ratio * 0.01  # Scale to reasonable range
        eng.append(si_dtc_signal)
        
        # 9. Short Volume Trend with Price Confirmation
        # Analyzes short volume trend in context of price movement
        if len(short_volume) >= 10 and len(close_prices) >= 10:
            # Calculate short volume trend
            recent_short_vol = np.mean(short_volume[-3:])
            older_short_vol = np.mean(short_volume[-10:-3])
            sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            
            # Calculate price trend
            recent_price = np.mean(close_prices[-3:])
            older_price = np.mean(close_prices[-10:-3])
            price_trend = recent_price / max(older_price, 1e-8) - 1.0
            
            # Combine signals based on confirmation/contradiction
            if sv_trend > 0 and price_trend < 0:
                sv_price_signal = 0.7 * sv_trend - 0.3 * price_trend  # Bearish confirmation
            elif sv_trend > 0 and price_trend > 0:
                sv_price_signal = 0.5 * sv_trend + 0.5 * price_trend  # Potential squeeze
            elif sv_trend < 0 and price_trend > 0:
                sv_price_signal = -0.6 * sv_trend + 0.4 * price_trend  # Bullish confirmation
            else:
                sv_price_signal = -0.5 * sv_trend - 0.5 * price_trend  # Potential reversal
        else:
            sv_price_signal = 0.0
        eng.append(sv_price_signal)
        
        # 10. Short Interest Efficiency Ratio
        # Measures how effectively short interest predicts price movements
        if t >= 5 and len(close_prices) >= 5:
            # Collect historical data points
            si_changes = []
            price_changes = []
            
            for i in range(1, min(6, t+1)):
                if t-i >= 0 and t-i+1 < lookback_window:
                    # Get short interest change
                    si_t = data[t-i+1, 0]
                    si_t_prev = data[t-i, 0]
                    si_change = si_t / max(abs(si_t_prev), 1e-8) - 1.0
                    
                    # Get corresponding price change
                    if t-i+1 < data.shape[0] and t-i < data.shape[0]:
                        close_t = data[t-i+1, 3:63].reshape(15, 4)[-1, 3]
                        close_t_prev = data[t-i, 3:63].reshape(15, 4)[-1, 3]
                        price_change = close_t / max(abs(close_t_prev), 1e-8) - 1.0
                        
                        si_changes.append(si_change)
                        price_changes.append(price_change)
            
            if si_changes and price_changes:
                # Calculate weighted correlation-like measure with recency bias
                weights = np.exp(np.linspace(0, 1.5, len(si_changes)))
                weights = weights / np.sum(weights)
                
                weighted_product = 0
                for j in range(len(si_changes)):
                    weighted_product += weights[j] * si_changes[j] * price_changes[j]
                
                # Negative correlation expected (higher SI → lower prices)
                si_efficiency = -weighted_product
            else:
                si_efficiency = 0.0
        else:
            si_efficiency = 0.0
        eng.append(si_efficiency)
        
        # 11. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations of volatility
        iv = max(abs(data[t, 65]), 1e-8)
        si_to_iv_ratio = data[t, 0] / iv
        
        # Normalize by historical context if available
        if t >= 5:
            hist_ratios = []
            for i in range(1, min(6, t+1)):
                if t-i >= 0:
                    hist_iv = max(abs(data[t-i, 65]), 1e-8)
                    hist_ratios.append(data[t-i, 0] / hist_iv)
            
            if hist_ratios:
                avg_ratio = np.mean(hist_ratios)
                si_iv_signal = si_to_iv_ratio / max(avg_ratio, 1e-8) - 1.0
            else:
                si_iv_signal = 0.0
        else:
            # Without history, use raw ratio scaled down
            si_iv_signal = si_to_iv_ratio * 0.01  # Scale to reasonable range
        eng.append(si_iv_signal)
        
        # 12. Bollinger Band Position with Volume Context
        # Measures price position within volatility bands with volume confirmation
        if len(close_prices) >= 20:
            # Calculate standard Bollinger Bands (20-period, 2 standard deviations)
            ma = np.mean(close_prices[-20:])
            std = np.std(close_prices[-20:])
            
            upper_band = ma + (2 * std)
            lower_band = ma - (2 * std)
            
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Normalize to [-1, 1] range
                bb_position = 2 * bb_position - 1
                
                # Volume confirmation - check if volume supports the position
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify signal when volume confirms extreme positions
                    if (bb_position > 0.5 and vol_ratio > 1.2) or (bb_position < -0.5 and vol_ratio > 1.2):
                        bb_position *= min(vol_ratio, 1.5)  # Cap amplification
                    
                    # Cap at [-1, 1]
                    bb_position = max(-1.0, min(1.0, bb_position))
            else:
                bb_position = 0.0
        else:
            bb_position = 0.0
        eng.append(bb_position)
        
        # 13. Short Interest Concentration Index
        # Measures how concentrated short interest is relative to trading volume
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            # Calculate daily short interest concentration
            daily_concentration = []
            for i in range(min(10, len(short_volume))):
                concentration = short_volume[-i-1] / max(total_volume[-i-1], 1e-8)
                daily_concentration.append(concentration)
            
            # Calculate concentration variability
            if len(daily_concentration) >= 3:
                concentration_std = np.std(daily_concentration)
                concentration_mean = np.mean(daily_concentration)
                
                # Normalize
                concentration_cv = concentration_std / max(concentration_mean, 1e-8)
                
                # Recent trend in concentration
                recent_conc = np.mean(daily_concentration[:3])
                older_conc = np.mean(daily_concentration[3:]) if len(daily_concentration) > 3 else recent_conc
                conc_trend = recent_conc / max(older_conc, 1e-8) - 1.0
                
                # Combine variability and trend
                if conc_trend > 0:
                    concentration_signal = concentration_cv * (1 + 0.7 * conc_trend)
                else:
                    concentration_signal = concentration_cv * (1 + 0.3 * conc_trend)
            else:
                concentration_signal = 0.0
        else:
            concentration_signal = 0.0
        eng.append(concentration_signal)
        
        # 14. Price Channel Breakout
        # Identifies price breakouts with volatility-adjusted lookback periods
        if len(close_prices) >= 10:
            # Calculate adaptive lookback period based on volatility
            price_std = np.std(close_prices[-10:])
            price_mean = np.mean(close_prices[-10:])
            rel_volatility = price_std / max(price_mean, 1e-8)
            
            # Adjust lookback period based on volatility
            if rel_volatility > 0.03:  # High volatility - shorter period
                channel_period = 5
            elif rel_volatility > 0.01:  # Medium volatility
                channel_period = 10
            else:  # Low volatility - longer period
                channel_period = 15
                
            channel_period = min(channel_period, len(close_prices))
            
            # Calculate upper and lower channels
            upper_channel = np.max(close_prices[-channel_period:-1])
            lower_channel = np.min(close_prices[-channel_period:-1])
            
            # Calculate breakout signal
            channel_width = upper_channel - lower_channel
            if channel_width > 1e-8:
                # Normalize to [-1, 1] range
                breakout_signal = 2 * ((close_prices[-1] - lower_channel) / channel_width) - 1
                
                # Add volume confirmation
                if len(total_volume) >= 5:
                    recent_vol = total_volume[-1]
                    avg_vol = np.mean(total_volume[-5:])
                    vol_ratio = recent_vol / max(avg_vol, 1e-8)
                    
                    # Amplify breakouts with high volume
                    if abs(breakout_signal) > 0.7 and vol_ratio > 1.2:
                        breakout_signal *= min(np.sqrt(vol_ratio), 1.3)
                
                # Bound the signal
                breakout_signal = max(-1.0, min(1.0, breakout_signal))
            else:
                breakout_signal = 0.0
        else:
            breakout_signal = 0.0
        eng.append(breakout_signal)
        
        # 15. Synthetic Short Cost Change
        # Tracks changes in the cost of creating synthetic short positions
        if t >= 1:
            current_cost = data[t, 64]
            prev_cost = data[t-1, 64]
            
            synth_cost_change = current_cost / max(abs(prev_cost), 1e-8) - 1.0
            
            # Add context from options data
            put_call_ratio = data[t, 63]
            prev_pc_ratio = data[t-1, 63] if t-1 >= 0 else put_call_ratio
            pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            
            # Combine signals with adaptive weighting
            if np.sign(synth_cost_change) == np.sign(pc_ratio_change):
                cost_signal = 0.7 * synth_cost_change + 0.3 * pc_ratio_change
            else:
                cost_signal = 0.6 * synth_cost_change + 0.2 * pc_ratio_change
        else:
            cost_signal = 0.0
        eng.append(cost_signal)
        
        # 16. Volume-Weighted Average Price (VWAP) Deviation
        # Measures price deviation from volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate VWAP over the last 5 days
            vwap_sum = 0
            volume_sum = 0
            
            for i in range(1, min(6, len(close_prices) + 1)):
                vwap_sum += close_prices[-i] * total_volume[-i]
                volume_sum += total_volume[-i]
            
            if volume_sum > 1e-8:
                vwap = vwap_sum / max(volume_sum, 1e-8)
                vwap_deviation = close_prices[-1] / max(vwap, 1e-8) - 1.0
            else:
                vwap_deviation = 0.0
        else:
            vwap_deviation = 0.0
        eng.append(vwap_deviation)
        
        # 17. Enhanced MACD Signal with Volume Context
        # MACD modified to incorporate trading volume for stronger signals
        if len(close_prices) >= 26:
            # Calculate EMA-12 and EMA-26 (approximated with weighted averages)
            weights_12 = np.exp(np.linspace(0, 2.5, min(12, len(close_prices))))
            weights_12 = weights_12 / np.sum(weights_12)
            ema12 = np.sum(close_prices[-min(12, len(close_prices)):] * weights_12)
            
            weights_26 = np.exp(np.linspace(0, 2.5, min(26, len(close_prices))))
            weights_26 = weights_26 / np.sum(weights_26)
            ema26 = np.sum(close_prices[-min(26, len(close_prices)):] * weights_26)
            
            # MACD Line
            macd_line = ema12 - ema26
            
            # Normalize by price level
            avg_price = np.mean(close_prices[-min(26, len(close_prices)):])
            norm_macd = macd_line / max(abs(avg_price), 1e-8)
            
            # Volume validation
            if len(total_volume) >= 5:
                recent_vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
                
                # Amplify MACD when volume confirms direction
                if (norm_macd > 0 and recent_vol_ratio > 1.2) or (norm_macd < 0 and recent_vol_ratio > 1.2):
                    norm_macd *= min(np.sqrt(recent_vol_ratio), 1.3)
            
            # Bound the signal
            macd_signal = np.tanh(norm_macd * 8)
        else:
            macd_signal = 0.0
        eng.append(macd_signal)
        
        # 18. Improved Short Interest Prediction Signal
        # Combines multiple signals that have shown high importance in previous iterations
        if t >= 2 and len(close_prices) >= 10:
            # 1. Short interest momentum
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            si_mom = si_t / max(abs(si_t1), 1e-8) - 1.0
            si_mom_prev = si_t1 / max(abs(si_t2), 1e-8) - 1.0
            
            # 2. Price momentum
            price_mom = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1.0
            
            # 3. Options sentiment
            put_call_ratio = data[t, 63]
            if t > 0:
                prev_pc_ratio = data[t-1, 63]
                pc_ratio_change = put_call_ratio / max(abs(prev_pc_ratio), 1e-8) - 1.0
            else:
                pc_ratio_change = 0.0
            
            # 4. Short volume trend
            if len(short_volume) >= 5:
                recent_short_vol = np.mean(short_volume[-3:])
                older_short_vol = np.mean(short_volume[-5:])
                sv_trend = recent_short_vol / max(older_short_vol, 1e-8) - 1.0
            else:
                sv_trend = 0.0
            
            # Combine signals with weights based on previous importance
            combined_signal = (
                0.35 * si_mom +                # Short interest momentum (highest importance)
                0.25 * -price_mom +            # Inverse price momentum (negative correlation)
                0.20 * pc_ratio_change +       # Options sentiment change
                0.20 * sv_trend                # Short volume trend
            )
        else:
            combined_signal = 0.0
        eng.append(combined_signal)
        
        # 19. Price Volatility Regime Indicator
        # Identifies current volatility regime relative to historical context
        if len(close_prices) >= 15:
            # Calculate recent volatility (5-day)
            recent_std = np.std(close_prices[-5:])
            recent_mean = np.mean(close_prices[-5:])
            recent_vol = recent_std / max(recent_mean, 1e-8)
            
            # Calculate longer-term volatility (15-day)
            longer_std = np.std(close_prices[-15:])
            longer_mean = np.mean(close_prices[-15:])
            longer_vol = longer_std / max(longer_mean, 1e-8)
            
            # Volatility regime change
            vol_regime = recent_vol / max(longer_vol, 1e-8) - 1.0
        else:
            vol_regime = 0.0
        eng.append(vol_regime)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 10 (claude) (SVM)
==================================================
Training SVM model...

Iteration 10 (claude) Performance:
MAE: 207246.4296
RMSE: 249813.1611
MAPE: 15.04%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 67
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0009, rank=1
   2. Feature_12_t0: importance=0.0006, rank=2
   3. Feature_24_t1: importance=0.0006, rank=3
   4. Feature_19_t0: importance=0.0005, rank=4
   5. Feature_19_t1: importance=0.0005, rank=5
💾 Saved code for iteration 10 to iteration_codes dictionary
📊 No significant improvement. Change: -1.46%

📈 Current best MAPE: 13.58%
🔄 Iterations without improvement: 4/5

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 243256.9853
RMSE: 309317.1754
MAPE: 14.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 301
   • Highly important features (top 5%): 130

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0003, rank=1
   2. Feature_73_t3: importance=0.0003, rank=2
   3. Feature_81_t2: importance=0.0003, rank=3
   4. Feature_70_t3: importance=0.0003, rank=4
   5. Feature_83_t2: importance=0.0003, rank=5
   Baseline MAPE: 14.65%
   Baseline MAE: 243256.9853
   Baseline RMSE: 309317.1754

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 255859.5432
RMSE: 311313.3901
MAPE: 15.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_6_t2: importance=0.0015, rank=1
   2. Feature_6_t0: importance=0.0008, rank=2
   3. Feature_9_t0: importance=0.0007, rank=3
   4. Feature_4_t2: importance=0.0006, rank=4
   5. Feature_8_t3: importance=0.0006, rank=5

📊 Best Model Test Set Performance:
   MAPE: 15.30%
   MAE: 255859.5432
   RMSE: 311313.3901

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 14.65%
   Best Model MAPE: 15.30%
   Absolute Improvement: -0.65%
   Relative Improvement: -4.5%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  15.91           N/A                 
1          Iteration 1               14.44           +1.47%              
2          Iteration 2               14.37           +0.08%              
3          Iteration 3               14.22           +0.22%              
4          Iteration 4               14.36           -0.14%              
5          Iteration 5               14.28           -0.06%              
6          Iteration 6               13.58           +0.64%              
7          Iteration 7               14.01           -0.43%              
8          Iteration 8               14.22           -0.64%              
9          Iteration 9               14.74           -1.16%              
10         Iteration 10              15.04           -1.46%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 6 - MAPE: 13.58%
✅ Saved ABM results to cache/ABM_iterative_results_enhanced.pkl
✅ Summary report saved for ABM

🎉 Process completed successfully for ABM!

================================================================================
PROCESSING TICKER 7/14: IART
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for IART
======================================================================
📊 Loading data from parquet file...
📊 Loading data for IART from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IART...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 352947.7297
RMSE: 529165.7714
MAPE: 10.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 241
   • Highly important features (top 5%): 125

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t2: importance=0.0003, rank=1
   2. Feature_91_t1: importance=0.0003, rank=2
   3. Feature_85_t0: importance=0.0002, rank=3
   4. Feature_84_t2: importance=0.0002, rank=4
   5. Feature_92_t3: importance=0.0002, rank=5

📊 Baseline Performance: MAPE = 10.03%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # Short interest
        raw_keep.append(data[t, 1])  # Average daily volume
        raw_keep.append(data[t, 2])  # Days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep options data which may be predictive for short interest
        raw_keep.append(data[t, 63])  # Options put/call volume ratio
        raw_keep.append(data[t, 64])  # Options synthetic short cost
        raw_keep.append(data[t, 65])  # Options avg implied volatility
        
        # Keep shares outstanding (important for relative measures)
        raw_keep.append(data[t, 66])  # Shares outstanding
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily average over 15 days)
        # This is a key indicator of short selling pressure
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        avg_short_ratio = np.mean(short_ratio)
        eng.append(avg_short_ratio)
        
        # 2. Short Volume Trend (slope of short volume ratio over 15 days)
        # Captures if short selling pressure is increasing/decreasing
        if len(short_ratio) >= 5:
            short_trend = (np.mean(short_ratio[-5:]) - np.mean(short_ratio[:5])) / np.mean(short_ratio[:5] + 1e-8)
            eng.append(short_trend)
        else:
            eng.append(0.0)
        
        # 3. Price Momentum (5-day)
        # Short sellers often target stocks with negative momentum
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1.0
            eng.append(momentum_5d)
        else:
            eng.append(0.0)
        
        # 4. Price Volatility (15-day)
        # High volatility stocks often attract short sellers
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / (close_prices[:-1] + 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
            eng.append(volatility)
        else:
            eng.append(0.0)
        
        # 5. Average True Range (ATR) - volatility measure
        # Measures volatility which can attract short sellers
        atr_values = []
        for i in range(1, len(ohlc)):
            tr1 = ohlc[i, 1] - ohlc[i, 2]  # High - Low
            tr2 = abs(ohlc[i, 1] - ohlc[i-1, 3])  # |High - Previous Close|
            tr3 = abs(ohlc[i, 2] - ohlc[i-1, 3])  # |Low - Previous Close|
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        
        atr = np.mean(atr_values) if atr_values else 0
        normalized_atr = atr / (np.mean(close_prices) + 1e-8)  # Normalize by price level
        eng.append(normalized_atr)
        
        # 6. Short Interest to Float Ratio
        # Key metric showing how much of available float is sold short
        shares_outstanding = data[t, 66]
        short_interest_to_float = data[t, 0] / (shares_outstanding + 1e-8)
        eng.append(short_interest_to_float)
        
        # 7. Short Volume Acceleration
        # Measures if short selling is accelerating or decelerating
        if len(short_ratio) >= 10:
            first_5d = np.mean(short_ratio[:5])
            mid_5d = np.mean(short_ratio[5:10])
            last_5d = np.mean(short_ratio[10:])
            
            first_delta = mid_5d - first_5d
            second_delta = last_5d - mid_5d
            
            acceleration = second_delta - first_delta
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # 8. Price to Volume Correlation (15-day)
        # Indicates if price movements are supported by volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_returns = np.diff(close_prices[-5:]) / (close_prices[-6:-1] + 1e-8)
            volume_changes = np.diff(total_volume[-5:]) / (total_volume[-6:-1] + 1e-8)
            
            if len(price_returns) > 0 and len(volume_changes) > 0:
                # Use a simple product of signs instead of correlation for stability
                sign_agreement = np.mean(np.sign(price_returns) * np.sign(volume_changes))
                eng.append(sign_agreement)
            else:
                eng.append(0.0)
        else:
            eng.append(0.0)
        
        # 9. RSI (Relative Strength Index) - 14 day
        # Overbought/oversold indicator that may signal short opportunity
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            
            rs = avg_gain / (avg_loss + 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(0.0)
        
        # 10. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        short_ratio_volatility = np.std(short_ratio) if len(short_ratio) > 0 else 0
        eng.append(short_ratio_volatility)
        
        # 11. Recent Price Range Relative to Historical
        # Indicates if recent price action is more volatile than usual
        if len(high_prices) >= 10 and len(low_prices) >= 10:
            recent_range = (high_prices[-5:].max() - low_prices[-5:].min()) / (np.mean(close_prices[-5:]) + 1e-8)
            historical_range = (high_prices[:10].max() - low_prices[:10].min()) / (np.mean(close_prices[:10]) + 1e-8)
            relative_range = recent_range / (historical_range + 1e-8)
            eng.append(relative_range)
        else:
            eng.append(0.0)
        
        # 12. Options Implied Volatility to Historical Volatility Ratio
        # Indicates market expectations vs. realized volatility
        implied_vol = data[t, 65]
        historical_vol = volatility if 'volatility' in locals() else 0
        iv_hv_ratio = implied_vol / (historical_vol + 1e-8)
        eng.append(iv_hv_ratio)
        
        # 13. Short Interest to Average Volume Ratio
        # How many days of average volume would it take to cover all shorts
        si_volume_ratio = data[t, 0] / (data[t, 1] + 1e-8)
        eng.append(si_volume_ratio)
        
        # 14. Short Volume Trend Reversal Signal
        # Detects potential reversals in short selling pressure
        if len(short_ratio) >= 10:
            short_ma5 = np.mean(short_ratio[-5:])
            short_ma10 = np.mean(short_ratio[-10:])
            reversal_signal = short_ma5 / (short_ma10 + 1e-8) - 1.0
            eng.append(reversal_signal)
        else:
            eng.append(0.0)
        
        # 15. Price Gap Analysis
        # Large overnight gaps can trigger short covering or new shorts
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gaps = []
            for i in range(1, min(len(open_prices), len(close_prices))):
                gap = (open_prices[i] - close_prices[i-1]) / (close_prices[i-1] + 1e-8)
                overnight_gaps.append(gap)
            
            avg_gap = np.mean(np.abs(overnight_gaps)) if overnight_gaps else 0
            eng.append(avg_gap)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW engineered features
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent width
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        raw_keep.extend([short_interest, avg_volume, days_to_cover])
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last day)
        last_open, last_high, last_low, last_close = open_prices[-1], high_prices[-1], low_prices[-1], close_prices[-1]
        raw_keep.extend([last_open, last_high, last_low, last_close])
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        raw_keep.extend([options_put_call_ratio, options_avg_implied_volatility])
        
        # Extract short interest volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep shares outstanding (important for relative measures)
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Important to normalize short interest by total shares available
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Indicates daily shorting intensity
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:])
        earlier_short_ratio = np.mean(daily_short_ratio[:-5])
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Price Momentum (5-day)
        # Short sellers often target stocks with negative momentum
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often attracts short sellers
        if len(close_prices) >= 2:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility measure
        # Measures price volatility, important for short sellers' risk assessment
        true_ranges = []
        for i in range(1, len(high_prices)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_ranges.append(max(tr1, tr2, tr3))
        atr = np.mean(true_ranges) if true_ranges else 0
        eng.append(atr)
        
        # 7. Options Implied Volatility to Historical Volatility Ratio
        # Indicates market expectations vs. realized volatility
        iv_hv_ratio = options_avg_implied_volatility / max(volatility, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 8. Short Interest to Float Ratio
        # Measures how much of available float is being shorted
        si_float_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_float_ratio)
        
        # 9. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 10. RSI (Relative Strength Index) - 14 period
        # Overbought/oversold indicator, often used by short sellers
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 11. Price to Moving Average Ratio (10-day)
        # Indicates trend strength and potential reversal points
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(ma10, 1e-8)
        else:
            price_to_ma = 1
        eng.append(price_to_ma)
        
        # 12. Short Interest Growth Rate
        # Rate of change in short interest, indicating increasing/decreasing short pressure
        si_growth = 0  # Default when we can't calculate
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 314390.9144
RMSE: 488125.8313
MAPE: 9.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t0: importance=0.0007, rank=1
   2. Feature_20_t3: importance=0.0007, rank=2
   3. Feature_7_t0: importance=0.0006, rank=3
   4. Feature_12_t2: importance=0.0005, rank=4
   5. Feature_11_t2: importance=0.0005, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.87%

📈 Current best MAPE: 9.15%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        raw_keep.extend([short_interest, avg_volume, days_to_cover])
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last day)
        last_open, last_high, last_low, last_close = open_prices[-1], high_prices[-1], low_prices[-1], close_prices[-1]
        raw_keep.extend([last_close])  # Only keep last close to reduce dimensionality
        
        # Extract options data - keep only the most important ones based on previous iterations
        options_put_call_ratio = data[t, 63]
        options_avg_implied_volatility = data[t, 65]
        raw_keep.extend([options_put_call_ratio, options_avg_implied_volatility])
        
        # Extract short interest volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep shares outstanding (important for relative measures)
        shares_outstanding = data[t, 66]
        raw_keep.append(shares_outstanding)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Important to normalize short interest by total shares available
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Indicates daily shorting intensity - high importance in previous iteration
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:])
        earlier_short_ratio = np.mean(daily_short_ratio[:-5])
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        # Rate of change in short interest, indicating increasing/decreasing short pressure
        si_growth = 0  # Default when we can't calculate
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Exponential Short Interest Growth (exponential of growth rate)
        # Amplifies the effect of significant changes in short interest
        exp_si_growth = np.exp(min(max(si_growth, -5), 5)) - 1  # Bounded to prevent extreme values
        eng.append(exp_si_growth)
        
        # 6. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 7. Price Momentum (5-day) - important for short sellers
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 8. Short-term Price Momentum (3-day) - captures more recent price action
        if len(close_prices) >= 3:
            momentum_3d = (close_prices[-1] / max(close_prices[-3], 1e-8)) - 1
        else:
            momentum_3d = 0
        eng.append(momentum_3d)
        
        # 9. Volatility (standard deviation of returns)
        # High volatility often attracts short sellers
        if len(close_prices) >= 2:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 10. RSI (Relative Strength Index) - 14 period
        # Overbought/oversold indicator, often used by short sellers
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 11. RSI Divergence with Short Interest
        # Captures when short interest moves opposite to price momentum
        rsi_norm = rsi / 100.0  # Normalize to 0-1 range
        si_norm = si_ratio / max(si_ratio + 1e-8, 1e-8)  # Normalize short interest ratio
        rsi_si_divergence = rsi_norm - si_norm
        eng.append(rsi_si_divergence)
        
        # 12. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 13. Short Volume Acceleration
        # Measures the rate of change in short volume over the last few days
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            earlier_short_vol = np.mean(short_volume[-5:-3])
            short_accel = recent_short_vol / max(earlier_short_vol, 1e-8) - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 14. Implied Volatility to Price Ratio
        # Higher ratio suggests market expects larger moves relative to current price
        iv_price_ratio = options_avg_implied_volatility / max(last_close, 1e-8)
        eng.append(iv_price_ratio)
        
        # 15. Put-Call Ratio Trend
        # Measures change in sentiment from options market
        put_call_trend = 0
        if t > 0:
            prev_put_call = data[t-1, 63]
            put_call_trend = options_put_call_ratio / max(prev_put_call, 1e-8) - 1
        eng.append(put_call_trend)
        
        # 16. Short Interest Concentration
        # Measures how concentrated short interest is relative to total market cap
        market_cap = shares_outstanding * last_close
        si_concentration = short_interest * last_close / max(market_cap, 1e-8)
        eng.append(si_concentration)
        
        # 17. Short Volume to Total Volume Ratio Volatility
        # Measures the consistency of shorting activity
        sv_tv_volatility = np.std(daily_short_ratio) if len(daily_short_ratio) > 0 else 0
        eng.append(sv_tv_volatility)
        
        # 18. Bollinger Band Width (measure of volatility)
        # Wider bands indicate higher volatility, which can attract short sellers
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 19. Price Distance from 10-day SMA
        # Measures potential mean reversion opportunity
        if len(close_prices) >= 10:
            sma10 = np.mean(close_prices[-10:])
            price_sma_distance = (last_close / max(sma10, 1e-8)) - 1
        else:
            price_sma_distance = 0
        eng.append(price_sma_distance)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 311703.8081
RMSE: 485871.7684
MAPE: 9.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t2: importance=0.0007, rank=1
   2. Feature_9_t0: importance=0.0006, rank=2
   3. Feature_16_t3: importance=0.0005, rank=3
   4. Feature_4_t0: importance=0.0005, rank=4
   5. Feature_10_t2: importance=0.0004, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.12%

📈 Current best MAPE: 9.03%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_9_t2, Feature_9_t0, Feature_16_t3, Feature_4_t0, Feature_10_t2 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest
            avg_volume,                      # Always keep average volume
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            shares_outstanding               # Important for normalization
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        earlier_short_ratio = np.mean(daily_short_ratio[:-5]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Volatility (standard deviation of returns)
        # High volatility often attracts short sellers
        volatility = 0
        if len(close_prices) >= 3:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 8. RSI (Relative Strength Index) - 14 period
        # Overbought/oversold indicator, often used by short sellers
        rsi = 50  # Neutral value when not enough data
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        eng.append(rsi)
        
        # 9. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 10. Short Interest Concentration
        # Measures how concentrated short interest is relative to total market cap
        market_cap = shares_outstanding * close_prices[-1]
        si_concentration = short_interest * close_prices[-1] / max(market_cap, 1e-8)
        eng.append(si_concentration)
        
        # 11. Bollinger Band Width (measure of volatility)
        # Wider bands indicate higher volatility, which can attract short sellers
        bb_width = 0
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)
        eng.append(bb_width)
        
        # 12. NEW: Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 13. NEW: Short Volume Momentum
        # Measures the rate of change in short volume over the last few days
        sv_momentum = 0
        if len(short_volume) >= 5:
            sv_momentum = (np.mean(short_volume[-2:]) / max(np.mean(short_volume[-5:-2]), 1e-8)) - 1
        eng.append(sv_momentum)
        
        # 14. NEW: Implied Volatility to Historical Volatility Ratio
        # Compares market expectations (IV) to realized volatility
        iv_hv_ratio = options_avg_implied_volatility / max(volatility, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 15. NEW: Short Interest Velocity
        # Second derivative of short interest - acceleration of shorting
        si_velocity = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            si_velocity = si_growth - prev_growth
        eng.append(si_velocity)
        
        # 16. NEW: Average True Range (ATR) - Volatility measure
        atr = 0
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                true_ranges.append(max(high_low, high_close, low_close))
            atr = np.mean(true_ranges) if true_ranges else 0
        eng.append(atr)
        
        # 17. NEW: Short Volume Ratio Trend
        # Measures the trend in daily short volume ratio
        sv_ratio_trend = 0
        if len(daily_short_ratio) >= 5:
            recent_ratio = np.mean(daily_short_ratio[-2:])
            previous_ratio = np.mean(daily_short_ratio[-5:-2])
            sv_ratio_trend = recent_ratio / max(previous_ratio, 1e-8) - 1
        eng.append(sv_ratio_trend)
        
        # 18. NEW: Synthetic Short Cost to Implied Volatility Ratio
        # Measures the cost efficiency of shorting relative to expected volatility
        short_cost_iv_ratio = options_synthetic_short_cost / max(options_avg_implied_volatility, 1e-8)
        eng.append(short_cost_iv_ratio)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 307861.7717
RMSE: 470975.0707
MAPE: 8.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t2: importance=0.0006, rank=1
   2. Feature_9_t0: importance=0.0005, rank=2
   3. Feature_4_t1: importance=0.0005, rank=3
   4. Feature_15_t3: importance=0.0004, rank=4
   5. Feature_4_t0: importance=0.0004, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: +0.08%

📈 Current best MAPE: 9.03%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_9_t2, Feature_9_t0, Feature_4_t1, Feature_15_t3, Feature_4_t0 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest
            avg_volume,                      # Always keep average volume
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            shares_outstanding,              # Important for normalization
            options_synthetic_short_cost     # Cost of synthetic shorting - important for short interest prediction
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        earlier_short_ratio = np.mean(daily_short_ratio[:-5]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Volatility (standard deviation of returns)
        # High volatility often attracts short sellers
        volatility = 0
        if len(close_prices) >= 3:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0
        eng.append(volatility)
        
        # 8. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 9. Short Interest Concentration
        # Measures how concentrated short interest is relative to total market cap
        market_cap = shares_outstanding * close_prices[-1]
        si_concentration = short_interest * close_prices[-1] / max(market_cap, 1e-8)
        eng.append(si_concentration)
        
        # 10. NEW: Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 11. NEW: Short Volume Momentum
        # Measures the rate of change in short volume over the last few days
        sv_momentum = 0
        if len(short_volume) >= 5:
            sv_momentum = (np.mean(short_volume[-2:]) / max(np.mean(short_volume[-5:-2]), 1e-8)) - 1
        eng.append(sv_momentum)
        
        # 12. NEW: Implied Volatility to Historical Volatility Ratio
        # Compares market expectations (IV) to realized volatility
        iv_hv_ratio = options_avg_implied_volatility / max(volatility, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 13. NEW: Short Interest Velocity
        # Second derivative of short interest - acceleration of shorting
        si_velocity = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            si_velocity = si_growth - prev_growth
        eng.append(si_velocity)
        
        # 14. NEW: Average True Range (ATR) - Volatility measure
        atr = 0
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                true_ranges.append(max(high_low, high_close, low_close))
            atr = np.mean(true_ranges) if true_ranges else 0
        eng.append(atr)
        
        # 15. NEW: Short Volume to Options Put/Call Ratio
        # Relates short selling activity to options market sentiment
        sv_options_ratio = avg_short_ratio / max(options_put_call_ratio, 1e-8)
        eng.append(sv_options_ratio)
        
        # 16. NEW: Relative Short Interest Position
        # Compares current short interest to its recent range
        rel_si_position = 0
        if t >= 5:
            si_history = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(si_history)
            si_max = max(si_history)
            si_range = si_max - si_min
            if si_range > 1e-8:
                rel_si_position = (short_interest - si_min) / si_range
            else:
                rel_si_position = 0.5  # Neutral if no range
        eng.append(rel_si_position)
        
        # 17. NEW: Short Interest to Synthetic Short Cost Efficiency
        # Measures how much short interest exists relative to the cost of synthetic shorting
        si_cost_efficiency = short_interest / max(options_synthetic_short_cost, 1e-8)
        eng.append(si_cost_efficiency)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 303900.2888
RMSE: 469423.8078
MAPE: 8.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t0: importance=0.0009, rank=1
   2. Feature_19_t2: importance=0.0009, rank=2
   3. Feature_10_t2: importance=0.0006, rank=3
   4. Feature_4_t1: importance=0.0005, rank=4
   5. Feature_19_t3: importance=0.0005, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.13%

📈 Current best MAPE: 8.90%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_10_t0, Feature_19_t2, Feature_10_t2, Feature_4_t1, Feature_19_t3 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest
            avg_volume,                      # Always keep average volume
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            shares_outstanding,              # Important for normalization
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        earlier_short_ratio = np.mean(daily_short_ratio[:-5]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric - high importance in previous iteration
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 8. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 9. Short Interest Concentration
        # Measures how concentrated short interest is relative to total market cap
        market_cap = shares_outstanding * close_prices[-1]
        si_concentration = short_interest * close_prices[-1] / max(market_cap, 1e-8)
        eng.append(si_concentration)
        
        # 10. NEW: Relative Strength Index (RSI) - 14 day
        # Technical indicator that measures the magnitude of recent price changes
        # to evaluate overbought or oversold conditions - often used by short sellers
        rsi = 0
        if len(close_prices) >= 3:
            delta = np.diff(close_prices)
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            avg_gain = gain / max(len(delta), 1e-8)
            avg_loss = loss / max(len(delta), 1e-8)
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        eng.append(rsi)
        
        # 11. NEW: Short Volume Acceleration
        # Third derivative of short volume - rate of change of momentum
        sv_acceleration = 0
        if len(short_volume) >= 5:
            recent_sv = np.mean(short_volume[-2:])
            mid_sv = np.mean(short_volume[-4:-2])
            early_sv = np.mean(short_volume[-5:-4])
            recent_momentum = (recent_sv / max(mid_sv, 1e-8)) - 1
            early_momentum = (mid_sv / max(early_sv, 1e-8)) - 1
            sv_acceleration = recent_momentum - early_momentum
        eng.append(sv_acceleration)
        
        # 12. NEW: Short Interest to Implied Volatility Ratio
        # Relates short interest to market's expectation of volatility
        si_iv_ratio = short_interest / max(options_avg_implied_volatility, 1e-8)
        eng.append(si_iv_ratio)
        
        # 13. NEW: Bollinger Band Width
        # Measures volatility - wider bands indicate higher volatility
        bb_width = 0
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(sma, 1e-8)
        eng.append(bb_width)
        
        # 14. NEW: Short Interest Velocity Normalized by Volume
        # Second derivative of short interest normalized by trading volume
        si_velocity_norm = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            current_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            si_velocity = current_growth - prev_growth
            si_velocity_norm = si_velocity / max(avg_volume, 1e-8) * 1000  # Scale for numerical stability
        eng.append(si_velocity_norm)
        
        # 15. NEW: Short Volume to Put/Call Ratio Correlation
        # Measures alignment between short selling and options market sentiment
        sv_pc_alignment = avg_short_ratio * options_put_call_ratio
        eng.append(sv_pc_alignment)
        
        # 16. NEW: Price Gap Analysis
        # Identifies significant overnight price gaps - often triggers for short positions
        price_gaps = 0
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            gaps = []
            for i in range(1, min(len(open_prices), len(close_prices))):
                gap = abs(open_prices[i] - close_prices[i-1]) / max(close_prices[i-1], 1e-8)
                gaps.append(gap)
            price_gaps = np.mean(gaps) if gaps else 0
        eng.append(price_gaps)
        
        # 17. NEW: Short Interest Efficiency
        # Measures how effectively short sellers are timing their positions
        si_efficiency = 0
        if t > 0 and data[t-1, 0] > 0 and len(close_prices) >= 2:
            price_change = (close_prices[-1] / max(close_prices[0], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            # Negative correlation (price down, SI up) is efficient
            si_efficiency = -1 * si_change * price_change
        eng.append(si_efficiency)
        
        # 18. NEW: Short Interest Relative to Historical Range (Z-score)
        # Standardizes current short interest against its historical distribution
        si_zscore = 0
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_mean = np.mean(si_history)
            si_std = np.std(si_history)
            if si_std > 1e-8:
                si_zscore = (short_interest - si_mean) / si_std
        eng.append(si_zscore)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 316019.7523
RMSE: 482679.0186
MAPE: 9.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 43

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t3: importance=0.0008, rank=1
   2. Feature_9_t0: importance=0.0008, rank=2
   3. Feature_21_t0: importance=0.0007, rank=3
   4. Feature_12_t3: importance=0.0006, rank=4
   5. Feature_21_t1: importance=0.0006, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.21%

📈 Current best MAPE: 8.90%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_23_t3, Feature_9_t0, Feature_21_t0, Feature_12_t3, Feature_21_t1 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest
            avg_volume,                      # Always keep average volume
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            shares_outstanding,              # Important for normalization
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        earlier_short_ratio = np.mean(daily_short_ratio[:-5]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric - high importance in previous iteration
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 8. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 9. Short Interest Concentration
        # Measures how concentrated short interest is relative to total market cap
        market_cap = shares_outstanding * close_prices[-1]
        si_concentration = short_interest * close_prices[-1] / max(market_cap, 1e-8)
        eng.append(si_concentration)
        
        # 10. Relative Strength Index (RSI) - 14 day
        # Technical indicator that measures the magnitude of recent price changes
        # to evaluate overbought or oversold conditions - often used by short sellers
        rsi = 50  # Default to neutral
        if len(close_prices) >= 3:
            delta = np.diff(close_prices)
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            avg_gain = gain / max(len(delta), 1e-8)
            avg_loss = loss / max(len(delta), 1e-8)
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        eng.append(rsi)
        
        # 11. NEW: Volatility-Adjusted Short Interest
        # Normalizes short interest by recent price volatility
        vol_adj_si = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            vol_adj_si = short_interest * price_volatility
        eng.append(vol_adj_si)
        
        # 12. NEW: Short Interest Momentum
        # Second derivative of short interest - acceleration of short interest changes
        si_momentum = 0
        if t >= 2:
            prev_si = data[t-1, 0]
            prev_prev_si = data[t-2, 0]
            if prev_prev_si > 0:
                prev_growth = (prev_si / max(prev_prev_si, 1e-8)) - 1
                current_growth = (short_interest / max(prev_si, 1e-8)) - 1
                si_momentum = current_growth - prev_growth
        eng.append(si_momentum)
        
        # 13. NEW: Short Volume Trend Strength
        # Measures consistency of short volume trend using coefficient of variation
        sv_trend_strength = 0
        if len(short_volume) >= 5:
            sv_mean = np.mean(short_volume[-5:])
            sv_std = np.std(short_volume[-5:])
            sv_trend_strength = sv_std / max(sv_mean, 1e-8)  # Lower values indicate more consistent trend
        eng.append(sv_trend_strength)
        
        # 14. NEW: Options-Adjusted Short Interest
        # Combines short interest with options market sentiment
        options_adj_si = short_interest * options_put_call_ratio / max(options_avg_implied_volatility, 1e-8)
        eng.append(options_adj_si)
        
        # 15. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency_ratio = 0
        if len(close_prices) >= 5 and t > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1 if data[t-1, 0] > 0 else 0
            # Negative correlation is more efficient for shorts
            si_efficiency_ratio = -1 * si_change * price_change
        eng.append(si_efficiency_ratio)
        
        # 16. NEW: Short Interest to Synthetic Short Cost Ratio
        # Compares actual short interest to the cost of creating synthetic shorts
        si_synthetic_ratio = short_interest / max(options_synthetic_short_cost, 1e-8)
        eng.append(si_synthetic_ratio)
        
        # 17. NEW: Short Interest Divergence from Volume
        # Measures when short interest and trading volume trends diverge
        si_volume_divergence = 0
        if t > 0 and data[t-1, 0] > 0 and data[t-1, 1] > 0:
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            vol_change = (avg_volume / max(data[t-1, 1], 1e-8)) - 1
            si_volume_divergence = si_change - vol_change
        eng.append(si_volume_divergence)
        
        # 18. NEW: Normalized Short Volume Trend
        # Measures the trend in short volume normalized by total volume
        norm_sv_trend = 0
        if len(daily_short_ratio) >= 5:
            norm_sv_trend = (np.mean(daily_short_ratio[-2:]) / max(np.mean(daily_short_ratio[-5:-2]), 1e-8)) - 1
        eng.append(norm_sv_trend)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 311896.7506
RMSE: 478089.5279
MAPE: 8.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 40
   • Highly important features (top 5%): 20

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0022, rank=1
   2. Feature_21_t3: importance=0.0009, rank=2
   3. Feature_9_t0: importance=0.0006, rank=3
   4. Feature_19_t2: importance=0.0006, rank=4
   5. Feature_20_t0: importance=0.0004, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -0.02%

📈 Current best MAPE: 8.90%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_4_t1, Feature_21_t3, Feature_9_t0, Feature_19_t2, Feature_20_t0 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest
            avg_volume,                      # Always keep average volume
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        recent_short_ratio = np.mean(daily_short_ratio[-5:]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        earlier_short_ratio = np.mean(daily_short_ratio[:-5]) if len(daily_short_ratio) >= 5 else avg_short_ratio
        short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric - high importance in previous iteration
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 8. Short Volume Intensity (max daily short volume / avg daily short volume)
        # Identifies days with unusual shorting activity
        max_short = np.max(short_volume) if len(short_volume) > 0 else 0
        avg_short = np.mean(short_volume) if len(short_volume) > 0 else 1e-8
        short_intensity = max_short / max(avg_short, 1e-8)
        eng.append(short_intensity)
        
        # 9. NEW: Volatility-Adjusted Short Interest Growth
        # Combines volatility with short interest growth - better than previous volatility-adjusted SI
        vol_adj_si_growth = 0
        if t > 0 and data[t-1, 0] > 0 and len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            si_growth_local = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            vol_adj_si_growth = si_growth_local * price_volatility
        eng.append(vol_adj_si_growth)
        
        # 10. NEW: Short Interest Acceleration
        # Second derivative of short interest - acceleration of short interest changes
        # Refined from previous iteration's momentum calculation
        si_acceleration = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_si_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            current_si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            si_acceleration = current_si_growth - prev_si_growth
        eng.append(si_acceleration)
        
        # 11. NEW: Short Volume Trend Consistency
        # Measures consistency of short volume trend using linear regression slope
        sv_trend_consistency = 0
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            sv_trend_consistency = slope / max(np.mean(y), 1e-8)  # Normalized slope
        eng.append(sv_trend_consistency)
        
        # 12. NEW: Options-Adjusted Short Interest Ratio
        # Combines short interest with options market sentiment, normalized by shares outstanding
        options_adj_si_ratio = (short_interest * options_put_call_ratio) / max(shares_outstanding, 1e-8)
        eng.append(options_adj_si_ratio)
        
        # 13. NEW: Short Interest Efficiency Ratio (Improved)
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency = 0
        if len(close_prices) >= 5 and t > 0 and data[t-1, 0] > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            # Negative correlation is more efficient for shorts (refined calculation)
            si_efficiency = -1 * si_change * np.sign(price_change) * np.log1p(abs(price_change) + 1e-8)
        eng.append(si_efficiency)
        
        # 14. NEW: Short Interest to Synthetic Short Cost Ratio (Improved)
        # Compares actual short interest to the cost of creating synthetic shorts
        si_synthetic_ratio = short_interest * close_prices[-1] / max(options_synthetic_short_cost, 1e-8)
        eng.append(si_synthetic_ratio)
        
        # 15. NEW: Short Interest Divergence from Volume (Improved)
        # Measures when short interest and trading volume trends diverge
        si_volume_divergence = 0
        if t > 0 and data[t-1, 0] > 0 and data[t-1, 1] > 0:
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            vol_change = (avg_volume / max(data[t-1, 1], 1e-8)) - 1
            # Using log ratio to better capture divergence
            si_volume_divergence = np.log1p(si_change + 1e-8) - np.log1p(vol_change + 1e-8)
        eng.append(si_volume_divergence)
        
        # 16. NEW: Short Volume to Price Volatility Ratio
        # Relates short selling activity to price volatility
        sv_vol_ratio = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            sv_vol_ratio = avg_short_ratio / max(price_volatility, 1e-8)
        eng.append(sv_vol_ratio)
        
        # 17. NEW: Short Interest Relative to Market Conditions
        # Adjusts short interest by implied volatility to account for market conditions
        market_adjusted_si = short_interest / max(options_avg_implied_volatility, 1e-8)
        eng.append(market_adjusted_si)
        
        # 18. NEW: Short Volume Momentum
        # Captures the acceleration in daily short volume
        sv_momentum = 0
        if len(short_volume) >= 5:
            recent_sv = np.mean(short_volume[-2:])
            earlier_sv = np.mean(short_volume[-5:-2])
            sv_momentum = (recent_sv / max(earlier_sv, 1e-8)) - 1
        eng.append(sv_momentum)
        
        # 19. NEW: Relative Short Interest Position
        # Measures current short interest relative to its recent range
        rel_si_position = 0
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min, si_max = np.min(si_history), np.max(si_history)
            si_range = si_max - si_min
            if si_range > 0:
                rel_si_position = (short_interest - si_min) / max(si_range, 1e-8)
            else:
                rel_si_position = 0.5  # Neutral if no range
        eng.append(rel_si_position)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 294152.9512
RMSE: 456379.1451
MAPE: 8.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 50
   • Highly important features (top 5%): 15

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0014, rank=1
   2. Feature_18_t3: importance=0.0011, rank=2
   3. Feature_16_t1: importance=0.0006, rank=3
   4. Feature_11_t3: importance=0.0006, rank=4
   5. Feature_23_t1: importance=0.0006, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.36%

📈 Current best MAPE: 8.54%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 8
======================================================================
🤖 Calling Claude for iteration 8...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_7_t0, Feature_18_t3, Feature_16_t1, Feature_11_t3, Feature_23_t1 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest
            avg_volume,                      # Always keep average volume
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            # Adding one more raw feature that was important in previous iterations
            options_synthetic_short_cost,    # Cost of synthetic shorts - important for arbitrage
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Short Interest to Days to Cover Ratio - high importance in previous iteration (Feature_7_t0)
        # Normalizes short interest by the days to cover metric
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 4. Short Volume Momentum - high importance in previous iteration (Feature_18_t3)
        # Captures the acceleration in daily short volume
        sv_momentum = 0
        if len(short_volume) >= 5:
            recent_sv = np.mean(short_volume[-2:])
            earlier_sv = np.mean(short_volume[-5:-2])
            sv_momentum = (recent_sv / max(earlier_sv, 1e-8)) - 1
        eng.append(sv_momentum)
        
        # 5. Short Volume to Price Volatility Ratio - high importance in previous iteration (Feature_16_t1)
        # Relates short selling activity to price volatility
        sv_vol_ratio = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            sv_vol_ratio = avg_short_ratio / max(price_volatility, 1e-8)
        eng.append(sv_vol_ratio)
        
        # 6. Short Interest Efficiency Ratio - high importance in previous iteration (Feature_11_t3)
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency = 0
        if len(close_prices) >= 5 and t > 0 and data[t-1, 0] > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            # Negative correlation is more efficient for shorts
            si_efficiency = -1 * si_change * np.sign(price_change) * np.log1p(abs(price_change) + 1e-8)
        eng.append(si_efficiency)
        
        # 7. Relative Short Interest Position - high importance in previous iteration (Feature_23_t1)
        # Measures current short interest relative to its recent range
        rel_si_position = 0
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min, si_max = np.min(si_history), np.max(si_history)
            si_range = si_max - si_min
            if si_range > 0:
                rel_si_position = (short_interest - si_min) / max(si_range, 1e-8)
            else:
                rel_si_position = 0.5  # Neutral if no range
        eng.append(rel_si_position)
        
        # 8. NEW: Short Interest Concentration
        # Measures how concentrated short interest is relative to total market cap
        # Higher values indicate more concentrated short positions
        market_cap = shares_outstanding * close_prices[-1]
        si_concentration = (short_interest * close_prices[-1]) / max(market_cap, 1e-8)
        eng.append(si_concentration)
        
        # 9. NEW: Short Interest Velocity
        # First derivative of short interest over time, normalized by shares outstanding
        # Improved version of previous SI growth rate
        si_velocity = 0
        if t > 0:
            prev_si_ratio = data[t-1, 0] / max(shares_outstanding, 1e-8)
            current_si_ratio = short_interest / max(shares_outstanding, 1e-8)
            si_velocity = (current_si_ratio - prev_si_ratio) / max(prev_si_ratio, 1e-8)
        eng.append(si_velocity)
        
        # 10. NEW: Short Interest Acceleration (Second Derivative)
        # Improved version that normalizes by shares outstanding for better scaling
        si_acceleration = 0
        if t >= 2:
            prev_velocity = 0
            if data[t-2, 0] > 0:
                prev_si_ratio_t1 = data[t-1, 0] / max(shares_outstanding, 1e-8)
                prev_si_ratio_t2 = data[t-2, 0] / max(shares_outstanding, 1e-8)
                prev_velocity = (prev_si_ratio_t1 - prev_si_ratio_t2) / max(prev_si_ratio_t2, 1e-8)
            
            current_velocity = si_velocity  # Reuse the previously calculated velocity
            si_acceleration = current_velocity - prev_velocity
        eng.append(si_acceleration)
        
        # 11. NEW: Short Interest to Options Volume Ratio
        # Relates short interest to options activity - captures potential hedging
        si_options_ratio = short_interest / max(options_put_call_ratio, 1e-8)
        eng.append(si_options_ratio)
        
        # 12. NEW: Short Interest Pressure Index
        # Combines short interest, days to cover, and implied volatility
        # Higher values indicate more pressure on short positions
        si_pressure = (short_interest * days_to_cover) / max(options_avg_implied_volatility, 1e-8)
        eng.append(si_pressure)
        
        # 13. NEW: Short Volume Trend Strength
        # Measures the strength and consistency of short volume trend using regression R²
        sv_trend_strength = 0
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            # Calculate slope and R² of linear regression
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            y_pred = np.mean(y) + slope * (x - np.mean(x))
            ss_total = np.sum((y - np.mean(y))**2)
            ss_residual = np.sum((y - y_pred)**2)
            sv_trend_strength = 1 - (ss_residual / max(ss_total, 1e-8))
            # Sign the R² by the slope direction
            sv_trend_strength *= np.sign(slope)
        eng.append(sv_trend_strength)
        
        # 14. NEW: Short Interest Relative to Historical Volatility
        # Adjusts short interest by historical price volatility
        hist_volatility = 0
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            hist_volatility = np.std(returns)
        si_vol_adjusted = short_interest / max(hist_volatility, 1e-8)
        eng.append(si_vol_adjusted)
        
        # 15. NEW: Short Interest Divergence Score
        # Measures divergence between short interest and price trends
        # Positive values indicate short interest increasing while price increases (potential squeeze)
        si_divergence = 0
        if t > 0 and len(close_prices) >= 5:
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_divergence = si_change * price_change  # Positive when both move in same direction
        eng.append(si_divergence)
        
        # 16. NEW: Short Volume Intensity Relative to Price Range
        # Relates short volume to price volatility
        sv_price_range_ratio = 0
        if len(close_prices) >= 5:
            price_range = (np.max(high_prices[-5:]) - np.min(low_prices[-5:])) / max(np.mean(close_prices[-5:]), 1e-8)
            sv_price_range_ratio = avg_short_ratio / max(price_range, 1e-8)
        eng.append(sv_price_range_ratio)
        
        # 17. NEW: Short Interest Synthetic Cost Efficiency
        # Measures efficiency of actual shorts vs synthetic shorts
        si_synthetic_efficiency = (short_interest * close_prices[-1]) / max(options_synthetic_short_cost, 1e-8)
        eng.append(si_synthetic_efficiency)
        
        # 18. NEW: Weighted Short Volume Trend
        # Weights recent short volume more heavily than older data
        weighted_sv_trend = 0
        if len(short_volume) >= 5:
            weights = np.array([0.1, 0.15, 0.2, 0.25, 0.3])  # More weight to recent days
            weighted_sv = np.sum(weights * short_volume[-5:]) / np.sum(weights)
            weighted_sv_trend = weighted_sv / max(np.mean(short_volume[-5:]), 1e-8) - 1
        eng.append(weighted_sv_trend)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_7_t0, Feature_18_t3, Feature_16_t1, Feature_11_t3, Feature_23_t1 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest (critical target-related feature)
            avg_volume,                      # Always keep average volume (critical liquidity indicator)
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
            shares_outstanding,              # Important for normalizing short interest
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # Normalized measure of short interest relative to total shares
        # High importance in previous iterations
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity - refined calculation
        if len(daily_short_ratio) >= 10:
            recent_short_ratio = np.mean(daily_short_ratio[-5:])
            earlier_short_ratio = np.mean(daily_short_ratio[-10:-5])
            short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 4. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 5. Short Interest to Volume Ratio
        # Measures how many days of average volume the short interest represents
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 6. Price Momentum (5-day) - important for short sellers
        momentum_5d = 0
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        eng.append(momentum_5d)
        
        # 7. Short Interest to Days to Cover Ratio
        # Normalizes short interest by the days to cover metric - high importance in previous iteration
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # 8. Volatility-Adjusted Short Interest
        # Combines volatility with short interest - better signal in volatile conditions
        vol_adj_si = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            vol_adj_si = short_interest * price_volatility
        eng.append(vol_adj_si)
        
        # 9. Short Interest Acceleration (second derivative)
        # Second derivative of short interest - acceleration of short interest changes
        si_acceleration = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_si_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            current_si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            si_acceleration = current_si_growth - prev_si_growth
        eng.append(si_acceleration)
        
        # 10. Short Volume Trend Strength
        # Measures strength and consistency of short volume trend using regression
        sv_trend_strength = 0
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            sv_trend_strength = slope / max(np.mean(y), 1e-8)  # Normalized slope
        eng.append(sv_trend_strength)
        
        # 11. Options-Adjusted Short Interest
        # Combines short interest with options market sentiment
        options_adj_si = short_interest * options_put_call_ratio
        eng.append(options_adj_si)
        
        # 12. Short Interest Efficiency
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency = 0
        if len(close_prices) >= 5 and t > 0 and data[t-1, 0] > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            # Negative correlation is more efficient for shorts
            si_efficiency = -1 * si_change * np.sign(price_change) * np.log1p(abs(price_change) + 1e-8)
        eng.append(si_efficiency)
        
        # 13. Short Interest to Synthetic Short Cost Ratio
        # Compares actual short interest to the cost of creating synthetic shorts
        si_synthetic_ratio = short_interest / max(options_synthetic_short_cost, 1e-8)
        eng.append(si_synthetic_ratio)
        
        # 14. Short Interest Divergence from Volume
        # Measures when short interest and trading volume trends diverge
        si_volume_divergence = 0
        if t > 0 and data[t-1, 0] > 0 and data[t-1, 1] > 0:
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            vol_change = (avg_volume / max(data[t-1, 1], 1e-8)) - 1
            si_volume_divergence = si_change - vol_change
        eng.append(si_volume_divergence)
        
        # 15. Relative Short Interest Position
        # Measures current short interest relative to its recent range
        rel_si_position = 0
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min, si_max = np.min(si_history), np.max(si_history)
            si_range = si_max - si_min
            if si_range > 0:
                rel_si_position = (short_interest - si_min) / max(si_range, 1e-8)
            else:
                rel_si_position = 0.5  # Neutral if no range
        eng.append(rel_si_position)
        
        # 16. NEW: Short Interest to Price Ratio
        # Normalizes short interest by current price level
        si_price_ratio = 0
        if len(close_prices) > 0 and close_prices[-1] > 0:
            si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
        eng.append(si_price_ratio)
        
        # 17. NEW: Short Volume Concentration
        # Measures if short volume is concentrated in specific days
        sv_concentration = 0
        if len(short_volume) > 0 and np.sum(short_volume) > 0:
            normalized_sv = short_volume / max(np.sum(short_volume), 1e-8)
            # Gini-inspired concentration measure
            sv_concentration = np.sum(np.abs(normalized_sv - 1/len(normalized_sv)))
        eng.append(sv_concentration)
        
        # 18. NEW: Short Interest to Implied Volatility Ratio
        # Relates short interest to market's expectation of volatility
        si_iv_ratio = short_interest / max(options_avg_implied_volatility, 1e-8)
        eng.append(si_iv_ratio)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 8 (claude) (SVM)
==================================================
Training SVM model...

Iteration 8 (claude) Performance:
MAE: 294906.3322
RMSE: 460949.0490
MAPE: 8.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_18_t3: importance=0.0016, rank=1
   2. Feature_16_t1: importance=0.0009, rank=2
   3. Feature_5_t3: importance=0.0006, rank=3
   4. Feature_18_t2: importance=0.0005, rank=4
   5. Feature_8_t3: importance=0.0005, rank=5
💾 Saved code for iteration 8 to iteration_codes dictionary
📊 No significant improvement. Change: +0.03%

📈 Current best MAPE: 8.54%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 9
======================================================================
🤖 Calling Claude for iteration 9...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_18_t3, Feature_16_t1, Feature_5_t3, Feature_18_t2, Feature_8_t3 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest (critical target-related feature)
            avg_volume,                      # Always keep average volume (critical liquidity indicator)
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest to Shares Outstanding Ratio
        # Normalized measure of short interest relative to total shares
        # High importance in previous iterations (Feature_18_t3 was top performer)
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity - high importance in previous iterations
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 3. Short Interest to Implied Volatility Ratio
        # Relates short interest to market's expectation of volatility
        # This was Feature_18_t2 in previous iteration - high importance
        si_iv_ratio = short_interest / max(options_avg_implied_volatility, 1e-8)
        eng.append(si_iv_ratio)
        
        # 4. Short Interest to Price Ratio
        # Normalizes short interest by current price level
        # This was Feature_16_t1 in previous iteration - high importance
        si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
        eng.append(si_price_ratio)
        
        # 5. Short Interest Growth Rate - high importance in previous iteration
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 6. Short Interest to Volume Ratio (Days to Cover alternative)
        # Measures how many days of average volume the short interest represents
        # This was Feature_5_t3 in previous iteration - high importance
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 7. Recent Short Volume Trend (last 5 days vs previous 10)
        # Captures acceleration in shorting activity
        if len(daily_short_ratio) >= 10:
            recent_short_ratio = np.mean(daily_short_ratio[-5:])
            earlier_short_ratio = np.mean(daily_short_ratio[-10:-5])
            short_trend = recent_short_ratio / max(earlier_short_ratio, 1e-8) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 8. Volatility-Adjusted Short Interest
        # Combines volatility with short interest - better signal in volatile conditions
        # This was Feature_8_t3 in previous iteration - high importance
        vol_adj_si = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            vol_adj_si = short_interest * price_volatility
        eng.append(vol_adj_si)
        
        # 9. Short Interest Acceleration (second derivative)
        # Second derivative of short interest - acceleration of short interest changes
        si_acceleration = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            prev_si_growth = (data[t-1, 0] / max(data[t-2, 0], 1e-8)) - 1
            current_si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            si_acceleration = current_si_growth - prev_si_growth
        eng.append(si_acceleration)
        
        # 10. NEW: Short Interest Relative to Historical Range
        # Measures where current short interest sits within its recent historical range
        si_range_position = 0.5  # Default to middle if not enough history
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min, si_max = np.min(si_history), np.max(si_history)
            si_range = si_max - si_min
            if si_range > 0:
                si_range_position = (short_interest - si_min) / max(si_range, 1e-8)
        eng.append(si_range_position)
        
        # 11. NEW: Short Interest Momentum Divergence
        # Measures divergence between short interest momentum and price momentum
        si_price_divergence = 0
        if t > 0 and len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_momentum = (short_interest / max(data[t-1, 0], 1e-8)) - 1 if data[t-1, 0] > 0 else 0
            si_price_divergence = si_momentum - price_momentum
        eng.append(si_price_divergence)
        
        # 12. NEW: Short Volume Concentration Index
        # Measures if short volume is concentrated in specific days (improved calculation)
        sv_concentration = 0
        if np.sum(short_volume) > 0:
            # Calculate normalized short volume (as proportion of total)
            norm_sv = short_volume / max(np.sum(short_volume), 1e-8)
            # Calculate Herfindahl-Hirschman Index (HHI) - measure of concentration
            sv_concentration = np.sum(norm_sv**2)
        eng.append(sv_concentration)
        
        # 13. NEW: Options-Adjusted Short Interest Trend
        # Combines short interest trend with options market sentiment trend
        options_adj_si_trend = 0
        if t > 0 and data[t-1, 63] > 0:
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1 if data[t-1, 0] > 0 else 0
            options_change = (options_put_call_ratio / max(data[t-1, 63], 1e-8)) - 1
            # Positive when both move in same direction (alignment of signals)
            options_adj_si_trend = si_change * options_change
        eng.append(options_adj_si_trend)
        
        # 14. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency = 0
        if len(close_prices) >= 5 and t > 0 and data[t-1, 0] > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            # Negative correlation is more efficient for shorts (improved calculation)
            if abs(price_change) > 1e-8:
                si_efficiency = -1 * si_change / max(abs(price_change), 1e-8)
        eng.append(si_efficiency)
        
        # 15. NEW: Short Interest to Synthetic Short Cost Ratio with Trend
        # Compares actual short interest to the cost of creating synthetic shorts, with trend component
        si_synthetic_ratio = short_interest / max(options_synthetic_short_cost, 1e-8)
        si_synthetic_trend = 0
        if t > 0 and data[t-1, 64] > 0 and data[t-1, 0] > 0:
            prev_ratio = data[t-1, 0] / max(data[t-1, 64], 1e-8)
            si_synthetic_trend = (si_synthetic_ratio / max(prev_ratio, 1e-8)) - 1
        eng.append(si_synthetic_ratio * (1 + si_synthetic_trend))
        
        # 16. NEW: Short Interest Volatility
        # Measures the volatility of short interest over time
        si_volatility = 0
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_mean = np.mean(si_history)
            if si_mean > 0:
                si_volatility = np.std(si_history) / max(si_mean, 1e-8)
        eng.append(si_volatility)
        
        # 17. NEW: Short Volume Trend Strength with Momentum
        # Measures strength and consistency of short volume trend using regression with momentum
        sv_trend_strength = 0
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            sv_trend_strength = slope / max(np.mean(y), 1e-8)  # Normalized slope
            
            # Add momentum component
            if len(short_volume) >= 10:
                prev_y = short_volume[-10:-5]
                prev_slope = (np.mean(x*prev_y) - np.mean(x)*np.mean(prev_y)) / max(np.var(x), 1e-8)
                prev_norm_slope = prev_slope / max(np.mean(prev_y), 1e-8)
                # Combine current trend with acceleration
                sv_trend_strength = sv_trend_strength * (1 + (sv_trend_strength - prev_norm_slope))
        eng.append(sv_trend_strength)
        
        # 18. NEW: Short Interest to Price Volatility Ratio
        # Relates short interest to recent price volatility
        si_price_vol_ratio = 0
        if len(close_prices) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            si_price_vol_ratio = short_interest / max(price_volatility, 1e-8)
        eng.append(si_price_vol_ratio)
        
        # 19. NEW: Composite Short Pressure Index
        # Combines multiple short indicators into a single composite measure
        short_pressure = 0
        components = [
            si_ratio,                    # Short interest to shares outstanding
            avg_short_ratio,             # Average short volume ratio
            options_put_call_ratio,      # Options put/call ratio
            si_volume_ratio              # Short interest to volume ratio
        ]
        # Normalize and combine components
        short_pressure = np.mean(components)
        eng.append(short_pressure)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 9 (claude) (SVM)
==================================================
Training SVM model...

Iteration 9 (claude) Performance:
MAE: 291934.9906
RMSE: 446530.2242
MAPE: 8.63%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t3: importance=0.0008, rank=1
   2. Feature_12_t2: importance=0.0006, rank=2
   3. Feature_17_t2: importance=0.0005, rank=3
   4. Feature_17_t3: importance=0.0004, rank=4
   5. Feature_12_t0: importance=0.0004, rank=5
💾 Saved code for iteration 9 to iteration_codes dictionary
📊 No significant improvement. Change: -0.10%

📈 Current best MAPE: 8.54%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 10
======================================================================
🤖 Calling Claude for iteration 10...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        
        # Extract shares outstanding
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep critical raw features based on previous importance analysis
        # Feature_5_t3, Feature_12_t2, Feature_17_t2, Feature_17_t3, Feature_12_t0 were top performers
        raw_keep.extend([
            short_interest,                  # Always keep short interest (critical target-related feature)
            avg_volume,                      # Always keep average volume (critical liquidity indicator)
            days_to_cover,                   # Important for short interest dynamics
            close_prices[-1],                # Most recent close price
            options_put_call_ratio,          # Important options sentiment indicator
            options_avg_implied_volatility,  # Market's expectation of volatility
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest to Volume Ratio (Days to Cover alternative)
        # Measures how many days of average volume the short interest represents
        # This was Feature_5_t3 in previous iteration - highest importance
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 2. Short Volume Concentration Index
        # Measures if short volume is concentrated in specific days
        # This was Feature_12_t2 in previous iteration - second highest importance
        sv_concentration = 0
        if np.sum(short_volume) > 0:
            # Calculate normalized short volume (as proportion of total)
            norm_sv = short_volume / max(np.sum(short_volume), 1e-8)
            # Calculate Herfindahl-Hirschman Index (HHI) - measure of concentration
            sv_concentration = np.sum(norm_sv**2)
        eng.append(sv_concentration)
        
        # 3. Short Volume Trend Strength with Momentum
        # Measures strength and consistency of short volume trend
        # This was Feature_17_t2 and Feature_17_t3 in previous iteration - high importance
        sv_trend_strength = 0
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            sv_trend_strength = slope / max(np.mean(y), 1e-8)  # Normalized slope
            
            # Add momentum component
            if len(short_volume) >= 10:
                prev_y = short_volume[-10:-5]
                prev_slope = (np.mean(x*prev_y) - np.mean(x)*np.mean(prev_y)) / max(np.var(x), 1e-8)
                prev_norm_slope = prev_slope / max(np.mean(prev_y), 1e-8)
                # Combine current trend with acceleration
                sv_trend_strength = sv_trend_strength * (1 + (sv_trend_strength - prev_norm_slope))
        eng.append(sv_trend_strength)
        
        # 4. Short Interest to Shares Outstanding Ratio
        # Normalized measure of short interest relative to total shares
        si_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_ratio)
        
        # 5. Short Volume Ratio (average of daily short volume / total volume)
        # Daily shorting intensity
        daily_short_ratio = short_volume / np.maximum(total_volume, 1e-8)
        avg_short_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_ratio)
        
        # 6. Short Interest Growth Rate
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(data[t-1, 0], 1e-8)) - 1
        eng.append(si_growth)
        
        # 7. NEW: Exponentially Weighted Short Interest Growth
        # Gives more weight to recent changes in short interest
        ew_si_growth = 0
        if t >= 3:
            si_history = np.array([data[t-i, 0] for i in range(4)])
            weights = np.array([0.5, 0.25, 0.15, 0.1])  # Exponential weights
            if si_history[1] > 0:  # Avoid division by zero
                growth_rates = [(si_history[i] / max(si_history[i+1], 1e-8)) - 1 for i in range(3)]
                growth_rates.append(0)  # Padding for the oldest point
                ew_si_growth = np.sum(weights * growth_rates)
        eng.append(ew_si_growth)
        
        # 8. Short Interest to Implied Volatility Ratio
        # Relates short interest to market's expectation of volatility
        si_iv_ratio = short_interest / max(options_avg_implied_volatility, 1e-8)
        eng.append(si_iv_ratio)
        
        # 9. NEW: Volatility-Adjusted Short Volume Trend
        # Combines price volatility with short volume trend
        vol_adj_sv_trend = 0
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            
            # Calculate short volume trend
            x = np.arange(5)
            y = short_volume[-5:]
            slope = (np.mean(x*y) - np.mean(x)*np.mean(y)) / max(np.var(x), 1e-8)
            norm_slope = slope / max(np.mean(y), 1e-8)
            
            # Adjust trend by volatility - higher volatility amplifies the trend signal
            vol_adj_sv_trend = norm_slope * (1 + price_volatility)
        eng.append(vol_adj_sv_trend)
        
        # 10. NEW: Short Interest Momentum Oscillator
        # Measures momentum of short interest changes using a modified RSI approach
        si_momentum_osc = 0.5  # Default to neutral
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(6)])
            si_changes = np.diff(si_history)
            
            # Calculate positive and negative changes
            pos_changes = np.sum(np.maximum(si_changes, 0))
            neg_changes = np.sum(np.abs(np.minimum(si_changes, 0)))
            
            # Calculate RSI-like oscillator
            if pos_changes + neg_changes > 0:
                si_momentum_osc = pos_changes / (pos_changes + neg_changes)
        eng.append(si_momentum_osc)
        
        # 11. NEW: Short Interest to Price Momentum Divergence
        # Measures divergence between short interest and price momentum
        si_price_divergence = 0
        if t > 0 and len(close_prices) >= 5:
            # Calculate price momentum (5-day)
            price_momentum = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            
            # Calculate short interest momentum
            si_momentum = (short_interest / max(data[t-1, 0], 1e-8)) - 1 if data[t-1, 0] > 0 else 0
            
            # Calculate divergence (positive when short interest increases while price increases)
            si_price_divergence = si_momentum - (-1 * price_momentum)
        eng.append(si_price_divergence)
        
        # 12. NEW: Short Volume Intensity Index
        # Measures the intensity of short selling relative to recent average
        sv_intensity = 0
        if len(short_volume) >= 10 and np.mean(short_volume[-10:]) > 0:
            recent_sv = np.mean(short_volume[-3:])
            baseline_sv = np.mean(short_volume[-10:])
            sv_intensity = (recent_sv / max(baseline_sv, 1e-8)) - 1
        eng.append(sv_intensity)
        
        # 13. NEW: Options-Adjusted Short Interest Indicator
        # Combines short interest with options market sentiment
        options_adj_si = 0
        if options_put_call_ratio > 0:
            # Higher values indicate stronger bearish sentiment alignment
            options_adj_si = short_interest * options_put_call_ratio / max(shares_outstanding, 1e-8)
        eng.append(options_adj_si)
        
        # 14. NEW: Short Interest Efficiency Ratio (Improved)
        # Measures how effectively short positions are being established relative to price movement
        si_efficiency = 0
        if len(close_prices) >= 5 and t > 0 and data[t-1, 0] > 0:
            # Calculate absolute price change
            abs_price_change = abs((close_prices[-1] / max(close_prices[-5], 1e-8)) - 1)
            
            # Calculate absolute short interest change
            abs_si_change = abs((short_interest / max(data[t-1, 0], 1e-8)) - 1)
            
            # Efficiency ratio: how much short interest change per unit of price change
            if abs_price_change > 1e-8:
                si_efficiency = abs_si_change / abs_price_change
        eng.append(si_efficiency)
        
        # 15. NEW: Short Interest Volatility Ratio
        # Compares volatility of short interest to price volatility
        si_vol_ratio = 0
        if t >= 5 and len(close_prices) >= 5:
            # Calculate short interest volatility
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_volatility = np.std(si_history) / max(np.mean(si_history), 1e-8)
            
            # Calculate price volatility
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            
            # Calculate ratio
            si_vol_ratio = si_volatility / max(price_volatility, 1e-8)
        eng.append(si_vol_ratio)
        
        # 16. NEW: Short Volume to Options Volume Alignment
        # Measures alignment between short volume and options put/call ratio
        sv_options_alignment = 0
        if t > 0 and data[t-1, 63] > 0:
            # Calculate short volume trend
            if np.mean(short_volume) > 0 and np.mean(total_volume) > 0:
                sv_ratio = np.mean(short_volume) / max(np.mean(total_volume), 1e-8)
                prev_sv_ratio = 0
                if t > 0:
                    prev_short_volume = data[t-1, 67:82]
                    prev_total_volume = data[t-1, 82:97]
                    if np.mean(prev_total_volume) > 0:
                        prev_sv_ratio = np.mean(prev_short_volume) / max(np.mean(prev_total_volume), 1e-8)
                
                sv_trend = (sv_ratio / max(prev_sv_ratio, 1e-8)) - 1 if prev_sv_ratio > 0 else 0
                
                # Calculate options trend
                options_trend = (options_put_call_ratio / max(data[t-1, 63], 1e-8)) - 1
                
                # Alignment is positive when both move in same direction
                sv_options_alignment = sv_trend * options_trend
        eng.append(sv_options_alignment)
        
        # 17. NEW: Composite Short Pressure Index (Improved)
        # Combines multiple short indicators into a single normalized composite measure
        components = []
        
        # Add normalized short interest to shares outstanding
        if shares_outstanding > 0:
            components.append(min(1.0, short_interest / max(shares_outstanding * 0.2, 1e-8)))
        
        # Add normalized short volume ratio
        if np.mean(total_volume) > 0:
            components.append(min(1.0, np.mean(short_volume) / max(np.mean(total_volume), 1e-8) * 2))
        
        # Add normalized options put/call ratio
        if options_put_call_ratio > 0:
            components.append(min(1.0, options_put_call_ratio / 2.0))
        
        # Add normalized days to cover
        components.append(min(1.0, days_to_cover / 10.0))
        
        # Calculate composite index
        short_pressure = np.mean(components) if components else 0
        eng.append(short_pressure)
        
        # 18. NEW: Short Interest Mean Reversion Indicator
        # Measures potential for mean reversion in short interest
        si_mean_reversion = 0
        if t >= 10:
            si_history = np.array([data[max(0, t-i), 0] for i in range(10)])
            si_mean = np.mean(si_history)
            si_std = np.std(si_history)
            
            if si_std > 0:
                # Calculate z-score of current short interest
                si_z_score = (short_interest - si_mean) / max(si_std, 1e-8)
                
                # Mean reversion potential increases with distance from mean
                si_mean_reversion = abs(si_z_score)
        eng.append(si_mean_reversion)
        
        # 19. NEW: Short Interest Acceleration (Improved)
        # Second derivative of short interest with smoothing
        si_acceleration = 0
        if t >= 3:
            # Get short interest history
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            si_t3 = data[t-3, 0] if t >= 3 else si_t2
            
            # Calculate first derivatives (growth rates)
            if si_t2 > 0 and si_t3 > 0:
                growth_t1_t2 = (si_t1 / max(si_t2, 1e-8)) - 1
                growth_t2_t3 = (si_t2 / max(si_t3, 1e-8)) - 1
                
                # Calculate second derivative (acceleration)
                si_acceleration = growth_t1_t2 - growth_t2_t3
                
                # Apply smoothing
                si_acceleration = si_acceleration * (1 - 0.5 * abs(si_acceleration))
        eng.append(si_acceleration)
        
        # Ensure we don't exceed MAX_NEW engineered features
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent size
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle any NaN or infinite values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 10 (claude) (SVM)
==================================================
Training SVM model...

Iteration 10 (claude) Performance:
MAE: 294196.6105
RMSE: 450580.6680
MAPE: 8.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 52
   • Highly important features (top 5%): 27

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_8_t1: importance=0.0020, rank=1
   2. Feature_5_t3: importance=0.0010, rank=2
   3. Feature_14_t1: importance=0.0008, rank=3
   4. Feature_7_t2: importance=0.0006, rank=4
   5. Feature_1_t0: importance=0.0005, rank=5
💾 Saved code for iteration 10 to iteration_codes dictionary
📊 No significant improvement. Change: -0.16%

📈 Current best MAPE: 8.54%
🔄 Iterations without improvement: 3/5

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 433260.6397
RMSE: 572048.8168
MAPE: 10.76%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 164
   • Highly important features (top 5%): 93

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t2: importance=0.0004, rank=1
   2. Feature_72_t3: importance=0.0004, rank=2
   3. Feature_69_t2: importance=0.0004, rank=3
   4. Feature_63_t0: importance=0.0003, rank=4
   5. Feature_84_t2: importance=0.0003, rank=5
   Baseline MAPE: 10.76%
   Baseline MAE: 433260.6397
   Baseline RMSE: 572048.8168

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 397176.2983
RMSE: 530171.4999
MAPE: 10.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t1: importance=0.0011, rank=1
   2. Feature_18_t3: importance=0.0007, rank=2
   3. Feature_9_t0: importance=0.0006, rank=3
   4. Feature_5_t3: importance=0.0005, rank=4
   5. Feature_23_t3: importance=0.0004, rank=5

📊 Best Model Test Set Performance:
   MAPE: 10.18%
   MAE: 397176.2983
   RMSE: 530171.4999

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 10.76%
   Best Model MAPE: 10.18%
   Absolute Improvement: 0.58%
   Relative Improvement: 5.4%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  10.03           N/A                 
1          Iteration 1               9.15            +0.87%              
2          Iteration 2               9.03            +0.12%              
3          Iteration 3               8.95            +0.08%              
4          Iteration 4               8.90            +0.13%              
5          Iteration 5               9.11            -0.21%              
6          Iteration 6               8.92            -0.02%              
7          Iteration 7               8.54            +0.36%              
8          Iteration 8               8.51            +0.03%              
9          Iteration 9               8.63            -0.10%              
10         Iteration 10              8.69            -0.16%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 8 - MAPE: 8.51%
✅ Saved IART results to cache/IART_iterative_results_enhanced.pkl
✅ Summary report saved for IART

🎉 Process completed successfully for IART!

================================================================================
PROCESSING TICKER 8/14: SRPT
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for SRPT
======================================================================
📊 Loading data from parquet file...
📊 Loading data for SRPT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SRPT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'SRPT' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 519356.7616
RMSE: 763111.9647
MAPE: 9.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 75
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_66_t1: importance=0.0002, rank=1
   2. Feature_66_t2: importance=0.0001, rank=2
   3. Feature_2_t0: importance=0.0001, rank=3
   4. Feature_64_t3: importance=0.0001, rank=4
   5. Feature_1_t1: importance=0.0001, rank=5

📊 Baseline Performance: MAPE = 9.38%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover (important per baseline)
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options data (synthetic short cost had high importance)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This is a key indicator of short selling pressure
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent Short Volume Ratio Trend (last 5 days vs previous 10)
        recent_svr = np.mean(short_volume_ratio[-5:])
        previous_svr = np.mean(short_volume_ratio[:-5])
        svr_trend = recent_svr / max(previous_svr, 1e-8) - 1
        eng.append(svr_trend)
        
        # 3. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often correlates with short interest changes
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility indicator
        # Measures market volatility which can affect short selling
        atr_values = []
        for i in range(1, len(high_prices)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        normalized_atr = atr / max(close_prices[-1], 1e-8)
        eng.append(normalized_atr)
        
        # 7. Short Volume Acceleration
        # Measures the rate of change in short volume
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-5:-3])
            short_vol_accel = recent_short_vol / max(prev_short_vol, 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 8. Volume Pressure (ratio of recent volume to longer-term average)
        recent_volume = np.mean(total_volume[-3:])
        avg_volume = np.mean(total_volume)
        volume_pressure = recent_volume / max(avg_volume, 1e-8)
        eng.append(volume_pressure)
        
        # 9. Price Range Relative to Average
        # Measures if recent price movements are unusual
        if len(high_prices) > 0 and len(low_prices) > 0:
            recent_range = high_prices[-1] - low_prices[-1]
            avg_range = np.mean(high_prices - low_prices)
            relative_range = recent_range / max(avg_range, 1e-8)
        else:
            relative_range = 0
        eng.append(relative_range)
        
        # 10. Short Interest to Volume Ratio
        # Relates short interest to trading volume
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 11. Implied Volatility Normalized
        # Options implied volatility normalized by historical volatility
        implied_vol = data[t, 65]
        iv_normalized = implied_vol / max(volatility, 1e-8)
        eng.append(iv_normalized)
        
        # 12. Put-Call Ratio Change
        # Rate of change in options sentiment
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 13. Price to Moving Average Ratio
        # Indicates overbought/oversold conditions
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(ma10, 1e-8)
        else:
            price_to_ma = 1
        eng.append(price_to_ma)
        
        # 14. RSI (Relative Strength Index)
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) > 1:
            delta = np.diff(close_prices)
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            
            avg_gain = gain / max(len(delta), 1e-8)
            avg_loss = loss / max(len(delta), 1e-8)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50
        eng.append(rsi)
        
        # 15. Short Volume to Average Volume Ratio
        # Compares recent short volume to average trading volume
        recent_short_vol_avg = np.mean(short_volume[-5:])
        short_vol_to_avg = recent_short_vol_avg / max(data[t, 1], 1e-8)
        eng.append(short_vol_to_avg)
        
        # 16. OHLC Price Compression
        # Last day's OHLC data compressed to a single value
        if len(close_prices) > 0:
            last_open = open_prices[-1]
            last_high = high_prices[-1]
            last_low = low_prices[-1]
            last_close = close_prices[-1]
            
            # Normalize by the average price
            avg_price = (last_open + last_high + last_low + last_close) / 4
            price_compression = (last_high - last_low) / max(avg_price, 1e-8)
        else:
            price_compression = 0
        eng.append(price_compression)
        
        # 17. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 18. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # 19. Synthetic Short Cost to Implied Vol Ratio
        # Relationship between shorting cost and market expectations
        synth_short_to_iv = data[t, 64] / max(data[t, 65], 1e-8)
        eng.append(synth_short_to_iv)
        
        # 20. Days to Cover Change
        # Rate of change in days to cover
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 448949.4449
RMSE: 684739.7055
MAPE: 8.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 47
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t1: importance=0.0003, rank=1
   2. Feature_21_t2: importance=0.0002, rank=2
   3. Feature_15_t1: importance=0.0002, rank=3
   4. Feature_15_t2: importance=0.0002, rank=4
   5. Feature_16_t2: importance=0.0001, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 1.33%

📈 Current best MAPE: 8.05%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options data (synthetic short cost had high importance)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was a high importance feature in previous iteration
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Weighted Short Volume Ratio (more weight to recent days)
        # Improvement: Add recency bias to short volume ratio
        weights = np.linspace(0.5, 1.5, len(short_volume_ratio))
        weighted_svr = np.sum(weights * short_volume_ratio) / np.sum(weights)
        eng.append(weighted_svr)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often correlates with short interest changes
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Bollinger Band Position
        # Indicates if price is overbought/oversold relative to volatility
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_position = (close_prices[-1] - sma) / max(2 * std, 1e-8)  # Normalized position within bands
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 7. Short Volume Acceleration
        # Measures the rate of change in short volume
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-5:-3])
            short_vol_accel = recent_short_vol / max(prev_short_vol, 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 8. Volume Pressure (ratio of recent volume to longer-term average)
        recent_volume = np.mean(total_volume[-3:]) if len(total_volume) >= 3 else np.mean(total_volume)
        avg_volume = np.mean(total_volume)
        volume_pressure = recent_volume / max(avg_volume, 1e-8)
        eng.append(volume_pressure)
        
        # 9. Short Interest to Volume Ratio
        # Relates short interest to trading volume
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 10. Implied Volatility Normalized
        # Options implied volatility normalized by historical volatility
        implied_vol = data[t, 65]
        iv_normalized = implied_vol / max(volatility, 1e-8)
        eng.append(iv_normalized)
        
        # 11. Put-Call Ratio Change
        # Rate of change in options sentiment
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 12. RSI (Relative Strength Index)
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) > 1:
            delta = np.diff(close_prices)
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            
            avg_gain = gain / max(len(delta), 1e-8)
            avg_loss = loss / max(len(delta), 1e-8)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50
        eng.append(rsi)
        
        # 13. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 14. Days to Cover Change
        # Rate of change in days to cover
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # 15. VWAP (Volume Weighted Average Price) Ratio
        # Compare current price to VWAP to identify potential pressure points
        if len(close_prices) > 0 and len(total_volume) > 0:
            vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
            vwap_ratio = close_prices[-1] / max(vwap, 1e-8)
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 16. Short Volume Trend Strength
        # Measures consistency of short volume trend
        if len(short_volume) >= 5:
            x = np.arange(len(short_volume[-5:]))
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (len(x) * np.sum(x * y) - np.sum(x) * np.sum(y)) / max(len(x) * np.sum(x**2) - np.sum(x)**2, 1e-8)
            # Normalize by average short volume
            trend_strength = slope / max(np.mean(short_volume[-5:]), 1e-8)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 17. Short Volume to Implied Volatility Ratio
        # Relates short selling activity to market expectations
        avg_short_vol = np.mean(short_volume)
        short_vol_to_iv = avg_short_vol / max(data[t, 65], 1e-8)
        eng.append(short_vol_to_iv)
        
        # 18. Synthetic Short Cost Change
        # Rate of change in cost to short
        synth_short_change = 0
        if t > 0:
            prev_cost = data[t-1, 64]
            synth_short_change = data[t, 64] / max(prev_cost, 1e-8) - 1
        eng.append(synth_short_change)
        
        # 19. Price Gap Analysis
        # Identifies significant overnight price gaps which may indicate sentiment shifts
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gap = open_prices[-1] / max(close_prices[-2], 1e-8) - 1
        else:
            overnight_gap = 0
        eng.append(overnight_gap)
        
        # 20. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 455131.0252
RMSE: 689852.4601
MAPE: 8.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 58
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0002, rank=1
   2. Feature_17_t2: importance=0.0002, rank=2
   3. Feature_14_t2: importance=0.0001, rank=3
   4. Feature_3_t2: importance=0.0001, rank=4
   5. Feature_14_t1: importance=0.0001, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -0.06%

📈 Current best MAPE: 8.05%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options synthetic short cost (high importance in baseline)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance feature
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Recent Price Trend (5-day)
        # Using exponential weighting to emphasize more recent price changes
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            price_trend = np.sum(weights * (close_prices[-5:] / close_prices[-5] - 1))
        else:
            price_trend = 0
        eng.append(price_trend)
        
        # 4. Price Volatility (Parkinson's measure - uses high-low range)
        # More robust volatility measure than standard deviation of returns
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            hl_ratio = np.log(high_prices[-5:] / low_prices[-5:])
            parkinson_vol = np.sqrt(np.sum(hl_ratio**2) / (4 * np.log(2) * 5))
        else:
            parkinson_vol = 0
        eng.append(parkinson_vol)
        
        # 5. Short Volume Trend
        # Linear regression slope of short volume over last 5 days
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            x_mean = np.mean(x)
            y_mean = np.mean(y)
            slope_num = np.sum((x - x_mean) * (y - y_mean))
            slope_den = max(np.sum((x - x_mean)**2), 1e-8)
            short_vol_trend = slope_num / slope_den
            # Normalize by mean short volume
            short_vol_trend = short_vol_trend / max(y_mean, 1e-8)
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 6. Short Volume Acceleration
        # Second derivative of short volume - captures changing momentum
        if len(short_volume) >= 7:
            first_diff = np.diff(short_volume[-7:])
            second_diff = np.diff(first_diff)
            short_accel = np.mean(second_diff) / max(np.mean(short_volume[-7:]), 1e-8)
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 7. Relative Short Interest
        # Short interest relative to historical range (z-score)
        if t >= 3:  # Need some history
            si_history = np.array([data[max(0, t-i), 0] for i in range(3)])
            si_mean = np.mean(si_history)
            si_std = max(np.std(si_history), 1e-8)
            rel_si = (data[t, 0] - si_mean) / si_std
        else:
            rel_si = 0
        eng.append(rel_si)
        
        # 8. Short Interest to Volume Ratio
        # Relates short interest to trading volume - high importance in previous iteration
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 9. Implied Volatility to Historical Volatility Ratio
        # Options market expectation vs realized volatility
        iv_to_hv = data[t, 65] / max(parkinson_vol, 1e-8)
        eng.append(iv_to_hv)
        
        # 10. Put-Call Ratio
        # Options market sentiment indicator
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 11. RSI (Relative Strength Index) with adaptive lookback
        # Momentum oscillator with lookback based on available data
        lookback = min(14, len(close_prices)-1)
        if lookback > 0:
            delta = np.diff(close_prices[-lookback-1:])
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            
            avg_gain = gain / max(lookback, 1e-8)
            avg_loss = loss / max(lookback, 1e-8)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50
        eng.append(rsi)
        
        # 12. Short Interest Momentum
        # Rate of change in short interest
        si_momentum = 0
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 13. Days to Cover Change
        # Rate of change in days to cover - high importance in previous iteration
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # 14. VWAP Deviation
        # Price deviation from volume-weighted average price
        if len(close_prices) > 0 and len(total_volume) > 0:
            vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
            vwap_dev = (close_prices[-1] / max(vwap, 1e-8)) - 1
        else:
            vwap_dev = 0
        eng.append(vwap_dev)
        
        # 15. Short Volume to Implied Volatility Ratio
        # Relates short selling activity to market expectations - high importance
        avg_short_vol = np.mean(short_volume)
        short_vol_to_iv = avg_short_vol / max(data[t, 65], 1e-8)
        eng.append(short_vol_to_iv)
        
        # 16. Synthetic Short Cost Change
        # Rate of change in cost to short - high importance
        synth_short_change = 0
        if t > 0:
            prev_cost = data[t-1, 64]
            synth_short_change = data[t, 64] / max(prev_cost, 1e-8) - 1
        eng.append(synth_short_change)
        
        # 17. Price Gap Analysis
        # Identifies significant overnight price gaps
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gap = open_prices[-1] / max(close_prices[-2], 1e-8) - 1
        else:
            overnight_gap = 0
        eng.append(overnight_gap)
        
        # 18. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # 19. Money Flow Index (MFI)
        # Volume-weighted RSI - combines price and volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            typical_price = (high_prices[-5:] + low_prices[-5:] + close_prices[-5:]) / 3
            money_flow = typical_price * total_volume[-5:]
            
            pos_flow = np.sum(np.where(np.diff(np.append([typical_price[0]], typical_price)) >= 0, 
                                       money_flow[1:], 0))
            neg_flow = np.sum(np.where(np.diff(np.append([typical_price[0]], typical_price)) < 0, 
                                       money_flow[1:], 0))
            
            if pos_flow + neg_flow > 0:
                mfi = 100 * pos_flow / (pos_flow + neg_flow)
            else:
                mfi = 50
        else:
            mfi = 50
        eng.append(mfi)
        
        # 20. Chaikin Money Flow (CMF)
        # Measures buying and selling pressure
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5 and len(total_volume) >= 5:
            mf_multiplier = ((close_prices[-5:] - low_prices[-5:]) - 
                             (high_prices[-5:] - close_prices[-5:])) / (high_prices[-5:] - low_prices[-5:])
            mf_multiplier = np.where(high_prices[-5:] - low_prices[-5:] > 1e-8, mf_multiplier, 0)
            mf_volume = mf_multiplier * total_volume[-5:]
            cmf = np.sum(mf_volume) / max(np.sum(total_volume[-5:]), 1e-8)
        else:
            cmf = 0
        eng.append(cmf)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (5,) (4,) () 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options data (synthetic short cost had high importance)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was a high importance feature in previous iteration
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Exponentially Weighted Short Volume Ratio (more weight to recent days)
        # Improvement: Use exponential weighting instead of linear for better recency bias
        weights = np.exp(np.linspace(0, 1, len(short_volume_ratio)))
        weighted_svr = np.sum(weights * short_volume_ratio) / np.sum(weights)
        eng.append(weighted_svr)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often correlates with short interest changes
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Bollinger Band Position
        # Indicates if price is overbought/oversold relative to volatility
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_position = (close_prices[-1] - sma) / max(2 * std, 1e-8)  # Normalized position within bands
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 7. Short Volume Acceleration
        # Measures the rate of change in short volume
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-5:-3])
            short_vol_accel = recent_short_vol / max(prev_short_vol, 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 8. Volume Pressure (ratio of recent volume to longer-term average)
        recent_volume = np.mean(total_volume[-3:]) if len(total_volume) >= 3 else np.mean(total_volume)
        avg_volume = np.mean(total_volume)
        volume_pressure = recent_volume / max(avg_volume, 1e-8)
        eng.append(volume_pressure)
        
        # 9. Short Interest to Volume Ratio
        # Relates short interest to trading volume
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 10. Implied Volatility Normalized
        # Options implied volatility normalized by historical volatility
        implied_vol = data[t, 65]
        iv_normalized = implied_vol / max(volatility, 1e-8)
        eng.append(iv_normalized)
        
        # 11. Put-Call Ratio
        # Options sentiment indicator
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 12. RSI (Relative Strength Index)
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) > 1:
            delta = np.diff(close_prices)
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            
            avg_gain = gain / max(len(delta), 1e-8)
            avg_loss = loss / max(len(delta), 1e-8)
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50
        eng.append(rsi)
        
        # 13. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 14. Days to Cover Change
        # Rate of change in days to cover
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # 15. VWAP (Volume Weighted Average Price) Ratio
        # Compare current price to VWAP to identify potential pressure points
        if len(close_prices) > 0 and len(total_volume) > 0:
            vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
            vwap_ratio = close_prices[-1] / max(vwap, 1e-8)
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 16. Short Volume Trend Strength
        # Measures consistency of short volume trend
        if len(short_volume) >= 5:
            x = np.arange(len(short_volume[-5:]))
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (len(x) * np.sum(x * y) - np.sum(x) * np.sum(y)) / max(len(x) * np.sum(x**2) - np.sum(x)**2, 1e-8)
            # Normalize by average short volume
            trend_strength = slope / max(np.mean(short_volume[-5:]), 1e-8)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 17. Short Volume to Implied Volatility Ratio
        # Relates short selling activity to market expectations
        avg_short_vol = np.mean(short_volume)
        short_vol_to_iv = avg_short_vol / max(data[t, 65], 1e-8)
        eng.append(short_vol_to_iv)
        
        # 18. Synthetic Short Cost Change
        # Rate of change in cost to short
        synth_short_change = 0
        if t > 0:
            prev_cost = data[t-1, 64]
            synth_short_change = data[t, 64] / max(prev_cost, 1e-8) - 1
        eng.append(synth_short_change)
        
        # 19. Average True Range (ATR)
        # Measures volatility considering gaps between sessions
        if len(high_prices) >= 2 and len(low_prices) >= 2 and len(close_prices) >= 2:
            tr_values = []
            for i in range(1, min(len(high_prices), 5)):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr = np.mean(tr_values) if tr_values else 0
            # Normalize by price level
            atr_normalized = atr / max(close_prices[-1], 1e-8)
        else:
            atr_normalized = 0
        eng.append(atr_normalized)
        
        # 20. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 454038.6030
RMSE: 683224.6240
MAPE: 8.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 48
   • Highly important features (top 5%): 32

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t2: importance=0.0004, rank=1
   2. Feature_3_t1: importance=0.0001, rank=2
   3. Feature_10_t1: importance=0.0001, rank=3
   4. Feature_14_t2: importance=0.0001, rank=4
   5. Feature_1_t1: importance=0.0001, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -0.06%

📈 Current best MAPE: 8.05%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options synthetic short cost (high importance in baseline)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was a high importance feature in previous iteration
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Recent Short Volume Ratio (last 5 days)
        # Focus on more recent short volume activity which may be more predictive
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else avg_short_volume_ratio
        eng.append(recent_svr)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend - high importance in previous iteration
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often correlates with short interest changes
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Interest to Volume Ratio
        # Relates short interest to trading volume - high importance in previous iteration
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 7. Put-Call Ratio
        # Options sentiment indicator
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 8. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 9. Days to Cover Change
        # Rate of change in days to cover - high importance in previous iteration
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # 10. Short Volume Trend Strength
        # Measures consistency of short volume trend
        if len(short_volume) >= 5:
            x = np.arange(len(short_volume[-5:]))
            y = short_volume[-5:]
            # Simple linear regression slope calculation
            slope = (len(x) * np.sum(x * y) - np.sum(x) * np.sum(y)) / max(len(x) * np.sum(x**2) - np.sum(x)**2, 1e-8)
            # Normalize by average short volume
            trend_strength = slope / max(np.mean(short_volume[-5:]), 1e-8)
        else:
            trend_strength = 0
        eng.append(trend_strength)
        
        # 11. Synthetic Short Cost Change
        # Rate of change in cost to short
        synth_short_change = 0
        if t > 0:
            prev_cost = data[t-1, 64]
            synth_short_change = data[t, 64] / max(prev_cost, 1e-8) - 1
        eng.append(synth_short_change)
        
        # 12. Implied Volatility (direct value)
        # Using raw IV instead of normalized version for more direct signal
        implied_vol = data[t, 65]
        eng.append(implied_vol)
        
        # 13. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # 14. Recent Price Range Normalized
        # Captures recent price action volatility
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            avg_price = np.mean(close_prices[-5:])
            norm_range = (recent_high - recent_low) / max(avg_price, 1e-8)
        else:
            norm_range = 0
        eng.append(norm_range)
        
        # 15. Short Volume to Total Volume Acceleration
        # Measures change in short selling intensity
        if len(short_volume_ratio) >= 5:
            recent_ratio = np.mean(short_volume_ratio[-2:])
            prev_ratio = np.mean(short_volume_ratio[-5:-2])
            svr_accel = recent_ratio / max(prev_ratio, 1e-8) - 1
        else:
            svr_accel = 0
        eng.append(svr_accel)
        
        # 16. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations
        si_to_iv = data[t, 0] / max(data[t, 65], 1e-8)
        eng.append(si_to_iv)
        
        # 17. Price Gap Significance
        # Measures overnight price jumps which may indicate significant news
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gaps = []
            for i in range(1, min(len(open_prices), 5)):
                gap = abs(open_prices[-i] - close_prices[-(i+1)]) / max(close_prices[-(i+1)], 1e-8)
                overnight_gaps.append(gap)
            avg_gap = np.mean(overnight_gaps) if overnight_gaps else 0
        else:
            avg_gap = 0
        eng.append(avg_gap)
        
        # 18. Volume Weighted Price Momentum
        # Price momentum weighted by volume to capture stronger signals
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            weighted_returns = []
            for i in range(1, 5):
                ret = (close_prices[-i] / max(close_prices[-(i+1)], 1e-8) - 1) * total_volume[-i]
                weighted_returns.append(ret)
            vw_momentum = np.sum(weighted_returns) / max(np.sum(total_volume[-5:]), 1e-8)
        else:
            vw_momentum = 0
        eng.append(vw_momentum)
        
        # 19. Short Volume Ratio Divergence from Price
        # Measures when short selling activity diverges from price action
        if len(close_prices) >= 5 and len(short_volume_ratio) >= 5:
            price_change = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
            svr_change = short_volume_ratio[-1] / max(np.mean(short_volume_ratio[-5:-1]), 1e-8) - 1
            # Positive divergence: price up but short volume ratio also up (unusual)
            # Negative divergence: price down but short volume ratio down (unusual)
            divergence = svr_change * price_change
        else:
            divergence = 0
        eng.append(divergence)
        
        # 20. Short Interest Relative to Historical Range
        # Position of current short interest within its historical range
        si_rel_position = 0
        if t >= 5:
            historical_si = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(historical_si)
            si_max = max(historical_si)
            si_range = si_max - si_min
            if si_range > 0:
                si_rel_position = (data[t, 0] - si_min) / si_range
            else:
                si_rel_position = 0.5  # Middle if no range
        eng.append(si_rel_position)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 455725.9458
RMSE: 684906.0206
MAPE: 8.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 50
   • Highly important features (top 5%): 40

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t2: importance=0.0002, rank=1
   2. Feature_3_t1: importance=0.0001, rank=2
   3. Feature_12_t2: importance=0.0001, rank=3
   4. Feature_10_t0: importance=0.0001, rank=4
   5. Feature_4_t2: importance=0.0001, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.06%

📈 Current best MAPE: 8.05%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options synthetic short cost (high importance in baseline)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance feature
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Recent Short Volume Ratio Trend (last 5 days)
        # Improved: Calculate slope instead of just average
        if len(short_volume_ratio) >= 5:
            x = np.arange(5)
            y = short_volume_ratio[-5:]
            slope = (5 * np.sum(x * y) - np.sum(x) * np.sum(y)) / max(5 * np.sum(x**2) - np.sum(x)**2, 1e-8)
            recent_svr_trend = slope / max(np.mean(short_volume_ratio[-5:]), 1e-8)  # Normalized slope
        else:
            recent_svr_trend = 0
        eng.append(recent_svr_trend)
        
        # 4. Price Momentum (5-day)
        # Improved: Use exponentially weighted momentum to give more weight to recent price changes
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-6:-1], 1e-8)
            momentum_5d = np.sum(returns * weights[1:])
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Relative Strength Index (RSI)
        # New feature: RSI is a momentum oscillator that measures the speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default neutral value
        eng.append(rsi)
        
        # 6. Short Interest to Volume Ratio
        # Relates short interest to trading volume
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 7. Options Market Sentiment Composite
        # Improved: Combine put-call ratio with implied volatility for a more comprehensive options sentiment
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        options_sentiment = put_call_ratio * implied_vol / 100  # Normalize
        eng.append(options_sentiment)
        
        # 8. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 9. Days to Cover Change Rate
        # Improved: Use exponential smoothing for more stable signal
        dtc_change = 0
        if t > 0:
            alpha = 0.7  # Smoothing factor
            prev_dtc_change = 0
            if t > 1:
                prev_dtc = data[t-2, 2]
                prev_dtc_change = data[t-1, 2] / max(prev_dtc, 1e-8) - 1
            
            current_dtc_change = data[t, 2] / max(data[t-1, 2], 1e-8) - 1
            dtc_change = alpha * current_dtc_change + (1-alpha) * prev_dtc_change
        eng.append(dtc_change)
        
        # 10. Bollinger Band Position
        # New feature: Position of price within Bollinger Bands (technical indicator)
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            # Position within bands (0 = at lower band, 1 = at upper band)
            bb_position = (close_prices[-1] - lower_band) / max(upper_band - lower_band, 1e-8)
            # Clamp to [0, 1]
            bb_position = max(0, min(1, bb_position))
        else:
            bb_position = 0.5  # Default to middle
        eng.append(bb_position)
        
        # 11. Synthetic Short Cost Change Rate
        # Rate of change in cost to short with smoothing
        synth_short_change = 0
        if t > 0:
            prev_cost = data[t-1, 64]
            synth_short_change = data[t, 64] / max(prev_cost, 1e-8) - 1
        eng.append(synth_short_change)
        
        # 12. Short Volume Concentration
        # New feature: Measures how concentrated short volume is in specific days
        if len(short_volume) >= 5:
            # Gini coefficient-like measure for concentration
            sorted_sv = np.sort(short_volume[-5:])
            n = len(sorted_sv)
            cumsum = np.cumsum(sorted_sv)
            concentration = (n + 1 - 2 * np.sum(cumsum) / (cumsum[-1] * n)) / n if cumsum[-1] > 0 else 0
        else:
            concentration = 0
        eng.append(concentration)
        
        # 13. Price Volatility to Implied Volatility Ratio
        # New feature: Compares realized volatility to market expectations
        if len(close_prices) > 5:
            returns = np.diff(close_prices[-6:]) / np.maximum(close_prices[-7:-1], 1e-8)
            realized_vol = np.std(returns) * np.sqrt(252)  # Annualized
            vol_ratio = realized_vol / max(data[t, 65], 1e-8)
        else:
            vol_ratio = 1.0  # Default to balanced
        eng.append(vol_ratio)
        
        # 14. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # 15. VWAP Deviation
        # New feature: Deviation of current price from Volume Weighted Average Price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_deviation = (close_prices[-1] / max(vwap, 1e-8)) - 1
        else:
            vwap_deviation = 0
        eng.append(vwap_deviation)
        
        # 16. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations
        si_to_iv = data[t, 0] / max(data[t, 65], 1e-8)
        eng.append(si_to_iv)
        
        # 17. Money Flow Index
        # New feature: Volume-weighted RSI that indicates buying/selling pressure
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            typical_price = (high_prices[-14:] + low_prices[-14:] + close_prices[-14:]) / 3
            money_flow = typical_price * total_volume[-14:]
            
            delta_tp = np.diff(typical_price)
            pos_flow = np.sum(money_flow[1:][delta_tp > 0])
            neg_flow = np.sum(money_flow[1:][delta_tp < 0])
            
            money_ratio = pos_flow / max(neg_flow, 1e-8)
            mfi = 100 - (100 / (1 + money_ratio))
        else:
            mfi = 50  # Default neutral value
        eng.append(mfi)
        
        # 18. Short Volume Acceleration
        # Improved: Measure of change in short volume momentum
        if len(short_volume) >= 7:
            # First derivative (momentum)
            momentum_1 = np.mean(short_volume[-3:]) - np.mean(short_volume[-6:-3])
            momentum_2 = np.mean(short_volume[-4:-1]) - np.mean(short_volume[-7:-4])
            # Second derivative (acceleration)
            acceleration = momentum_1 - momentum_2
            # Normalize by average short volume
            norm_acceleration = acceleration / max(np.mean(short_volume[-7:]), 1e-8)
        else:
            norm_acceleration = 0
        eng.append(norm_acceleration)
        
        # 19. Short Interest Relative to Historical Range
        # Position of current short interest within its historical range
        si_rel_position = 0
        if t >= 5:
            historical_si = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(historical_si)
            si_max = max(historical_si)
            si_range = si_max - si_min
            if si_range > 0:
                si_rel_position = (data[t, 0] - si_min) / si_range
            else:
                si_rel_position = 0.5  # Middle if no range
        eng.append(si_rel_position)
        
        # 20. Average True Range (ATR)
        # New feature: Measure of market volatility
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr = np.mean(tr_values)
            # Normalize by average price
            norm_atr = atr / max(np.mean(close_prices[-5:]), 1e-8)
        else:
            norm_atr = 0
        eng.append(norm_atr)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options synthetic short cost (high importance in baseline)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was a high importance feature in previous iteration
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding to get relative measure
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Recent Short Volume Ratio (last 5 days)
        # Focus on more recent short volume activity which may be more predictive
        recent_svr = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else avg_short_volume_ratio
        eng.append(recent_svr)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend - high importance in previous iteration
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # High volatility often correlates with short interest changes
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Interest to Volume Ratio
        # Relates short interest to trading volume - high importance in previous iteration
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 7. Put-Call Ratio
        # Options sentiment indicator
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 8. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 9. Days to Cover Change
        # Rate of change in days to cover - high importance in previous iteration
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # 10. Implied Volatility (direct value)
        # Using raw IV instead of normalized version for more direct signal
        implied_vol = data[t, 65]
        eng.append(implied_vol)
        
        # 11. Short Volume Ratio Volatility
        # Measures consistency of short selling pressure
        svr_volatility = np.std(short_volume_ratio) if len(short_volume_ratio) > 1 else 0
        eng.append(svr_volatility)
        
        # 12. Recent Price Range Normalized
        # Captures recent price action volatility
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            avg_price = np.mean(close_prices[-5:])
            norm_range = (recent_high - recent_low) / max(avg_price, 1e-8)
        else:
            norm_range = 0
        eng.append(norm_range)
        
        # 13. RSI (Relative Strength Index) - 14 period
        # Technical indicator to identify overbought/oversold conditions
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 14. VWAP (Volume Weighted Average Price) - Deviation
        # Measures price action relative to volume, important for institutional activity
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            typical_price = (high_prices[-5:] + low_prices[-5:] + close_prices[-5:]) / 3
            vwap = np.sum(typical_price * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_deviation = (close_prices[-1] / max(vwap, 1e-8)) - 1
        else:
            vwap_deviation = 0
        eng.append(vwap_deviation)
        
        # 15. Short Volume Acceleration
        # Measures rate of change in short volume, indicating changing sentiment
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            short_vol_accel = recent_short_vol / max(prev_short_vol, 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 16. Bollinger Band Width
        # Measures volatility expansion/contraction
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 17. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations
        si_to_iv = data[t, 0] / max(data[t, 65], 1e-8)
        eng.append(si_to_iv)
        
        # 18. Money Flow Index (MFI)
        # Volume-weighted RSI, identifies buying/selling pressure
        if len(close_prices) >= 14 and len(high_prices) >= 14 and len(low_prices) >= 14 and len(total_volume) >= 14:
            typical_price = (high_prices + low_prices + close_prices) / 3
            money_flow = typical_price * total_volume
            
            delta_tp = np.diff(typical_price)
            pos_flow = np.zeros_like(delta_tp)
            neg_flow = np.zeros_like(delta_tp)
            
            for i in range(len(delta_tp)):
                if delta_tp[i] > 0:
                    pos_flow[i] = money_flow[i+1]
                else:
                    neg_flow[i] = money_flow[i+1]
            
            pos_flow_sum = np.sum(pos_flow[-14:])
            neg_flow_sum = np.sum(neg_flow[-14:])
            
            money_ratio = pos_flow_sum / max(neg_flow_sum, 1e-8)
            mfi = 100 - (100 / (1 + money_ratio))
        else:
            mfi = 50  # Neutral value
        eng.append(mfi)
        
        # 19. Short Volume Trend vs Price Trend Divergence
        # Identifies when short selling activity diverges from price action
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_trend = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
            short_vol_trend = short_volume[-1] / max(short_volume[-5], 1e-8) - 1
            # Positive when price and short volume move in same direction (unusual)
            divergence = price_trend * short_vol_trend
        else:
            divergence = 0
        eng.append(divergence)
        
        # 20. Short Interest Relative to Historical Range
        # Position of current short interest within its historical range
        si_rel_position = 0
        if t >= 5:
            historical_si = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(historical_si)
            si_max = max(historical_si)
            si_range = si_max - si_min
            if si_range > 0:
                si_rel_position = (data[t, 0] - si_min) / si_range
            else:
                si_rel_position = 0.5  # Middle if no range
        eng.append(si_rel_position)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 456610.7951
RMSE: 685052.1113
MAPE: 8.12%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 53
   • Highly important features (top 5%): 35

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t2: importance=0.0002, rank=1
   2. Feature_3_t0: importance=0.0001, rank=2
   3. Feature_10_t0: importance=0.0001, rank=3
   4. Feature_8_t0: importance=0.0001, rank=4
   5. Feature_14_t2: importance=0.0001, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.07%

📈 Current best MAPE: 8.05%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (most important baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep shares outstanding (high importance in baseline)
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Keep options synthetic short cost (high importance in baseline)
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance feature
        short_volume_ratio = np.divide(short_volume, np.maximum(total_volume, 1e-8))
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        # Normalize short interest by shares outstanding
        si_to_float = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_to_float)
        
        # 3. Recent Short Volume Ratio Trend
        # Improved: Calculate slope of short volume ratio over last 5 days instead of just average
        if len(short_volume_ratio) >= 5:
            recent_svr_trend = (short_volume_ratio[-1] - short_volume_ratio[-5]) / 5
        else:
            recent_svr_trend = 0
        eng.append(recent_svr_trend)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trend - high importance in previous iteration
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Exponential Price Volatility
        # Improved: Use exponentially weighted volatility to give more weight to recent price movements
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            if len(returns) >= 10:
                weights = np.exp(np.linspace(-1, 0, len(returns)))
                weights = weights / np.sum(weights)
                exp_volatility = np.sqrt(np.sum(weights * returns**2))
            else:
                exp_volatility = np.std(returns)
        else:
            exp_volatility = 0
        eng.append(exp_volatility)
        
        # 6. Short Interest to Volume Ratio
        # Relates short interest to trading volume - high importance in previous iteration
        si_to_volume = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_to_volume)
        
        # 7. Put-Call Ratio
        # Options sentiment indicator
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 8. Short Interest Momentum
        # If we have previous short interest data, calculate momentum
        si_momentum = 0  # Default value
        if t > 0:
            prev_si = data[t-1, 0]
            si_momentum = data[t, 0] / max(prev_si, 1e-8) - 1
        eng.append(si_momentum)
        
        # 9. Days to Cover Change
        # Rate of change in days to cover - high importance in previous iteration
        dtc_change = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_change = data[t, 2] / max(prev_dtc, 1e-8) - 1
        eng.append(dtc_change)
        
        # 10. Implied Volatility (direct value)
        # Using raw IV instead of normalized version for more direct signal
        implied_vol = data[t, 65]
        eng.append(implied_vol)
        
        # 11. Short Volume Trend Acceleration
        # Improved: Measure acceleration of short volume trend (second derivative)
        if len(short_volume) >= 10:
            recent_trend = (short_volume[-1] - short_volume[-5]) / max(np.mean(short_volume[-5:]), 1e-8)
            older_trend = (short_volume[-6] - short_volume[-10]) / max(np.mean(short_volume[-10:-5]), 1e-8)
            sv_trend_accel = recent_trend - older_trend
        else:
            sv_trend_accel = 0
        eng.append(sv_trend_accel)
        
        # 12. Normalized Price Range with Volume Weighting
        # Improved: Weight price range by volume to capture significant price movements
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(total_volume) >= 5:
            vol_weights = total_volume[-5:] / max(np.sum(total_volume[-5:]), 1e-8)
            weighted_high = np.sum(high_prices[-5:] * vol_weights)
            weighted_low = np.sum(low_prices[-5:] * vol_weights)
            avg_price = np.mean(close_prices[-5:])
            norm_weighted_range = (weighted_high - weighted_low) / max(avg_price, 1e-8)
        else:
            norm_weighted_range = 0
        eng.append(norm_weighted_range)
        
        # 13. Adaptive RSI (Relative Strength Index)
        # Improved: Use adaptive lookback period based on volatility
        if len(close_prices) >= 14:
            # Determine lookback period based on volatility
            returns_std = np.std(np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8))
            lookback = min(14, max(5, int(10 / max(returns_std, 0.01))))
            
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-lookback:])
            avg_loss = np.mean(loss[-lookback:])
            rs = avg_gain / max(avg_loss, 1e-8)
            adaptive_rsi = 100 - (100 / (1 + rs))
        else:
            adaptive_rsi = 50  # Neutral value when not enough data
        eng.append(adaptive_rsi)
        
        # 14. Short Volume to Price Correlation
        # Improved: Measure correlation between short volume and price changes
        if len(close_prices) >= 10 and len(short_volume) >= 10:
            price_changes = np.diff(close_prices[-10:])
            short_vol_changes = np.diff(short_volume[-10:])
            if len(price_changes) > 1 and len(short_vol_changes) > 1:
                # Use a safer correlation calculation
                price_std = np.std(price_changes)
                sv_std = np.std(short_vol_changes)
                if price_std > 1e-8 and sv_std > 1e-8:
                    corr = np.mean((price_changes - np.mean(price_changes)) * 
                                   (short_vol_changes - np.mean(short_vol_changes))) / (price_std * sv_std)
                    # Bound correlation to [-1, 1]
                    corr = max(min(corr, 1.0), -1.0)
                else:
                    corr = 0
            else:
                corr = 0
        else:
            corr = 0
        eng.append(corr)
        
        # 15. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations
        si_to_iv = data[t, 0] / max(data[t, 65], 1e-8)
        eng.append(si_to_iv)
        
        # 16. Bollinger Band Position
        # Improved: Position of current price within Bollinger Bands
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            if band_width > 1e-8:
                bb_position = (close_prices[-1] - lower_band) / band_width
                # Bound to [0, 1]
                bb_position = max(min(bb_position, 1.0), 0.0)
            else:
                bb_position = 0.5
        else:
            bb_position = 0.5
        eng.append(bb_position)
        
        # 17. Short Interest Relative to Historical Range
        # Position of current short interest within its historical range
        si_rel_position = 0
        if t >= 5:
            historical_si = [data[max(0, t-i), 0] for i in range(5)]
            si_min = min(historical_si)
            si_max = max(historical_si)
            si_range = si_max - si_min
            if si_range > 0:
                si_rel_position = (data[t, 0] - si_min) / si_range
            else:
                si_rel_position = 0.5  # Middle if no range
        eng.append(si_rel_position)
        
        # 18. Short Volume Ratio Divergence from Price
        # Improved: Measure divergence between short volume ratio and price movement
        if len(close_prices) >= 5 and len(short_volume_ratio) >= 5:
            price_change = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
            svr_change = short_volume_ratio[-1] / max(short_volume_ratio[-5], 1e-8) - 1
            # Positive when short volume ratio increases while price increases (unusual)
            divergence = price_change * svr_change
            # Apply sigmoid-like transformation to bound extreme values
            divergence = divergence / max(1.0, abs(divergence))
        else:
            divergence = 0
        eng.append(divergence)
        
        # 19. Volume Pressure Indicator
        # New: Measure buying/selling pressure through volume analysis
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            up_volume = 0
            down_volume = 0
            for i in range(1, min(5, len(close_prices))):
                if close_prices[i] > close_prices[i-1]:
                    up_volume += total_volume[i]
                else:
                    down_volume += total_volume[i]
            volume_pressure = (up_volume - down_volume) / max(up_volume + down_volume, 1e-8)
        else:
            volume_pressure = 0
        eng.append(volume_pressure)
        
        # 20. Options Implied Volatility to Historical Volatility Ratio
        # New: Compare market expectations (IV) to realized volatility
        if len(close_prices) >= 10:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            iv_hv_ratio = data[t, 65] / max(hist_vol, 1e-8)
        else:
            iv_hv_ratio = 1.0  # Neutral when not enough data
        eng.append(iv_hv_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 454607.7420
RMSE: 681024.1746
MAPE: 8.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t2: importance=0.0001, rank=1
   2. Feature_14_t0: importance=0.0001, rank=2
   3. Feature_14_t3: importance=0.0001, rank=3
   4. Feature_20_t3: importance=0.0001, rank=4
   5. Feature_9_t2: importance=0.0001, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -0.05%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 671815.5123
RMSE: 1138522.0027
MAPE: 8.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 74
   • Highly important features (top 5%): 43

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_66_t1: importance=0.0007, rank=1
   2. Feature_65_t3: importance=0.0003, rank=2
   3. Feature_63_t3: importance=0.0003, rank=3
   4. Feature_0_t3: importance=0.0002, rank=4
   5. Feature_64_t0: importance=0.0001, rank=5
   Baseline MAPE: 8.94%
   Baseline MAE: 671815.5123
   Baseline RMSE: 1138522.0027

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 644639.8590
RMSE: 1129104.3626
MAPE: 8.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 50
   • Highly important features (top 5%): 34

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t1: importance=0.0004, rank=1
   2. Feature_15_t2: importance=0.0003, rank=2
   3. Feature_16_t3: importance=0.0003, rank=3
   4. Feature_3_t3: importance=0.0002, rank=4
   5. Feature_3_t2: importance=0.0002, rank=5

📊 Best Model Test Set Performance:
   MAPE: 8.54%
   MAE: 644639.8590
   RMSE: 1129104.3626

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 8.94%
   Best Model MAPE: 8.54%
   Absolute Improvement: 0.40%
   Relative Improvement: 4.4%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  9.38            N/A                 
1          Iteration 1               8.05            +1.33%              
2          Iteration 2               8.11            -0.06%              
3          Iteration 3               8.11            -0.06%              
4          Iteration 4               8.10            -0.06%              
5          Iteration 5               8.12            -0.07%              
6          Iteration 6               8.10            -0.05%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 1 - MAPE: 8.05%
✅ Saved SRPT results to cache/SRPT_iterative_results_enhanced.pkl
✅ Summary report saved for SRPT

🎉 Process completed successfully for SRPT!

================================================================================
PROCESSING TICKER 9/14: EXTR
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for EXTR
======================================================================
📊 Loading data from parquet file...
📊 Loading data for EXTR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EXTR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 868933.0676
RMSE: 1257909.5342
MAPE: 7.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 250
   • Highly important features (top 5%): 133

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t3: importance=0.0013, rank=1
   2. Feature_0_t3: importance=0.0011, rank=2
   3. Feature_82_t3: importance=0.0007, rank=3
   4. Feature_65_t2: importance=0.0006, rank=4
   5. Feature_88_t1: importance=0.0005, rank=5

📊 Baseline Performance: MAPE = 7.64%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
            data[t, 65], # options_avg_implied_volatility
            data[t, 66]  # shares_outstanding
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Add the most recent OHLC values (last day)
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio (short volume / total volume) - recent trend
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        # Average short ratio over last 5 days
        eng.append(np.mean(short_ratio[-5:]))
        
        # 2. Price momentum features
        # 5-day price momentum
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            eng.append(momentum_5d)
        else:
            eng.append(0)
        
        # 10-day price momentum
        if len(close_prices) >= 10:
            momentum_10d = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            eng.append(momentum_10d)
        else:
            eng.append(0)
        
        # 3. Volatility measures
        # Price range volatility (High-Low)/Close
        daily_volatility = np.zeros(15)
        for i in range(15):
            denom = max(abs(close_prices[i]), 1e-8)
            daily_volatility[i] = (high_prices[i] - low_prices[i]) / denom
        
        # 5-day average volatility
        eng.append(np.mean(daily_volatility[-5:]))
        
        # 4. Short interest to shares outstanding ratio
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_to_shares = data[t, 0] / shares_out
        eng.append(short_to_shares)
        
        # 5. Options-related metrics
        # Put/Call ratio (already in raw data at index 63)
        eng.append(data[t, 63])
        
        # Synthetic short cost (already in raw data at index 64)
        eng.append(data[t, 64])
        
        # 6. Volume trend features
        # 5-day volume trend compared to 15-day average
        recent_vol_avg = np.mean(total_volume[-5:])
        full_vol_avg = max(abs(np.mean(total_volume)), 1e-8)
        vol_trend = recent_vol_avg / full_vol_avg
        eng.append(vol_trend)
        
        # 7. Short volume trend
        recent_short_avg = np.mean(short_volume[-5:])
        full_short_avg = max(abs(np.mean(short_volume)), 1e-8)
        short_vol_trend = recent_short_avg / full_short_avg
        eng.append(short_vol_trend)
        
        # 8. RSI (Relative Strength Index) - 14 day
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain[-14:])
            avg_loss = max(abs(np.mean(loss[-14:])), 1e-8)
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50)  # Default RSI value
        
        # 9. Short interest acceleration (rate of change)
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_accel = (curr_short / denom) - 1
            eng.append(short_accel)
        else:
            eng.append(0)
        
        # 10. Price to volume ratio (Dollar volume)
        price_vol_ratio = close_prices[-1] * data[t, 1]  # Close * Avg Volume
        eng.append(price_vol_ratio)
        
        # 11. Short interest to average daily volume ratio
        si_to_adv = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_adv)
        
        # 12. Bollinger Band position
        if len(close_prices) >= 10:
            sma_20 = np.mean(close_prices[-10:])
            std_20 = np.std(close_prices[-10:])
            bb_position = (close_prices[-1] - sma_20) / max(abs(std_20), 1e-8)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 13. MACD-like indicator (5-day EMA vs 10-day EMA)
        if len(close_prices) >= 10:
            ema_5 = np.mean(close_prices[-5:])
            ema_10 = np.mean(close_prices[-10:])
            macd = ema_5 - ema_10
            eng.append(macd)
        else:
            eng.append(0)
        
        # 14. Short volume acceleration
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-2:])
            prev_short = max(abs(np.mean(short_volume[-5:-2])), 1e-8)
            short_vol_accel = (recent_short / prev_short) - 1
            eng.append(short_vol_accel)
        else:
            eng.append(0)
        
        # 15. Implied volatility to historical volatility ratio
        if len(daily_volatility) >= 5:
            hist_vol = np.mean(daily_volatility[-5:])
            impl_vol = max(abs(data[t, 65]), 1e-8)
            vol_ratio = data[t, 65] / impl_vol
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 816796.6387
RMSE: 1265699.6801
MAPE: 7.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t3: importance=0.0025, rank=1
   2. Feature_15_t3: importance=0.0015, rank=2
   3. Feature_10_t3: importance=0.0011, rank=3
   4. Feature_9_t2: importance=0.0010, rank=4
   5. Feature_13_t0: importance=0.0008, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.30%

📈 Current best MAPE: 7.34%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we're keeping the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - critical target-related feature
            data[t, 1],  # average daily volume - critical for liquidity context
            data[t, 2],  # days to cover - direct measure of short covering difficulty
            data[t, 65], # options_avg_implied_volatility - high importance in previous iterations
            data[t, 63], # options_put_call_volume_ratio - options sentiment indicator
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Add the most recent close price - important price anchor
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio (short volume / total volume) - recent trend
        # This was highly significant in previous iterations
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        # Average short ratio over last 5 days - more recent data has higher importance
        eng.append(np.mean(short_ratio[-5:]))
        
        # 2. Short interest to shares outstanding ratio
        # This provides context for how much of the float is being shorted
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_to_shares = data[t, 0] / shares_out
        eng.append(short_to_shares)
        
        # 3. Short interest acceleration (rate of change)
        # Captures momentum in short interest changes
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_accel = (curr_short / denom) - 1
            eng.append(short_accel)
        else:
            eng.append(0)
        
        # 4. Short interest to average daily volume ratio
        # Key metric showing how many days of average volume would be needed to cover shorts
        si_to_adv = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_adv)
        
        # 5. Exponential price momentum (more weight to recent price changes)
        # Improved version of previous momentum calculation
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)  # Normalize weights
            momentum = np.sum(weights * (close_prices[-5:] / max(close_prices[-5], 1e-8) - 1))
            eng.append(momentum)
        else:
            eng.append(0)
        
        # 6. Volatility ratio: recent vs historical
        # Captures changes in volatility regime
        if len(close_prices) >= 10:
            recent_vol = np.std(close_prices[-5:]) / max(abs(np.mean(close_prices[-5:])), 1e-8)
            hist_vol = np.std(close_prices[-10:]) / max(abs(np.mean(close_prices[-10:])), 1e-8)
            vol_ratio = recent_vol / max(abs(hist_vol), 1e-8)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 7. Short volume trend with exponential weighting
        # Gives more weight to recent short volume changes
        if len(short_volume) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            short_trend = np.sum(weights * short_volume[-5:]) / max(abs(np.mean(short_volume[-5:])), 1e-8)
            eng.append(short_trend)
        else:
            eng.append(1)
        
        # 8. Price gap analysis
        # Captures significant overnight price movements
        if len(close_prices) >= 2 and len(open_prices) >= 1:
            overnight_gap = (open_prices[-1] / max(abs(close_prices[-2]), 1e-8)) - 1
            eng.append(overnight_gap)
        else:
            eng.append(0)
        
        # 9. Bollinger Band position (normalized)
        # Indicates overbought/oversold conditions
        if len(close_prices) >= 10:
            sma_10 = np.mean(close_prices[-10:])
            std_10 = np.std(close_prices[-10:])
            bb_position = (close_prices[-1] - sma_10) / max(abs(std_10), 1e-8)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 10. Implied volatility to historical volatility ratio
        # Captures market expectations vs realized volatility
        daily_returns = np.zeros(14)
        for i in range(1, 15):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        hist_vol = np.std(daily_returns) * np.sqrt(252)  # Annualized
        impl_vol = data[t, 65]
        vol_ratio = impl_vol / max(abs(hist_vol), 1e-8)
        eng.append(vol_ratio)
        
        # 11. RSI (Relative Strength Index) - 14 day
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain[-14:])
            avg_loss = max(abs(np.mean(loss[-14:])), 1e-8)
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50)  # Default RSI value
        
        # 12. Volume-weighted average price (VWAP) ratio
        # Price relative to volume-weighted average
        if len(close_prices) >= 5 and len(total_volume[-5:]) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(abs(np.sum(total_volume[-5:])), 1e-8)
            vwap_ratio = close_prices[-1] / max(abs(vwap), 1e-8)
            eng.append(vwap_ratio)
        else:
            eng.append(1)
        
        # 13. Short volume concentration
        # Measures if short volume is concentrated in specific days
        if len(short_volume) >= 5:
            short_vol_std = np.std(short_volume[-5:])
            short_vol_mean = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_concentration = short_vol_std / short_vol_mean
            eng.append(short_concentration)
        else:
            eng.append(0)
        
        # 14. Options synthetic short cost to implied volatility ratio
        # Relationship between shorting cost and expected volatility
        synth_short_cost = data[t, 64]
        impl_vol = max(abs(data[t, 65]), 1e-8)
        cost_vol_ratio = synth_short_cost / impl_vol
        eng.append(cost_vol_ratio)
        
        # 15. Price trend strength
        # Measures consistency of price direction
        if len(close_prices) >= 10:
            price_diff = np.diff(close_prices[-10:])
            pos_moves = np.sum(price_diff > 0)
            neg_moves = np.sum(price_diff < 0)
            trend_strength = (pos_moves - neg_moves) / 9  # Normalized to [-1, 1]
            eng.append(trend_strength)
        else:
            eng.append(0)
        
        # 16. Short volume acceleration
        # Rate of change in short volume
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-2:])
            prev_short = max(abs(np.mean(short_volume[-5:-2])), 1e-8)
            short_vol_accel = (recent_short / prev_short) - 1
            eng.append(short_vol_accel)
        else:
            eng.append(0)
        
        # 17. Average true range (ATR) - volatility indicator
        # Captures average price range including gaps
        if len(close_prices) >= 2:
            tr = np.zeros(14)
            for i in range(1, 15):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr[i-1] = max(high_low, high_close, low_close)
            atr = np.mean(tr)
            atr_ratio = atr / max(abs(close_prices[-1]), 1e-8)
            eng.append(atr_ratio)
        else:
            eng.append(0)
        
        # 18. Short interest to implied volatility ratio
        # Relationship between short interest and expected volatility
        si_iv_ratio = data[t, 0] / max(abs(data[t, 65]), 1e-8)
        eng.append(si_iv_ratio)
        
        # 19. Price to volume anomaly
        # Detects unusual price movements on low volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1
            vol_change = (np.mean(total_volume[-5:]) / max(abs(np.mean(total_volume[-10:-5])), 1e-8)) - 1
            price_vol_anomaly = price_change / max(abs(vol_change), 1e-8)
            eng.append(price_vol_anomaly)
        else:
            eng.append(0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 850103.4801
RMSE: 1277472.1728
MAPE: 7.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0021, rank=1
   2. Feature_22_t3: importance=0.0013, rank=2
   3. Feature_23_t3: importance=0.0007, rank=3
   4. Feature_6_t1: importance=0.0006, rank=4
   5. Feature_4_t1: importance=0.0006, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -0.35%

📈 Current best MAPE: 7.34%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, keeping the most important raw features
        raw_keep = [
            data[t, 0],   # short interest - critical target-related feature
            data[t, 1],   # average daily volume - critical for liquidity context
            data[t, 2],   # days to cover - direct measure of short covering difficulty
            data[t, 65],  # options_avg_implied_volatility - high importance in previous iterations
            data[t, 63],  # options_put_call_volume_ratio - options sentiment indicator
            data[t, 64],  # options_synthetic_short_cost - important for shorting dynamics
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Add the most recent close price - important price anchor
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio (short volume / total volume) - recent trend
        # This was highly significant in previous iterations
        # Using exponential weighting to emphasize recent data
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        # Exponentially weighted short ratio (more weight to recent data)
        if len(short_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_short_ratio = np.sum(weights * short_ratio[-5:])
            eng.append(exp_short_ratio)
        else:
            eng.append(np.mean(short_ratio))
        
        # 2. Short interest to shares outstanding ratio
        # This provides context for how much of the float is being shorted
        shares_out = max(abs(data[t, 66]), 1e-8)
        short_to_shares = data[t, 0] / shares_out
        eng.append(short_to_shares)
        
        # 3. Short interest acceleration (rate of change)
        # Captures momentum in short interest changes
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_accel = (curr_short / denom) - 1
            eng.append(short_accel)
        else:
            eng.append(0)
        
        # 4. Relative short interest change over multiple periods
        # Captures longer-term trend in short interest
        if t > 2:
            short_3ago = max(abs(data[t-3, 0]), 1e-8)
            rel_short_change = data[t, 0] / short_3ago - 1
            eng.append(rel_short_change)
        else:
            eng.append(0)
        
        # 5. Exponential price momentum (more weight to recent price changes)
        # Improved version focusing on most recent price action
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            momentum = np.sum(weights * (close_prices[-5:] / max(close_prices[-5], 1e-8) - 1))
            eng.append(momentum)
        else:
            eng.append(0)
        
        # 6. Volatility ratio: recent vs historical
        # Captures changes in volatility regime
        if len(close_prices) >= 10:
            recent_vol = np.std(close_prices[-5:]) / max(abs(np.mean(close_prices[-5:])), 1e-8)
            hist_vol = np.std(close_prices[-10:]) / max(abs(np.mean(close_prices[-10:])), 1e-8)
            vol_ratio = recent_vol / max(abs(hist_vol), 1e-8)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 7. RSI (Relative Strength Index) - 14 day
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain[-14:])
            avg_loss = max(abs(np.mean(loss[-14:])), 1e-8)
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            # Normalize RSI to [-1, 1] range for better model compatibility
            norm_rsi = (rsi - 50) / 50
            eng.append(norm_rsi)
        else:
            eng.append(0)
        
        # 8. Short volume to price change correlation
        # Measures if short selling is driving price action
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_changes = np.diff(close_prices[-6:])
            short_vol_changes = np.diff(short_volume[-6:])
            
            # Calculate correlation manually to avoid np.corrcoef instability
            if np.std(price_changes) > 1e-8 and np.std(short_vol_changes) > 1e-8:
                price_changes_norm = (price_changes - np.mean(price_changes)) / max(np.std(price_changes), 1e-8)
                short_vol_changes_norm = (short_vol_changes - np.mean(short_vol_changes)) / max(np.std(short_vol_changes), 1e-8)
                corr = np.mean(price_changes_norm * short_vol_changes_norm)
                eng.append(corr)
            else:
                eng.append(0)
        else:
            eng.append(0)
        
        # 9. Bollinger Band position (normalized)
        # Indicates overbought/oversold conditions
        if len(close_prices) >= 10:
            sma_10 = np.mean(close_prices[-10:])
            std_10 = np.std(close_prices[-10:])
            bb_position = (close_prices[-1] - sma_10) / max(abs(std_10), 1e-8)
            # Clamp extreme values for stability
            bb_position = max(min(bb_position, 3), -3)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 10. Implied volatility to historical volatility ratio
        # Captures market expectations vs realized volatility
        daily_returns = np.zeros(14)
        for i in range(1, 15):
            daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
        hist_vol = np.std(daily_returns) * np.sqrt(252)  # Annualized
        impl_vol = data[t, 65]
        vol_ratio = impl_vol / max(abs(hist_vol), 1e-8)
        # Clamp extreme values
        vol_ratio = max(min(vol_ratio, 5), 0.2)
        eng.append(vol_ratio)
        
        # 11. Volume-weighted average price (VWAP) ratio
        # Price relative to volume-weighted average
        if len(close_prices) >= 5 and len(total_volume[-5:]) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(abs(np.sum(total_volume[-5:])), 1e-8)
            vwap_ratio = close_prices[-1] / max(abs(vwap), 1e-8) - 1
            eng.append(vwap_ratio)
        else:
            eng.append(0)
        
        # 12. Short volume concentration
        # Measures if short volume is concentrated in specific days
        if len(short_volume) >= 5:
            short_vol_std = np.std(short_volume[-5:])
            short_vol_mean = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_concentration = short_vol_std / short_vol_mean
            eng.append(short_concentration)
        else:
            eng.append(0)
        
        # 13. Options synthetic short cost to implied volatility ratio
        # Relationship between shorting cost and expected volatility
        synth_short_cost = data[t, 64]
        impl_vol = max(abs(data[t, 65]), 1e-8)
        cost_vol_ratio = synth_short_cost / impl_vol
        eng.append(cost_vol_ratio)
        
        # 14. Short interest to options put/call ratio
        # Relationship between actual shorts and options sentiment
        put_call_ratio = max(abs(data[t, 63]), 1e-8)
        si_options_ratio = data[t, 0] / put_call_ratio
        # Normalize to prevent extreme values
        si_options_ratio = si_options_ratio / max(abs(data[t, 1]), 1e-8)
        eng.append(si_options_ratio)
        
        # 15. Price trend strength with volume confirmation
        # Measures consistency of price direction weighted by volume
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_diff = np.diff(close_prices[-10:])
            vol_norm = total_volume[-9:] / max(abs(np.mean(total_volume[-9:])), 1e-8)
            # Weight price changes by volume
            weighted_moves = price_diff * vol_norm
            trend_strength = np.sum(np.sign(weighted_moves)) / 9  # Normalized to [-1, 1]
            eng.append(trend_strength)
        else:
            eng.append(0)
        
        # 16. Average true range (ATR) ratio - volatility indicator
        # Captures average price range including gaps, normalized by price
        if len(close_prices) >= 2:
            tr = np.zeros(14)
            for i in range(1, 15):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr[i-1] = max(high_low, high_close, low_close)
            atr = np.mean(tr)
            atr_ratio = atr / max(abs(close_prices[-1]), 1e-8)
            eng.append(atr_ratio)
        else:
            eng.append(0)
        
        # 17. Short interest to implied volatility ratio
        # Relationship between short interest and expected volatility
        si_iv_ratio = data[t, 0] / max(abs(data[t, 65]), 1e-8)
        eng.append(si_iv_ratio)
        
        # 18. Short volume trend change
        # Detects inflection points in short selling activity
        if len(short_volume) >= 10:
            recent_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
            eng.append(recent_trend)
        else:
            eng.append(0)
        
        # 19. Abnormal short volume
        # Identifies days with unusually high short volume relative to historical patterns
        if len(short_volume) >= 10:
            mean_short = np.mean(short_volume[-10:])
            std_short = max(np.std(short_volume[-10:]), 1e-8)
            z_score = (short_volume[-1] - mean_short) / std_short
            # Clamp extreme values
            z_score = max(min(z_score, 3), -3)
            eng.append(z_score)
        else:
            eng.append(0)
        
        # 20. Short interest to days-to-cover ratio change
        # Captures changes in the relationship between SI and DTC
        if t > 0:
            curr_ratio = data[t, 0] / max(abs(data[t, 2]), 1e-8)
            prev_ratio = data[t-1, 0] / max(abs(data[t-1, 2]), 1e-8)
            ratio_change = curr_ratio / max(abs(prev_ratio), 1e-8) - 1
            eng.append(ratio_change)
        else:
            eng.append(0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 817190.1075
RMSE: 1296874.9620
MAPE: 7.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 81

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0016, rank=1
   2. Feature_8_t3: importance=0.0009, rank=2
   3. Feature_0_t3: importance=0.0009, rank=3
   4. Feature_13_t3: importance=0.0008, rank=4
   5. Feature_17_t3: importance=0.0007, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -0.13%

📈 Current best MAPE: 7.34%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, keeping the most important raw features
        raw_keep = [
            data[t, 0],   # short interest - critical target-related feature
            data[t, 1],   # average daily volume - critical for liquidity context
            data[t, 2],   # days to cover - direct measure of short covering difficulty
            data[t, 65],  # options_avg_implied_volatility - high importance in previous iterations
            data[t, 63],  # options_put_call_volume_ratio - options sentiment indicator
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Add the most recent close price - important price anchor
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio with exponential weighting (highly significant in previous iterations)
        # This captures the recent trend in short selling activity relative to total volume
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        if len(short_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_short_ratio = np.sum(weights * short_ratio[-5:])
            eng.append(exp_short_ratio)
        else:
            eng.append(np.mean(short_ratio))
        
        # 2. Short interest to shares outstanding ratio
        # Provides normalized context for how much of the float is being shorted
        si_to_shares = data[t, 0] / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # 3. Short interest momentum (rate of change)
        # Captures acceleration in short interest changes - a key predictor
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_momentum = (curr_short / denom) - 1
            eng.append(short_momentum)
        else:
            eng.append(0)
        
        # 4. Relative price strength (normalized price momentum)
        # Improved version focusing on most recent price action with volume weighting
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate returns
            returns = np.zeros(4)
            for i in range(4):
                returns[i] = close_prices[-i-1] / max(abs(close_prices[-i-2]), 1e-8) - 1
            
            # Weight returns by volume
            vol_weights = total_volume[-5:-1] / max(abs(np.sum(total_volume[-5:-1])), 1e-8)
            weighted_momentum = np.sum(returns * vol_weights)
            eng.append(weighted_momentum)
        else:
            eng.append(0)
        
        # 5. Volatility ratio: recent vs historical
        # Captures changes in volatility regime - important for predicting short interest changes
        if len(close_prices) >= 10:
            recent_returns = np.zeros(5)
            hist_returns = np.zeros(10)
            
            for i in range(1, 6):
                recent_returns[i-1] = close_prices[-i] / max(abs(close_prices[-i-1]), 1e-8) - 1
            
            for i in range(1, 11):
                hist_returns[i-1] = close_prices[-i] / max(abs(close_prices[-i-1]), 1e-8) - 1
            
            recent_vol = np.std(recent_returns)
            hist_vol = max(abs(np.std(hist_returns)), 1e-8)
            vol_ratio = recent_vol / hist_vol
            # Clamp extreme values
            vol_ratio = max(min(vol_ratio, 3), 0.33)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 6. RSI (Relative Strength Index) - 14 day
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain[-14:])
            avg_loss = max(abs(np.mean(loss[-14:])), 1e-8)
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            # Normalize RSI to [-1, 1] range for better model compatibility
            norm_rsi = (rsi - 50) / 50
            eng.append(norm_rsi)
        else:
            eng.append(0)
        
        # 7. Short volume to price change correlation
        # Measures if short selling is driving price action
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_changes = np.diff(close_prices[-6:])
            short_vol_changes = np.diff(short_volume[-6:])
            
            # Calculate correlation manually to avoid np.corrcoef instability
            if np.std(price_changes) > 1e-8 and np.std(short_vol_changes) > 1e-8:
                price_changes_norm = (price_changes - np.mean(price_changes)) / max(np.std(price_changes), 1e-8)
                short_vol_changes_norm = (short_vol_changes - np.mean(short_vol_changes)) / max(np.std(short_vol_changes), 1e-8)
                corr = np.mean(price_changes_norm * short_vol_changes_norm)
                eng.append(corr)
            else:
                eng.append(0)
        else:
            eng.append(0)
        
        # 8. Bollinger Band position (normalized)
        # Indicates overbought/oversold conditions - important for predicting reversals
        if len(close_prices) >= 10:
            sma_10 = np.mean(close_prices[-10:])
            std_10 = max(abs(np.std(close_prices[-10:])), 1e-8)
            bb_position = (close_prices[-1] - sma_10) / std_10
            # Clamp extreme values for stability
            bb_position = max(min(bb_position, 3), -3)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 9. Implied volatility to historical volatility ratio
        # Captures market expectations vs realized volatility
        if len(close_prices) >= 14:
            daily_returns = np.zeros(14)
            for i in range(1, 15):
                daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
            hist_vol = np.std(daily_returns) * np.sqrt(252)  # Annualized
            impl_vol = data[t, 65]
            vol_ratio = impl_vol / max(abs(hist_vol), 1e-8)
            # Clamp extreme values
            vol_ratio = max(min(vol_ratio, 5), 0.2)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 10. Short volume trend change
        # Detects inflection points in short selling activity
        if len(short_volume) >= 10:
            recent_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
            eng.append(recent_trend)
        else:
            eng.append(0)
        
        # 11. Abnormal short volume
        # Identifies days with unusually high short volume relative to historical patterns
        if len(short_volume) >= 10:
            mean_short = np.mean(short_volume[-10:])
            std_short = max(np.std(short_volume[-10:]), 1e-8)
            z_score = (short_volume[-1] - mean_short) / std_short
            # Clamp extreme values
            z_score = max(min(z_score, 3), -3)
            eng.append(z_score)
        else:
            eng.append(0)
        
        # 12. Short interest to days-to-cover ratio change
        # Captures changes in the relationship between SI and DTC
        if t > 0:
            curr_ratio = data[t, 0] / max(abs(data[t, 2]), 1e-8)
            prev_ratio = data[t-1, 0] / max(abs(data[t-1, 2]), 1e-8)
            ratio_change = curr_ratio / max(abs(prev_ratio), 1e-8) - 1
            eng.append(ratio_change)
        else:
            eng.append(0)
        
        # 13. Price trend strength with volume confirmation
        # Measures consistency of price direction weighted by volume
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_diff = np.diff(close_prices[-10:])
            vol_norm = total_volume[-9:] / max(abs(np.mean(total_volume[-9:])), 1e-8)
            # Weight price changes by volume
            weighted_moves = price_diff * vol_norm
            trend_strength = np.sum(np.sign(weighted_moves)) / 9  # Normalized to [-1, 1]
            eng.append(trend_strength)
        else:
            eng.append(0)
        
        # 14. Average true range (ATR) ratio - volatility indicator
        # Captures average price range including gaps, normalized by price
        if len(close_prices) >= 2:
            tr = np.zeros(14)
            for i in range(1, 15):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr[i-1] = max(high_low, high_close, low_close)
            atr = np.mean(tr)
            atr_ratio = atr / max(abs(close_prices[-1]), 1e-8)
            eng.append(atr_ratio)
        else:
            eng.append(0)
        
        # 15. Short interest to implied volatility ratio
        # Relationship between short interest and expected volatility
        si_iv_ratio = data[t, 0] / max(abs(data[t, 65]), 1e-8)
        eng.append(si_iv_ratio)
        
        # 16. MACD Signal - Moving Average Convergence Divergence
        # Trend-following momentum indicator showing relationship between two moving averages
        if len(close_prices) >= 12:
            ema_12 = np.mean(close_prices[-12:])  # Simplified EMA calculation
            ema_26 = np.mean(close_prices[-min(len(close_prices), 26):])
            macd = ema_12 - ema_26
            # Normalize by price level
            norm_macd = macd / max(abs(close_prices[-1]), 1e-8)
            eng.append(norm_macd)
        else:
            eng.append(0)
        
        # 17. Short volume concentration
        # Measures if short volume is concentrated in specific days
        if len(short_volume) >= 5:
            short_vol_std = np.std(short_volume[-5:])
            short_vol_mean = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_concentration = short_vol_std / short_vol_mean
            eng.append(short_concentration)
        else:
            eng.append(0)
        
        # 18. Price gap analysis
        # Identifies significant overnight price gaps which often precede short interest changes
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = np.zeros(4)
            for i in range(4):
                gaps[i] = open_prices[-i-1] / max(abs(close_prices[-i-2]), 1e-8) - 1
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1])
            weighted_gap = np.sum(gaps * weights)
            eng.append(weighted_gap)
        else:
            eng.append(0)
        
        # 19. Volume trend change
        # Detects shifts in trading volume which often precede short interest changes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = max(abs(np.mean(total_volume[-10:-5])), 1e-8)
            vol_trend_change = recent_vol / prev_vol - 1
            eng.append(vol_trend_change)
        else:
            eng.append(0)
        
        # 20. Options synthetic short cost to short interest ratio
        # Relationship between shorting cost and actual short interest
        synth_short_cost = data[t, 64]
        short_interest = max(abs(data[t, 0]), 1e-8)
        cost_si_ratio = synth_short_cost / short_interest
        eng.append(cost_si_ratio)
        
        # 21. High-Low range relative to average daily volume
        # Captures price volatility relative to liquidity
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_range = np.mean(high_prices[-5:] - low_prices[-5:])
            range_to_vol = avg_range / max(abs(data[t, 1]), 1e-8)
            eng.append(range_to_vol)
        else:
            eng.append(0)
        
        # 22. Stochastic oscillator (K%)
        # Momentum indicator comparing a closing price to its price range over time
        if len(high_prices) >= 14 and len(low_prices) >= 14 and len(close_prices) >= 14:
            highest_high = np.max(high_prices[-14:])
            lowest_low = np.min(low_prices[-14:])
            range_hl = max(abs(highest_high - lowest_low), 1e-8)
            k_percent = (close_prices[-1] - lowest_low) / range_hl * 100
            # Normalize to [-1, 1]
            norm_k = (k_percent - 50) / 50
            eng.append(norm_k)
        else:
            eng.append(0)
        
        # 23. Chaikin Money Flow (CMF) - simplified version
        # Volume-weighted accumulation/distribution line used to confirm price trends
        if len(close_prices) >= 10 and len(high_prices) >= 10 and len(low_prices) >= 10 and len(total_volume) >= 10:
            mfv = np.zeros(10)  # Money Flow Volume
            for i in range(10):
                if high_prices[-i-1] - low_prices[-i-1] > 1e-8:
                    mf_multiplier = ((close_prices[-i-1] - low_prices[-i-1]) - 
                                    (high_prices[-i-1] - close_prices[-i-1])) / (high_prices[-i-1] - low_prices[-i-1])
                    mfv[i] = mf_multiplier * total_volume[-i-1]
                else:
                    mfv[i] = 0
            
            cmf = np.sum(mfv) / max(abs(np.sum(total_volume[-10:])), 1e-8)
            eng.append(cmf)
        else:
            eng.append(0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 843513.1914
RMSE: 1310918.0215
MAPE: 7.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0015, rank=1
   2. Feature_23_t3: importance=0.0015, rank=2
   3. Feature_4_t0: importance=0.0013, rank=3
   4. Feature_20_t3: importance=0.0008, rank=4
   5. Feature_21_t3: importance=0.0007, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.34%

📈 Current best MAPE: 7.34%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, keeping the most important raw features
        raw_keep = [
            data[t, 0],   # short interest - critical target-related feature
            data[t, 1],   # average daily volume - critical for liquidity context
            data[t, 2],   # days to cover - direct measure of short covering difficulty
            data[t, 65],  # options_avg_implied_volatility - high importance in previous iterations
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        
        # Add the most recent close price - important price anchor
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio with exponential weighting (highly significant in previous iterations)
        # This captures the recent trend in short selling activity relative to total volume
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        if len(short_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_short_ratio = np.sum(weights * short_ratio[-5:])
            eng.append(exp_short_ratio)
        else:
            eng.append(np.mean(short_ratio))
        
        # 2. Short interest to shares outstanding ratio
        # Provides normalized context for how much of the float is being shorted
        si_to_shares = data[t, 0] / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # 3. Short interest momentum (rate of change)
        # Captures acceleration in short interest changes - a key predictor
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_momentum = (curr_short / denom) - 1
            eng.append(short_momentum)
        else:
            eng.append(0)
        
        # 4. Short interest acceleration (second derivative)
        # Captures changes in the rate of change of short interest
        if t > 1:
            prev_momentum = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            curr_momentum = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            si_acceleration = curr_momentum - prev_momentum
            eng.append(si_acceleration)
        else:
            eng.append(0)
        
        # 5. Volatility ratio: recent vs historical
        # Captures changes in volatility regime - important for predicting short interest changes
        if len(close_prices) >= 10:
            recent_returns = np.zeros(5)
            hist_returns = np.zeros(10)
            
            for i in range(1, 6):
                recent_returns[i-1] = close_prices[-i] / max(abs(close_prices[-i-1]), 1e-8) - 1
            
            for i in range(1, 11):
                hist_returns[i-1] = close_prices[-i] / max(abs(close_prices[-i-1]), 1e-8) - 1
            
            recent_vol = np.std(recent_returns)
            hist_vol = max(abs(np.std(hist_returns)), 1e-8)
            vol_ratio = recent_vol / hist_vol
            # Clamp extreme values
            vol_ratio = max(min(vol_ratio, 3), 0.33)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 6. RSI (Relative Strength Index) - 14 day
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            avg_gain = np.mean(gain[-14:])
            avg_loss = max(abs(np.mean(loss[-14:])), 1e-8)
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            # Normalize RSI to [-1, 1] range for better model compatibility
            norm_rsi = (rsi - 50) / 50
            eng.append(norm_rsi)
        else:
            eng.append(0)
        
        # 7. Short volume to price change correlation
        # Measures if short selling is driving price action
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            price_changes = np.diff(close_prices[-6:])
            short_vol_changes = np.diff(short_volume[-6:])
            
            # Calculate correlation manually to avoid np.corrcoef instability
            if np.std(price_changes) > 1e-8 and np.std(short_vol_changes) > 1e-8:
                price_changes_norm = (price_changes - np.mean(price_changes)) / max(np.std(price_changes), 1e-8)
                short_vol_changes_norm = (short_vol_changes - np.mean(short_vol_changes)) / max(np.std(short_vol_changes), 1e-8)
                corr = np.mean(price_changes_norm * short_vol_changes_norm)
                eng.append(corr)
            else:
                eng.append(0)
        else:
            eng.append(0)
        
        # 8. Bollinger Band position (normalized)
        # Indicates overbought/oversold conditions - important for predicting reversals
        if len(close_prices) >= 10:
            sma_10 = np.mean(close_prices[-10:])
            std_10 = max(abs(np.std(close_prices[-10:])), 1e-8)
            bb_position = (close_prices[-1] - sma_10) / std_10
            # Clamp extreme values for stability
            bb_position = max(min(bb_position, 3), -3)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 9. Implied volatility to historical volatility ratio
        # Captures market expectations vs realized volatility
        if len(close_prices) >= 14:
            daily_returns = np.zeros(14)
            for i in range(1, 15):
                daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
            hist_vol = np.std(daily_returns) * np.sqrt(252)  # Annualized
            impl_vol = data[t, 65]
            vol_ratio = impl_vol / max(abs(hist_vol), 1e-8)
            # Clamp extreme values
            vol_ratio = max(min(vol_ratio, 5), 0.2)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 10. Short volume trend change
        # Detects inflection points in short selling activity
        if len(short_volume) >= 10:
            recent_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
            eng.append(recent_trend)
        else:
            eng.append(0)
        
        # 11. Abnormal short volume
        # Identifies days with unusually high short volume relative to historical patterns
        if len(short_volume) >= 10:
            mean_short = np.mean(short_volume[-10:])
            std_short = max(np.std(short_volume[-10:]), 1e-8)
            z_score = (short_volume[-1] - mean_short) / std_short
            # Clamp extreme values
            z_score = max(min(z_score, 3), -3)
            eng.append(z_score)
        else:
            eng.append(0)
        
        # 12. Short interest to days-to-cover ratio change
        # Captures changes in the relationship between SI and DTC
        if t > 0:
            curr_ratio = data[t, 0] / max(abs(data[t, 2]), 1e-8)
            prev_ratio = data[t-1, 0] / max(abs(data[t-1, 2]), 1e-8)
            ratio_change = curr_ratio / max(abs(prev_ratio), 1e-8) - 1
            eng.append(ratio_change)
        else:
            eng.append(0)
        
        # 13. Price trend strength with volume confirmation
        # Measures consistency of price direction weighted by volume
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_diff = np.diff(close_prices[-10:])
            vol_norm = total_volume[-9:] / max(abs(np.mean(total_volume[-9:])), 1e-8)
            # Weight price changes by volume
            weighted_moves = price_diff * vol_norm
            trend_strength = np.sum(np.sign(weighted_moves)) / 9  # Normalized to [-1, 1]
            eng.append(trend_strength)
        else:
            eng.append(0)
        
        # 14. Average true range (ATR) ratio - volatility indicator
        # Captures average price range including gaps, normalized by price
        if len(close_prices) >= 2:
            tr = np.zeros(min(14, len(close_prices)-1))
            for i in range(1, min(15, len(close_prices))):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr[i-1] = max(high_low, high_close, low_close)
            atr = np.mean(tr)
            atr_ratio = atr / max(abs(close_prices[-1]), 1e-8)
            eng.append(atr_ratio)
        else:
            eng.append(0)
        
        # 15. Short interest to implied volatility ratio
        # Relationship between short interest and expected volatility
        si_iv_ratio = data[t, 0] / max(abs(data[t, 65]), 1e-8)
        eng.append(si_iv_ratio)
        
        # 16. Put-Call ratio to short interest ratio
        # Relationship between options sentiment and short interest
        pc_si_ratio = options_put_call_ratio / max(abs(data[t, 0]), 1e-8)
        eng.append(pc_si_ratio)
        
        # 17. Short volume concentration
        # Measures if short volume is concentrated in specific days
        if len(short_volume) >= 5:
            short_vol_std = np.std(short_volume[-5:])
            short_vol_mean = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_concentration = short_vol_std / short_vol_mean
            eng.append(short_concentration)
        else:
            eng.append(0)
        
        # 18. Price gap analysis
        # Identifies significant overnight price gaps which often precede short interest changes
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = np.zeros(min(4, len(open_prices)-1))
            for i in range(min(4, len(open_prices)-1)):
                gaps[i] = open_prices[-i-1] / max(abs(close_prices[-i-2]), 1e-8) - 1
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1])[:len(gaps)]
            weights = weights / np.sum(weights)
            weighted_gap = np.sum(gaps * weights)
            eng.append(weighted_gap)
        else:
            eng.append(0)
        
        # 19. Volume trend change
        # Detects shifts in trading volume which often precede short interest changes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = max(abs(np.mean(total_volume[-10:-5])), 1e-8)
            vol_trend_change = recent_vol / prev_vol - 1
            eng.append(vol_trend_change)
        else:
            eng.append(0)
        
        # 20. Options synthetic short cost to short interest ratio
        # Relationship between shorting cost and actual short interest
        synth_short_cost = data[t, 64]
        short_interest = max(abs(data[t, 0]), 1e-8)
        cost_si_ratio = synth_short_cost / short_interest
        eng.append(cost_si_ratio)
        
        # 21. High-Low range relative to average daily volume
        # Captures price volatility relative to liquidity
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_range = np.mean(high_prices[-5:] - low_prices[-5:])
            range_to_vol = avg_range / max(abs(data[t, 1]), 1e-8)
            eng.append(range_to_vol)
        else:
            eng.append(0)
        
        # 22. Short interest to volume ratio change
        # Captures changes in the relationship between short interest and trading volume
        if t > 0:
            curr_si_vol = data[t, 0] / max(abs(data[t, 1]), 1e-8)
            prev_si_vol = data[t-1, 0] / max(abs(data[t-1, 1]), 1e-8)
            si_vol_change = curr_si_vol / max(abs(prev_si_vol), 1e-8) - 1
            eng.append(si_vol_change)
        else:
            eng.append(0)
        
        # 23. Short interest to price ratio
        # Relationship between short interest and stock price
        si_price_ratio = data[t, 0] / max(abs(close_prices[-1]), 1e-8)
        eng.append(si_price_ratio)
        
        # 24. Short interest to price ratio change
        # Captures changes in the relationship between short interest and stock price
        if t > 0 and len(close_prices) >= 2:
            curr_si_price = data[t, 0] / max(abs(close_prices[-1]), 1e-8)
            prev_close = 0
            if t > 0 and t < len(close_prices):
                prev_close = close_prices[-2]
            else:
                prev_close = close_prices[-1]  # Fallback
            prev_si_price = data[t-1, 0] / max(abs(prev_close), 1e-8)
            si_price_change = curr_si_price / max(abs(prev_si_price), 1e-8) - 1
            eng.append(si_price_change)
        else:
            eng.append(0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 853263.0242
RMSE: 1322177.9850
MAPE: 7.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0016, rank=1
   2. Feature_18_t3: importance=0.0011, rank=2
   3. Feature_10_t3: importance=0.0010, rank=3
   4. Feature_21_t2: importance=0.0008, rank=4
   5. Feature_15_t1: importance=0.0007, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.50%

📈 Current best MAPE: 7.34%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, keeping only the most critical raw features
        raw_keep = [
            data[t, 0],   # short interest - critical target-related feature
            data[t, 1],   # average daily volume - critical for liquidity context
            data[t, 2],   # days to cover - direct measure of short covering difficulty
            data[t, 65],  # options_avg_implied_volatility - high importance in previous iterations
        ]
        
        # Get OHLC data for the last 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Get short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        
        # Add the most recent close price - important price anchor
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Start building engineered features
        eng = []
        
        # 1. Short Volume Ratio with exponential weighting (highly significant in previous iterations)
        # This captures the recent trend in short selling activity relative to total volume
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        
        if len(short_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_short_ratio = np.sum(weights * short_ratio[-5:])
            eng.append(exp_short_ratio)
        else:
            eng.append(np.mean(short_ratio))
        
        # 2. Short interest to shares outstanding ratio
        # Provides normalized context for how much of the float is being shorted
        si_to_shares = data[t, 0] / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # 3. Short interest momentum (rate of change)
        # Captures acceleration in short interest changes - a key predictor
        if t > 0:
            prev_short = data[t-1, 0]
            curr_short = data[t, 0]
            denom = max(abs(prev_short), 1e-8)
            short_momentum = (curr_short / denom) - 1
            eng.append(short_momentum)
        else:
            eng.append(0)
        
        # 4. Short interest to days-to-cover ratio change
        # Captures changes in the relationship between SI and DTC - high importance in previous iterations
        if t > 0:
            curr_ratio = data[t, 0] / max(abs(data[t, 2]), 1e-8)
            prev_ratio = data[t-1, 0] / max(abs(data[t-1, 2]), 1e-8)
            ratio_change = curr_ratio / max(abs(prev_ratio), 1e-8) - 1
            eng.append(ratio_change)
        else:
            eng.append(0)
        
        # 5. Short interest to price ratio
        # Relationship between short interest and stock price - high importance in previous iterations
        si_price_ratio = data[t, 0] / max(abs(close_prices[-1]), 1e-8)
        eng.append(si_price_ratio)
        
        # 6. Bollinger Band position (normalized)
        # Indicates overbought/oversold conditions - important for predicting reversals
        if len(close_prices) >= 10:
            sma_10 = np.mean(close_prices[-10:])
            std_10 = max(abs(np.std(close_prices[-10:])), 1e-8)
            bb_position = (close_prices[-1] - sma_10) / std_10
            # Clamp extreme values for stability
            bb_position = max(min(bb_position, 3), -3)
            eng.append(bb_position)
        else:
            eng.append(0)
        
        # 7. Implied volatility to historical volatility ratio
        # Captures market expectations vs realized volatility - important for predicting short interest changes
        if len(close_prices) >= 14:
            daily_returns = np.zeros(14)
            for i in range(1, 15):
                daily_returns[i-1] = close_prices[i] / max(abs(close_prices[i-1]), 1e-8) - 1
            hist_vol = np.std(daily_returns) * np.sqrt(252)  # Annualized
            impl_vol = data[t, 65]
            vol_ratio = impl_vol / max(abs(hist_vol), 1e-8)
            # Clamp extreme values
            vol_ratio = max(min(vol_ratio, 5), 0.2)
            eng.append(vol_ratio)
        else:
            eng.append(1)
        
        # 8. Short volume trend change
        # Detects inflection points in short selling activity - high importance in previous iterations
        if len(short_volume) >= 10:
            recent_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
            eng.append(recent_trend)
        else:
            eng.append(0)
        
        # 9. Abnormal short volume
        # Identifies days with unusually high short volume relative to historical patterns
        if len(short_volume) >= 10:
            mean_short = np.mean(short_volume[-10:])
            std_short = max(np.std(short_volume[-10:]), 1e-8)
            z_score = (short_volume[-1] - mean_short) / std_short
            # Clamp extreme values
            z_score = max(min(z_score, 3), -3)
            eng.append(z_score)
        else:
            eng.append(0)
        
        # 10. Price momentum with volume weighting
        # Captures price trend strength weighted by volume - new feature to improve performance
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_changes = np.zeros(5)
            for i in range(1, 6):
                price_changes[i-1] = close_prices[-i] / max(abs(close_prices[-i-1]), 1e-8) - 1
            
            vol_weights = total_volume[-5:] / max(abs(np.sum(total_volume[-5:])), 1e-8)
            weighted_momentum = np.sum(price_changes * vol_weights)
            eng.append(weighted_momentum)
        else:
            eng.append(0)
        
        # 11. Short interest to implied volatility ratio
        # Relationship between short interest and expected volatility - high importance in previous iterations
        si_iv_ratio = data[t, 0] / max(abs(data[t, 65]), 1e-8)
        eng.append(si_iv_ratio)
        
        # 12. Put-Call ratio to short interest ratio
        # Relationship between options sentiment and short interest - important for predicting short interest changes
        pc_si_ratio = options_put_call_ratio / max(abs(data[t, 0]), 1e-8)
        eng.append(pc_si_ratio)
        
        # 13. Short volume concentration
        # Measures if short volume is concentrated in specific days - high importance in previous iterations
        if len(short_volume) >= 5:
            short_vol_std = np.std(short_volume[-5:])
            short_vol_mean = max(abs(np.mean(short_volume[-5:])), 1e-8)
            short_concentration = short_vol_std / short_vol_mean
            eng.append(short_concentration)
        else:
            eng.append(0)
        
        # 14. Price gap analysis
        # Identifies significant overnight price gaps which often precede short interest changes
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = np.zeros(min(4, len(open_prices)-1))
            for i in range(min(4, len(open_prices)-1)):
                gaps[i] = open_prices[-i-1] / max(abs(close_prices[-i-2]), 1e-8) - 1
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1])[:len(gaps)]
            weights = weights / np.sum(weights)
            weighted_gap = np.sum(gaps * weights)
            eng.append(weighted_gap)
        else:
            eng.append(0)
        
        # 15. Volume trend change
        # Detects shifts in trading volume which often precede short interest changes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = max(abs(np.mean(total_volume[-10:-5])), 1e-8)
            vol_trend_change = recent_vol / prev_vol - 1
            eng.append(vol_trend_change)
        else:
            eng.append(0)
        
        # 16. Short interest to volume ratio change
        # Captures changes in the relationship between short interest and trading volume - high importance in previous iterations
        if t > 0:
            curr_si_vol = data[t, 0] / max(abs(data[t, 1]), 1e-8)
            prev_si_vol = data[t-1, 0] / max(abs(data[t-1, 1]), 1e-8)
            si_vol_change = curr_si_vol / max(abs(prev_si_vol), 1e-8) - 1
            eng.append(si_vol_change)
        else:
            eng.append(0)
        
        # 17. Average true range (ATR) ratio - volatility indicator
        # Captures average price range including gaps, normalized by price
        if len(close_prices) >= 2:
            tr = np.zeros(min(14, len(close_prices)-1))
            for i in range(1, min(15, len(close_prices))):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr[i-1] = max(high_low, high_close, low_close)
            atr = np.mean(tr)
            atr_ratio = atr / max(abs(close_prices[-1]), 1e-8)
            eng.append(atr_ratio)
        else:
            eng.append(0)
        
        # 18. Options synthetic short cost to short interest ratio
        # Relationship between shorting cost and actual short interest - important for predicting short interest changes
        synth_short_cost = data[t, 64]
        short_interest = max(abs(data[t, 0]), 1e-8)
        cost_si_ratio = synth_short_cost / short_interest
        eng.append(cost_si_ratio)
        
        # 19. High-Low range relative to average daily volume
        # Captures price volatility relative to liquidity - high importance in previous iterations
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_range = np.mean(high_prices[-5:] - low_prices[-5:])
            range_to_vol = avg_range / max(abs(data[t, 1]), 1e-8)
            eng.append(range_to_vol)
        else:
            eng.append(0)
        
        # 20. Short interest acceleration (second derivative)
        # NEW FEATURE: Captures changes in the rate of change of short interest - important for predicting trend changes
        if t > 1:
            prev_momentum = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            curr_momentum = (data[t, 0] / max(abs(data[t-1, 0]), 1e-8)) - 1
            si_acceleration = curr_momentum - prev_momentum
            # Clamp extreme values
            si_acceleration = max(min(si_acceleration, 5), -5)
            eng.append(si_acceleration)
        else:
            eng.append(0)
        
        # 21. NEW FEATURE: Directional Movement Index (DMI) - Trend strength indicator
        # Captures the strength and direction of price trends - important for predicting short interest changes
        if len(high_prices) >= 14 and len(low_prices) >= 14 and len(close_prices) >= 14:
            # Calculate True Range (TR)
            tr_values = np.zeros(13)
            for i in range(1, 14):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr_values[i-1] = max(high_low, high_close, low_close)
            
            # Calculate Directional Movement
            plus_dm = np.zeros(13)
            minus_dm = np.zeros(13)
            for i in range(1, 14):
                up_move = high_prices[i] - high_prices[i-1]
                down_move = low_prices[i-1] - low_prices[i]
                
                if up_move > down_move and up_move > 0:
                    plus_dm[i-1] = up_move
                else:
                    plus_dm[i-1] = 0
                
                if down_move > up_move and down_move > 0:
                    minus_dm[i-1] = down_move
                else:
                    minus_dm[i-1] = 0
            
            # Calculate smoothed averages
            tr_avg = np.mean(tr_values)
            plus_di = np.mean(plus_dm) / max(abs(tr_avg), 1e-8) * 100
            minus_di = np.mean(minus_dm) / max(abs(tr_avg), 1e-8) * 100
            
            # Calculate DX
            di_diff = abs(plus_di - minus_di)
            di_sum = plus_di + minus_di
            dx = di_diff / max(abs(di_sum), 1e-8) * 100
            
            # Normalize to [-1, 1] range
            normalized_dx = (dx / 100) * 2 - 1
            eng.append(normalized_dx)
        else:
            eng.append(0)
        
        # 22. NEW FEATURE: Short Volume Momentum
        # Captures acceleration in short selling activity - important for predicting short interest changes
        if len(short_volume) >= 10:
            recent_short_vol = short_volume[-5:]
            prev_short_vol = short_volume[-10:-5]
            
            recent_momentum = 0
            prev_momentum = 0
            
            for i in range(1, 5):
                recent_momentum += recent_short_vol[i] / max(abs(recent_short_vol[i-1]), 1e-8) - 1
                prev_momentum += prev_short_vol[i] / max(abs(prev_short_vol[i-1]), 1e-8) - 1
            
            recent_momentum /= 4
            prev_momentum /= 4
            
            short_vol_acceleration = recent_momentum - prev_momentum
            # Clamp extreme values
            short_vol_acceleration = max(min(short_vol_acceleration, 3), -3)
            eng.append(short_vol_acceleration)
        else:
            eng.append(0)
        
        # 23. NEW FEATURE: Short Interest to Price Momentum Ratio
        # Captures relationship between short interest and price momentum - important for predicting short interest changes
        if len(close_prices) >= 10:
            price_momentum = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
            si_price_momentum_ratio = data[t, 0] / max(abs(1 + price_momentum), 1e-8)
            # Clamp extreme values
            si_price_momentum_ratio = max(min(si_price_momentum_ratio, 10), 0.1)
            eng.append(si_price_momentum_ratio)
        else:
            eng.append(0)
        
        # 24. NEW FEATURE: Short Interest Relative to Historical Range
        # Captures where current short interest stands relative to its historical range
        if t >= 5:
            historical_si = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min = np.min(historical_si)
            si_max = np.max(historical_si)
            si_range = max(abs(si_max - si_min), 1e-8)
            si_position = (data[t, 0] - si_min) / si_range
            # Normalize to [-1, 1] range
            si_position = max(min(si_position, 1), 0) * 2 - 1
            eng.append(si_position)
        else:
            eng.append(0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 878162.7328
RMSE: 1326572.2467
MAPE: 8.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 81

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_18_t3: importance=0.0018, rank=1
   2. Feature_21_t3: importance=0.0013, rank=2
   3. Feature_15_t3: importance=0.0010, rank=3
   4. Feature_12_t3: importance=0.0008, rank=4
   5. Feature_11_t2: importance=0.0008, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -0.76%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 604268.4340
RMSE: 814981.7429
MAPE: 7.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 246
   • Highly important features (top 5%): 120

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t3: importance=0.0008, rank=1
   2. Feature_84_t2: importance=0.0005, rank=2
   3. Feature_69_t1: importance=0.0005, rank=3
   4. Feature_0_t3: importance=0.0004, rank=4
   5. Feature_65_t0: importance=0.0004, rank=5
   Baseline MAPE: 7.53%
   Baseline MAE: 604268.4340
   Baseline RMSE: 814981.7429

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 816632.7619
RMSE: 1091762.6207
MAPE: 9.82%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 75
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t3: importance=0.0030, rank=1
   2. Feature_15_t3: importance=0.0019, rank=2
   3. Feature_16_t3: importance=0.0016, rank=3
   4. Feature_6_t1: importance=0.0012, rank=4
   5. Feature_14_t0: importance=0.0011, rank=5

📊 Best Model Test Set Performance:
   MAPE: 9.82%
   MAE: 816632.7619
   RMSE: 1091762.6207

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 7.53%
   Best Model MAPE: 9.82%
   Absolute Improvement: -2.28%
   Relative Improvement: -30.3%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  7.64            N/A                 
1          Iteration 1               7.34            +0.30%              
2          Iteration 2               7.69            -0.35%              
3          Iteration 3               7.47            -0.13%              
4          Iteration 4               7.68            -0.34%              
5          Iteration 5               7.85            -0.50%              
6          Iteration 6               8.10            -0.76%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 1 - MAPE: 7.34%
✅ Saved EXTR results to cache/EXTR_iterative_results_enhanced.pkl
✅ Summary report saved for EXTR

🎉 Process completed successfully for EXTR!

================================================================================
PROCESSING TICKER 10/14: SCSC
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for SCSC
======================================================================
📊 Loading data from parquet file...
📊 Loading data for SCSC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SCSC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 38219.9934
RMSE: 51448.7866
MAPE: 14.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 165
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t0: importance=0.0010, rank=1
   2. Feature_82_t2: importance=0.0010, rank=2
   3. Feature_82_t0: importance=0.0009, rank=3
   4. Feature_82_t3: importance=0.0007, rank=4
   5. Feature_70_t3: importance=0.0006, rank=5

📊 Baseline Performance: MAPE = 14.15%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
            data[t, 63], # options_put_call_volume_ratio
            data[t, 64], # options_synthetic_short_cost
            data[t, 65]  # options_avg_implied_volatility
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Add the most recent close price (last day)
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was indicated as important in feature importance analysis
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            den = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / den
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent short volume ratio trend (last 5 days vs previous 10 days)
        recent_short_ratio = np.mean(short_volume_ratio[-5:])
        previous_short_ratio = np.mean(short_volume_ratio[:-5])
        den = max(abs(previous_short_ratio), 1e-8)
        short_ratio_trend = recent_short_ratio / den - 1
        eng.append(short_ratio_trend)
        
        # 3. Price momentum: 5-day return
        if len(close_prices) >= 5:
            den = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = close_prices[-1] / den - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 4. Price volatility: normalized range
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            den = max(abs(recent_low), 1e-8)
            normalized_range = (recent_high - recent_low) / den
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 5. Short interest to shares outstanding ratio
        shares_outstanding = data[t, 66]
        den = max(abs(shares_outstanding), 1e-8)
        short_interest_ratio = data[t, 0] / den
        eng.append(short_interest_ratio)
        
        # 6. Volume trend: recent volume vs previous volume
        recent_volume = np.mean(total_volume[-5:])
        previous_volume = np.mean(total_volume[:-5])
        den = max(abs(previous_volume), 1e-8)
        volume_trend = recent_volume / den - 1
        eng.append(volume_trend)
        
        # 7. Short volume acceleration
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-3:])
            previous_short = np.mean(short_volume[-5:-2])
            den = max(abs(previous_short), 1e-8)
            short_accel = recent_short / den - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 8. Price gap: difference between consecutive closes
        if len(close_prices) >= 2:
            den = max(abs(close_prices[-2]), 1e-8)
            price_gap = close_prices[-1] / den - 1
        else:
            price_gap = 0
        eng.append(price_gap)
        
        # 9. RSI (14-day)
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            den = max(abs(avg_loss), 1e-8)
            rs = avg_gain / den
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # neutral value when not enough data
        eng.append(rsi)
        
        # 10. Bollinger Band Width
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            den = max(abs(sma), 1e-8)
            bb_width = (2 * std) / den
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 11. Short volume to average daily volume ratio
        avg_short_volume = np.mean(short_volume)
        den = max(abs(data[t, 1]), 1e-8)
        short_to_avg_volume = avg_short_volume / den
        eng.append(short_to_avg_volume)
        
        # 12. Options implied volatility to historical volatility ratio
        if len(close_prices) >= 10:
            hist_vol = np.std(np.diff(np.log(close_prices[-10:]))) * np.sqrt(252)
            den = max(abs(hist_vol), 1e-8)
            iv_to_hv_ratio = data[t, 65] / den
        else:
            iv_to_hv_ratio = 1
        eng.append(iv_to_hv_ratio)
        
        # 13. Short interest momentum (if we have previous data)
        if t > 0:
            den = max(abs(data[t-1, 0]), 1e-8)
            si_momentum = data[t, 0] / den - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 14. VWAP (Volume Weighted Average Price) for last 5 days
        if len(close_prices) >= 5:
            vwap_num = np.sum(close_prices[-5:] * total_volume[-5:])
            vwap_den = max(np.sum(total_volume[-5:]), 1e-8)
            vwap = vwap_num / vwap_den
            den = max(abs(close_prices[-1]), 1e-8)
            vwap_ratio = vwap / den
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 15. Short volume volatility
        short_vol_std = np.std(short_volume_ratio)
        eng.append(short_vol_std)
        
        # 16. Put-call ratio trend
        if t > 0:
            den = max(abs(data[t-1, 63]), 1e-8)
            pc_ratio_trend = data[t, 63] / den - 1
        else:
            pc_ratio_trend = 0
        eng.append(pc_ratio_trend)
        
        # 17. Synthetic short cost trend
        if t > 0:
            den = max(abs(data[t-1, 64]), 1e-8)
            short_cost_trend = data[t, 64] / den - 1
        else:
            short_cost_trend = 0
        eng.append(short_cost_trend)
        
        # 18. Days to cover trend
        if t > 0:
            den = max(abs(data[t-1, 2]), 1e-8)
            dtc_trend = data[t, 2] / den - 1
        else:
            dtc_trend = 0
        eng.append(dtc_trend)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 38781.6795
RMSE: 52382.0018
MAPE: 14.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t2: importance=0.0046, rank=1
   2. Feature_23_t1: importance=0.0012, rank=2
   3. Feature_18_t2: importance=0.0010, rank=3
   4. Feature_0_t3: importance=0.0009, rank=4
   5. Feature_15_t3: importance=0.0009, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
📊 No significant improvement. Change: -0.63%

📈 Current best MAPE: 14.15%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we're keeping the most important raw features
        raw_keep = [
            data[t, 0],   # short interest - fundamental target variable
            data[t, 1],   # average daily volume - essential for liquidity context
            data[t, 2],   # days to cover - key short interest metric
            data[t, 63],  # options_put_call_volume_ratio - sentiment indicator
            data[t, 64],  # options_synthetic_short_cost - cost of shorting
            data[t, 65]   # options_avg_implied_volatility - market expectation of volatility
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was indicated as important in feature importance analysis
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            den = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / den
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short Volume Ratio Trend (last 5 days vs previous 10 days)
        # Captures acceleration in short selling activity
        recent_short_ratio = np.mean(short_volume_ratio[-5:])
        previous_short_ratio = np.mean(short_volume_ratio[:-5])
        den = max(abs(previous_short_ratio), 1e-8)
        short_ratio_trend = recent_short_ratio / den - 1
        eng.append(short_ratio_trend)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of tradable shares are sold short
        den = max(abs(shares_outstanding), 1e-8)
        short_interest_ratio = data[t, 0] / den
        eng.append(short_interest_ratio)
        
        # 4. Short Interest Momentum (if we have previous data)
        # Rate of change in short interest - high importance in previous iteration
        if t > 0:
            den = max(abs(data[t-1, 0]), 1e-8)
            si_momentum = data[t, 0] / den - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 5. Short Volume Volatility
        # Measures consistency/inconsistency in short selling behavior
        short_vol_std = np.std(short_volume_ratio)
        eng.append(short_vol_std)
        
        # 6. Recent Price Trend (5-day)
        # Captures medium-term price momentum
        if len(close_prices) >= 5:
            den = max(abs(close_prices[-5]), 1e-8)
            price_trend_5d = close_prices[-1] / den - 1
        else:
            price_trend_5d = 0
        eng.append(price_trend_5d)
        
        # 7. Recent Price Trend (3-day)
        # Captures short-term price momentum
        if len(close_prices) >= 3:
            den = max(abs(close_prices[-3]), 1e-8)
            price_trend_3d = close_prices[-1] / den - 1
        else:
            price_trend_3d = 0
        eng.append(price_trend_3d)
        
        # 8. Price Volatility: normalized range
        # Measures recent price volatility
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            den = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / den
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 9. Volume Trend: recent volume vs previous volume
        # Captures changes in trading activity
        recent_volume = np.mean(total_volume[-5:])
        previous_volume = np.mean(total_volume[:-5])
        den = max(abs(previous_volume), 1e-8)
        volume_trend = recent_volume / den - 1
        eng.append(volume_trend)
        
        # 10. Short Volume to Average Daily Volume Ratio
        # Compares short selling to overall trading activity
        avg_short_volume = np.mean(short_volume)
        den = max(abs(data[t, 1]), 1e-8)
        short_to_avg_volume = avg_short_volume / den
        eng.append(short_to_avg_volume)
        
        # 11. Days to Cover Trend
        # Captures changes in how long it would take shorts to cover
        if t > 0:
            den = max(abs(data[t-1, 2]), 1e-8)
            dtc_trend = data[t, 2] / den - 1
        else:
            dtc_trend = 0
        eng.append(dtc_trend)
        
        # 12. RSI (14-day) - Relative Strength Index
        # Technical indicator showing overbought/oversold conditions
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            den = max(abs(avg_loss), 1e-8)
            rs = avg_gain / den
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # neutral value when not enough data
        eng.append(rsi)
        
        # 13. Short Volume Acceleration
        # Captures acceleration in short selling activity
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-3:])
            previous_short = np.mean(short_volume[-5:-2])
            den = max(abs(previous_short), 1e-8)
            short_accel = recent_short / den - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 14. VWAP Ratio (Volume Weighted Average Price)
        # Compares current price to average price weighted by volume
        if len(close_prices) >= 5:
            vwap_num = np.sum(close_prices[-5:] * total_volume[-5:])
            vwap_den = max(np.sum(total_volume[-5:]), 1e-8)
            vwap = vwap_num / vwap_den
            den = max(abs(close_prices[-1]), 1e-8)
            vwap_ratio = vwap / den
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 15. Options Implied Volatility to Historical Volatility Ratio
        # Compares market expectations to realized volatility
        if len(close_prices) >= 10:
            returns = np.diff(np.log(close_prices[-11:]))
            hist_vol = np.std(returns) * np.sqrt(252)
            den = max(abs(hist_vol), 1e-8)
            iv_to_hv_ratio = data[t, 65] / den
        else:
            iv_to_hv_ratio = 1
        eng.append(iv_to_hv_ratio)
        
        # 16. Short Interest to Days to Cover Ratio
        # Combines two key metrics for a more comprehensive view
        den = max(abs(data[t, 2]), 1e-8)
        si_to_dtc = data[t, 0] / den
        eng.append(si_to_dtc)
        
        # 17. Recent Short Volume Trend (3-day)
        # Very recent short selling activity
        if len(short_volume) >= 3:
            recent_3d_short = np.mean(short_volume[-3:])
            den = max(abs(np.mean(short_volume[:-3])), 1e-8)
            short_trend_3d = recent_3d_short / den - 1
        else:
            short_trend_3d = 0
        eng.append(short_trend_3d)
        
        # 18. Price Gap: difference between consecutive closes
        # Captures overnight price jumps
        if len(close_prices) >= 2:
            den = max(abs(close_prices[-2]), 1e-8)
            price_gap = close_prices[-1] / den - 1
        else:
            price_gap = 0
        eng.append(price_gap)
        
        # 19. Bollinger Band Width
        # Measures expected price range based on volatility
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            den = max(abs(sma), 1e-8)
            bb_width = (2 * std) / den
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 39892.2345
RMSE: 53143.4159
MAPE: 15.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0018, rank=1
   2. Feature_17_t1: importance=0.0014, rank=2
   3. Feature_20_t2: importance=0.0013, rank=3
   4. Feature_8_t3: importance=0.0012, rank=4
   5. Feature_17_t3: importance=0.0010, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -1.01%

📈 Current best MAPE: 14.15%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we're keeping the most important raw features
        # Feature_82_t0, Feature_82_t2, Feature_82_t3, Feature_70_t3 were top important features
        # These correspond to short volume and total volume data
        raw_keep = [
            data[t, 0],   # short interest - fundamental target variable
            data[t, 1],   # average daily volume - essential for liquidity context
            data[t, 2],   # days to cover - key short interest metric
            data[t, 63],  # options_put_call_volume_ratio - sentiment indicator
            data[t, 65]   # options_avg_implied_volatility - market expectation of volatility
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data (these were top important features)
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # This was indicated as important in feature importance analysis
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            den = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / den
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent Short Volume Ratio (last 5 days)
        # Feature_82_t0 was a top important feature, focusing on recent short volume
        recent_short_ratio = np.mean(short_volume_ratio[-5:])
        eng.append(recent_short_ratio)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of tradable shares are sold short
        den = max(abs(shares_outstanding), 1e-8)
        short_interest_ratio = data[t, 0] / den
        eng.append(short_interest_ratio)
        
        # 4. Short Interest Momentum (if we have previous data)
        # Rate of change in short interest - high importance in previous iteration
        if t > 0:
            den = max(abs(data[t-1, 0]), 1e-8)
            si_momentum = data[t, 0] / den - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 5. Short Volume Volatility
        # Measures consistency/inconsistency in short selling behavior
        short_vol_std = np.std(short_volume_ratio)
        eng.append(short_vol_std)
        
        # 6. Recent Price Trend (5-day)
        # Captures medium-term price momentum
        if len(close_prices) >= 5:
            den = max(abs(close_prices[-5]), 1e-8)
            price_trend_5d = close_prices[-1] / den - 1
        else:
            price_trend_5d = 0
        eng.append(price_trend_5d)
        
        # 7. Price Volatility: normalized range
        # Measures recent price volatility
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            den = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / den
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 8. Short Volume to Average Daily Volume Ratio
        # Compares short selling to overall trading activity
        avg_short_volume = np.mean(short_volume)
        den = max(abs(data[t, 1]), 1e-8)
        short_to_avg_volume = avg_short_volume / den
        eng.append(short_to_avg_volume)
        
        # 9. Days to Cover Trend
        # Captures changes in how long it would take shorts to cover
        if t > 0:
            den = max(abs(data[t-1, 2]), 1e-8)
            dtc_trend = data[t, 2] / den - 1
        else:
            dtc_trend = 0
        eng.append(dtc_trend)
        
        # 10. Short Volume Acceleration
        # Captures acceleration in short selling activity
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-3:])
            previous_short = np.mean(short_volume[-5:-2])
            den = max(abs(previous_short), 1e-8)
            short_accel = recent_short / den - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 11. Short Volume Ratio Trend (last 3 days vs previous 3 days)
        # Captures very recent changes in short selling behavior
        if len(short_volume_ratio) >= 6:
            recent_ratio = np.mean(short_volume_ratio[-3:])
            previous_ratio = np.mean(short_volume_ratio[-6:-3])
            den = max(abs(previous_ratio), 1e-8)
            short_ratio_trend_3d = recent_ratio / den - 1
        else:
            short_ratio_trend_3d = 0
        eng.append(short_ratio_trend_3d)
        
        # 12. Recent Total Volume Trend (3-day)
        # Feature_82_t0 was important - focusing on recent total volume trends
        if len(total_volume) >= 6:
            recent_vol = np.mean(total_volume[-3:])
            previous_vol = np.mean(total_volume[-6:-3])
            den = max(abs(previous_vol), 1e-8)
            total_vol_trend_3d = recent_vol / den - 1
        else:
            total_vol_trend_3d = 0
        eng.append(total_vol_trend_3d)
        
        # 13. Short Interest to Days to Cover Ratio
        # Combines two key metrics for a more comprehensive view
        den = max(abs(data[t, 2]), 1e-8)
        si_to_dtc = data[t, 0] / den
        eng.append(si_to_dtc)
        
        # 14. Price to Volume Correlation
        # Measures relationship between price movement and volume
        if len(close_prices) >= 5:
            price_returns = np.diff(close_prices[-6:])
            vol_changes = np.diff(total_volume[-6:])
            if len(price_returns) > 0 and len(vol_changes) > 0 and np.std(price_returns) > 0 and np.std(vol_changes) > 0:
                price_vol_corr = np.corrcoef(price_returns, vol_changes)[0, 1]
                if np.isnan(price_vol_corr):
                    price_vol_corr = 0
            else:
                price_vol_corr = 0
        else:
            price_vol_corr = 0
        eng.append(price_vol_corr)
        
        # 15. Short Volume Ratio Dispersion
        # Measures how spread out the short volume ratio is
        short_ratio_dispersion = np.max(short_volume_ratio) - np.min(short_volume_ratio)
        eng.append(short_ratio_dispersion)
        
        # 16. Recent Short Volume Ratio Volatility (5-day)
        # Measures recent volatility in short volume ratio
        if len(short_volume_ratio) >= 5:
            recent_short_ratio_vol = np.std(short_volume_ratio[-5:])
        else:
            recent_short_ratio_vol = 0
        eng.append(recent_short_ratio_vol)
        
        # 17. Short Volume Ratio Skew
        # Measures asymmetry in short volume ratio distribution
        if len(short_volume_ratio) >= 5:
            mean_ratio = np.mean(short_volume_ratio)
            std_ratio = max(np.std(short_volume_ratio), 1e-8)
            skew_values = ((short_volume_ratio - mean_ratio) / std_ratio) ** 3
            short_ratio_skew = np.mean(skew_values)
        else:
            short_ratio_skew = 0
        eng.append(short_ratio_skew)
        
        # 18. Recent Price Gap Volatility
        # Measures volatility in overnight price gaps
        if len(close_prices) >= 6 and len(open_prices) >= 6:
            gaps = open_prices[-5:] / np.maximum(abs(close_prices[-6:-1]), 1e-8) - 1
            gap_volatility = np.std(gaps)
        else:
            gap_volatility = 0
        eng.append(gap_volatility)
        
        # 19. Short Volume Ratio Momentum
        # Rate of change in short volume ratio
        if len(short_volume_ratio) >= 2:
            den = max(abs(short_volume_ratio[-2]), 1e-8)
            short_ratio_momentum = short_volume_ratio[-1] / den - 1
        else:
            short_ratio_momentum = 0
        eng.append(short_ratio_momentum)
        
        # 20. Weighted Short Volume Ratio (recent days weighted more)
        # Gives more importance to recent short volume activity
        if len(short_volume_ratio) >= 5:
            weights = np.array([1, 2, 3, 4, 5])
            weighted_ratio = np.sum(short_volume_ratio[-5:] * weights) / np.sum(weights)
        else:
            weighted_ratio = avg_short_volume_ratio
        eng.append(weighted_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 40044.4850
RMSE: 53112.0882
MAPE: 15.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t3: importance=0.0017, rank=1
   2. Feature_21_t3: importance=0.0014, rank=2
   3. Feature_14_t3: importance=0.0013, rank=3
   4. Feature_14_t1: importance=0.0012, rank=4
   5. Feature_16_t1: importance=0.0012, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -1.08%

📈 Current best MAPE: 14.15%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Extract key data components for easier access
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features based on importance analysis
        # Previous iterations showed short interest, volume metrics, and options data were most important
        raw_keep = [
            short_interest,                # Target variable - essential
            avg_daily_volume,              # Key liquidity metric
            days_to_cover,                 # Important short interest metric
            put_call_ratio,                # Options sentiment indicator
            implied_volatility,            # Market expectation of volatility
            synthetic_short_cost,          # Cost of shorting - directly relevant
            close_prices[-1],              # Most recent closing price
            shares_outstanding             # Important for normalizing short interest
        ]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            den = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / den
        
        # 2. Recent Short Volume Ratio (last 5 days)
        # Feature_82_t0 was a top important feature, focusing on recent short volume
        recent_short_ratio = np.mean(short_volume_ratio[-5:])
        eng.append(recent_short_ratio)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of tradable shares are sold short
        den = max(abs(shares_outstanding), 1e-8)
        short_interest_ratio = short_interest / den
        eng.append(short_interest_ratio)
        
        # 4. Short Interest Momentum (if we have previous data)
        # Rate of change in short interest - high importance in previous iteration
        if t > 0:
            den = max(abs(data[t-1, 0]), 1e-8)
            si_momentum = short_interest / den - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 5. Short Volume Trend Strength
        # Measures the strength and direction of short volume trend
        if len(short_volume) >= 10:
            x = np.arange(10)
            y = short_volume[-10:]
            den = max(abs(np.mean(y)), 1e-8)
            normalized_y = y / den
            # Simple linear regression slope
            slope = np.polyfit(x, normalized_y, 1)[0] * 10  # Scale for better signal
        else:
            slope = 0
        eng.append(slope)
        
        # 6. Short Volume Acceleration
        # Captures acceleration in short selling activity - second derivative
        if len(short_volume) >= 10:
            recent_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
            older_trend = np.mean(short_volume[-10:-5]) / max(abs(np.mean(short_volume[-15:-10]) if len(short_volume) >= 15 else short_volume[-10:-5]), 1e-8) - 1
            short_accel = recent_trend - older_trend
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 7. Price Momentum (5-day)
        # Captures medium-term price momentum
        if len(close_prices) >= 5:
            den = max(abs(close_prices[-5]), 1e-8)
            price_momentum_5d = close_prices[-1] / den - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # 8. Price Volatility: normalized range
        # Measures recent price volatility
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            den = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / den
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 9. Short Volume to Average Daily Volume Ratio
        # Compares short selling to overall trading activity
        avg_short_volume = np.mean(short_volume)
        den = max(abs(avg_daily_volume), 1e-8)
        short_to_avg_volume = avg_short_volume / den
        eng.append(short_to_avg_volume)
        
        # 10. Days to Cover Trend
        # Captures changes in how long it would take shorts to cover
        if t > 0:
            den = max(abs(data[t-1, 2]), 1e-8)
            dtc_trend = days_to_cover / den - 1
        else:
            dtc_trend = 0
        eng.append(dtc_trend)
        
        # 11. Short Volume Ratio Dispersion
        # Measures how spread out the short volume ratio is
        short_ratio_dispersion = np.max(short_volume_ratio) - np.min(short_volume_ratio)
        eng.append(short_ratio_dispersion)
        
        # 12. Implied Volatility to Price Volatility Ratio
        # Compares market expectations (options) to actual price volatility
        if normalized_range > 0:
            iv_to_price_vol = implied_volatility / max(normalized_range, 1e-8)
        else:
            iv_to_price_vol = implied_volatility
        eng.append(iv_to_price_vol)
        
        # 13. Short Interest to Days to Cover Ratio
        # Combines two key metrics for a more comprehensive view
        den = max(abs(days_to_cover), 1e-8)
        si_to_dtc = short_interest / den
        eng.append(si_to_dtc)
        
        # 14. Volume Trend Strength
        # Measures the strength and direction of total volume trend
        if len(total_volume) >= 10:
            x = np.arange(10)
            y = total_volume[-10:]
            den = max(abs(np.mean(y)), 1e-8)
            normalized_y = y / den
            # Simple linear regression slope
            vol_slope = np.polyfit(x, normalized_y, 1)[0] * 10  # Scale for better signal
        else:
            vol_slope = 0
        eng.append(vol_slope)
        
        # 15. Short Interest to Put/Call Ratio
        # Relates short interest to options market sentiment
        den = max(abs(put_call_ratio), 1e-8)
        si_to_pc = short_interest / den
        eng.append(si_to_pc)
        
        # 16. Relative Strength Index (RSI) of Short Volume
        # Technical indicator adapted for short volume
        if len(short_volume) >= 14:
            delta = np.diff(short_volume[-15:])
            gain = np.sum(delta[delta > 0])
            loss = np.sum(-delta[delta < 0])
            if loss == 0:
                rsi = 100
            else:
                rs = gain / max(loss, 1e-8)
                rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 17. Synthetic Short Cost to Implied Volatility Ratio
        # Relates cost of shorting to market volatility expectations
        den = max(abs(implied_volatility), 1e-8)
        short_cost_to_iv = synthetic_short_cost / den
        eng.append(short_cost_to_iv)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 41456.4055
RMSE: 53629.0559
MAPE: 15.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0016, rank=1
   2. Feature_18_t1: importance=0.0011, rank=2
   3. Feature_23_t0: importance=0.0011, rank=3
   4. Feature_23_t3: importance=0.0010, rank=4
   5. Feature_9_t3: importance=0.0009, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -1.42%

📈 Current best MAPE: 14.15%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Extract key data components for easier access
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features based on importance analysis
        # Focus on the most important features from previous iterations
        raw_keep = [
            short_interest,                # Target variable - essential
            avg_daily_volume,              # Key liquidity metric
            days_to_cover,                 # Important short interest metric
            put_call_ratio,                # Options sentiment indicator
            implied_volatility,            # Market expectation of volatility
            synthetic_short_cost,          # Cost of shorting - directly relevant
            close_prices[-1],              # Most recent closing price
            # Removed shares_outstanding as it showed lower importance
        ]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        # Focus on the most recent 5 days which showed higher importance
        short_volume_ratio = np.zeros(len(short_volume))
        for i in range(len(short_volume)):
            den = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / den
        
        # 2. Recent Short Volume Ratio (last 5 days)
        # Feature_82_t0 was a top important feature
        recent_short_ratio = np.mean(short_volume_ratio[-5:])
        eng.append(recent_short_ratio)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of tradable shares are sold short
        den = max(abs(shares_outstanding), 1e-8)
        short_interest_ratio = short_interest / den
        eng.append(short_interest_ratio)
        
        # 4. Short Interest Momentum (if we have previous data)
        # Rate of change in short interest - high importance in previous iteration
        if t > 0:
            den = max(abs(data[t-1, 0]), 1e-8)
            si_momentum = short_interest / den - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 5. Short Volume Trend Strength
        # Measures the strength and direction of short volume trend
        if len(short_volume) >= 10:
            x = np.arange(10)
            y = short_volume[-10:]
            den = max(abs(np.mean(y)), 1e-8)
            normalized_y = y / den
            # Simple linear regression slope
            slope = np.polyfit(x, normalized_y, 1)[0] * 10  # Scale for better signal
        else:
            slope = 0
        eng.append(slope)
        
        # 6. Short Volume Acceleration
        # Captures acceleration in short selling activity - second derivative
        if len(short_volume) >= 10:
            recent_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
            older_trend = np.mean(short_volume[-10:-5]) / max(abs(np.mean(short_volume[-15:-10]) if len(short_volume) >= 15 else short_volume[-10:-5]), 1e-8) - 1
            short_accel = recent_trend - older_trend
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 7. Price Momentum (5-day)
        # Captures medium-term price momentum
        if len(close_prices) >= 5:
            den = max(abs(close_prices[-5]), 1e-8)
            price_momentum_5d = close_prices[-1] / den - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # 8. Price Volatility: normalized range
        # Measures recent price volatility
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            den = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / den
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 9. Short Volume to Average Daily Volume Ratio
        # Compares short selling to overall trading activity
        avg_short_volume = np.mean(short_volume)
        den = max(abs(avg_daily_volume), 1e-8)
        short_to_avg_volume = avg_short_volume / den
        eng.append(short_to_avg_volume)
        
        # 10. Days to Cover Trend
        # Captures changes in how long it would take shorts to cover
        if t > 0:
            den = max(abs(data[t-1, 2]), 1e-8)
            dtc_trend = days_to_cover / den - 1
        else:
            dtc_trend = 0
        eng.append(dtc_trend)
        
        # 11. Short Volume Ratio Dispersion
        # Measures how spread out the short volume ratio is
        short_ratio_dispersion = np.std(short_volume_ratio)  # Changed to std for better statistical properties
        eng.append(short_ratio_dispersion)
        
        # 12. Implied Volatility to Price Volatility Ratio
        # Compares market expectations (options) to actual price volatility
        if normalized_range > 0:
            iv_to_price_vol = implied_volatility / max(normalized_range, 1e-8)
        else:
            iv_to_price_vol = implied_volatility
        eng.append(iv_to_price_vol)
        
        # 13. Short Interest to Days to Cover Ratio
        # Combines two key metrics for a more comprehensive view
        den = max(abs(days_to_cover), 1e-8)
        si_to_dtc = short_interest / den
        eng.append(si_to_dtc)
        
        # NEW FEATURE: 14. Relative Short Volume Trend
        # Compares recent short volume to longer-term average
        if len(short_volume) >= 10:
            recent_short = np.mean(short_volume[-5:])
            longer_short = np.mean(short_volume[-10:])
            den = max(abs(longer_short), 1e-8)
            rel_short_trend = recent_short / den - 1
        else:
            rel_short_trend = 0
        eng.append(rel_short_trend)
        
        # NEW FEATURE: 15. Short Volume Volatility
        # Measures the volatility of short volume over time
        if len(short_volume) >= 5:
            short_vol_volatility = np.std(short_volume[-5:]) / max(abs(np.mean(short_volume[-5:])), 1e-8)
        else:
            short_vol_volatility = 0
        eng.append(short_vol_volatility)
        
        # NEW FEATURE: 16. Price-Volume Correlation
        # Measures the correlation between price changes and volume
        if len(close_prices) >= 5:
            price_changes = np.diff(close_prices[-6:])
            vol_changes = np.diff(np.array(total_volume[-6:]))
            if len(price_changes) >= 2 and len(vol_changes) >= 2:
                # Use a simple correlation calculation to avoid numerical instability
                price_changes_norm = price_changes - np.mean(price_changes)
                vol_changes_norm = vol_changes - np.mean(vol_changes)
                den_price = max(np.sqrt(np.sum(price_changes_norm**2)), 1e-8)
                den_vol = max(np.sqrt(np.sum(vol_changes_norm**2)), 1e-8)
                price_vol_corr = np.sum(price_changes_norm * vol_changes_norm) / (den_price * den_vol)
            else:
                price_vol_corr = 0
        else:
            price_vol_corr = 0
        eng.append(price_vol_corr)
        
        # NEW FEATURE: 17. Short Interest Efficiency
        # Measures how effectively short sellers are timing their positions
        if t > 0 and len(close_prices) >= 5:
            prev_si = data[t-1, 0]
            si_change = short_interest / max(abs(prev_si), 1e-8) - 1
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            # Negative correlation indicates effective short selling
            si_efficiency = -1 * si_change * price_change
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # NEW FEATURE: 18. Short Volume Ratio Momentum
        # Captures the rate of change in short volume ratio
        if len(short_volume_ratio) >= 10:
            recent_ratio = np.mean(short_volume_ratio[-5:])
            older_ratio = np.mean(short_volume_ratio[-10:-5])
            den = max(abs(older_ratio), 1e-8)
            ratio_momentum = recent_ratio / den - 1
        else:
            ratio_momentum = 0
        eng.append(ratio_momentum)
        
        # NEW FEATURE: 19. Relative Strength Index (RSI) of Price
        # Technical indicator for price momentum
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.sum(delta[delta > 0])
            loss = np.sum(-delta[delta < 0])
            if loss == 0:
                price_rsi = 100
            else:
                rs = gain / max(loss, 1e-8)
                price_rsi = 100 - (100 / (1 + rs))
        else:
            price_rsi = 50  # Neutral value when not enough data
        eng.append(price_rsi)
        
        # NEW FEATURE: 20. Short Interest to Price Momentum Ratio
        # Relates short interest to recent price movements
        den = max(abs(price_momentum_5d), 1e-8)
        si_to_price_momentum = short_interest / den
        eng.append(si_to_price_momentum)
        
        # NEW FEATURE: 21. Bollinger Band Width of Short Volume
        # Measures the volatility of short volume using Bollinger Bands
        if len(short_volume) >= 10:
            sma = np.mean(short_volume[-10:])
            std = np.std(short_volume[-10:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # NEW FEATURE: 22. Short Volume Ratio Extremes
        # Captures extreme short selling behavior
        if len(short_volume_ratio) >= 5:
            max_ratio = np.max(short_volume_ratio[-5:])
            min_ratio = np.min(short_volume_ratio[-5:])
            avg_ratio = np.mean(short_volume_ratio[-5:])
            den = max(abs(avg_ratio), 1e-8)
            ratio_extremes = (max_ratio - min_ratio) / den
        else:
            ratio_extremes = 0
        eng.append(ratio_extremes)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 42010.3584
RMSE: 56143.5028
MAPE: 16.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t0: importance=0.0013, rank=1
   2. Feature_20_t2: importance=0.0010, rank=2
   3. Feature_22_t1: importance=0.0010, rank=3
   4. Feature_20_t3: importance=0.0009, rank=4
   5. Feature_16_t2: importance=0.0008, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -1.96%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 166784.6698
RMSE: 242181.3330
MAPE: 11.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 238
   • Highly important features (top 5%): 115

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t0: importance=0.0008, rank=1
   2. Feature_67_t0: importance=0.0007, rank=2
   3. Feature_85_t0: importance=0.0006, rank=3
   4. Feature_82_t3: importance=0.0006, rank=4
   5. Feature_69_t0: importance=0.0006, rank=5
   Baseline MAPE: 11.52%
   Baseline MAE: 166784.6698
   Baseline RMSE: 242181.3330

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 154027.3836
RMSE: 236641.5424
MAPE: 11.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t2: importance=0.0035, rank=1
   2. Feature_4_t3: importance=0.0012, rank=2
   3. Feature_15_t1: importance=0.0012, rank=3
   4. Feature_19_t2: importance=0.0011, rank=4
   5. Feature_0_t3: importance=0.0010, rank=5

📊 Best Model Test Set Performance:
   MAPE: 11.28%
   MAE: 154027.3836
   RMSE: 236641.5424

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 11.52%
   Best Model MAPE: 11.28%
   Absolute Improvement: 0.24%
   Relative Improvement: 2.1%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  14.15           N/A                 
1          Iteration 1               14.78           -0.63%              
2          Iteration 2               15.16           -1.01%              
3          Iteration 3               15.23           -1.08%              
4          Iteration 4               15.57           -1.42%              
5          Iteration 5               16.11           -1.96%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 1 - MAPE: 14.78%
✅ Saved SCSC results to cache/SCSC_iterative_results_enhanced.pkl
✅ Summary report saved for SCSC

🎉 Process completed successfully for SCSC!

================================================================================
PROCESSING TICKER 11/14: SLG
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for SLG
======================================================================
📊 Loading data from parquet file...
📊 Loading data for SLG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SLG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 747582.0063
RMSE: 1120316.5031
MAPE: 5.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 293
   • Highly important features (top 5%): 208

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t3: importance=0.0011, rank=1
   2. Feature_71_t2: importance=0.0001, rank=2
   3. Feature_83_t2: importance=0.0001, rank=3
   4. Feature_88_t1: importance=0.0001, rank=4
   5. Feature_90_t2: importance=0.0001, rank=5

📊 Baseline Performance: MAPE = 5.68%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume as they're fundamental
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep the most recent close price
        raw_keep.append(close_prices[-1])
        
        # Extract options data
        raw_keep.append(data[t, 63])  # put_call_volume_ratio
        raw_keep.append(data[t, 65])  # avg_implied_volatility
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep the most recent short volume and total volume
        raw_keep.append(short_volume[-1])
        raw_keep.append(total_volume[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        short_vol_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_vol_ratio[i] = short_volume[i] / denom
        
        # Recent short volume ratio (most predictive according to feature importance)
        eng.append(short_vol_ratio[-1])
        
        # 2. Short Volume Ratio 5-day trend
        if len(eng) < MAX_NEW:
            short_vol_ratio_trend = 0
            if len(short_vol_ratio) >= 5:
                recent_ratio = short_vol_ratio[-5:]
                if np.std(recent_ratio) > 1e-8:
                    # Simple linear regression slope
                    x = np.arange(5)
                    slope = np.polyfit(x, recent_ratio, 1)[0]
                    short_vol_ratio_trend = slope
            eng.append(short_vol_ratio_trend)
        
        # 3. Price momentum (5-day)
        if len(eng) < MAX_NEW:
            price_momentum = 0
            if len(close_prices) >= 5:
                denom = max(abs(close_prices[-5]), 1e-8)
                price_momentum = (close_prices[-1] / denom) - 1
            eng.append(price_momentum)
        
        # 4. Volatility (standard deviation of returns over 10 days)
        if len(eng) < MAX_NEW:
            volatility = 0
            if len(close_prices) >= 10:
                returns = np.diff(close_prices[-10:]) / close_prices[-11:-1]
                volatility = np.std(returns)
            eng.append(volatility)
        
        # 5. RSI (14-day)
        if len(eng) < MAX_NEW:
            rsi = 50  # Default to neutral
            if len(close_prices) >= 15:
                delta = np.diff(close_prices)
                gain = np.where(delta > 0, delta, 0)
                loss = np.where(delta < 0, -delta, 0)
                
                avg_gain = np.mean(gain)
                avg_loss = np.mean(loss)
                
                if avg_loss > 1e-8:
                    rs = avg_gain / avg_loss
                    rsi = 100 - (100 / (1 + rs))
                elif avg_gain > 0:
                    rsi = 100
            eng.append(rsi)
        
        # 6. Short Interest to Float Ratio
        if len(eng) < MAX_NEW:
            shares_outstanding = data[t, 66]
            denom = max(abs(shares_outstanding), 1e-8)
            short_interest_to_float = data[t, 0] / denom
            eng.append(short_interest_to_float)
        
        # 7. Short Volume Acceleration (change in short volume ratio)
        if len(eng) < MAX_NEW:
            short_vol_accel = 0
            if len(short_vol_ratio) >= 3:
                short_vol_accel = short_vol_ratio[-1] - short_vol_ratio[-3]
            eng.append(short_vol_accel)
        
        # 8. Price Range Ratio (High-Low)/Close
        if len(eng) < MAX_NEW:
            price_range_ratio = 0
            if len(close_prices) > 0:
                recent_high = np.max(high_prices[-5:])
                recent_low = np.min(low_prices[-5:])
                denom = max(abs(close_prices[-1]), 1e-8)
                price_range_ratio = (recent_high - recent_low) / denom
            eng.append(price_range_ratio)
        
        # 9. Volume Trend (5-day)
        if len(eng) < MAX_NEW:
            volume_trend = 0
            if len(total_volume) >= 5:
                recent_volume = total_volume[-5:]
                if np.std(recent_volume) > 1e-8:
                    x = np.arange(5)
                    slope = np.polyfit(x, recent_volume, 1)[0]
                    denom = max(abs(np.mean(recent_volume)), 1e-8)
                    volume_trend = slope / denom
            eng.append(volume_trend)
        
        # 10. Options Implied Volatility to Historical Volatility Ratio
        if len(eng) < MAX_NEW:
            iv_hv_ratio = 0
            implied_vol = data[t, 65]
            if len(close_prices) >= 10 and implied_vol > 0:
                returns = np.diff(close_prices[-10:]) / close_prices[-11:-1]
                hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
                denom = max(abs(hist_vol), 1e-8)
                iv_hv_ratio = implied_vol / denom
            eng.append(iv_hv_ratio)
        
        # 11. Short Interest Change Rate
        if len(eng) < MAX_NEW and t > 0:
            prev_short_interest = data[t-1, 0]
            denom = max(abs(prev_short_interest), 1e-8)
            short_interest_change = (data[t, 0] / denom) - 1
            eng.append(short_interest_change)
        elif len(eng) < MAX_NEW:
            eng.append(0)  # Placeholder for first timestep
        
        # 12. Average True Range (ATR)
        if len(eng) < MAX_NEW:
            atr = 0
            if len(close_prices) >= 2:
                tr_values = []
                for i in range(1, min(10, len(close_prices))):
                    high_low = high_prices[-i] - low_prices[-i]
                    high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                    low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                    tr = max(high_low, high_close, low_close)
                    tr_values.append(tr)
                atr = np.mean(tr_values) if tr_values else 0
            eng.append(atr)
        
        # 13. Put-Call Ratio Trend
        if len(eng) < MAX_NEW and t >= 2:
            put_call_trend = data[t, 63] - data[t-2, 63]
            eng.append(put_call_trend)
        elif len(eng) < MAX_NEW:
            eng.append(0)  # Placeholder for first two timesteps
        
        # 14. Short Volume to Average Volume Ratio
        if len(eng) < MAX_NEW:
            denom = max(abs(data[t, 1]), 1e-8)  # Average daily volume
            short_vol_to_avg = np.mean(short_volume) / denom
            eng.append(short_vol_to_avg)
        
        # 15. Price to Moving Average Ratio
        if len(eng) < MAX_NEW:
            price_to_ma = 1.0
            if len(close_prices) >= 10:
                ma10 = np.mean(close_prices[-10:])
                denom = max(abs(ma10), 1e-8)
                price_to_ma = close_prices[-1] / denom
            eng.append(price_to_ma)
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure we have exactly MAX_TOTAL features
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average daily volume
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)
        raw_keep.append(avg_daily_volume)
        raw_keep.append(days_to_cover)
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values
        raw_keep.append(close_prices[-1])  # Most recent close
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep important options data
        raw_keep.append(put_call_ratio)
        raw_keep.append(implied_volatility)
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep the most recent short volume and total volume
        raw_keep.append(short_volume[-1])
        raw_keep.append(total_volume[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        if shares_outstanding > 1e-8:
            short_interest_ratio = short_interest / shares_outstanding
        else:
            short_interest_ratio = 0.0
        eng.append(short_interest_ratio)
        
        # Feature 2: Short volume to total volume ratio (average over 15 days)
        short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(abs(total_volume[i]), 1e-8)
            short_ratio[i] = short_volume[i] / denom
        avg_short_ratio = np.mean(short_ratio)
        eng.append(avg_short_ratio)
        
        # Feature 3: Price momentum (5-day)
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # Feature 4: Price momentum (10-day)
        if len(close_prices) >= 10:
            momentum_10d = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1.0
        else:
            momentum_10d = 0.0
        eng.append(momentum_10d)
        
        # Feature 5: Volatility (standard deviation of returns over 10 days)
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0.0
        else:
            volatility = 0.0
        eng.append(volatility)
        
        # Feature 6: Average True Range (ATR) - 5 day
        atr_5d = 0.0
        if len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr_5d = np.mean(tr_values) if tr_values else 0.0
        eng.append(atr_5d)
        
        # Feature 7: RSI (14-day)
        rsi_14d = 0.0
        if len(close_prices) >= 15:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0.0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0.0
            
            if avg_loss > 1e-8:
                rs = avg_gain / avg_loss
                rsi_14d = 100 - (100 / (1 + rs))
            else:
                rsi_14d = 100.0 if avg_gain > 0 else 50.0
        eng.append(rsi_14d)
        
        # Feature 8: Short volume trend (slope of short volume over 15 days)
        if len(short_volume) >= 15:
            x = np.arange(15)
            slope = np.polyfit(x, short_volume, 1)[0] if np.any(short_volume != 0) else 0.0
        else:
            slope = 0.0
        eng.append(slope)
        
        # Feature 9: Short interest to average daily volume ratio
        if avg_daily_volume > 1e-8:
            si_to_adv = short_interest / avg_daily_volume
        else:
            si_to_adv = 0.0
        eng.append(si_to_adv)
        
        # Feature 10: Price range relative to average (volatility measure)
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            avg_price = np.mean(close_prices[-5:])
            if avg_price > 1e-8:
                price_range = (np.max(high_prices[-5:]) - np.min(low_prices[-5:])) / avg_price
            else:
                price_range = 0.0
        else:
            price_range = 0.0
        eng.append(price_range)
        
        # Feature 11: Short volume acceleration (change in short volume rate)
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
            older_ratio = np.mean(short_volume[-10:-5] / np.maximum(total_volume[-10:-5], 1e-8))
            short_accel = recent_ratio - older_ratio
        else:
            short_accel = 0.0
        eng.append(short_accel)
        
        # Feature 12: Implied volatility to historical volatility ratio
        if volatility > 1e-8:
            iv_hv_ratio = implied_volatility / volatility
        else:
            iv_hv_ratio = 1.0
        eng.append(iv_hv_ratio)
        
        # Feature 13: Short interest change rate
        # This would require previous short interest data which isn't directly available in the current timestep
        # We'll use a placeholder of 0 for now
        eng.append(0.0)
        
        # Feature 14: Volume trend (slope of total volume over 15 days)
        if len(total_volume) >= 15:
            x = np.arange(15)
            vol_slope = np.polyfit(x, total_volume, 1)[0] if np.any(total_volume != 0) else 0.0
        else:
            vol_slope = 0.0
        eng.append(vol_slope)
        
        # Feature 15: Price to volume correlation (last 15 days)
        if len(close_prices) >= 15 and len(total_volume) >= 15 and np.std(close_prices) > 1e-8 and np.std(total_volume) > 1e-8:
            price_vol_corr = np.corrcoef(close_prices, total_volume)[0, 1]
            if np.isnan(price_vol_corr):
                price_vol_corr = 0.0
        else:
            price_vol_corr = 0.0
        eng.append(price_vol_corr)
        
        # Feature 16: MACD Line (12-26 day EMA difference)
        macd = 0.0
        if len(close_prices) >= 26:
            ema_12 = close_prices[-12:].mean()  # Simplified EMA calculation
            ema_26 = close_prices[-26:].mean()
            macd = ema_12 - ema_26
        eng.append(macd)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 2/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average daily volume
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)
        raw_keep.append(avg_daily_volume)
        raw_keep.append(days_to_cover)
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep important options data
        raw_keep.append(put_call_ratio)
        raw_keep.append(implied_volatility)
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        # This measures what percentage of total shares are sold short
        si_to_shares = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # Feature 2: Short volume ratio (average of last 15 days)
        # Higher ratio indicates more selling pressure
        short_volume_ratio = np.mean(short_volume / np.maximum(total_volume, 1e-8))
        eng.append(short_volume_ratio)
        
        # Feature 3: Recent short volume trend (last 5 days vs previous 10)
        recent_svr = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        earlier_svr = np.mean(short_volume[:-5] / np.maximum(total_volume[:-5], 1e-8))
        svr_trend = recent_svr / max(abs(earlier_svr), 1e-8) - 1
        eng.append(svr_trend)
        
        # Feature 4: Price momentum (5-day)
        # Captures recent price trend
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # Feature 5: Price momentum (10-day)
        # Captures medium-term price trend
        if len(close_prices) >= 10:
            price_momentum_10d = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
        else:
            price_momentum_10d = 0
        eng.append(price_momentum_10d)
        
        # Feature 6: Volatility (standard deviation of returns)
        # Higher volatility may attract short sellers
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # Feature 7: Average True Range (ATR) - volatility indicator
        # Measures market volatility
        atr_values = []
        for i in range(1, len(ohlc)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        eng.append(atr)
        
        # Feature 8: Relative strength index (RSI)
        # Overbought/oversold indicator
        if len(close_prices) > 1:
            diff = np.diff(close_prices)
            gains = np.sum(np.where(diff > 0, diff, 0))
            losses = np.sum(np.where(diff < 0, -diff, 0))
            
            if losses > 0:
                rs = gains / max(losses, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if gains > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # Feature 9: Short volume to average daily volume ratio
        # Indicates if short selling is higher than normal trading
        short_vol_to_avg_vol = np.mean(short_volume) / max(avg_daily_volume, 1e-8)
        eng.append(short_vol_to_avg_vol)
        
        # Feature 10: Implied volatility to historical volatility ratio
        # Indicates market expectations vs actual volatility
        if volatility > 0:
            iv_to_hv = implied_volatility / max(volatility, 1e-8)
        else:
            iv_to_hv = 1.0
        eng.append(iv_to_hv)
        
        # Feature 11: Recent volume trend (last 5 days vs previous 10)
        recent_vol = np.mean(total_volume[-5:])
        earlier_vol = np.mean(total_volume[:-5])
        vol_trend = recent_vol / max(abs(earlier_vol), 1e-8) - 1
        eng.append(vol_trend)
        
        # Feature 12: Price range relative to average
        # Indicates if recent price movement is unusual
        if len(high_prices) > 0 and len(low_prices) > 0:
            recent_range = (high_prices[-1] - low_prices[-1]) / max(abs(close_prices[-1]), 1e-8)
            avg_range = np.mean((high_prices - low_prices) / np.maximum(close_prices, 1e-8))
            relative_range = recent_range / max(abs(avg_range), 1e-8)
        else:
            relative_range = 1.0
        eng.append(relative_range)
        
        # Feature 13: Short interest growth rate
        # Indicates acceleration in short positions
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_growth)
        
        # Feature 14: Synthetic short cost to implied volatility ratio
        # Cost efficiency of shorting relative to expected volatility
        synth_cost_to_iv = synthetic_short_cost / max(abs(implied_volatility), 1e-8)
        eng.append(synth_cost_to_iv)
        
        # Feature 15: VWAP (Volume Weighted Average Price)
        # Important price level watched by traders
        vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
        price_to_vwap = close_prices[-1] / max(abs(vwap), 1e-8) - 1
        eng.append(price_to_vwap)
        
        # Feature 16: Bollinger Band Width
        # Indicates if price is in a tight range (potential breakout)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Feature 17: Short interest to days to cover ratio
        si_to_dtc = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_to_dtc)
        
        # Feature 18: Recent short volume acceleration
        # Measures if short selling is accelerating
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            short_vol_accel = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 744245.7391
RMSE: 1124676.5486
MAPE: 5.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0004, rank=1
   2. Feature_17_t0: importance=0.0002, rank=2
   3. Feature_15_t0: importance=0.0002, rank=3
   4. Feature_16_t3: importance=0.0002, rank=4
   5. Feature_2_t0: importance=0.0002, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
📊 No significant improvement. Change: -0.06%

📈 Current best MAPE: 5.68%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average daily volume
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep these key raw features based on importance analysis
        raw_keep.append(short_interest)
        raw_keep.append(avg_daily_volume)
        raw_keep.append(days_to_cover)
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent close price (important for relative measures)
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep important options data (high importance in previous iterations)
        raw_keep.append(put_call_ratio)
        raw_keep.append(implied_volatility)
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        # This is a fundamental measure of short selling intensity relative to available shares
        si_to_shares = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # Feature 2: Short volume ratio (average of last 15 days)
        # This was a high-importance feature in previous iterations
        short_volume_ratio = np.mean(short_volume / np.maximum(total_volume, 1e-8))
        eng.append(short_volume_ratio)
        
        # Feature 3: Short interest to days to cover ratio
        # This was the highest importance feature in previous iterations
        si_to_dtc = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_to_dtc)
        
        # Feature 4: Recent short volume trend (last 5 days vs previous 10)
        # Captures acceleration in short selling activity
        if len(short_volume) >= 15:
            recent_svr = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
            earlier_svr = np.mean(short_volume[:-5] / np.maximum(total_volume[:-5], 1e-8))
            svr_trend = recent_svr / max(abs(earlier_svr), 1e-8) - 1
        else:
            svr_trend = 0
        eng.append(svr_trend)
        
        # Feature 5: Volatility (standard deviation of returns)
        # Higher volatility may attract short sellers
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # Feature 6: Short interest growth rate
        # Indicates acceleration in short positions - important signal
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_growth)
        
        # Feature 7: VWAP (Volume Weighted Average Price) ratio
        # Important price level watched by traders
        vwap = np.sum(close_prices * total_volume) / max(np.sum(total_volume), 1e-8)
        price_to_vwap = close_prices[-1] / max(abs(vwap), 1e-8) - 1
        eng.append(price_to_vwap)
        
        # Feature 8: Bollinger Band Width
        # Indicates if price is in a tight range (potential breakout)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Feature 9: Recent short volume acceleration
        # Measures if short selling is accelerating - refined from previous version
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            short_vol_accel = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # Feature 10: Relative Strength Index (RSI)
        # Overbought/oversold indicator - refined calculation
        if len(close_prices) > 1:
            diff = np.diff(close_prices)
            up_moves = np.where(diff > 0, diff, 0)
            down_moves = np.where(diff < 0, -diff, 0)
            
            avg_up = np.mean(up_moves) if len(up_moves) > 0 else 0
            avg_down = np.mean(down_moves) if len(down_moves) > 0 else 0
            
            if avg_down > 0:
                rs = avg_up / max(avg_down, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if avg_up > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # Feature 11: Short volume to average daily volume ratio
        # Indicates if short selling is higher than normal trading
        short_vol_to_avg_vol = np.mean(short_volume) / max(avg_daily_volume, 1e-8)
        eng.append(short_vol_to_avg_vol)
        
        # Feature 12: Implied volatility to historical volatility ratio
        # Indicates market expectations vs actual volatility
        iv_to_hv = implied_volatility / max(volatility, 1e-8)
        eng.append(iv_to_hv)
        
        # Feature 13: Short interest to total volume ratio
        # New feature: Measures short interest relative to trading activity
        si_to_total_vol = short_interest / max(np.sum(total_volume), 1e-8)
        eng.append(si_to_total_vol)
        
        # Feature 14: Price momentum (5-day)
        # Captures recent price trend - simplified from previous version
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # Feature 15: Average True Range (ATR) - volatility indicator
        # Measures market volatility - important for short interest prediction
        atr_values = []
        for i in range(1, len(ohlc)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        eng.append(atr)
        
        # Feature 16: Short interest to synthetic short cost ratio
        # New feature: Measures efficiency of actual shorts vs synthetic shorts
        si_to_synth_cost = short_interest / max(abs(synthetic_short_cost), 1e-8)
        eng.append(si_to_synth_cost)
        
        # Feature 17: Recent volume trend (last 5 days vs previous 10)
        # Captures changes in trading activity
        if len(total_volume) >= 15:
            recent_vol = np.mean(total_volume[-5:])
            earlier_vol = np.mean(total_volume[:-5])
            vol_trend = recent_vol / max(abs(earlier_vol), 1e-8) - 1
        else:
            vol_trend = 0
        eng.append(vol_trend)
        
        # Feature 18: MACD-like indicator (short-term vs long-term momentum)
        # New feature: Captures momentum divergence
        if len(close_prices) >= 12:
            ema_short = np.mean(close_prices[-5:])
            ema_long = np.mean(close_prices[-12:])
            macd = ema_short / max(abs(ema_long), 1e-8) - 1
        else:
            macd = 0
        eng.append(macd)
        
        # Feature 19: Short interest to put-call ratio
        # New feature: Relates actual short positions to options market sentiment
        si_to_pc_ratio = short_interest / max(abs(put_call_ratio), 1e-8)
        eng.append(si_to_pc_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 772566.8949
RMSE: 1133411.6339
MAPE: 5.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 71
   • Highly important features (top 5%): 43

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t0: importance=0.0005, rank=1
   2. Feature_18_t3: importance=0.0003, rank=2
   3. Feature_24_t2: importance=0.0003, rank=3
   4. Feature_20_t3: importance=0.0003, rank=4
   5. Feature_17_t0: importance=0.0002, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -0.24%

📈 Current best MAPE: 5.68%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features (based on previous importance analysis)
        raw_keep.append(short_interest)  # Always keep short interest
        raw_keep.append(avg_daily_volume)  # Always keep average daily volume
        raw_keep.append(days_to_cover)  # High importance in previous iterations
        raw_keep.append(close_prices[-1])  # Most recent close price
        raw_keep.append(put_call_ratio)  # Important options market indicator
        raw_keep.append(implied_volatility)  # Key market expectation metric
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        # Fundamental measure of short selling intensity relative to float
        si_to_shares = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # Feature 2: Short volume ratio (average of last 15 days)
        # High importance in previous iterations - refined calculation
        short_volume_ratio = np.mean(short_volume / np.maximum(total_volume, 1e-8))
        eng.append(short_volume_ratio)
        
        # Feature 3: Recent short volume trend (last 3 days vs previous 12)
        # Refined from previous iteration - captures more recent acceleration
        if len(short_volume) >= 15:
            recent_svr = np.mean(short_volume[-3:] / np.maximum(total_volume[-3:], 1e-8))
            earlier_svr = np.mean(short_volume[:-3] / np.maximum(total_volume[:-3], 1e-8))
            svr_trend = recent_svr / max(abs(earlier_svr), 1e-8) - 1
        else:
            svr_trend = 0
        eng.append(svr_trend)
        
        # Feature 4: Short interest growth rate (if previous data available)
        # Key indicator of changing short seller sentiment
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_growth)
        
        # Feature 5: Volatility (standard deviation of returns)
        # Refined calculation - uses exponential weighting to prioritize recent volatility
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            weights = np.exp(np.linspace(-1, 0, len(returns)))
            weights = weights / np.sum(weights)
            weighted_var = np.sum(weights * (returns - np.average(returns, weights=weights))**2)
            volatility = np.sqrt(weighted_var) if weighted_var > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # Feature 6: Short interest to average daily volume ratio
        # Direct measure of how many days of volume the short interest represents
        si_to_adv = short_interest / max(abs(avg_daily_volume), 1e-8)
        eng.append(si_to_adv)
        
        # Feature 7: Price momentum (5-day)
        # Captures recent price trend - high importance in previous iterations
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # Feature 8: Relative Strength Index (RSI) - refined calculation
        # Overbought/oversold indicator - important for predicting short interest changes
        if len(close_prices) > 2:
            diff = np.diff(close_prices)
            # Use exponential weighting to prioritize recent price movements
            weights = np.exp(np.linspace(-1, 0, len(diff)))
            weights = weights / np.sum(weights)
            
            up_moves = np.where(diff > 0, diff, 0)
            down_moves = np.where(diff < 0, -diff, 0)
            
            avg_up = np.sum(weights * up_moves)
            avg_down = np.sum(weights * down_moves)
            
            if avg_down > 0:
                rs = avg_up / max(avg_down, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if avg_up > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # Feature 9: Short volume acceleration (3-day)
        # Refined from previous version - focuses on very recent acceleration
        if len(short_volume) >= 5:
            recent_short_vol = short_volume[-1]
            prev_short_vol = np.mean(short_volume[-4:-1])
            short_vol_accel = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # Feature 10: Implied volatility to historical volatility ratio
        # Market expectations vs actual volatility - refined from previous version
        iv_to_hv = implied_volatility / max(volatility, 1e-8)
        eng.append(iv_to_hv)
        
        # Feature 11: Short interest to synthetic short cost ratio
        # Measures efficiency of actual shorts vs synthetic shorts
        si_to_synth_cost = short_interest / max(abs(synthetic_short_cost), 1e-8)
        eng.append(si_to_synth_cost)
        
        # Feature 12: Average True Range (ATR) normalized by price
        # Volatility indicator normalized by price level for better comparability
        atr_values = []
        for i in range(1, len(ohlc)):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        norm_atr = atr / max(abs(close_prices[-1]), 1e-8)
        eng.append(norm_atr)
        
        # Feature 13: Short interest to put-call ratio
        # Relates actual short positions to options market sentiment
        si_to_pc_ratio = short_interest / max(abs(put_call_ratio), 1e-8)
        eng.append(si_to_pc_ratio)
        
        # Feature 14: Bollinger Band position
        # Indicates if price is near upper/lower bands (potential reversal points)
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            # Position within bands (-1 to +1 scale)
            bb_position = 2 * (close_prices[-1] - lower_band) / max(band_width, 1e-8) - 1
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # Feature 15: Short volume to total volume ratio change
        # Measures if short selling is becoming more/less dominant
        if len(short_volume) >= 10:
            recent_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
            earlier_ratio = np.mean(short_volume[-10:-5] / np.maximum(total_volume[-10:-5], 1e-8))
            ratio_change = recent_ratio / max(abs(earlier_ratio), 1e-8) - 1
        else:
            ratio_change = 0
        eng.append(ratio_change)
        
        # Feature 16: MACD Signal Line Crossover
        # Momentum indicator - refined from previous version
        if len(close_prices) >= 12:
            ema12 = np.mean(close_prices[-5:])  # Simplified EMA calculation
            ema26 = np.mean(close_prices[-12:])
            macd_line = ema12 - ema26
            
            # Signal line (9-period EMA of MACD)
            if t >= 9:
                macd_history = []
                for i in range(9):
                    if t-i >= 0 and len(data[t-i, 3:63].reshape(15, 4)[:, 3]) >= 12:
                        prev_close = data[t-i, 3:63].reshape(15, 4)[:, 3]
                        prev_ema12 = np.mean(prev_close[-5:])
                        prev_ema26 = np.mean(prev_close[-12:])
                        macd_history.append(prev_ema12 - prev_ema26)
                
                signal_line = np.mean(macd_history) if macd_history else macd_line
                macd_crossover = macd_line - signal_line
            else:
                macd_crossover = 0
        else:
            macd_crossover = 0
        eng.append(macd_crossover)
        
        # Feature 17: Price to 10-day moving average ratio
        # Indicates overbought/oversold conditions
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(abs(ma10), 1e-8) - 1
        else:
            price_to_ma = 0
        eng.append(price_to_ma)
        
        # Feature 18: Short interest to days to cover ratio
        # This was a high importance feature in previous iterations
        si_to_dtc = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_to_dtc)
        
        # Feature 19: Volume trend (exponentially weighted)
        # Captures recent volume changes with more weight on recent days
        if len(total_volume) >= 10:
            weights = np.exp(np.linspace(-1, 0, 10))
            weights = weights / np.sum(weights)
            weighted_recent = np.sum(weights * total_volume[-10:])
            
            # Compare to previous period
            if t > 0 and len(data[t-1, 82:97]) >= 10:
                prev_volume = data[t-1, 82:97][-10:]
                weighted_prev = np.sum(weights * prev_volume)
                vol_trend_ew = weighted_recent / max(abs(weighted_prev), 1e-8) - 1
            else:
                vol_trend_ew = 0
        else:
            vol_trend_ew = 0
        eng.append(vol_trend_ew)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 785837.6510
RMSE: 1141335.5743
MAPE: 5.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 35

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_18_t0: importance=0.0005, rank=1
   2. Feature_14_t2: importance=0.0004, rank=2
   3. Feature_15_t0: importance=0.0004, rank=3
   4. Feature_18_t2: importance=0.0002, rank=4
   5. Feature_5_t1: importance=0.0002, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -0.30%

📈 Current best MAPE: 5.68%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features (based on previous importance analysis)
        # Always include short interest and average volume (required)
        raw_keep.append(short_interest)
        raw_keep.append(avg_daily_volume)
        
        # Keep days to cover - consistently high importance in previous iterations
        raw_keep.append(days_to_cover)
        
        # Keep most recent close price - fundamental for price-based indicators
        raw_keep.append(close_prices[-1])
        
        # Keep put-call ratio - important options market indicator
        raw_keep.append(put_call_ratio)
        
        # Keep implied volatility - key market expectation metric
        raw_keep.append(implied_volatility)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        # Fundamental measure of short selling intensity relative to float
        si_to_shares = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # Feature 2: Short volume ratio (average of last 5 days)
        # Focus on more recent short volume activity - more responsive to changes
        if len(short_volume) >= 5:
            recent_short_vol_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        else:
            recent_short_vol_ratio = np.mean(short_volume / np.maximum(total_volume, 1e-8))
        eng.append(recent_short_vol_ratio)
        
        # Feature 3: Short interest growth rate (if previous data available)
        # Key indicator of changing short seller sentiment
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_growth)
        
        # Feature 4: Exponentially weighted volatility (prioritizes recent price movements)
        # Improved from previous version with better weighting
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            weights = np.exp(np.linspace(-2, 0, len(returns)))  # Steeper decay
            weights = weights / np.sum(weights)
            weighted_var = np.sum(weights * (returns - np.average(returns, weights=weights))**2)
            volatility = np.sqrt(weighted_var) if weighted_var > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # Feature 5: Short interest to days to cover ratio
        # High importance in previous iterations
        si_to_dtc = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_to_dtc)
        
        # Feature 6: Price momentum (3-day)
        # Shorter timeframe than previous version - more responsive to recent changes
        if len(close_prices) >= 3:
            price_momentum_3d = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            price_momentum_3d = 0
        eng.append(price_momentum_3d)
        
        # Feature 7: Bollinger Band Width normalized by price
        # Measures volatility expansion/contraction - indicator of potential large moves
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            bb_width = (upper_band - lower_band) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Feature 8: RSI (Relative Strength Index) - improved calculation
        # Overbought/oversold indicator - important for predicting short interest changes
        if len(close_prices) > 5:
            diff = np.diff(close_prices[-6:])  # Last 5 changes
            up_moves = np.where(diff > 0, diff, 0)
            down_moves = np.where(diff < 0, -diff, 0)
            
            avg_up = np.mean(up_moves)
            avg_down = np.mean(down_moves)
            
            if avg_down > 0:
                rs = avg_up / max(avg_down, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if avg_up > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # Feature 9: Short volume acceleration (2-day vs previous 3-day)
        # Captures very recent changes in short selling activity
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            short_vol_accel = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # Feature 10: Implied volatility to historical volatility ratio
        # Market expectations vs actual volatility
        iv_to_hv = implied_volatility / max(volatility, 1e-8)
        eng.append(iv_to_hv)
        
        # Feature 11: Average True Range (ATR) normalized by price
        # Volatility indicator normalized by price level
        atr_values = []
        for i in range(1, min(10, len(ohlc))):  # Use up to last 10 days
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        norm_atr = atr / max(abs(close_prices[-1]), 1e-8)
        eng.append(norm_atr)
        
        # Feature 12: Short interest to put-call ratio
        # Relates actual short positions to options market sentiment
        si_to_pc_ratio = short_interest / max(abs(put_call_ratio), 1e-8)
        eng.append(si_to_pc_ratio)
        
        # Feature 13: Volume trend (5-day vs previous 5-day)
        # Captures medium-term volume changes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = np.mean(total_volume[-10:-5])
            vol_trend = recent_vol / max(abs(prev_vol), 1e-8) - 1
        else:
            vol_trend = 0
        eng.append(vol_trend)
        
        # Feature 14: Price to 5-day moving average ratio
        # Shorter timeframe than previous version - more responsive
        if len(close_prices) >= 5:
            ma5 = np.mean(close_prices[-5:])
            price_to_ma = close_prices[-1] / max(abs(ma5), 1e-8) - 1
        else:
            price_to_ma = 0
        eng.append(price_to_ma)
        
        # Feature 15: Short volume to total volume ratio change (3-day)
        # Measures if short selling is becoming more/less dominant in very recent trading
        if len(short_volume) >= 6:
            recent_ratio = np.mean(short_volume[-3:] / np.maximum(total_volume[-3:], 1e-8))
            earlier_ratio = np.mean(short_volume[-6:-3] / np.maximum(total_volume[-6:-3], 1e-8))
            ratio_change = recent_ratio / max(abs(earlier_ratio), 1e-8) - 1
        else:
            ratio_change = 0
        eng.append(ratio_change)
        
        # Feature 16: High-Low Range relative to price (volatility measure)
        # New feature - captures price range volatility
        if len(high_prices) > 0 and len(low_prices) > 0:
            avg_range = np.mean((high_prices - low_prices) / np.maximum(close_prices, 1e-8))
        else:
            avg_range = 0
        eng.append(avg_range)
        
        # Feature 17: Short interest to synthetic short cost efficiency
        # Measures efficiency of actual shorts vs synthetic shorts
        si_to_synth_cost = short_interest / max(abs(synthetic_short_cost), 1e-8)
        eng.append(si_to_synth_cost)
        
        # Feature 18: Gap analysis - overnight price jumps
        # New feature - captures significant overnight price movements
        gap_sum = 0
        if len(open_prices) > 1 and len(close_prices) > 1:
            gaps = open_prices[1:] - close_prices[:-1]
            normalized_gaps = gaps / np.maximum(close_prices[:-1], 1e-8)
            gap_sum = np.sum(np.abs(normalized_gaps))
        eng.append(gap_sum)
        
        # Feature 19: Short interest velocity (rate of change)
        # New feature - second derivative of short interest
        si_velocity = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            current_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
            previous_growth = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_velocity = current_growth - previous_growth
        eng.append(si_velocity)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 779187.5593
RMSE: 1132304.9109
MAPE: 5.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 25

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0007, rank=1
   2. Feature_15_t0: importance=0.0003, rank=2
   3. Feature_17_t2: importance=0.0003, rank=3
   4. Feature_18_t0: importance=0.0003, rank=4
   5. Feature_13_t3: importance=0.0003, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.30%

📈 Current best MAPE: 5.68%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features (based on previous importance analysis)
        # Always include short interest and average volume (required)
        raw_keep.append(short_interest)
        raw_keep.append(avg_daily_volume)
        
        # Keep days to cover - consistently high importance
        raw_keep.append(days_to_cover)
        
        # Keep most recent close price
        raw_keep.append(close_prices[-1])
        
        # Keep put-call ratio - important options market indicator
        raw_keep.append(put_call_ratio)
        
        # Keep implied volatility - key market expectation metric
        raw_keep.append(implied_volatility)
        
        # Keep synthetic short cost - high importance in previous iterations
        raw_keep.append(synthetic_short_cost)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        # Fundamental measure of short selling intensity relative to float
        si_to_shares = short_interest / max(abs(shares_outstanding), 1e-8)
        eng.append(si_to_shares)
        
        # Feature 2: Short volume ratio (average of last 5 days)
        # Recent short volume activity relative to total volume
        if len(short_volume) >= 5:
            recent_short_vol_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        else:
            recent_short_vol_ratio = np.mean(short_volume / np.maximum(total_volume, 1e-8))
        eng.append(recent_short_vol_ratio)
        
        # Feature 3: Short interest growth rate (if previous data available)
        # Key indicator of changing short seller sentiment
        si_growth = 0
        if t > 0 and data[t-1, 0] > 0:
            si_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_growth)
        
        # Feature 4: Short interest to synthetic short cost efficiency
        # Measures efficiency of actual shorts vs synthetic shorts - high importance in previous iterations
        si_to_synth_cost = short_interest / max(abs(synthetic_short_cost), 1e-8)
        eng.append(si_to_synth_cost)
        
        # Feature 5: Exponentially weighted price volatility
        # Prioritizes recent price movements with steeper decay
        if len(close_prices) > 1:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            weights = np.exp(np.linspace(-2, 0, len(returns)))
            weights = weights / np.sum(weights)
            weighted_var = np.sum(weights * (returns - np.average(returns, weights=weights))**2)
            volatility = np.sqrt(weighted_var) if weighted_var > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # Feature 6: RSI (Relative Strength Index) - 5-day
        # Overbought/oversold indicator - important for predicting short interest changes
        if len(close_prices) > 5:
            diff = np.diff(close_prices[-6:])
            up_moves = np.where(diff > 0, diff, 0)
            down_moves = np.where(diff < 0, -diff, 0)
            
            avg_up = np.mean(up_moves)
            avg_down = np.mean(down_moves)
            
            if avg_down > 0:
                rs = avg_up / max(avg_down, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100 if avg_up > 0 else 50
        else:
            rsi = 50
        eng.append(rsi)
        
        # Feature 7: Short volume acceleration (2-day vs previous 3-day)
        # Captures very recent changes in short selling activity
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-2:])
            prev_short_vol = np.mean(short_volume[-5:-2])
            short_vol_accel = recent_short_vol / max(abs(prev_short_vol), 1e-8) - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # Feature 8: Implied volatility to historical volatility ratio
        # Market expectations vs actual volatility
        iv_to_hv = implied_volatility / max(volatility, 1e-8)
        eng.append(iv_to_hv)
        
        # Feature 9: Short interest velocity (second derivative)
        # Acceleration of short interest changes - new feature with potential high importance
        si_velocity = 0
        if t >= 2 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            current_growth = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
            previous_growth = (data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1
            si_velocity = current_growth - previous_growth
        eng.append(si_velocity)
        
        # Feature 10: Average True Range (ATR) normalized by price
        # Volatility indicator normalized by price level
        atr_values = []
        for i in range(1, min(10, len(ohlc))):
            tr1 = high_prices[i] - low_prices[i]
            tr2 = abs(high_prices[i] - close_prices[i-1])
            tr3 = abs(low_prices[i] - close_prices[i-1])
            true_range = max(tr1, tr2, tr3)
            atr_values.append(true_range)
        atr = np.mean(atr_values) if atr_values else 0
        norm_atr = atr / max(abs(close_prices[-1]), 1e-8)
        eng.append(norm_atr)
        
        # Feature 11: Price momentum (3-day)
        # Short-term price trend - responsive to recent changes
        if len(close_prices) >= 3:
            price_momentum_3d = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
        else:
            price_momentum_3d = 0
        eng.append(price_momentum_3d)
        
        # Feature 12: Short volume to total volume ratio change (3-day)
        # Measures if short selling is becoming more/less dominant in recent trading
        if len(short_volume) >= 6:
            recent_ratio = np.mean(short_volume[-3:] / np.maximum(total_volume[-3:], 1e-8))
            earlier_ratio = np.mean(short_volume[-6:-3] / np.maximum(total_volume[-6:-3], 1e-8))
            ratio_change = recent_ratio / max(abs(earlier_ratio), 1e-8) - 1
        else:
            ratio_change = 0
        eng.append(ratio_change)
        
        # Feature 13: Gap analysis - overnight price jumps
        # Captures significant overnight price movements
        gap_sum = 0
        if len(open_prices) > 1 and len(close_prices) > 1:
            gaps = open_prices[1:] - close_prices[:-1]
            normalized_gaps = gaps / np.maximum(close_prices[:-1], 1e-8)
            gap_sum = np.sum(np.abs(normalized_gaps))
        eng.append(gap_sum)
        
        # Feature 14: Bollinger Band Width normalized by price
        # Measures volatility expansion/contraction - indicator of potential large moves
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            bb_width = (upper_band - lower_band) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Feature 15: Short interest to days to cover ratio
        # High importance in previous iterations
        si_to_dtc = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_to_dtc)
        
        # Feature 16: MACD Signal Line Crossover
        # Momentum indicator showing trend changes
        if len(close_prices) >= 12:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA calculation
            ema26 = np.mean(close_prices)  # Use all available data for longer EMA
            macd = ema12 - ema26
            signal = np.mean(close_prices[-9:])  # Simplified signal line
            macd_signal_diff = macd - signal
        else:
            macd_signal_diff = 0
        eng.append(macd_signal_diff)
        
        # Feature 17: High-Low Range relative to price (volatility measure)
        # Captures price range volatility
        if len(high_prices) > 0 and len(low_prices) > 0:
            avg_range = np.mean((high_prices - low_prices) / np.maximum(close_prices, 1e-8))
        else:
            avg_range = 0
        eng.append(avg_range)
        
        # Feature 18: Short interest to put-call ratio
        # Relates actual short positions to options market sentiment
        si_to_pc_ratio = short_interest / max(abs(put_call_ratio), 1e-8)
        eng.append(si_to_pc_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN, inf values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 789063.4775
RMSE: 1144226.1703
MAPE: 6.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t2: importance=0.0005, rank=1
   2. Feature_24_t0: importance=0.0005, rank=2
   3. Feature_8_t2: importance=0.0004, rank=3
   4. Feature_13_t2: importance=0.0003, rank=4
   5. Feature_14_t0: importance=0.0003, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.33%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 437113.1914
RMSE: 560535.7022
MAPE: 5.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 241
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_85_t3: importance=0.0002, rank=1
   2. Feature_64_t2: importance=0.0002, rank=2
   3. Feature_90_t3: importance=0.0002, rank=3
   4. Feature_93_t3: importance=0.0001, rank=4
   5. Feature_63_t0: importance=0.0001, rank=5
   Baseline MAPE: 5.00%
   Baseline MAE: 437113.1914
   Baseline RMSE: 560535.7022

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 407100.2193
RMSE: 554248.3521
MAPE: 4.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0003, rank=1
   2. Feature_2_t0: importance=0.0002, rank=2
   3. Feature_2_t2: importance=0.0002, rank=3
   4. Feature_17_t0: importance=0.0002, rank=4
   5. Feature_19_t0: importance=0.0002, rank=5

📊 Best Model Test Set Performance:
   MAPE: 4.86%
   MAE: 407100.2193
   RMSE: 554248.3521

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 5.00%
   Best Model MAPE: 4.86%
   Absolute Improvement: 0.14%
   Relative Improvement: 2.9%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  5.68            N/A                 
1          Iteration 1               5.75            -0.06%              
2          Iteration 2               5.92            -0.24%              
3          Iteration 3               5.98            -0.30%              
4          Iteration 4               5.98            -0.30%              
5          Iteration 5               6.01            -0.33%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 1 - MAPE: 5.75%
✅ Saved SLG results to cache/SLG_iterative_results_enhanced.pkl
✅ Summary report saved for SLG

🎉 Process completed successfully for SLG!

================================================================================
PROCESSING TICKER 12/14: HL
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for HL
======================================================================
📊 Loading data from parquet file...
📊 Loading data for HL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 1982072.0950
RMSE: 2392423.0992
MAPE: 10.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 115
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t0: importance=0.0010, rank=1
   2. Feature_71_t0: importance=0.0005, rank=2
   3. Feature_65_t2: importance=0.0004, rank=3
   4. Feature_76_t1: importance=0.0004, rank=4
   5. Feature_69_t3: importance=0.0004, rank=5

📊 Baseline Performance: MAPE = 10.95%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This is a key indicator of short selling pressure
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (slope of short volume ratio)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Recent price momentum (5-day)
        # Important for capturing recent price trends that may influence short interest
        if len(close_prices) >= 5:
            price_momentum_5d = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1.0
            eng.append(price_momentum_5d)
        else:
            eng.append(0.0)
        
        # 4. Volatility (15-day)
        # Higher volatility often correlates with increased short interest
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
            eng.append(volatility)
        else:
            eng.append(0.0)
        
        # 5. Average True Range (ATR) - volatility indicator
        # Provides insight into market volatility which affects short selling decisions
        atr_sum = 0
        if len(high_prices) >= 2:
            for i in range(1, min(10, len(high_prices))):
                true_range = max(
                    high_prices[i] - low_prices[i],
                    abs(high_prices[i] - close_prices[i-1]),
                    abs(low_prices[i] - close_prices[i-1])
                )
                atr_sum += true_range
            atr = atr_sum / min(9, len(high_prices)-1)
            eng.append(atr)
        else:
            eng.append(0.0)
        
        # 6. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 7. Short Volume Acceleration
        # Captures acceleration in short selling activity
        if len(short_volume) >= 3:
            short_vol_diff1 = short_volume[-1] - short_volume[-2]
            short_vol_diff2 = short_volume[-2] - short_volume[-3]
            short_accel = short_vol_diff1 - short_vol_diff2
            eng.append(short_accel)
        else:
            eng.append(0.0)
        
        # 8. Price Range Ratio (High-Low spread relative to price)
        # Indicates intraday volatility which can affect short selling
        if len(close_prices) >= 5:
            avg_close = np.mean(close_prices[-5:])
            avg_range = np.mean(high_prices[-5:] - low_prices[-5:])
            price_range_ratio = avg_range / max(avg_close, 1e-8)
            eng.append(price_range_ratio)
        else:
            eng.append(0.0)
        
        # 9. Volume Trend
        # Captures changes in trading volume which can signal changing market interest
        if len(total_volume) >= 5:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5]) if len(total_volume) >= 10 else np.mean(total_volume[:-5])
            volume_trend = recent_vol_avg / max(older_vol_avg, 1e-8) - 1
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 10. RSI (Relative Strength Index)
        # Technical indicator that can signal overbought/oversold conditions
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(0.0)
        
        # 11. Options Implied Volatility to Historical Volatility Ratio
        # Compares market expectations vs. realized volatility
        if len(returns) > 0:
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            implied_vol = data[t, 65]  # options_avg_implied_volatility
            iv_hv_ratio = implied_vol / max(hist_vol, 1e-8)
            eng.append(iv_hv_ratio)
        else:
            eng.append(0.0)
        
        # 12. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = data[t-1, 0]
            current_si = data[t, 0]
            si_change_rate = (current_si / max(prev_si, 1e-8)) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 1857189.1161
RMSE: 2359436.2756
MAPE: 10.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t3: importance=0.0008, rank=1
   2. Feature_7_t3: importance=0.0007, rank=2
   3. Feature_10_t1: importance=0.0007, rank=3
   4. Feature_16_t0: importance=0.0006, rank=4
   5. Feature_13_t1: importance=0.0006, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.85%

📈 Current best MAPE: 10.10%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = data[t-1, 0]
            current_si = data[t, 0]
            si_change_rate = (current_si / max(prev_si, 1e-8)) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Bollinger Band Width - measure of volatility
        # Wider bands indicate higher volatility which can affect short interest
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
            eng.append(bb_width)
        else:
            eng.append(0.0)
        
        # 6. VWAP (Volume Weighted Average Price) - price trend indicator
        # Compares current price to VWAP to identify potential reversal points
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap_sum = 0
            volume_sum = 0
            for i in range(-5, 0):
                vwap_sum += close_prices[i] * total_volume[i]
                volume_sum += total_volume[i]
            vwap = vwap_sum / max(volume_sum, 1e-8)
            vwap_ratio = close_prices[-1] / max(vwap, 1e-8)
            eng.append(vwap_ratio)
        else:
            eng.append(0.0)
        
        # 7. Money Flow Index (MFI) - volume-weighted RSI
        # Identifies potential overbought/oversold conditions with volume confirmation
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            typical_price = (high_prices + low_prices + close_prices) / 3
            money_flow = typical_price * total_volume
            
            pos_flow = 0
            neg_flow = 0
            for i in range(1, 14):
                if typical_price[i] > typical_price[i-1]:
                    pos_flow += money_flow[i]
                else:
                    neg_flow += money_flow[i]
            
            money_ratio = pos_flow / max(neg_flow, 1e-8)
            mfi = 100 - (100 / (1 + money_ratio))
            eng.append(mfi)
        else:
            eng.append(0.0)
        
        # 8. Short Volume Concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.sum(short_volume[-5:])
            total_short_vol = np.sum(short_volume[-10:])
            short_vol_concentration = recent_short_vol / max(total_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.0)
        
        # 9. Options Implied Volatility to Historical Volatility Ratio
        # Compares market expectations vs. realized volatility
        if len(close_prices) >= 10:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            implied_vol = data[t, 65]  # options_avg_implied_volatility
            iv_hv_ratio = implied_vol / max(hist_vol, 1e-8)
            eng.append(iv_hv_ratio)
        else:
            eng.append(0.0)
        
        # 10. Price Momentum with Volume Confirmation
        # Combines price momentum with volume trend for stronger signal
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_change = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            volume_change = (np.mean(total_volume[-5:]) / max(np.mean(total_volume[-10:-5]), 1e-8)) - 1
            # Positive when price and volume move in same direction
            momentum_confirmation = price_change * volume_change
            eng.append(momentum_confirmation)
        else:
            eng.append(0.0)
        
        # 11. Short Volume Volatility
        # Measures the stability/volatility of short selling activity
        if len(short_volume) >= 10:
            short_vol_volatility = np.std(short_volume) / max(np.mean(short_volume), 1e-8)
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 12. Gap Analysis
        # Overnight price gaps can trigger short covering or new short positions
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = []
            for i in range(1, 5):
                gap = (open_prices[i] / max(close_prices[i-1], 1e-8)) - 1
                gaps.append(gap)
            avg_gap = np.mean(gaps)
            eng.append(avg_gap)
        else:
            eng.append(0.0)
        
        # 13. Short Interest to Options Volume Ratio
        # Relationship between short interest and options activity
        options_volume = data[t, 63]  # options_put_call_volume_ratio
        short_to_options = data[t, 0] / max(options_volume, 1e-8)
        eng.append(short_to_options)
        
        # 14. Chaikin Money Flow (CMF) - volume-based indicator of buying/selling pressure
        # Helps identify accumulation/distribution patterns
        if len(close_prices) >= 10:
            cmf_sum = 0
            vol_sum = 0
            for i in range(-10, 0):
                money_flow_multiplier = ((close_prices[i] - low_prices[i]) - (high_prices[i] - close_prices[i])) / max(high_prices[i] - low_prices[i], 1e-8)
                money_flow_volume = money_flow_multiplier * total_volume[i]
                cmf_sum += money_flow_volume
                vol_sum += total_volume[i]
            cmf = cmf_sum / max(vol_sum, 1e-8)
            eng.append(cmf)
        else:
            eng.append(0.0)
        
        # 15. Short Volume to Days to Cover Ratio
        # Relates current short selling activity to the time needed to cover all shorts
        days_to_cover = data[t, 2]
        short_vol_to_dtc = np.mean(short_volume) / max(days_to_cover, 1e-8)
        eng.append(short_vol_to_dtc)
        
        # 16. Price Trend Strength (ADX-inspired)
        # Measures the strength of the current price trend
        if len(close_prices) >= 14:
            up_moves = np.zeros(13)
            down_moves = np.zeros(13)
            
            for i in range(1, 14):
                up_moves[i-1] = max(high_prices[i] - high_prices[i-1], 0)
                down_moves[i-1] = max(low_prices[i-1] - low_prices[i], 0)
            
            avg_up = np.mean(up_moves)
            avg_down = np.mean(down_moves)
            
            if avg_up + avg_down > 0:
                trend_strength = abs(avg_up - avg_down) / (avg_up + avg_down)
                eng.append(trend_strength)
            else:
                eng.append(0.0)
        else:
            eng.append(0.0)
        
        # 17. Synthetic Short Cost to Implied Volatility Ratio
        # Relationship between cost of shorting and expected volatility
        synthetic_short_cost = data[t, 64]
        implied_vol = data[t, 65]
        cost_to_vol_ratio = synthetic_short_cost / max(implied_vol, 1e-8)
        eng.append(cost_to_vol_ratio)
        
        # 18. Short Volume Momentum
        # Rate of change in short volume over recent periods
        if len(short_volume) >= 10:
            recent_short_vol_avg = np.mean(short_volume[-5:])
            older_short_vol_avg = np.mean(short_volume[-10:-5])
            short_vol_momentum = (recent_short_vol_avg / max(older_short_vol_avg, 1e-8)) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 1971174.4546
RMSE: 2380126.7897
MAPE: 10.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t2: importance=0.0007, rank=1
   2. Feature_11_t1: importance=0.0006, rank=2
   3. Feature_18_t0: importance=0.0005, rank=3
   4. Feature_10_t2: importance=0.0005, rank=4
   5. Feature_5_t3: importance=0.0004, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
📊 No significant improvement. Change: -0.67%

📈 Current best MAPE: 10.10%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = data[t-1, 0]
            current_si = data[t, 0]
            si_change_rate = (current_si / max(prev_si, 1e-8)) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Recent Price Trend (5-day)
        # Simple but effective measure of recent price direction
        if len(close_prices) >= 5:
            price_trend = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            eng.append(price_trend)
        else:
            eng.append(0.0)
        
        # 6. Price Volatility (10-day)
        # Measure of recent price volatility which affects short interest decisions
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns)
            eng.append(volatility)
        else:
            eng.append(0.0)
        
        # 7. Short Volume Acceleration
        # Second derivative of short volume - captures acceleration in short selling
        if len(short_volume) >= 10:
            recent_change = np.mean(short_volume[-3:]) - np.mean(short_volume[-6:-3])
            older_change = np.mean(short_volume[-6:-3]) - np.mean(short_volume[-9:-6])
            acceleration = recent_change - older_change
            eng.append(acceleration / max(abs(np.mean(short_volume[-9:])), 1e-8))
        else:
            eng.append(0.0)
        
        # 8. RSI (Relative Strength Index)
        # Momentum oscillator measuring speed and change of price movements
        if len(close_prices) >= 14:
            diff = np.diff(close_prices[-14:])
            gain = np.sum(np.where(diff > 0, diff, 0))
            loss = np.sum(np.where(diff < 0, -diff, 0))
            
            if loss == 0:
                rsi = 100.0
            else:
                rs = gain / max(loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            eng.append(rsi)
        else:
            eng.append(0.0)
        
        # 9. Short Volume to Average Volume Ratio
        # Compares recent short volume to average trading volume
        avg_short_vol = np.mean(short_volume[-5:])
        avg_vol = data[t, 1]  # average daily volume
        short_to_avg_ratio = avg_short_vol / max(avg_vol, 1e-8)
        eng.append(short_to_avg_ratio)
        
        # 10. Options Implied Volatility Change
        # Rate of change in implied volatility, which can predict short interest changes
        if t > 0:
            prev_iv = data[t-1, 65]
            current_iv = data[t, 65]
            iv_change = (current_iv / max(prev_iv, 1e-8)) - 1
            eng.append(iv_change)
        else:
            eng.append(0.0)
        
        # 11. Price to Synthetic Short Cost Ratio
        # Relationship between current price and cost of synthetic shorting
        synthetic_cost = data[t, 64]
        price_to_cost_ratio = close_prices[-1] / max(synthetic_cost, 1e-8)
        eng.append(price_to_cost_ratio)
        
        # 12. Short Volume Volatility
        # Measures the stability/volatility of short selling activity
        if len(short_volume) >= 10:
            short_vol_volatility = np.std(short_volume[-10:]) / max(np.mean(short_volume[-10:]), 1e-8)
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 13. ATR (Average True Range) - Volatility indicator
        # Measures market volatility which affects short interest
        if len(high_prices) >= 14 and len(low_prices) >= 14 and len(close_prices) >= 14:
            tr_values = []
            for i in range(1, 14):
                tr1 = high_prices[-i] - low_prices[-i]
                tr2 = abs(high_prices[-i] - close_prices[-(i+1)])
                tr3 = abs(low_prices[-i] - close_prices[-(i+1)])
                tr_values.append(max(tr1, tr2, tr3))
            atr = np.mean(tr_values)
            # Normalize by price level
            normalized_atr = atr / max(close_prices[-1], 1e-8)
            eng.append(normalized_atr)
        else:
            eng.append(0.0)
        
        # 14. Volume Trend
        # Direction and strength of volume changes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            older_vol = np.mean(total_volume[-10:-5])
            vol_trend = (recent_vol / max(older_vol, 1e-8)) - 1
            eng.append(vol_trend)
        else:
            eng.append(0.0)
        
        # 15. Short Interest to Days to Cover Ratio Change
        # Captures changes in the relationship between short interest and days to cover
        if t > 0:
            current_ratio = data[t, 0] / max(data[t, 2], 1e-8)
            prev_ratio = data[t-1, 0] / max(data[t-1, 2], 1e-8)
            ratio_change = (current_ratio / max(prev_ratio, 1e-8)) - 1
            eng.append(ratio_change)
        else:
            eng.append(0.0)
        
        # 16. Price Gap Analysis
        # Overnight price gaps can trigger short covering or new short positions
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            gaps = []
            for i in range(1, min(5, len(open_prices))):
                if i < len(close_prices):
                    gap = (open_prices[i] / max(close_prices[i-1], 1e-8)) - 1
                    gaps.append(gap)
            if gaps:
                avg_gap = np.mean(gaps)
                eng.append(avg_gap)
            else:
                eng.append(0.0)
        else:
            eng.append(0.0)
        
        # 17. Short Volume Concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.sum(short_volume[-3:])
            total_short_vol = np.sum(short_volume[-10:])
            short_vol_concentration = recent_short_vol / max(total_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.0)
        
        # 18. Price Momentum with Volume Confirmation
        # Combines price momentum with volume trend for stronger signal
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_change = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            volume_change = (np.mean(total_volume[-5:]) / max(np.mean(total_volume[-10:-5]), 1e-8)) - 1
            # Sign agreement between price and volume changes
            momentum_confirmation = np.sign(price_change) * np.sign(volume_change) * abs(price_change)
            eng.append(momentum_confirmation)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = data[t-1, 0]
            current_si = data[t, 0]
            si_change_rate = (current_si / max(prev_si, 1e-8)) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Price Momentum (10-day)
        # Measures recent price trend strength which can trigger short covering
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            eng.append(price_momentum)
        else:
            eng.append(0.0)
        
        # 6. Relative Strength Index (RSI)
        # Identifies overbought/oversold conditions that may affect short interest
        if len(close_prices) >= 14:
            gains = np.zeros(13)
            losses = np.zeros(13)
            
            for i in range(1, 14):
                change = close_prices[i] - close_prices[i-1]
                if change > 0:
                    gains[i-1] = change
                else:
                    losses[i-1] = abs(change)
            
            avg_gain = np.mean(gains)
            avg_loss = np.mean(losses)
            
            if avg_loss > 0:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100.0
            
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 7. Short Volume Volatility
        # Measures the stability/volatility of short selling activity
        if len(short_volume) >= 5:
            short_vol_volatility = np.std(short_volume[-5:]) / max(np.mean(short_volume[-5:]), 1e-8)
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 8. Short Volume Momentum
        # Rate of change in short volume over recent periods
        if len(short_volume) >= 10:
            recent_short_vol_avg = np.mean(short_volume[-5:])
            older_short_vol_avg = np.mean(short_volume[-10:-5])
            short_vol_momentum = (recent_short_vol_avg / max(older_short_vol_avg, 1e-8)) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # 9. Synthetic Short Cost to Implied Volatility Ratio
        # Relationship between cost of shorting and expected volatility
        synthetic_short_cost = data[t, 64]
        implied_vol = data[t, 65]
        cost_to_vol_ratio = synthetic_short_cost / max(implied_vol, 1e-8)
        eng.append(cost_to_vol_ratio)
        
        # 10. Average True Range (ATR) - Volatility indicator
        # Higher volatility can lead to short covering or new short positions
        if len(close_prices) >= 14:
            tr_values = np.zeros(13)
            
            for i in range(1, 14):
                hl = high_prices[i] - low_prices[i]
                hc = abs(high_prices[i] - close_prices[i-1])
                lc = abs(low_prices[i] - close_prices[i-1])
                tr_values[i-1] = max(hl, hc, lc)
            
            atr = np.mean(tr_values)
            # Normalize by current price
            norm_atr = atr / max(close_prices[-1], 1e-8)
            eng.append(norm_atr)
        else:
            eng.append(0.0)
        
        # 11. Volume Trend (5-day)
        # Identifies if trading volume is increasing or decreasing
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_trend = (recent_vol_avg / max(older_vol_avg, 1e-8)) - 1
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 12. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest_to_dtc = data[t, 0] / days_to_cover
        eng.append(short_interest_to_dtc)
        
        # 13. Price to Moving Average Ratio (10-day)
        # Identifies if price is above/below recent average, indicating potential trend
        if len(close_prices) >= 10:
            ma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(ma10, 1e-8)
            eng.append(price_to_ma)
        else:
            eng.append(1.0)
        
        # 14. Short Volume Concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.sum(short_volume[-5:])
            total_short_vol = np.sum(short_volume[-10:])
            short_vol_concentration = recent_short_vol / max(total_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.5)  # Neutral value
        
        # 15. Options Put/Call Ratio Change
        # Tracks changes in options sentiment
        if t > 0:
            prev_pc_ratio = data[t-1, 63]
            current_pc_ratio = data[t, 63]
            pc_ratio_change = (current_pc_ratio / max(prev_pc_ratio, 1e-8)) - 1
            eng.append(pc_ratio_change)
        else:
            eng.append(0.0)
        
        # 16. Volatility Ratio (Implied/Historical)
        # Compares market expectations vs. realized volatility
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            implied_vol = data[t, 65]  # options_avg_implied_volatility
            iv_hv_ratio = implied_vol / max(hist_vol, 1e-8)
            eng.append(iv_hv_ratio)
        else:
            eng.append(1.0)
        
        # 17. Price Range Volatility
        # Measures recent price range relative to price level
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            max_high = np.max(high_prices[-5:])
            min_low = np.min(low_prices[-5:])
            avg_price = np.mean(close_prices[-5:])
            price_range_vol = (max_high - min_low) / max(avg_price, 1e-8)
            eng.append(price_range_vol)
        else:
            eng.append(0.0)
        
        # 18. Short Volume to Average Volume Ratio
        # Compares recent short volume to overall trading volume
        avg_short_vol = np.mean(short_volume)
        avg_volume = max(data[t, 1], 1e-8)  # average daily volume
        short_to_avg_vol = avg_short_vol / avg_volume
        eng.append(short_to_avg_vol)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 2/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features that showed high importance
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Recent Price Momentum (5-day)
        # Captures short-term price trend which can trigger short covering
        if len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            eng.append(price_momentum)
        else:
            eng.append(0.0)
        
        # 6. Short Volume Acceleration
        # Second derivative of short volume - captures changing momentum in short selling
        if len(short_volume) >= 6:
            recent_change = short_volume[-1] - short_volume[-3]
            previous_change = short_volume[-3] - short_volume[-6]
            denom = max(abs(previous_change), 1e-8)
            short_accel = (recent_change / denom) - 1
            eng.append(short_accel)
        else:
            eng.append(0.0)
        
        # 7. Short Volume to Average Volume Ratio
        # Relates current short selling to typical trading volume
        avg_volume = max(data[t, 1], 1e-8)
        short_to_avg_ratio = np.mean(short_volume) / avg_volume
        eng.append(short_to_avg_ratio)
        
        # 8. Price Volatility (normalized)
        # Volatility often correlates with short interest changes
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns)
            eng.append(volatility)
        else:
            eng.append(0.0)
        
        # 9. Relative Strength Index (RSI)
        # Momentum oscillator that measures speed and change of price movements
        if len(close_prices) >= 14:
            diff = np.diff(close_prices[-14:])
            gains = np.sum(np.maximum(diff, 0))
            losses = np.sum(np.abs(np.minimum(diff, 0)))
            
            if losses == 0:
                rsi = 100.0
            else:
                rs = gains / max(losses, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            eng.append(rsi / 100.0)  # Normalize to 0-1
        else:
            eng.append(0.5)  # Neutral RSI value
        
        # 10. Short Volume Concentration (Recent vs Total)
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.sum(short_volume[-3:])
            total_short_vol = np.sum(short_volume[-10:])
            short_vol_concentration = recent_short_vol / max(total_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.0)
        
        # 11. Options Implied Volatility to Historical Volatility Ratio
        # Compares market expectations vs. realized volatility
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            implied_vol = data[t, 65]  # options_avg_implied_volatility
            iv_hv_ratio = implied_vol / max(hist_vol, 1e-8)
            eng.append(iv_hv_ratio)
        else:
            eng.append(1.0)  # Neutral value
        
        # 12. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover
        days_to_cover = max(data[t, 2], 1e-8)
        si_to_dtc = data[t, 0] / days_to_cover
        eng.append(si_to_dtc)
        
        # 13. Price to Moving Average Ratio
        # Identifies potential mean reversion opportunities
        if len(close_prices) >= 10:
            sma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(sma10, 1e-8)
            eng.append(price_to_ma)
        else:
            eng.append(1.0)
        
        # 14. Short Volume Trend Strength
        # Measures consistency of short volume trend
        if len(short_volume) >= 10:
            short_vol_trend = np.polyfit(np.arange(10), short_volume[-10:], 1)[0]
            short_vol_mean = np.mean(short_volume[-10:])
            short_trend_strength = short_vol_trend / max(short_vol_mean, 1e-8)
            eng.append(short_trend_strength)
        else:
            eng.append(0.0)
        
        # 15. Volume Weighted Price Momentum
        # Price momentum weighted by volume significance
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            vol_ratio = total_volume[-1] / max(np.mean(total_volume[-5:]), 1e-8)
            vol_weighted_momentum = price_change * vol_ratio
            eng.append(vol_weighted_momentum)
        else:
            eng.append(0.0)
        
        # 16. Short Volume Volatility
        # Measures the stability/volatility of short selling activity
        if len(short_volume) >= 10:
            short_vol_volatility = np.std(short_volume[-10:]) / max(np.mean(short_volume[-10:]), 1e-8)
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 17. Synthetic Short Cost to Implied Volatility Ratio
        # Relationship between cost of shorting and expected volatility
        synthetic_short_cost = data[t, 64]
        implied_vol = max(data[t, 65], 1e-8)
        cost_to_vol_ratio = synthetic_short_cost / implied_vol
        eng.append(cost_to_vol_ratio)
        
        # 18. Short Volume Momentum
        # Rate of change in short volume over recent periods
        if len(short_volume) >= 10:
            recent_short_vol_avg = np.mean(short_volume[-5:])
            older_short_vol_avg = max(np.mean(short_volume[-10:-5]), 1e-8)
            short_vol_momentum = (recent_short_vol_avg / older_short_vol_avg) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 3/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Relative Strength Index (RSI) - momentum oscillator
        # Identifies overbought/oversold conditions that may trigger short covering
        if len(close_prices) >= 14:
            price_diff = np.diff(close_prices)
            gains = np.where(price_diff > 0, price_diff, 0)
            losses = np.where(price_diff < 0, -price_diff, 0)
            
            avg_gain = np.mean(gains)
            avg_loss = np.mean(losses)
            
            if avg_loss == 0:
                rsi = 100.0
            else:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 6. Short Volume Concentration
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.sum(short_volume[-5:])
            total_short_vol = np.sum(short_volume[-10:])
            short_vol_concentration = recent_short_vol / max(total_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.5)  # Neutral concentration
        
        # 7. Price Volatility (ATR-based)
        # Higher volatility can lead to short covering or new short positions
        if len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            atr = np.mean(tr_values)
            # Normalize by price level
            norm_atr = atr / max(close_prices[-1], 1e-8)
            eng.append(norm_atr)
        else:
            eng.append(0.0)
        
        # 8. Short Volume Momentum
        # Rate of change in short volume over recent periods
        if len(short_volume) >= 10:
            recent_short_vol_avg = np.mean(short_volume[-5:])
            older_short_vol_avg = np.mean(short_volume[-10:-5])
            short_vol_momentum = (recent_short_vol_avg / max(older_short_vol_avg, 1e-8)) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # 9. Price to Moving Average Ratio
        # Indicates potential mean reversion or trend continuation points
        if len(close_prices) >= 10:
            sma10 = np.mean(close_prices[-10:])
            price_to_ma = close_prices[-1] / max(sma10, 1e-8)
            eng.append(price_to_ma)
        else:
            eng.append(1.0)  # Neutral value
        
        # 10. Volume Trend
        # Increasing volume can signal potential short covering or new short positions
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_trend = (recent_vol_avg / max(older_vol_avg, 1e-8)) - 1
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 11. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover all shorts
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        eng.append(si_to_dtc)
        
        # 12. Options Implied Volatility to Price Ratio
        # Higher ratio may indicate increased likelihood of short covering
        implied_vol = data[t, 65]
        price = close_prices[-1] if len(close_prices) > 0 else 1.0
        iv_to_price = implied_vol / max(price, 1e-8)
        eng.append(iv_to_price)
        
        # 13. Short Volume Volatility
        # Measures the stability/volatility of short selling activity
        if len(short_volume) >= 5:
            short_vol_volatility = np.std(short_volume[-5:]) / max(np.mean(short_volume[-5:]), 1e-8)
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 14. Price Momentum (Rate of Change)
        # Strong price momentum can trigger short covering
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            eng.append(price_momentum)
        else:
            eng.append(0.0)
        
        # 15. Short Interest to Options Put/Call Ratio
        # Relationship between short interest and options sentiment
        put_call_ratio = max(data[t, 63], 1e-8)
        si_to_options = data[t, 0] / put_call_ratio
        eng.append(si_to_options)
        
        # 16. Synthetic Short Cost to Average Volume Ratio
        # Relates cost of shorting to liquidity
        synthetic_short_cost = data[t, 64]
        avg_volume = max(data[t, 1], 1e-8)
        cost_to_volume = synthetic_short_cost / avg_volume
        eng.append(cost_to_volume)
        
        # 17. Recent Price Range Relative to Historical
        # Identifies if current price action is unusual compared to historical
        if len(high_prices) >= 10 and len(low_prices) >= 10:
            recent_range = np.max(high_prices[-5:]) - np.min(low_prices[-5:])
            historical_range = np.max(high_prices[-10:]) - np.min(low_prices[-10:])
            relative_range = recent_range / max(historical_range, 1e-8)
            eng.append(relative_range)
        else:
            eng.append(1.0)
        
        # 18. Short Volume to Total Volume Acceleration
        # Second derivative of short volume ratio - captures changing momentum
        if len(short_volume_ratio) >= 10:
            recent_change = short_volume_ratio[-1] - short_volume_ratio[-5]
            older_change = short_volume_ratio[-6] - short_volume_ratio[-10]
            acceleration = recent_change - older_change
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 1824680.1937
RMSE: 2284212.1185
MAPE: 9.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t0: importance=0.0008, rank=1
   2. Feature_24_t1: importance=0.0006, rank=2
   3. Feature_23_t0: importance=0.0006, rank=3
   4. Feature_14_t0: importance=0.0005, rank=4
   5. Feature_23_t2: importance=0.0005, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.23%

📈 Current best MAPE: 9.87%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical baseline features)
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was one of the most important features in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Improved RSI with Weighted Recent Values
        # Gives more weight to recent price movements to better capture short-term momentum
        if len(close_prices) >= 14:
            price_diff = np.diff(close_prices)
            gains = np.where(price_diff > 0, price_diff, 0)
            losses = np.where(price_diff < 0, -price_diff, 0)
            
            # Apply exponential weighting to recent values
            weights = np.exp(np.linspace(0, 1, len(gains)))
            weights = weights / np.sum(weights)
            
            avg_gain = np.sum(gains * weights[:len(gains)])
            avg_loss = np.sum(losses * weights[:len(losses)])
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / avg_loss
                rsi = 100.0 - (100.0 / (1.0 + rs))
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 6. Short Volume Concentration with Exponential Weighting
        # Measures if short volume is concentrated in recent days with more weight on most recent days
        if len(short_volume) >= 10:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            recent_short_vol = np.sum(short_volume[-5:] * weights)
            
            older_weights = np.exp(np.linspace(0, 0.5, 5))
            older_weights = older_weights / np.sum(older_weights)
            older_short_vol = np.sum(short_volume[-10:-5] * older_weights)
            
            short_vol_concentration = recent_short_vol / max(older_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(0.5)  # Neutral concentration
        
        # 7. Bollinger Band Width - Normalized by Price
        # Measures volatility and potential mean reversion points
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)
            eng.append(bb_width)
        else:
            eng.append(0.0)
        
        # 8. Short Volume Momentum with Exponential Smoothing
        # Improved rate of change in short volume with noise reduction
        if len(short_volume) >= 10:
            # Apply exponential smoothing to reduce noise
            alpha = 0.7
            smoothed_recent = short_volume[-5:].copy()
            for i in range(1, len(smoothed_recent)):
                smoothed_recent[i] = alpha * short_volume[-5+i] + (1-alpha) * smoothed_recent[i-1]
            
            smoothed_older = short_volume[-10:-5].copy()
            for i in range(1, len(smoothed_older)):
                smoothed_older[i] = alpha * short_volume[-10+i] + (1-alpha) * smoothed_older[i-1]
            
            recent_short_vol_avg = np.mean(smoothed_recent)
            older_short_vol_avg = np.mean(smoothed_older)
            short_vol_momentum = (recent_short_vol_avg / max(older_short_vol_avg, 1e-8)) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # 9. Price Trend Strength (Directional Movement Index inspired)
        # Measures the strength of a price trend, which can influence short covering
        if len(close_prices) >= 10:
            up_moves = np.zeros(9)
            down_moves = np.zeros(9)
            
            for i in range(1, 10):
                up_moves[i-1] = max(high_prices[-i] - high_prices[-i-1], 0)
                down_moves[i-1] = max(low_prices[-i-1] - low_prices[-i], 0)
            
            pos_dm_sum = np.sum(up_moves)
            neg_dm_sum = np.sum(down_moves)
            
            if abs(pos_dm_sum + neg_dm_sum) < 1e-8:
                trend_strength = 0.0
            else:
                trend_strength = abs(pos_dm_sum - neg_dm_sum) / (pos_dm_sum + neg_dm_sum)
            eng.append(trend_strength)
        else:
            eng.append(0.0)
        
        # 10. Volume Trend with Volatility Adjustment
        # Increasing volume with low volatility can signal stronger trend
        if len(total_volume) >= 10 and len(close_prices) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_trend = (recent_vol_avg / max(older_vol_avg, 1e-8)) - 1
            
            # Adjust by price volatility
            price_volatility = np.std(close_prices[-5:]) / max(np.mean(close_prices[-5:]), 1e-8)
            vol_trend_adjusted = volume_trend / max(price_volatility, 1e-8)
            eng.append(vol_trend_adjusted)
        else:
            eng.append(0.0)
        
        # 11. Short Interest to Days to Cover Ratio with Volume Trend Adjustment
        # Relates total short interest to the time needed to cover all shorts, adjusted for volume trend
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        
        # Adjust by recent volume trend if available
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_trend = (recent_vol_avg / max(older_vol_avg, 1e-8))
            si_to_dtc_adj = si_to_dtc * volume_trend
            eng.append(si_to_dtc_adj)
        else:
            eng.append(si_to_dtc)
        
        # 12. Options Implied Volatility to Historical Volatility Ratio
        # Higher ratio may indicate increased likelihood of short covering or market expectations diverging from reality
        implied_vol = data[t, 65]
        if len(close_prices) >= 10:
            hist_vol = np.std(close_prices[-10:]) / max(np.mean(close_prices[-10:]), 1e-8) * np.sqrt(252)  # Annualized
            iv_to_hv = implied_vol / max(hist_vol, 1e-8)
            eng.append(iv_to_hv)
        else:
            eng.append(1.0)
        
        # 13. Short Volume Volatility with Trend Direction
        # Measures the stability/volatility of short selling activity with trend direction
        if len(short_volume) >= 5:
            short_vol_volatility = np.std(short_volume[-5:]) / max(np.mean(short_volume[-5:]), 1e-8)
            
            # Add trend direction component
            if short_volume[-1] > short_volume[-5]:
                trend_sign = 1.0
            else:
                trend_sign = -1.0
                
            signed_volatility = short_vol_volatility * trend_sign
            eng.append(signed_volatility)
        else:
            eng.append(0.0)
        
        # 14. Price Momentum with Volume Confirmation
        # Strong price momentum with volume confirmation can trigger short covering
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_ratio = recent_vol_avg / max(older_vol_avg, 1e-8)
            
            # Combine price momentum with volume confirmation
            confirmed_momentum = price_momentum * volume_ratio
            eng.append(confirmed_momentum)
        else:
            eng.append(0.0)
        
        # 15. Short Interest to Options Put/Call Ratio with Implied Volatility Adjustment
        # Relationship between short interest and options sentiment, adjusted for market volatility expectations
        put_call_ratio = max(data[t, 63], 1e-8)
        implied_vol = data[t, 65]
        
        # Normalize implied volatility to a 0-1 scale assuming typical range is 0.1 to 0.6
        norm_iv = min(max((implied_vol - 0.1) / 0.5, 0), 1)
        
        # Adjust put/call ratio by implied volatility (higher IV makes put/call ratio more significant)
        adjusted_pc_ratio = put_call_ratio * (1 + norm_iv)
        si_to_options = data[t, 0] / max(adjusted_pc_ratio, 1e-8)
        eng.append(si_to_options)
        
        # 16. Synthetic Short Cost to Average Volume Ratio with Days to Cover Adjustment
        # Relates cost of shorting to liquidity and time to cover
        synthetic_short_cost = data[t, 64]
        avg_volume = max(data[t, 1], 1e-8)
        days_to_cover = max(data[t, 2], 1e-8)
        
        # Higher days to cover makes synthetic short cost more significant
        adjusted_cost = synthetic_short_cost * (1 + min(days_to_cover / 10, 1))  # Cap at 10 days
        cost_to_volume = adjusted_cost / avg_volume
        eng.append(cost_to_volume)
        
        # 17. VWAP Distance
        # Distance of current price from Volume Weighted Average Price, indicating potential mean reversion
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_distance = (close_prices[-1] / max(vwap, 1e-8)) - 1
            eng.append(vwap_distance)
        else:
            eng.append(0.0)
        
        # 18. Short Volume Acceleration with Smoothing
        # Second derivative of short volume ratio with noise reduction
        if len(short_volume_ratio) >= 10:
            # Apply smoothing to reduce noise
            smoothed_ratio = short_volume_ratio.copy()
            alpha = 0.6
            for i in range(1, len(smoothed_ratio)):
                smoothed_ratio[i] = alpha * short_volume_ratio[i] + (1-alpha) * smoothed_ratio[i-1]
                
            recent_change = smoothed_ratio[-1] - smoothed_ratio[-5]
            older_change = smoothed_ratio[-6] - smoothed_ratio[-10]
            acceleration = recent_change - older_change
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 1960161.5851
RMSE: 2322950.3413
MAPE: 10.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 81

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0007, rank=1
   2. Feature_16_t1: importance=0.0007, rank=2
   3. Feature_18_t0: importance=0.0006, rank=3
   4. Feature_10_t2: importance=0.0005, rank=4
   5. Feature_12_t0: importance=0.0005, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.92%

📈 Current best MAPE: 9.87%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features that showed high importance
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance in previous iterations
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio with Exponential Weighting
        # This was consistently one of the most important features
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Apply exponential weighting to emphasize recent days
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            weighted_svr = np.sum(short_volume_ratio[-5:] * weights)
            eng.append(weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend with Volatility Adjustment
        # Captures directional trend in short selling activity, adjusted for volatility
        if len(short_volume_ratio) >= 10:
            recent_svr = np.mean(short_volume_ratio[-5:])
            older_svr = np.mean(short_volume_ratio[-10:-5])
            svr_trend = recent_svr - older_svr
            
            # Adjust by volatility to normalize the signal
            svr_volatility = np.std(short_volume_ratio[-10:])
            if svr_volatility > 1e-8:
                svr_trend_adj = svr_trend / svr_volatility
            else:
                svr_trend_adj = svr_trend
            eng.append(svr_trend_adj)
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio with Volume Trend Adjustment
        # Key metric showing percentage of available shares being shorted, adjusted for volume trend
        shares_out = max(data[t, 66], 1e-8)  # shares_outstanding
        short_interest_to_float = data[t, 0] / shares_out
        
        # Adjust by recent volume trend if available
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = np.mean(total_volume[-10:-5])
            volume_trend = recent_vol_avg / max(older_vol_avg, 1e-8)
            # Higher volume trend makes short interest more significant
            si_float_adj = short_interest_to_float * np.sqrt(volume_trend)
            eng.append(si_float_adj)
        else:
            eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate with Momentum
        # Improved rate of change in short interest with momentum component
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            
            # Add momentum component if we have enough history
            if t > 1:
                prev_prev_si = max(data[t-2, 0], 1e-8)
                prev_change_rate = (prev_si / prev_prev_si) - 1
                si_momentum = si_change_rate - prev_change_rate
                eng.append(si_change_rate * (1 + si_momentum))  # Amplify by momentum
            else:
                eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Adaptive RSI with Volume Weighting
        # RSI that adapts to market conditions and weights by volume
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            price_diff = np.diff(close_prices)
            gains = np.where(price_diff > 0, price_diff, 0)
            losses = np.where(price_diff < 0, -price_diff, 0)
            
            # Weight by normalized volume
            norm_volume = total_volume[1:] / max(np.mean(total_volume[1:]), 1e-8)
            volume_weighted_gains = gains * norm_volume
            volume_weighted_losses = losses * norm_volume
            
            # Use exponential weighting for recency
            weights = np.exp(np.linspace(0, 1, len(gains)))
            weights = weights / np.sum(weights)
            
            avg_gain = np.sum(volume_weighted_gains * weights[:len(gains)])
            avg_loss = np.sum(volume_weighted_losses * weights[:len(losses)])
            
            if avg_loss < 1e-8:
                rsi = 100.0
            else:
                rs = avg_gain / avg_loss
                rsi = 100.0 - (100.0 / (1.0 + rs))
            
            # Normalize to -1 to 1 range (centered at 50)
            norm_rsi = (rsi - 50) / 50
            eng.append(norm_rsi)
        else:
            eng.append(0.0)
        
        # 6. Short Volume Concentration Index
        # Measures if short volume is concentrated in specific days
        if len(short_volume) >= 10:
            # Calculate Gini coefficient-inspired concentration measure
            sorted_short_vol = np.sort(short_volume[-10:])
            n = len(sorted_short_vol)
            cumulative = np.cumsum(sorted_short_vol)
            # Normalize by total sum
            total_sum = max(cumulative[-1], 1e-8)
            lorenz_curve = cumulative / total_sum
            # Calculate area under Lorenz curve
            area = np.sum(lorenz_curve) / n
            # Gini coefficient = 1 - 2*area
            concentration_index = 1 - 2 * area
            eng.append(concentration_index)
        else:
            eng.append(0.0)
        
        # 7. Normalized Bollinger Band Position with Volume Confirmation
        # Position within Bollinger Bands with volume confirmation
        if len(close_prices) >= 20 and len(total_volume) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            # Avoid division by zero
            if std20 > 1e-8:
                # Calculate position within bands (-1 to +1 scale)
                bb_position = (close_prices[-1] - sma20) / (2 * std20)
                bb_position = max(min(bb_position, 1.0), -1.0)  # Clamp to [-1, 1]
                
                # Volume confirmation - higher volume makes the signal stronger
                recent_vol_avg = np.mean(total_volume[-5:])
                overall_vol_avg = np.mean(total_volume[-20:])
                vol_ratio = recent_vol_avg / max(overall_vol_avg, 1e-8)
                
                # Amplify signal when volume is high, dampen when low
                bb_position_adj = bb_position * np.sqrt(vol_ratio)
                eng.append(bb_position_adj)
            else:
                eng.append(0.0)
        else:
            eng.append(0.0)
        
        # 8. Short Volume Momentum with Noise Reduction
        # Improved rate of change in short volume with better noise handling
        if len(short_volume) >= 10:
            # Apply double smoothing to reduce noise
            alpha = 0.7
            smoothed = short_volume.copy()
            for _ in range(2):  # Apply smoothing twice
                for i in range(1, len(smoothed)):
                    smoothed[i] = alpha * short_volume[i] + (1-alpha) * smoothed[i-1]
            
            recent_short_vol_avg = np.mean(smoothed[-5:])
            older_short_vol_avg = np.mean(smoothed[-10:-5])
            
            # Calculate momentum as percentage change
            denom = max(older_short_vol_avg, 1e-8)
            short_vol_momentum = (recent_short_vol_avg / denom) - 1
            
            # Apply sigmoid-like transformation to handle outliers
            short_vol_momentum = np.tanh(short_vol_momentum)
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # 9. Directional Movement Strength with Short Volume Correlation
        # Combines price trend strength with short volume behavior
        if len(close_prices) >= 10 and len(short_volume) >= 10:
            # Calculate directional movement
            up_moves = np.zeros(9)
            down_moves = np.zeros(9)
            
            for i in range(1, 10):
                up_moves[i-1] = max(high_prices[-i] - high_prices[-i-1], 0)
                down_moves[i-1] = max(low_prices[-i-1] - low_prices[-i], 0)
            
            pos_dm_sum = np.sum(up_moves)
            neg_dm_sum = np.sum(down_moves)
            
            if abs(pos_dm_sum + neg_dm_sum) < 1e-8:
                trend_strength = 0.0
            else:
                # Calculate trend strength and direction
                trend_strength = abs(pos_dm_sum - neg_dm_sum) / (pos_dm_sum + neg_dm_sum)
                trend_direction = 1.0 if pos_dm_sum > neg_dm_sum else -1.0
                trend_strength *= trend_direction
            
            # Correlate with short volume behavior
            recent_short_vol_change = (short_volume[-1] / max(short_volume[-5], 1e-8)) - 1
            
            # Combine: strong uptrend + decreasing short volume is bullish
            # strong downtrend + increasing short volume is bearish
            combined_signal = trend_strength * (1 - recent_short_vol_change)
            eng.append(combined_signal)
        else:
            eng.append(0.0)
        
        # 10. Options Sentiment Index with Short Interest Alignment
        # Combines options market sentiment with short interest
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        
        # Normalize put/call ratio (typical range 0.5-2.0)
        norm_pc = np.tanh((put_call_ratio - 1.0) / 0.5)  # Center at 1.0
        
        # Normalize implied volatility (typical range 0.1-0.6)
        norm_iv = np.tanh((implied_vol - 0.3) / 0.15)  # Center at 0.3
        
        # Combine: high put/call + high IV + high short interest = strong bearish sentiment
        short_interest_norm = data[t, 0] / max(data[t, 66], 1e-8)  # SI/Float
        short_interest_norm = np.tanh(short_interest_norm * 10)  # Scale and bound
        
        options_sentiment = (norm_pc + norm_iv + short_interest_norm) / 3
        eng.append(options_sentiment)
        
        # 11. Short Squeeze Potential Index
        # Measures likelihood of a short squeeze based on multiple factors
        days_to_cover = data[t, 2]
        short_interest = data[t, 0]
        avg_volume = max(data[t, 1], 1e-8)
        
        # Normalize days to cover (typical range 1-10)
        norm_dtc = np.tanh(days_to_cover / 5)
        
        # Short interest to float ratio
        si_float = short_interest / max(data[t, 66], 1e-8)
        norm_si_float = np.tanh(si_float * 10)
        
        # Recent price momentum (if available)
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            norm_momentum = np.tanh(price_momentum * 5)
            
            # Short squeeze potential: high SI + high DTC + positive momentum
            squeeze_potential = (norm_si_float + norm_dtc + norm_momentum) / 3
            eng.append(squeeze_potential)
        else:
            # Without price data, use just SI and DTC
            squeeze_potential = (norm_si_float + norm_dtc) / 2
            eng.append(squeeze_potential)
        
        # 12. Synthetic Short Cost Efficiency
        # Relates cost of shorting to potential profit/loss
        synthetic_short_cost = data[t, 64]
        
        if len(close_prices) >= 20:
            # Calculate historical volatility
            returns = np.diff(close_prices) / close_prices[:-1]
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            
            # Cost efficiency: cost relative to potential profit from volatility
            cost_efficiency = synthetic_short_cost / max(hist_vol, 1e-8)
            eng.append(np.tanh(cost_efficiency))  # Bound outliers
        else:
            # Normalize raw cost if history unavailable
            eng.append(np.tanh(synthetic_short_cost * 5))
        
        # 13. VWAP Mean Reversion Signal
        # Distance from VWAP with mean reversion potential
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate 10-day VWAP
            vwap = np.sum(close_prices[-10:] * total_volume[-10:]) / max(np.sum(total_volume[-10:]), 1e-8)
            
            # Calculate distance from VWAP
            vwap_distance = (close_prices[-1] / max(vwap, 1e-8)) - 1
            
            # Calculate historical mean reversion strength
            if len(close_prices) >= 20:
                # Look at past deviations and subsequent moves
                past_deviations = []
                subsequent_moves = []
                
                for i in range(10, min(20, len(close_prices))):
                    past_vwap = np.sum(close_prices[i-10:i] * total_volume[i-10:i]) / max(np.sum(total_volume[i-10:i]), 1e-8)
                    deviation = (close_prices[i-1] / past_vwap) - 1
                    next_move = (close_prices[i] / close_prices[i-1]) - 1
                    
                    past_deviations.append(deviation)
                    subsequent_moves.append(next_move)
                
                # Calculate if deviations tend to revert
                reversion_strength = 0.0
                if len(past_deviations) > 0:
                    # Negative correlation means reversion
                    products = [a * b for a, b in zip(past_deviations, subsequent_moves)]
                    reversion_strength = -np.mean(products)
                
                # Combine current distance with historical reversion strength
                mean_reversion_signal = vwap_distance * reversion_strength
                eng.append(mean_reversion_signal)
            else:
                # Just use distance if not enough history
                eng.append(vwap_distance)
        else:
            eng.append(0.0)
        
        # 14. Short Volume Acceleration with Adaptive Smoothing
        # Second derivative of short volume with adaptive smoothing
        if len(short_volume_ratio) >= 15:
            # Apply adaptive smoothing based on volatility
            volatility = np.std(short_volume_ratio)
            alpha = max(min(0.8 - volatility, 0.9), 0.1)  # More smoothing for high volatility
            
            smoothed_ratio = short_volume_ratio.copy()
            for i in range(1, len(smoothed_ratio)):
                smoothed_ratio[i] = alpha * short_volume_ratio[i] + (1-alpha) * smoothed_ratio[i-1]
            
            # Calculate first derivatives (velocity)
            velocity_recent = smoothed_ratio[-1] - smoothed_ratio[-6]
            velocity_older = smoothed_ratio[-6] - smoothed_ratio[-11]
            
            # Calculate acceleration (second derivative)
            acceleration = velocity_recent - velocity_older
            
            # Normalize by historical volatility
            norm_acceleration = acceleration / max(volatility, 1e-8)
            eng.append(np.tanh(norm_acceleration))  # Bound outliers
        else:
            eng.append(0.0)
        
        # 15. Options-Implied Short Interest Change Predictor
        # Uses options market data to predict short interest changes
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        synthetic_cost = data[t, 64]
        
        # Normalize inputs
        norm_pc = np.tanh((put_call_ratio - 1.0) / 0.5)
        norm_iv = np.tanh((implied_vol - 0.3) / 0.15)
        norm_cost = np.tanh(synthetic_cost * 5)
        
        # Combine with learned weights (from feature importance)
        # High put/call + rising IV + low cost = likely short interest increase
        options_predictor = 0.5 * norm_pc + 0.3 * norm_iv - 0.2 * norm_cost
        eng.append(options_predictor)
        
        # 16. Volume Pressure Index
        # Measures buying/selling pressure through volume analysis
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Identify up and down days
            up_days = close_prices[1:] > close_prices[:-1]
            down_days = ~up_days
            
            # Calculate volume on up vs down days
            up_vol = np.sum(total_volume[1:][up_days[-9:]])
            down_vol = np.sum(total_volume[1:][down_days[-9:]])
            
            # Calculate pressure index
            total_vol = max(up_vol + down_vol, 1e-8)
            volume_pressure = (up_vol - down_vol) / total_vol
            
            # Adjust by short volume ratio
            if len(short_volume_ratio) >= 10:
                avg_short_ratio = np.mean(short_volume_ratio[-10:])
                # High short ratio reduces positive pressure, amplifies negative
                adjusted_pressure = volume_pressure * (1 - avg_short_ratio)
                eng.append(adjusted_pressure)
            else:
                eng.append(volume_pressure)
        else:
            eng.append(0.0)
        
        # 17. Short Interest Efficiency Ratio
        # Measures how effectively short sellers are timing their positions
        if t > 0 and len(close_prices) >= 10:
            # Calculate price change
            price_change = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            
            # Calculate short interest change
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change = (current_si / prev_si) - 1
            
            # Efficiency: negative correlation between SI change and price change is efficient
            # (shorts increase when price rises, decrease when price falls)
            efficiency = -1 * si_change * price_change
            eng.append(efficiency)
        else:
            eng.append(0.0)
        
        # 18. Adaptive Market Regime Indicator
        # Identifies current market regime (trending, mean-reverting, volatile)
        if len(close_prices) >= 20:
            # Calculate returns
            returns = np.diff(close_prices) / close_prices[:-1]
            
            # Autocorrelation (lag 1) - positive for trending, negative for mean-reverting
            if len(returns) >= 10:
                # Simple autocorrelation estimate
                returns_lag0 = returns[-10:]
                returns_lag1 = returns[-11:-1]
                
                # Calculate correlation
                mean0 = np.mean(returns_lag0)
                mean1 = np.mean(returns_lag1)
                
                num = np.sum((returns_lag0 - mean0) * (returns_lag1 - mean1))
                den0 = np.sum((returns_lag0 - mean0) ** 2)
                den1 = np.sum((returns_lag1 - mean1) ** 2)
                
                if den0 > 1e-8 and den1 > 1e-8:
                    autocorr = num / np.sqrt(den0 * den1)
                else:
                    autocorr = 0.0
                
                # Volatility component
                recent_vol = np.std(returns[-10:])
                older_vol = np.std(returns[-20:-10])
                vol_ratio = recent_vol / max(older_vol, 1e-8)
                
                # Combine: regime indicator
                # +1 = strong trend, 0 = random, -1 = mean-reverting
                # Multiply by volatility ratio to amplify signal in volatile markets
                regime = autocorr * np.sqrt(vol_ratio)
                eng.append(regime)
            else:
                eng.append(0.0)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: boolean index did not match indexed array along dimension 0; dimension is 14 but corresponding boolean dimension is 9
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest (most important)
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(shares_outstanding, 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Short Volume Concentration (Recent vs Older)
        # Measures if short volume is concentrated in recent days
        if len(short_volume) >= 10:
            recent_short_vol = np.mean(short_volume[-5:])
            older_short_vol = np.mean(short_volume[-10:-5])
            short_vol_concentration = recent_short_vol / max(older_short_vol, 1e-8)
            eng.append(short_vol_concentration)
        else:
            eng.append(1.0)
        
        # 6. Price Volatility (Normalized)
        # Measures recent price volatility which can trigger short covering
        if len(close_prices) >= 10:
            price_std = np.std(close_prices[-10:])
            price_mean = max(np.mean(close_prices[-10:]), 1e-8)
            normalized_volatility = price_std / price_mean
            eng.append(normalized_volatility)
        else:
            eng.append(0.0)
        
        # 7. Short Volume Momentum
        # Rate of change in short volume
        if len(short_volume) >= 10:
            recent_short_vol_avg = np.mean(short_volume[-5:])
            older_short_vol_avg = max(np.mean(short_volume[-10:-5]), 1e-8)
            short_vol_momentum = (recent_short_vol_avg / older_short_vol_avg) - 1
            eng.append(short_vol_momentum)
        else:
            eng.append(0.0)
        
        # 8. Price Trend Strength
        # Measures the strength and direction of recent price movement
        if len(close_prices) >= 10:
            price_change = close_prices[-1] - close_prices[-10]
            price_range = max(np.max(high_prices[-10:]) - np.min(low_prices[-10:]), 1e-8)
            trend_strength = price_change / price_range
            eng.append(trend_strength)
        else:
            eng.append(0.0)
        
        # 9. Volume Trend
        # Increasing volume can signal stronger price movements
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = max(np.mean(total_volume[-10:-5]), 1e-8)
            volume_trend = (recent_vol_avg / older_vol_avg) - 1
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 10. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover all shorts
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        eng.append(si_to_dtc)
        
        # 11. Options Implied Volatility to Historical Volatility Ratio
        # Higher ratio may indicate increased likelihood of short covering
        implied_vol = data[t, 65]
        if len(close_prices) >= 10:
            # Calculate historical volatility (annualized)
            returns = np.diff(close_prices[-11:]) / close_prices[-11:-1]
            hist_vol = max(np.std(returns) * np.sqrt(252), 1e-8)
            iv_to_hv = implied_vol / hist_vol
            eng.append(iv_to_hv)
        else:
            eng.append(1.0)
        
        # 12. Short Volume Volatility
        # Measures the stability of short selling activity
        if len(short_volume) >= 5:
            short_vol_mean = max(np.mean(short_volume[-5:]), 1e-8)
            short_vol_std = np.std(short_volume[-5:])
            short_vol_volatility = short_vol_std / short_vol_mean
            eng.append(short_vol_volatility)
        else:
            eng.append(0.0)
        
        # 13. Price Momentum with Volume Confirmation
        # Strong price momentum with volume confirmation can trigger short covering
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            volume_ratio = np.mean(total_volume[-5:]) / max(np.mean(total_volume[-10:-5]), 1e-8)
            confirmed_momentum = price_momentum * volume_ratio
            eng.append(confirmed_momentum)
        else:
            eng.append(0.0)
        
        # 14. Short Interest to Options Put/Call Ratio
        # Relationship between short interest and options sentiment
        put_call_ratio = max(data[t, 63], 1e-8)
        si_to_options = data[t, 0] / put_call_ratio
        eng.append(si_to_options)
        
        # 15. Synthetic Short Cost to Average Volume Ratio
        # Relates cost of shorting to liquidity
        synthetic_short_cost = data[t, 64]
        avg_volume = max(data[t, 1], 1e-8)
        cost_to_volume = synthetic_short_cost / avg_volume
        eng.append(cost_to_volume)
        
        # 16. VWAP Distance
        # Distance of current price from Volume Weighted Average Price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_distance = (close_prices[-1] / max(vwap, 1e-8)) - 1
            eng.append(vwap_distance)
        else:
            eng.append(0.0)
        
        # 17. Short Volume Acceleration
        # Second derivative of short volume
        if len(short_volume) >= 10:
            recent_change = short_volume[-1] - short_volume[-5]
            older_change = short_volume[-6] - short_volume[-10]
            acceleration = recent_change - older_change
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # 18. Short Interest Utilization
        # Percentage of shares outstanding that are being shorted
        shares_out = max(shares_outstanding, 1e-8)
        utilization = data[t, 0] / shares_out
        eng.append(utilization)
        
        # 19. Recent Price Range Relative to Average
        # Measures if recent price action is more volatile than usual
        if len(high_prices) >= 10 and len(low_prices) >= 10:
            recent_range = np.mean(high_prices[-5:] - low_prices[-5:])
            older_range = max(np.mean(high_prices[-10:-5] - low_prices[-10:-5]), 1e-8)
            relative_range = recent_range / older_range
            eng.append(relative_range)
        else:
            eng.append(1.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 1948443.9307
RMSE: 2401781.2678
MAPE: 10.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0007, rank=1
   2. Feature_19_t0: importance=0.0006, rank=2
   3. Feature_1_t1: importance=0.0005, rank=3
   4. Feature_11_t1: importance=0.0005, rank=4
   5. Feature_5_t2: importance=0.0005, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.67%

📈 Current best MAPE: 9.87%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features
        raw_keep.append(data[t, 0])  # short interest (most important)
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Volume Ratio Trend (5-day)
        # Captures directional trend in short selling activity
        if len(short_volume_ratio) >= 5:
            eng.append(short_volume_ratio[-1] - short_volume_ratio[-5])
        else:
            eng.append(0.0)
        
        # 3. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(shares_outstanding, 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Exponential Short Volume Ratio
        # Gives more weight to recent short volume activity
        if len(short_volume_ratio) >= 10:
            weights = np.exp(np.linspace(0, 1, 10))
            weights = weights / np.sum(weights)  # Normalize weights
            exp_weighted_svr = np.sum(short_volume_ratio[-10:] * weights)
            eng.append(exp_weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 6. Price Volatility (Normalized)
        # Measures recent price volatility which can trigger short covering
        if len(close_prices) >= 10:
            price_std = np.std(close_prices[-10:])
            price_mean = max(np.mean(close_prices[-10:]), 1e-8)
            normalized_volatility = price_std / price_mean
            eng.append(normalized_volatility)
        else:
            eng.append(0.0)
        
        # 7. Short Volume to Price Momentum Ratio
        # Relates short selling activity to price momentum
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            recent_svr = np.mean(short_volume_ratio[-5:])
            sv_price_momentum = recent_svr / max(abs(price_momentum), 1e-8)
            eng.append(sv_price_momentum)
        else:
            eng.append(0.0)
        
        # 8. RSI (Relative Strength Index)
        # Technical indicator that can signal potential short covering
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = max(np.mean(loss), 1e-8)
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 9. Volume Trend with Short Interest Adjustment
        # Increasing volume adjusted by short interest can signal stronger covering potential
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = max(np.mean(total_volume[-10:-5]), 1e-8)
            volume_trend = (recent_vol_avg / older_vol_avg) - 1
            si_adjusted_vol_trend = volume_trend * (1 + short_interest_to_float)
            eng.append(si_adjusted_vol_trend)
        else:
            eng.append(0.0)
        
        # 10. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover all shorts
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        eng.append(si_to_dtc)
        
        # 11. Options Implied Volatility to Historical Volatility Ratio
        # Higher ratio may indicate increased likelihood of short covering
        implied_vol = data[t, 65]
        if len(close_prices) >= 10:
            # Calculate historical volatility (annualized)
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            hist_vol = max(np.std(returns) * np.sqrt(252), 1e-8)
            iv_to_hv = implied_vol / hist_vol
            eng.append(iv_to_hv)
        else:
            eng.append(1.0)
        
        # 12. Bollinger Band Position
        # Position of current price within Bollinger Bands can signal potential reversals
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            band_width = max(upper_band - lower_band, 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_width
            eng.append(bb_position)
        else:
            eng.append(0.5)  # Middle of the band
        
        # 13. Short Volume Concentration with Price Reversal Potential
        # Combines short volume concentration with price reversal signals
        if len(close_prices) >= 10 and len(short_volume) >= 10:
            # Short volume concentration
            recent_short_vol = np.mean(short_volume[-5:])
            older_short_vol = max(np.mean(short_volume[-10:-5]), 1e-8)
            short_vol_concentration = recent_short_vol / older_short_vol
            
            # Price reversal potential (negative = potential upward reversal)
            price_change = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            reversal_potential = -price_change * short_vol_concentration
            eng.append(reversal_potential)
        else:
            eng.append(0.0)
        
        # 14. Short Interest to Options Put/Call Ratio
        # Relationship between short interest and options sentiment
        put_call_ratio = max(data[t, 63], 1e-8)
        si_to_options = data[t, 0] / put_call_ratio
        eng.append(si_to_options)
        
        # 15. Synthetic Short Cost to Average Volume Ratio
        # Relates cost of shorting to liquidity
        synthetic_short_cost = data[t, 64]
        avg_volume = max(data[t, 1], 1e-8)
        cost_to_volume = synthetic_short_cost / avg_volume
        eng.append(cost_to_volume)
        
        # 16. VWAP Distance with Short Volume Weighting
        # Distance of current price from Volume Weighted Average Price, adjusted by short volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_distance = (close_prices[-1] / max(vwap, 1e-8)) - 1
            
            # Weight by recent short volume ratio
            recent_svr = np.mean(short_volume_ratio[-5:])
            weighted_vwap_distance = vwap_distance * (1 + recent_svr)
            eng.append(weighted_vwap_distance)
        else:
            eng.append(0.0)
        
        # 17. Money Flow Index (MFI)
        # Volume-weighted RSI that can indicate potential reversals
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            typical_price = (high_prices[-14:] + low_prices[-14:] + close_prices[-14:]) / 3
            money_flow = typical_price * total_volume[-14:]
            
            delta_tp = np.diff(typical_price)
            positive_flow = np.sum(money_flow[1:][delta_tp > 0])
            negative_flow = np.sum(money_flow[1:][delta_tp < 0])
            
            if negative_flow == 0:
                mfi = 100
            else:
                money_ratio = positive_flow / max(negative_flow, 1e-8)
                mfi = 100 - (100 / (1 + money_ratio))
            
            eng.append(mfi)
        else:
            eng.append(50.0)  # Neutral MFI value
        
        # 18. Short Interest Utilization with Volatility Adjustment
        # Percentage of shares outstanding that are being shorted, adjusted by volatility
        shares_out = max(shares_outstanding, 1e-8)
        utilization = data[t, 0] / shares_out
        
        if len(close_prices) >= 10:
            price_std = np.std(close_prices[-10:])
            price_mean = max(np.mean(close_prices[-10:]), 1e-8)
            normalized_volatility = price_std / price_mean
            vol_adjusted_utilization = utilization * (1 + normalized_volatility)
            eng.append(vol_adjusted_utilization)
        else:
            eng.append(utilization)
        
        # 19. Short Squeeze Potential Index
        # Combines multiple factors that could indicate a potential short squeeze
        if t > 0 and len(close_prices) >= 10:
            # Short interest change
            prev_si = max(data[t-1, 0], 1e-8)
            si_change = (data[t, 0] / prev_si) - 1
            
            # Price momentum
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            
            # Volume surge
            recent_vol = np.mean(total_volume[-5:])
            older_vol = max(np.mean(total_volume[-10:-5]), 1e-8)
            volume_surge = (recent_vol / older_vol) - 1
            
            # Days to cover (lower is more squeeze potential)
            dtc_factor = 1 / max(data[t, 2], 1e-8)
            
            # Combine factors (positive value = higher squeeze potential)
            squeeze_potential = (si_change + price_momentum + volume_surge + dtc_factor) / 4
            eng.append(squeeze_potential)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 2026652.1164
RMSE: 2473519.0150
MAPE: 10.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 53
   • Highly important features (top 5%): 20

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t0: importance=0.0019, rank=1
   2. Feature_12_t2: importance=0.0015, rank=2
   3. Feature_5_t2: importance=0.0006, rank=3
   4. Feature_7_t0: importance=0.0006, rank=4
   5. Feature_9_t1: importance=0.0005, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -1.03%

📈 Current best MAPE: 9.87%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features - these showed high importance
        raw_keep.append(data[t, 0])  # short interest (most important)
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Bollinger Band Position - highest importance in previous iteration
        # Position of current price within Bollinger Bands can signal potential reversals
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            band_width = max(upper_band - lower_band, 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_width
            eng.append(bb_position)
        else:
            # Use available data if less than 20 points
            sma = np.mean(close_prices)
            std = np.std(close_prices)
            upper_band = sma + (2 * std)
            lower_band = sma - (2 * std)
            band_width = max(upper_band - lower_band, 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_width
            eng.append(bb_position)
        
        # 2. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 3. Short Interest to Float Ratio - key metric
        shares_out = max(shares_outstanding, 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 4. Short Interest Change Rate - improved with exponential weighting
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            
            # Add exponential weighting if we have more history
            if t > 1:
                prev2_si = max(data[t-2, 0], 1e-8)
                si_change_rate2 = (prev_si / prev2_si) - 1
                # Weighted average with more weight on recent change
                si_change_rate = 0.7 * si_change_rate + 0.3 * si_change_rate2
            
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 5. Price Momentum with Short Interest Adjustment
        # Combines price momentum with short interest to identify potential squeeze scenarios
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            # Adjust momentum by short interest - higher short interest amplifies momentum impact
            si_adjusted_momentum = price_momentum * (1 + short_interest_to_float)
            eng.append(si_adjusted_momentum)
        else:
            eng.append(0.0)
        
        # 6. Volume Trend with Short Volume Weighting
        # Improved version that weights volume trend by short volume ratio
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = max(np.mean(total_volume[-10:-5]), 1e-8)
            volume_trend = (recent_vol_avg / older_vol_avg) - 1
            
            # Weight by recent short volume ratio
            recent_svr = np.mean(short_volume_ratio[-5:])
            sv_weighted_vol_trend = volume_trend * (1 + recent_svr)
            eng.append(sv_weighted_vol_trend)
        else:
            eng.append(0.0)
        
        # 7. RSI (Relative Strength Index) with Volume Weighting
        # Enhanced RSI that incorporates volume information
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Volume weighting for gains and losses
            vol_weights = total_volume[-14:] / max(np.mean(total_volume[-14:]), 1e-8)
            vol_weighted_gain = np.sum(gain * vol_weights[1:]) / max(np.sum(vol_weights[1:]), 1e-8)
            vol_weighted_loss = np.sum(loss * vol_weights[1:]) / max(np.sum(vol_weights[1:]), 1e-8)
            
            rs = vol_weighted_gain / max(vol_weighted_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 8. Short Interest to Days to Cover Ratio - key metric for squeeze potential
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        eng.append(si_to_dtc)
        
        # 9. Options Implied Volatility to Historical Volatility Ratio
        # Higher ratio may indicate increased likelihood of short covering
        implied_vol = data[t, 65]
        if len(close_prices) >= 10:
            # Calculate historical volatility (annualized)
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            hist_vol = max(np.std(returns) * np.sqrt(252), 1e-8)
            iv_to_hv = implied_vol / hist_vol
            eng.append(iv_to_hv)
        else:
            eng.append(1.0)
        
        # 10. Short Squeeze Potential Index - Improved version
        # Combines multiple factors that could indicate a potential short squeeze
        if t > 0 and len(close_prices) >= 10:
            # Short interest change
            prev_si = max(data[t-1, 0], 1e-8)
            si_change = (data[t, 0] / prev_si) - 1
            
            # Price momentum
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            
            # Volume surge
            recent_vol = np.mean(total_volume[-5:])
            older_vol = max(np.mean(total_volume[-10:-5]), 1e-8)
            volume_surge = (recent_vol / older_vol) - 1
            
            # Days to cover (lower is more squeeze potential)
            dtc_factor = 1 / max(data[t, 2], 1e-8)
            
            # Options implied volatility factor
            iv_factor = data[t, 65] / 100  # Normalize
            
            # Combine factors with optimized weights
            squeeze_potential = (0.3 * si_change + 0.25 * price_momentum + 
                                0.2 * volume_surge + 0.15 * dtc_factor + 
                                0.1 * iv_factor)
            eng.append(squeeze_potential)
        else:
            eng.append(0.0)
        
        # 11. Price Trend Reversal Signal
        # Identifies potential trend reversals which could trigger short covering
        if len(close_prices) >= 10:
            # Short-term trend (3 days)
            short_trend = (close_prices[-1] / max(close_prices[-3], 1e-8)) - 1
            
            # Medium-term trend (10 days)
            medium_trend = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            
            # Reversal signal: short-term trend opposite to medium-term trend
            # Positive value = potential reversal from downtrend to uptrend
            reversal_signal = short_trend - medium_trend
            eng.append(reversal_signal)
        else:
            eng.append(0.0)
        
        # 12. VWAP Distance with Short Volume Weighting - improved version
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate VWAP
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_distance = (close_prices[-1] / max(vwap, 1e-8)) - 1
            
            # Weight by recent short volume ratio and short interest
            recent_svr = np.mean(short_volume_ratio[-5:])
            weighted_vwap_distance = vwap_distance * (1 + recent_svr) * (1 + short_interest_to_float)
            eng.append(weighted_vwap_distance)
        else:
            eng.append(0.0)
        
        # 13. Short Volume Acceleration
        # Measures the rate of change in short selling activity
        if len(short_volume) >= 10:
            recent_sv = np.mean(short_volume[-3:])
            mid_sv = np.mean(short_volume[-7:-3])
            older_sv = max(np.mean(short_volume[-10:-7]), 1e-8)
            
            # First and second derivatives of short volume
            first_deriv = (recent_sv / max(mid_sv, 1e-8)) - 1
            second_deriv = ((mid_sv / older_sv) - 1) - first_deriv
            
            # Acceleration is the second derivative
            sv_acceleration = second_deriv
            eng.append(sv_acceleration)
        else:
            eng.append(0.0)
        
        # 14. Volatility-Adjusted Short Interest
        # Short interest normalized by price volatility
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = max(np.std(returns), 1e-8)
            vol_adjusted_si = data[t, 0] * volatility
            eng.append(vol_adjusted_si)
        else:
            eng.append(data[t, 0])  # Fallback to raw SI
        
        # 15. Options Put/Call Ratio Trend
        # Trend in options sentiment can signal changing market expectations
        if t > 0:
            current_pc_ratio = data[t, 63]
            prev_pc_ratio = max(data[t-1, 63], 1e-8)
            pc_ratio_trend = (current_pc_ratio / prev_pc_ratio) - 1
            eng.append(pc_ratio_trend)
        else:
            eng.append(0.0)
        
        # 16. Short Interest Concentration Index
        # Measures how concentrated short interest is relative to trading volume
        avg_daily_vol = max(data[t, 1], 1e-8)
        short_interest = data[t, 0]
        si_concentration = short_interest / (avg_daily_vol * 15)  # 15 days of volume
        eng.append(si_concentration)
        
        # 17. Price Channel Breakout with Short Interest
        # Identifies price breakouts weighted by short interest
        if len(close_prices) >= 10:
            high_channel = np.max(close_prices[-10:-1])
            low_channel = np.min(close_prices[-10:-1])
            channel_width = max(high_channel - low_channel, 1e-8)
            
            # Normalized position within channel
            channel_position = (close_prices[-1] - low_channel) / channel_width
            
            # Breakout signal weighted by short interest
            breakout_signal = (channel_position - 0.5) * (1 + short_interest_to_float)
            eng.append(breakout_signal)
        else:
            eng.append(0.0)
        
        # 18. Synthetic Short Cost to Implied Volatility Ratio
        # Relates cost of shorting to market expectations of volatility
        synthetic_short_cost = data[t, 64]
        implied_vol = max(data[t, 65], 1e-8)
        cost_to_iv_ratio = synthetic_short_cost / implied_vol
        eng.append(cost_to_iv_ratio)
        
        # 19. Exponentially Weighted Short Volume Ratio
        # Gives more weight to recent short volume activity
        if len(short_volume_ratio) >= 10:
            weights = np.exp(np.linspace(0, 1, 10))
            weights = weights / np.sum(weights)  # Normalize weights
            exp_weighted_svr = np.sum(short_volume_ratio[-10:] * weights)
            eng.append(exp_weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (14,) (13,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features - these showed high importance
        raw_keep.append(data[t, 0])  # short interest (most important)
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # Consistently high importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over past 15 days
        eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Interest to Float Ratio
        # Key metric showing what percentage of available shares are being shorted
        shares_out = max(shares_outstanding, 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Short Interest Change Rate
        # Rate of change in short interest, a key predictor
        if t > 0:
            prev_si = max(data[t-1, 0], 1e-8)
            current_si = data[t, 0]
            si_change_rate = (current_si / prev_si) - 1
            eng.append(si_change_rate)
        else:
            eng.append(0.0)
        
        # 4. Exponentially Weighted Short Volume Ratio
        # Gives more weight to recent short volume activity
        if len(short_volume_ratio) >= 10:
            weights = np.exp(np.linspace(0, 1, 10))
            weights = weights / np.sum(weights)  # Normalize weights
            exp_weighted_svr = np.sum(short_volume_ratio[-10:] * weights)
            eng.append(exp_weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 5. Price Volatility (Normalized)
        # Measures recent price volatility which can trigger short covering
        if len(close_prices) >= 10:
            price_std = np.std(close_prices[-10:])
            price_mean = max(np.mean(close_prices[-10:]), 1e-8)
            normalized_volatility = price_std / price_mean
            eng.append(normalized_volatility)
        else:
            eng.append(0.0)
        
        # 6. RSI (Relative Strength Index)
        # Technical indicator that can signal potential short covering
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = max(np.mean(loss), 1e-8)
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50.0)  # Neutral RSI value
        
        # 7. Volume Trend
        # Increasing volume can signal stronger covering potential
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-5:])
            older_vol_avg = max(np.mean(total_volume[-10:-5]), 1e-8)
            volume_trend = (recent_vol_avg / older_vol_avg) - 1
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 8. Short Interest to Days to Cover Ratio
        # Relates total short interest to the time needed to cover all shorts
        days_to_cover = max(data[t, 2], 1e-8)
        short_interest = data[t, 0]
        si_to_dtc = short_interest / days_to_cover
        eng.append(si_to_dtc)
        
        # 9. Options Implied Volatility to Historical Volatility Ratio
        # Higher ratio may indicate increased likelihood of short covering
        implied_vol = data[t, 65]
        if len(close_prices) >= 10:
            # Calculate historical volatility (annualized)
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            hist_vol = max(np.std(returns) * np.sqrt(252), 1e-8)
            iv_to_hv = implied_vol / hist_vol
            eng.append(iv_to_hv)
        else:
            eng.append(1.0)
        
        # 10. Bollinger Band Position
        # Position of current price within Bollinger Bands can signal potential reversals
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            band_width = max(upper_band - lower_band, 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_width
            eng.append(bb_position)
        else:
            eng.append(0.5)  # Middle of the band
        
        # 11. Short Volume Concentration
        # Measures recent concentration of short volume compared to older periods
        if len(short_volume) >= 10:
            recent_short_vol = np.mean(short_volume[-5:])
            older_short_vol = max(np.mean(short_volume[-10:-5]), 1e-8)
            short_vol_concentration = recent_short_vol / older_short_vol
            eng.append(short_vol_concentration)
        else:
            eng.append(1.0)
        
        # 12. Short Interest to Options Put/Call Ratio
        # Relationship between short interest and options sentiment
        put_call_ratio = max(data[t, 63], 1e-8)
        si_to_options = data[t, 0] / put_call_ratio
        eng.append(si_to_options)
        
        # 13. VWAP Distance
        # Distance of current price from Volume Weighted Average Price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_distance = (close_prices[-1] / max(vwap, 1e-8)) - 1
            eng.append(vwap_distance)
        else:
            eng.append(0.0)
        
        # 14. Money Flow Index (MFI)
        # Volume-weighted RSI that can indicate potential reversals
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            typical_price = (high_prices[-14:] + low_prices[-14:] + close_prices[-14:]) / 3
            money_flow = typical_price * total_volume[-14:]
            
            delta_tp = np.diff(typical_price)
            positive_flow = np.sum(money_flow[1:][delta_tp > 0])
            negative_flow = np.sum(money_flow[1:][delta_tp < 0])
            
            if negative_flow == 0:
                mfi = 100
            else:
                money_ratio = positive_flow / max(negative_flow, 1e-8)
                mfi = 100 - (100 / (1 + money_ratio))
            
            eng.append(mfi)
        else:
            eng.append(50.0)  # Neutral MFI value
        
        # 15. Short Interest Utilization
        # Percentage of shares outstanding that are being shorted
        shares_out = max(shares_outstanding, 1e-8)
        utilization = data[t, 0] / shares_out
        eng.append(utilization)
        
        # 16. Price Momentum
        # Recent price momentum can trigger short covering
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            eng.append(price_momentum)
        else:
            eng.append(0.0)
        
        # 17. Average True Range (ATR) - Volatility Indicator
        # Measures market volatility
        if len(high_prices) >= 14 and len(low_prices) >= 14 and len(close_prices) >= 14:
            tr_values = []
            for i in range(1, 14):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close = abs(low_prices[-i] - close_prices[-(i+1)])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr = np.mean(tr_values)
            # Normalize by price level
            norm_atr = atr / max(close_prices[-1], 1e-8)
            eng.append(norm_atr)
        else:
            eng.append(0.0)
        
        # 18. Short Volume Trend
        # Trend in short volume can indicate changing sentiment
        if len(short_volume) >= 10:
            recent_short = np.mean(short_volume[-5:])
            older_short = max(np.mean(short_volume[-10:-5]), 1e-8)
            short_trend = (recent_short / older_short) - 1
            eng.append(short_trend)
        else:
            eng.append(0.0)
        
        # 19. Synthetic Short Cost to Implied Volatility Ratio
        # Relates cost of shorting to market expectations of volatility
        synthetic_cost = data[t, 64]
        implied_vol = max(data[t, 65], 1e-8)
        cost_to_iv = synthetic_cost / implied_vol
        eng.append(cost_to_iv)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 1936263.6332
RMSE: 2354709.8135
MAPE: 10.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t2: importance=0.0007, rank=1
   2. Feature_22_t1: importance=0.0007, rank=2
   3. Feature_10_t1: importance=0.0007, rank=3
   4. Feature_14_t0: importance=0.0006, rank=4
   5. Feature_8_t2: importance=0.0005, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
📊 No significant improvement. Change: -0.57%

📈 Current best MAPE: 9.87%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 8
======================================================================
🤖 Calling Claude for iteration 8...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    """
    Constructs features for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Keep critical baseline features - these showed high importance
        raw_keep.append(data[t, 0])  # short interest (most important)
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep key options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep the most recent OHLC values (showed high importance in previous iterations)
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume) - Weighted Recent
        # Giving more weight to recent short volume ratios
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Exponentially weighted short volume ratio (more weight to recent days)
        if len(short_volume_ratio) >= 10:
            weights = np.exp(np.linspace(0, 2, 10))  # Increased exponential weighting
            weights = weights / np.sum(weights)
            exp_weighted_svr = np.sum(short_volume_ratio[-10:] * weights)
            eng.append(exp_weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Interest to Float Ratio - Key metric showing percentage of available shares shorted
        shares_out = max(shares_outstanding, 1e-8)
        short_interest_to_float = data[t, 0] / shares_out
        eng.append(short_interest_to_float)
        
        # 3. Short Interest Momentum - Improved calculation
        # Measures acceleration of short interest changes
        if t >= 2:
            si_t = data[t, 0]
            si_t1 = max(data[t-1, 0], 1e-8)
            si_t2 = max(data[t-2, 0], 1e-8)
            
            # First derivative (rate of change)
            si_velocity = (si_t / si_t1) - 1
            
            # Second derivative (acceleration)
            prev_velocity = (si_t1 / si_t2) - 1
            si_acceleration = si_velocity - prev_velocity
            
            eng.append(si_velocity)
            eng.append(si_acceleration)
        else:
            eng.append(0.0)  # Placeholder for velocity
            eng.append(0.0)  # Placeholder for acceleration
        
        # 4. Price Trend and Volatility Features
        if len(close_prices) >= 10:
            # Price momentum over different timeframes
            price_momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            price_momentum_10d = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            
            # Normalized volatility (coefficient of variation)
            recent_std = np.std(close_prices[-10:])
            recent_mean = max(np.mean(close_prices[-10:]), 1e-8)
            norm_volatility = recent_std / recent_mean
            
            eng.append(price_momentum_5d)
            eng.append(price_momentum_10d)
            eng.append(norm_volatility)
        else:
            eng.append(0.0)  # Placeholder for 5d momentum
            eng.append(0.0)  # Placeholder for 10d momentum
            eng.append(0.0)  # Placeholder for normalized volatility
        
        # 5. RSI with Divergence Detection
        # RSI with additional divergence signal between price and RSI
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = max(np.mean(loss), 1e-8)
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            
            # Check for RSI divergence with price
            if len(close_prices) >= 20:
                # Price making higher highs but RSI making lower highs (bearish)
                price_trend = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
                
                # Calculate previous RSI for comparison
                prev_delta = np.diff(close_prices[-25:-10])
                prev_gain = np.where(prev_delta > 0, prev_delta, 0)
                prev_loss = np.where(prev_delta < 0, -prev_delta, 0)
                prev_avg_gain = np.mean(prev_gain)
                prev_avg_loss = max(np.mean(prev_loss), 1e-8)
                prev_rs = prev_avg_gain / prev_avg_loss
                prev_rsi = 100 - (100 / (1 + prev_rs))
                
                # RSI divergence signal
                rsi_trend = (rsi / max(prev_rsi, 1e-8)) - 1
                
                # Divergence occurs when price trend and RSI trend have opposite signs
                divergence = price_trend * rsi_trend
                
                eng.append(rsi)
                eng.append(divergence)
            else:
                eng.append(rsi)
                eng.append(0.0)  # Placeholder for divergence
        else:
            eng.append(50.0)  # Neutral RSI value
            eng.append(0.0)   # Placeholder for divergence
        
        # 6. Short Volume to Options Activity Ratio
        # Relates short selling activity to options market sentiment
        put_call_ratio = max(data[t, 63], 1e-8)
        recent_short_vol_ratio = np.mean(short_volume_ratio[-5:]) if len(short_volume_ratio) >= 5 else np.mean(short_volume_ratio)
        short_options_ratio = recent_short_vol_ratio / put_call_ratio
        eng.append(short_options_ratio)
        
        # 7. Synthetic Short Cost Efficiency
        # Measures the cost efficiency of shorting relative to days to cover
        synthetic_cost = data[t, 64]
        days_to_cover = max(data[t, 2], 1e-8)
        cost_efficiency = synthetic_cost * days_to_cover
        eng.append(cost_efficiency)
        
        # 8. Bollinger Band Squeeze with Volume
        # Detects potential breakouts from periods of low volatility
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            
            # Bollinger Band width normalized by price
            bb_width = (2 * std20) / max(sma20, 1e-8)
            
            # Position within the bands
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            band_range = max(upper_band - lower_band, 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_range
            
            # Volume surge detection
            recent_vol = np.mean(total_volume[-5:])
            older_vol = max(np.mean(total_volume[-20:-5]), 1e-8)
            vol_surge = recent_vol / older_vol
            
            # Combine into a "squeeze with volume" indicator
            squeeze_vol = bb_width * vol_surge
            
            eng.append(bb_position)
            eng.append(squeeze_vol)
        else:
            eng.append(0.5)  # Middle of the band
            eng.append(1.0)  # Neutral squeeze value
        
        # 9. Short Interest to Implied Volatility Ratio
        # Relates short interest to market expectations of volatility
        implied_vol = max(data[t, 65], 1e-8)
        si_to_iv = data[t, 0] / implied_vol
        eng.append(si_to_iv)
        
        # 10. Volume-Weighted Short Interest Trend
        # Weights short interest changes by volume to detect significant movements
        if t > 0:
            si_change = (data[t, 0] / max(data[t-1, 0], 1e-8)) - 1
            recent_vol = np.mean(total_volume[-5:])
            avg_vol = max(data[t, 1], 1e-8)
            vol_ratio = recent_vol / avg_vol
            vol_weighted_si_trend = si_change * vol_ratio
            eng.append(vol_weighted_si_trend)
        else:
            eng.append(0.0)
        
        # 11. Short Squeeze Potential Score
        # Combines multiple factors that contribute to short squeeze potential
        if len(close_prices) >= 10 and t > 0:
            # Days to cover (higher is more squeeze potential)
            dtc_factor = min(data[t, 2] / 10.0, 1.0)  # Normalize to 0-1 range
            
            # Short interest to float ratio (higher is more squeeze potential)
            si_float_factor = min(short_interest_to_float * 5, 1.0)  # Normalize to 0-1 range
            
            # Recent price momentum (higher is more squeeze potential)
            price_momentum = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            momentum_factor = min(max(price_momentum * 5, 0), 1.0)  # Normalize to 0-1 range
            
            # Volume surge (higher is more squeeze potential)
            recent_vol = np.mean(total_volume[-3:])
            older_vol = max(np.mean(total_volume[-10:-3]), 1e-8)
            vol_surge = min((recent_vol / older_vol - 0.8) * 2, 1.0)  # Normalize to 0-1 range
            vol_surge = max(vol_surge, 0)
            
            # Combine factors with appropriate weights
            squeeze_potential = (dtc_factor * 0.3 + 
                                si_float_factor * 0.3 + 
                                momentum_factor * 0.2 + 
                                vol_surge * 0.2)
            
            eng.append(squeeze_potential)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent width
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 8 (claude) (SVM)
==================================================
Training SVM model...

Iteration 8 (claude) Performance:
MAE: 1923916.8982
RMSE: 2288194.7571
MAPE: 10.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 68
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0011, rank=1
   2. Feature_13_t1: importance=0.0008, rank=2
   3. Feature_12_t1: importance=0.0008, rank=3
   4. Feature_5_t1: importance=0.0007, rank=4
   5. Feature_21_t2: importance=0.0006, rank=5
💾 Saved code for iteration 8 to iteration_codes dictionary
📊 No significant improvement. Change: -0.57%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 2353785.5622
RMSE: 2830303.8659
MAPE: 11.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 170
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t0: importance=0.0006, rank=1
   2. Feature_76_t1: importance=0.0005, rank=2
   3. Feature_65_t2: importance=0.0004, rank=3
   4. Feature_71_t0: importance=0.0004, rank=4
   5. Feature_65_t3: importance=0.0002, rank=5
   Baseline MAPE: 11.80%
   Baseline MAE: 2353785.5622
   Baseline RMSE: 2830303.8659

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 2369725.0855
RMSE: 2882923.8572
MAPE: 11.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t0: importance=0.0007, rank=1
   2. Feature_23_t3: importance=0.0005, rank=2
   3. Feature_23_t0: importance=0.0004, rank=3
   4. Feature_5_t2: importance=0.0004, rank=4
   5. Feature_11_t0: importance=0.0004, rank=5

📊 Best Model Test Set Performance:
   MAPE: 11.80%
   MAE: 2369725.0855
   RMSE: 2882923.8572

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 11.80%
   Best Model MAPE: 11.80%
   Absolute Improvement: -0.01%
   Relative Improvement: -0.1%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  10.95           N/A                 
1          Iteration 1               10.10           +0.85%              
2          Iteration 2               10.77           -0.67%              
3          Iteration 3               9.87            +0.23%              
4          Iteration 4               10.79           -0.92%              
5          Iteration 5               10.53           -0.67%              
6          Iteration 6               10.90           -1.03%              
7          Iteration 7               10.43           -0.57%              
8          Iteration 8               10.44           -0.57%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 3 - MAPE: 9.87%
✅ Saved HL results to cache/HL_iterative_results_enhanced.pkl
✅ Summary report saved for HL

🎉 Process completed successfully for HL!

================================================================================
PROCESSING TICKER 13/14: ANDE
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for ANDE
======================================================================
📊 Loading data from parquet file...
📊 Loading data for ANDE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ANDE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 112138.4092
RMSE: 143882.3549
MAPE: 15.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 258
   • Highly important features (top 5%): 130

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0005, rank=1
   2. Feature_70_t3: importance=0.0003, rank=2
   3. Feature_2_t3: importance=0.0003, rank=3
   4. Feature_88_t3: importance=0.0003, rank=4
   5. Feature_88_t0: importance=0.0003, rank=5

📊 Baseline Performance: MAPE = 15.28%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume as they are core metrics
        raw_keep.append(data[t, 0])  # short interest
        raw_keep.append(data[t, 1])  # average daily volume
        raw_keep.append(data[t, 2])  # days to cover
        
        # Keep options data which showed high importance
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 64])  # options_synthetic_short_cost
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep only the most recent OHLC values instead of all 60 values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        # This measures what percentage of total shares are sold short
        shares_out = max(data[t, 66], 1e-8)
        short_interest_ratio = data[t, 0] / shares_out
        eng.append(short_interest_ratio)
        
        # 2. Short Volume Ratio (average of daily short volume / total volume)
        # Higher values indicate more shorting activity relative to overall trading
        daily_short_ratio = np.zeros(15)
        for i in range(15):
            denom = max(total_volume[i], 1e-8)
            daily_short_ratio[i] = short_volume[i] / denom
        avg_short_volume_ratio = np.mean(daily_short_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 3. Recent Short Volume Trend (last 5 days vs previous 10)
        recent_short_ratio = np.mean(daily_short_ratio[-5:])
        older_short_ratio = np.mean(daily_short_ratio[:-5])
        denom = max(abs(older_short_ratio), 1e-8)
        short_trend = recent_short_ratio / denom - 1
        eng.append(short_trend)
        
        # 4. Price Momentum (5-day)
        # Captures recent price trends that might correlate with short interest changes
        if len(close_prices) >= 5:
            price_momentum_5d = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
        else:
            price_momentum_5d = 0
        eng.append(price_momentum_5d)
        
        # 5. Price Volatility (standard deviation of returns)
        # Higher volatility often attracts more short interest
        if len(close_prices) >= 2:
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            price_volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            price_volatility = 0
        eng.append(price_volatility)
        
        # 6. Volume Trend (recent vs older volume)
        # Increasing volume might signal changing sentiment
        recent_volume = np.mean(total_volume[-5:])
        older_volume = np.mean(total_volume[:-5])
        denom = max(abs(older_volume), 1e-8)
        volume_trend = recent_volume / denom - 1
        eng.append(volume_trend)
        
        # 7. Price Range Relative to Volume
        # Measures price movement efficiency per unit of volume
        if len(high_prices) > 0 and len(low_prices) > 0:
            price_range = np.mean(high_prices - low_prices)
            avg_volume = np.mean(total_volume)
            denom = max(avg_volume, 1e-8)
            price_range_per_volume = price_range / denom
        else:
            price_range_per_volume = 0
        eng.append(price_range_per_volume)
        
        # 8. Options Implied Volatility to Historical Volatility Ratio
        # Compares market expectations to realized volatility
        implied_vol = data[t, 65]
        hist_vol = price_volatility
        denom = max(hist_vol, 1e-8)
        iv_hv_ratio = implied_vol / denom
        eng.append(iv_hv_ratio)
        
        # 9. Short Interest to Volume Ratio
        # Measures how many days of current volume would be needed to cover all shorts
        si_volume_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_volume_ratio)
        
        # 10. Put-Call Ratio Change
        # Measures changing sentiment in options market
        put_call_ratio = data[t, 63]
        eng.append(put_call_ratio)
        
        # 11. RSI (Relative Strength Index)
        # Momentum oscillator that measures speed and change of price movements
        if len(close_prices) >= 14:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            denom = max(avg_loss, 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 12. Short Cost Pressure
        # Combines synthetic short cost with put-call ratio
        short_cost_pressure = data[t, 64] * data[t, 63]
        eng.append(short_cost_pressure)
        
        # 13. Normalized Short Interest
        # Short interest normalized by historical range
        norm_si = data[t, 0] / max(data[t, 1], 1e-8) / max(data[t, 2], 1e-8)
        eng.append(norm_si)
        
        # 14. Short Volume Acceleration
        # Measures the rate of change in short volume
        if len(short_volume) >= 3:
            short_vol_diff = np.diff(short_volume[-3:])
            short_vol_accel = np.mean(short_vol_diff)
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 15. Price to Volume Correlation
        # Measures relationship between price and volume movements
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            price_returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-6:-1], 1e-8)
            volume_changes = np.diff(total_volume[-5:]) / np.maximum(total_volume[-6:-1], 1e-8)
            if len(price_returns) > 0 and len(volume_changes) > 0:
                # Simplified correlation calculation to avoid numerical instability
                price_returns_norm = price_returns - np.mean(price_returns)
                volume_changes_norm = volume_changes - np.mean(volume_changes)
                price_vol_corr = np.sum(price_returns_norm * volume_changes_norm)
                denom = max(np.sqrt(np.sum(price_returns_norm**2) * np.sum(volume_changes_norm**2)), 1e-8)
                price_vol_corr /= denom
            else:
                price_vol_corr = 0
        else:
            price_vol_corr = 0
        eng.append(price_vol_corr)
        
        # 16. Short Interest Momentum
        # Rate of change in short interest
        si_momentum = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_momentum)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaNs and infinities
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    all_features = []
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)  # Short interest
        raw_keep.append(avg_volume)      # Average daily volume
        raw_keep.append(days_to_cover)   # Days to cover
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Options data
        put_call_ratio = data[t, 63]
        synthetic_short_cost = data[t, 64]
        implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep important options data
        raw_keep.append(implied_volatility)  # Implied volatility (high importance)
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep recent short volume (high importance from feature importance analysis)
        raw_keep.append(short_volume[-1])  # Most recent short volume
        raw_keep.append(total_volume[-1])  # Most recent total volume
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Interest Ratio (SI / Shares Outstanding)
        if shares_outstanding > 1e-8:
            si_ratio = short_interest / shares_outstanding
        else:
            si_ratio = 0.0
        eng.append(si_ratio)
        
        # 2. Short Volume Ratio (recent 5 days)
        recent_short_ratio = 0.0
        if np.sum(total_volume[-5:]) > 1e-8:
            recent_short_ratio = np.sum(short_volume[-5:]) / np.sum(total_volume[-5:])
        eng.append(recent_short_ratio)
        
        # 3. Price momentum (5-day)
        if len(close_prices) >= 5 and close_prices[-5] > 1e-8:
            price_momentum_5d = (close_prices[-1] / close_prices[-5]) - 1.0
        else:
            price_momentum_5d = 0.0
        eng.append(price_momentum_5d)
        
        # 4. Price momentum (10-day)
        if len(close_prices) >= 10 and close_prices[-10] > 1e-8:
            price_momentum_10d = (close_prices[-1] / close_prices[-10]) - 1.0
        else:
            price_momentum_10d = 0.0
        eng.append(price_momentum_10d)
        
        # 5. Volatility (standard deviation of returns over 10 days)
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / close_prices[-11:-1]
            volatility = np.std(returns) if len(returns) > 0 else 0.0
        else:
            volatility = 0.0
        eng.append(volatility)
        
        # 6. Average True Range (ATR) - volatility indicator
        atr = 0.0
        if len(close_prices) >= 2:
            true_ranges = []
            for i in range(1, min(10, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close_prev = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close_prev = abs(low_prices[-i] - close_prices[-(i+1)])
                true_range = max(high_low, high_close_prev, low_close_prev)
                true_ranges.append(true_range)
            atr = np.mean(true_ranges) if true_ranges else 0.0
        eng.append(atr)
        
        # 7. RSI (Relative Strength Index) - 14 period
        rsi = 50.0  # Default to neutral
        if len(close_prices) >= 15:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:]) if len(gain) >= 14 else np.mean(gain)
            avg_loss = np.mean(loss[-14:]) if len(loss) >= 14 else np.mean(loss)
            
            if avg_loss > 1e-8:
                rs = avg_gain / avg_loss
                rsi = 100.0 - (100.0 / (1.0 + rs))
            elif avg_gain > 0:
                rsi = 100.0
        eng.append(rsi)
        
        # 8. Short Volume Trend (ratio of recent 3-day to previous 3-day)
        if len(short_volume) >= 6:
            recent_3d = np.sum(short_volume[-3:])
            previous_3d = np.sum(short_volume[-6:-3])
            if previous_3d > 1e-8:
                short_vol_trend = recent_3d / previous_3d
            else:
                short_vol_trend = 1.0
        else:
            short_vol_trend = 1.0
        eng.append(short_vol_trend)
        
        # 9. Short Interest to Volume Ratio
        if avg_volume > 1e-8:
            si_volume_ratio = short_interest / avg_volume
        else:
            si_volume_ratio = 0.0
        eng.append(si_volume_ratio)
        
        # 10. Price Range Ratio (High-Low)/Close
        price_range_ratio = 0.0
        if len(close_prices) > 0 and close_prices[-1] > 1e-8:
            price_range_ratio = (high_prices[-1] - low_prices[-1]) / close_prices[-1]
        eng.append(price_range_ratio)
        
        # 11. Short Volume Acceleration (change in short volume rate)
        short_vol_accel = 0.0
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_ratio = np.sum(short_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            previous_ratio = np.sum(short_volume[-10:-5]) / max(np.sum(total_volume[-10:-5]), 1e-8)
            short_vol_accel = recent_ratio - previous_ratio
        eng.append(short_vol_accel)
        
        # 12. Options Pressure Indicator (combines put/call ratio and implied volatility)
        options_pressure = put_call_ratio * implied_volatility
        eng.append(options_pressure)
        
        # 13. Short Cost Pressure (synthetic short cost * days to cover)
        short_cost_pressure = synthetic_short_cost * days_to_cover
        eng.append(short_cost_pressure)
        
        # 14. MACD-like indicator (difference between 5-day and 10-day price averages)
        if len(close_prices) >= 10:
            ema5 = np.mean(close_prices[-5:])
            ema10 = np.mean(close_prices[-10:])
            if ema10 > 1e-8:
                macd = (ema5 / ema10) - 1.0
            else:
                macd = 0.0
        else:
            macd = 0.0
        eng.append(macd)
        
        # 15. Short Interest Change Rate
        si_change_rate = 0.0
        if t > 0 and data[t-1, 0] > 1e-8:
            si_change_rate = (short_interest / data[t-1, 0]) - 1.0
        eng.append(si_change_rate)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
            
        all_features.append(row)
    
    # Stack all rows and handle NaN values
    features_array = np.stack(all_features)
    features_array = np.nan_to_num(features_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features_array
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 2/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features_array = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Keep these critical raw features
        raw_keep.append(short_interest)  # Short interest
        raw_keep.append(avg_volume)      # Average daily volume
        raw_keep.append(days_to_cover)   # Days to cover
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values instead of all 60 values
        raw_keep.append(close_prices[-1])  # Most recent close price
        
        # Keep important options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        raw_keep.append(options_put_call_ratio)
        raw_keep.append(options_avg_implied_volatility)
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep the most recent short volume and total volume
        raw_keep.append(short_volume[-1])
        raw_keep.append(total_volume[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Feature 1: Short interest to shares outstanding ratio
        if abs(shares_outstanding) > 1e-8:
            si_to_shares = short_interest / shares_outstanding
        else:
            si_to_shares = 0.0
        eng.append(si_to_shares)
        
        # Feature 2: Short volume to total volume ratio (average over 15 days)
        short_ratio = np.zeros(len(short_volume))
        for i in range(len(short_volume)):
            if abs(total_volume[i]) > 1e-8:
                short_ratio[i] = short_volume[i] / total_volume[i]
        avg_short_ratio = np.mean(short_ratio)
        eng.append(avg_short_ratio)
        
        # Feature 3: Price momentum (5-day)
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1.0
        else:
            momentum_5d = 0.0
        eng.append(momentum_5d)
        
        # Feature 4: Price momentum (10-day)
        if len(close_prices) >= 10:
            momentum_10d = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1.0
        else:
            momentum_10d = 0.0
        eng.append(momentum_10d)
        
        # Feature 5: Volatility (standard deviation of returns over 10 days)
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-10:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0.0
        else:
            volatility = 0.0
        eng.append(volatility)
        
        # Feature 6: Average True Range (ATR) - volatility indicator
        atr_sum = 0.0
        if len(close_prices) > 1:
            for i in range(1, min(10, len(close_prices))):
                high_low = high_prices[-i] - low_prices[-i]
                high_close_prev = abs(high_prices[-i] - close_prices[-(i+1)])
                low_close_prev = abs(low_prices[-i] - close_prices[-(i+1)])
                true_range = max(high_low, high_close_prev, low_close_prev)
                atr_sum += true_range
            atr = atr_sum / min(9, len(close_prices)-1)
        else:
            atr = 0.0
        eng.append(atr)
        
        # Feature 7: Relative Strength Index (RSI)
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            
            if abs(loss) > 1e-8:
                rs = gain / loss
            else:
                rs = 100.0
                
            rsi = 100.0 - (100.0 / (1.0 + rs))
        else:
            rsi = 50.0  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # Feature 8: Short interest change rate
        si_change = 0.0
        if t > 0 and abs(data[t-1, 0]) > 1e-8:
            si_change = (short_interest / data[t-1, 0]) - 1.0
        eng.append(si_change)
        
        # Feature 9: Short volume trend (slope of short volume over 15 days)
        if len(short_volume) >= 5:
            x = np.arange(5)
            y = short_volume[-5:]
            slope = np.polyfit(x, y, 1)[0] if np.sum(np.abs(y)) > 1e-8 else 0.0
        else:
            slope = 0.0
        eng.append(slope)
        
        # Feature 10: Price to volume ratio
        if abs(avg_volume) > 1e-8:
            price_to_volume = close_prices[-1] / avg_volume
        else:
            price_to_volume = 0.0
        eng.append(price_to_volume)
        
        # Feature 11: Bollinger Band Width (volatility measure)
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)
        else:
            bb_width = 0.0
        eng.append(bb_width)
        
        # Feature 12: MACD Line (momentum indicator)
        if len(close_prices) >= 26:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA
            ema26 = np.mean(close_prices[-26:])
            macd = ema12 - ema26
        else:
            macd = 0.0
        eng.append(macd)
        
        # Feature 13: Short interest acceleration
        si_accel = 0.0
        if t >= 2:
            prev_si_change = 0.0
            if abs(data[t-2, 0]) > 1e-8:
                prev_si_change = (data[t-1, 0] / data[t-2, 0]) - 1.0
            si_accel = si_change - prev_si_change
        eng.append(si_accel)
        
        # Feature 14: Options implied volatility to historical volatility ratio
        if volatility > 1e-8:
            iv_to_hv_ratio = options_avg_implied_volatility / volatility
        else:
            iv_to_hv_ratio = 1.0
        eng.append(iv_to_hv_ratio)
        
        # Feature 15: Short interest to average volume ratio
        if abs(avg_volume) > 1e-8:
            si_to_volume = short_interest / avg_volume
        else:
            si_to_volume = 0.0
        eng.append(si_to_volume)
        
        # Feature 16: Price gap analysis (average of overnight gaps)
        gap_sum = 0.0
        gap_count = 0
        if len(open_prices) > 1 and len(close_prices) > 1:
            for i in range(1, min(10, len(open_prices))):
                if abs(close_prices[-(i+1)]) > 1e-8:
                    gap = (open_prices[-i] / close_prices[-(i+1)]) - 1.0
                    gap_sum += abs(gap)
                    gap_count += 1
            avg_gap = gap_sum / max(gap_count, 1)
        else:
            avg_gap = 0.0
        eng.append(avg_gap)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure the row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
            
        features_array.append(row)
    
    # Convert to numpy array and handle NaN values
    result = np.array(features_array, dtype=np.float32)
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 3/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume as they are key predictors
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)
        raw_keep.append(avg_volume)
        raw_keep.append(days_to_cover)
        
        # Extract options data which showed high importance
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        raw_keep.append(options_avg_implied_volatility)  # High importance in baseline
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep last day's OHLC as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Recent trend in short volume ratio (last 5 days vs previous 10)
        recent_svr = np.mean(short_volume_ratio[-5:])
        previous_svr = np.mean(short_volume_ratio[:-5])
        denom = max(abs(previous_svr), 1e-8)
        svr_trend = recent_svr / denom - 1
        eng.append(svr_trend)
        
        # 3. Price momentum: 5-day return
        if len(close_prices) >= 5:
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = close_prices[-1] / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 4. Price volatility: normalized range
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            denom = max(abs(recent_low), 1e-8)
            normalized_range = (recent_high / denom) - 1
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 5. Volume trend: recent volume vs historical
        recent_volume = np.mean(total_volume[-5:])
        historical_volume = np.mean(total_volume[:-5]) if len(total_volume) > 5 else avg_volume
        denom = max(abs(historical_volume), 1e-8)
        volume_trend = recent_volume / denom - 1
        eng.append(volume_trend)
        
        # 6. Short interest to float ratio
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 7. Options sentiment indicator
        options_sentiment = options_put_call_ratio * options_avg_implied_volatility
        eng.append(options_sentiment)
        
        # 8. Short cost pressure
        short_cost_pressure = options_synthetic_short_cost * days_to_cover
        eng.append(short_cost_pressure)
        
        # 9. Price gap analysis
        if len(close_prices) >= 2:
            gaps = np.zeros(len(close_prices)-1)
            for i in range(1, len(close_prices)):
                denom = max(abs(close_prices[i-1]), 1e-8)
                gaps[i-1] = abs(open_prices[i] / denom - 1)
            avg_gap = np.mean(gaps)
        else:
            avg_gap = 0
        eng.append(avg_gap)
        
        # 10. RSI (14-day)
        if len(close_prices) >= 2:
            deltas = np.diff(close_prices)
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)
            
            avg_gain = np.mean(gains) if len(gains) > 0 else 0
            avg_loss = np.mean(losses) if len(losses) > 0 else 1e-8
            
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # 11. Short volume acceleration
        if len(short_volume) >= 5:
            recent_short_vol = np.mean(short_volume[-3:])
            prev_short_vol = np.mean(short_volume[-6:-3])
            denom = max(abs(prev_short_vol), 1e-8)
            short_vol_accel = recent_short_vol / denom - 1
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 12. Price-volume correlation
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate returns
            returns = np.zeros(len(close_prices)-1)
            for i in range(1, len(close_prices)):
                denom = max(abs(close_prices[i-1]), 1e-8)
                returns[i-1] = close_prices[i] / denom - 1
            
            # Calculate volume changes
            vol_changes = np.zeros(len(total_volume)-1)
            for i in range(1, len(total_volume)):
                denom = max(abs(total_volume[i-1]), 1e-8)
                vol_changes[i-1] = total_volume[i] / denom - 1
            
            # Calculate correlation
            if len(returns) >= 5 and len(vol_changes) >= 5:
                # Use a simple product of normalized values instead of correlation
                norm_returns = returns[-5:] / max(np.std(returns[-5:]), 1e-8)
                norm_vol_changes = vol_changes[-5:] / max(np.std(vol_changes[-5:]), 1e-8)
                price_vol_relation = np.mean(norm_returns * norm_vol_changes)
            else:
                price_vol_relation = 0
        else:
            price_vol_relation = 0
        eng.append(price_vol_relation)
        
        # 13. Short interest momentum
        # This is a key predictor for future short interest changes
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 14. Volatility-adjusted short interest
        vol_adjusted_si = short_interest * normalized_range
        eng.append(vol_adjusted_si)
        
        # 15. Short volume concentration
        if len(short_volume) >= 5:
            max_short_vol = np.max(short_volume[-5:])
            avg_short_vol = np.mean(short_volume[-5:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_concentration = max_short_vol / denom
        else:
            short_vol_concentration = 1
        eng.append(short_vol_concentration)
        
        # 16. Implied volatility to historical volatility ratio
        if len(close_prices) >= 10:
            returns = np.zeros(len(close_prices)-1)
            for i in range(1, len(close_prices)):
                denom = max(abs(close_prices[i-1]), 1e-8)
                returns[i-1] = close_prices[i] / denom - 1
            
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            denom = max(abs(hist_vol), 1e-8)
            iv_hv_ratio = options_avg_implied_volatility / denom
        else:
            iv_hv_ratio = 1
        eng.append(iv_hv_ratio)
        
        # 17. Short interest to days to cover ratio
        si_dtc_ratio = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_dtc_ratio)
        
        # 18. Recent price trend direction
        if len(close_prices) >= 10:
            recent_trend = np.mean(close_prices[-5:]) - np.mean(close_prices[-10:-5])
            denom = max(abs(np.mean(close_prices[-10:-5])), 1e-8)
            price_trend_direction = recent_trend / denom
        else:
            price_trend_direction = 0
        eng.append(price_trend_direction)
        
        # 19. Short volume to options volume indicator
        short_options_indicator = avg_short_volume_ratio * options_put_call_ratio
        eng.append(short_options_indicator)
        
        # 20. Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 110511.0606
RMSE: 132465.0818
MAPE: 15.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t1: importance=0.0009, rank=1
   2. Feature_3_t3: importance=0.0008, rank=2
   3. Feature_22_t2: importance=0.0007, rank=3
   4. Feature_6_t2: importance=0.0007, rank=4
   5. Feature_20_t3: importance=0.0007, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.19%

📈 Current best MAPE: 15.09%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Most important target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data (showed high importance in previous iterations)
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)  # High importance in baseline
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # This was a high-importance feature in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short volume ratio trend (last 5 days vs previous 10)
        # Improved from previous iteration by using weighted average
        if len(short_volume_ratio) >= 15:
            weights = np.linspace(0.5, 1.5, 5)  # Increasing weights for recency
            recent_svr = np.average(short_volume_ratio[-5:], weights=weights)
            previous_svr = np.mean(short_volume_ratio[:-5])
            denom = max(abs(previous_svr), 1e-8)
            svr_trend = recent_svr / denom - 1
        else:
            svr_trend = 0
        eng.append(svr_trend)
        
        # 3. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 4. Short interest momentum (normalized by volume)
        # This was a high-importance feature in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 5. Short interest to days to cover ratio
        # Improved by normalizing to reduce scale issues
        si_dtc_ratio = short_interest / max(abs(days_to_cover), 1e-8)
        eng.append(si_dtc_ratio)
        
        # 6. Price momentum: 5-day return (improved calculation)
        if len(close_prices) >= 5:
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = close_prices[-1] / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 7. Price volatility: normalized range (high importance in previous iterations)
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            denom = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / denom
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 8. Volume trend: recent volume vs historical (improved calculation)
        if len(total_volume) >= 10:
            weights = np.linspace(0.5, 1.5, 5)  # Increasing weights for recency
            recent_volume = np.average(total_volume[-5:], weights=weights)
            historical_volume = np.mean(total_volume[-10:-5])
            denom = max(abs(historical_volume), 1e-8)
            volume_trend = recent_volume / denom - 1
        else:
            volume_trend = 0
        eng.append(volume_trend)
        
        # 9. Options sentiment indicator (combining put/call ratio with implied volatility)
        # This was a high-importance feature in previous iterations
        options_sentiment = options_put_call_ratio * options_avg_implied_volatility
        eng.append(options_sentiment)
        
        # 10. Short cost pressure (improved calculation)
        # Combines synthetic short cost with days to cover
        short_cost_pressure = options_synthetic_short_cost * days_to_cover
        eng.append(short_cost_pressure)
        
        # 11. RSI (14-day) - improved calculation with proper smoothing
        if len(close_prices) >= 15:
            deltas = np.diff(close_prices)
            seed = deltas[:14]
            up = seed[seed >= 0].sum() / 14.0
            down = -seed[seed < 0].sum() / 14.0
            
            if down != 0:
                rs = up / max(down, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                rsi = 100.0
        else:
            rsi = 50.0  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # 12. Short volume acceleration (improved calculation)
        if len(short_volume) >= 9:
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            # Second derivative approximation
            first_diff = recent_short_vol - mid_short_vol
            second_diff = (recent_short_vol - mid_short_vol) - (mid_short_vol - early_short_vol)
            
            denom = max(abs(mid_short_vol), 1e-8)
            short_vol_accel = second_diff / denom
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 13. Price-volume divergence (improved from correlation)
        # Measures when price and volume move in opposite directions
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate price change
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            # Calculate volume change
            volume_change = np.mean(total_volume[-3:]) / max(abs(np.mean(total_volume[-5:-2])), 1e-8) - 1
            
            # Divergence is high when signs are opposite
            price_vol_divergence = price_change * volume_change * -1
        else:
            price_vol_divergence = 0
        eng.append(price_vol_divergence)
        
        # 14. Volatility-adjusted short interest (high importance in previous iterations)
        vol_adjusted_si = short_interest * normalized_range
        eng.append(vol_adjusted_si)
        
        # 15. Short volume concentration (improved calculation)
        if len(short_volume) >= 5:
            max_short_vol = np.max(short_volume[-5:])
            avg_short_vol = np.mean(short_volume[-5:])
            denom = max(abs(avg_short_vol), 1e-8)
            short_vol_concentration = max_short_vol / denom
        else:
            short_vol_concentration = 1
        eng.append(short_vol_concentration)
        
        # 16. Implied volatility to historical volatility ratio (improved calculation)
        if len(close_prices) >= 10:
            returns = np.zeros(len(close_prices)-1)
            for i in range(1, len(close_prices)):
                denom = max(abs(close_prices[i-1]), 1e-8)
                returns[i-1] = close_prices[i] / denom - 1
            
            hist_vol = np.std(returns) * np.sqrt(252)  # Annualized
            denom = max(abs(hist_vol), 1e-8)
            iv_hv_ratio = options_avg_implied_volatility / denom
        else:
            iv_hv_ratio = 1
        eng.append(iv_hv_ratio)
        
        # 17. Short volume to options volume indicator (high importance in previous iterations)
        short_options_indicator = avg_short_volume_ratio * options_put_call_ratio
        eng.append(short_options_indicator)
        
        # 18. NEW: VWAP deviation
        # Measures how current price deviates from volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_deviation = close_prices[-1] / max(abs(vwap), 1e-8) - 1
        else:
            vwap_deviation = 0
        eng.append(vwap_deviation)
        
        # 19. NEW: Short interest rate of change
        # Measures acceleration in short interest changes
        si_roc = short_interest / max(abs(days_to_cover * avg_volume), 1e-8)
        eng.append(si_roc)
        
        # 20. NEW: Bollinger Band width (volatility measure)
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(abs(sma), 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 107214.1927
RMSE: 129702.8502
MAPE: 14.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0008, rank=1
   2. Feature_17_t1: importance=0.0008, rank=2
   3. Feature_6_t3: importance=0.0007, rank=3
   4. Feature_6_t2: importance=0.0006, rank=4
   5. Feature_23_t3: importance=0.0006, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.67%

📈 Current best MAPE: 14.43%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data (showed high importance in previous iterations)
        raw_keep.append(options_avg_implied_volatility)
        raw_keep.append(options_put_call_ratio)  # Added based on previous importance
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest momentum (normalized by volume)
        # High importance in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 4. Price momentum: 5-day return with exponential weighting
        # Improved from previous iteration with exponential weighting
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))  # Exponential weights for recency
            weights = weights / np.sum(weights)  # Normalize weights
            weighted_close = np.sum(close_prices[-5:] * weights)
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = weighted_close / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price volatility: normalized range (high importance in previous iterations)
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            denom = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / denom
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 6. Options sentiment indicator (combining put/call ratio with implied volatility)
        # High importance in previous iterations, refined calculation
        options_sentiment = np.log1p(options_put_call_ratio) * options_avg_implied_volatility
        eng.append(options_sentiment)
        
        # 7. Short cost pressure (improved calculation)
        # Combines synthetic short cost with days to cover
        short_cost_pressure = options_synthetic_short_cost * np.log1p(days_to_cover)
        eng.append(short_cost_pressure)
        
        # 8. RSI (14-day) - improved calculation with proper smoothing
        if len(close_prices) >= 15:
            deltas = np.diff(close_prices)
            seed = deltas[:14]
            up = seed[seed >= 0].sum() / 14.0
            down = -seed[seed < 0].sum() / 14.0
            
            if down != 0:
                rs = up / max(down, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                rsi = 100.0
        else:
            rsi = 50.0  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # 9. Short volume acceleration (improved calculation)
        if len(short_volume) >= 9:
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            # Second derivative approximation
            first_diff = recent_short_vol - mid_short_vol
            second_diff = (recent_short_vol - mid_short_vol) - (mid_short_vol - early_short_vol)
            
            denom = max(abs(mid_short_vol), 1e-8)
            short_vol_accel = second_diff / denom
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 10. Volatility-adjusted short interest (high importance in previous iterations)
        vol_adjusted_si = short_interest * normalized_range
        eng.append(vol_adjusted_si)
        
        # 11. NEW: Relative Strength of Short Interest
        # Compares current short interest to its historical range
        si_strength = short_interest / max(abs(short_interest_momentum), 1e-8)
        eng.append(si_strength)
        
        # 12. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short sellers are timing their positions
        if len(close_prices) >= 5:
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            si_efficiency = short_interest_to_float * (-1 * price_change)  # Higher when shorts correctly predict price drops
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 13. NEW: Short Volume Trend Strength
        # Measures consistency of short volume trend
        if len(short_volume) >= 10:
            # Calculate linear regression slope of short volume
            x = np.arange(10)
            y = short_volume[-10:]
            mean_x = np.mean(x)
            mean_y = np.mean(y)
            
            # Calculate slope using covariance and variance
            numerator = np.sum((x - mean_x) * (y - mean_y))
            denominator = max(np.sum((x - mean_x) ** 2), 1e-8)
            slope = numerator / denominator
            
            # Normalize slope by mean short volume
            denom = max(abs(mean_y), 1e-8)
            normalized_slope = slope / denom
            
            # Calculate R-squared to measure trend strength
            y_pred = mean_y + slope * (x - mean_x)
            ss_total = np.sum((y - mean_y) ** 2)
            ss_residual = np.sum((y - y_pred) ** 2)
            
            if ss_total > 0:
                r_squared = 1 - (ss_residual / max(ss_total, 1e-8))
            else:
                r_squared = 0
                
            short_trend_strength = normalized_slope * r_squared
        else:
            short_trend_strength = 0
        eng.append(short_trend_strength)
        
        # 14. NEW: Liquidity-adjusted Short Interest
        # Adjusts short interest by market liquidity conditions
        liquidity_factor = avg_volume / max(abs(shares_outstanding), 1e-8)
        liquidity_adjusted_si = short_interest * liquidity_factor
        eng.append(liquidity_adjusted_si)
        
        # 15. NEW: Short Interest Divergence from Price Trend
        # Identifies when short interest moves against price trend (potential squeeze indicator)
        if len(close_prices) >= 10:
            # Calculate price trend
            price_trend = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
            
            # Calculate short interest trend proxy using short volume
            if len(short_volume) >= 10:
                short_trend = np.mean(short_volume[-5:]) / max(abs(np.mean(short_volume[-10:-5])), 1e-8) - 1
                
                # Divergence is high when signs are opposite or magnitudes differ significantly
                si_price_divergence = short_trend * (-1 * price_trend)
            else:
                si_price_divergence = 0
        else:
            si_price_divergence = 0
        eng.append(si_price_divergence)
        
        # 16. NEW: Implied Volatility Skew
        # Proxy for market sentiment about tail risk
        iv_skew = options_avg_implied_volatility * options_put_call_ratio / max(abs(normalized_range), 1e-8)
        eng.append(iv_skew)
        
        # 17. NEW: Short Interest Concentration Index
        # Measures how concentrated short interest is relative to float and volume
        si_concentration = short_interest_to_float / max(abs(liquidity_factor), 1e-8)
        eng.append(si_concentration)
        
        # 18. NEW: Short Squeeze Potential Score
        # Combines days to cover, short interest ratio, and price momentum
        squeeze_potential = days_to_cover * short_interest_to_float * (1 + momentum_5d)
        eng.append(squeeze_potential)
        
        # 19. NEW: Abnormal Short Volume Detection
        # Identifies unusual short volume relative to historical patterns
        if len(short_volume) >= 10:
            recent_short_vol = np.mean(short_volume[-3:])
            historical_short_vol = np.mean(short_volume[-10:-3])
            historical_std = np.std(short_volume[-10:-3])
            
            if historical_std > 0:
                z_score = (recent_short_vol - historical_short_vol) / max(abs(historical_std), 1e-8)
            else:
                z_score = 0
                
            abnormal_short_vol = np.tanh(z_score)  # Bounded between -1 and 1
        else:
            abnormal_short_vol = 0
        eng.append(abnormal_short_vol)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 110353.4294
RMSE: 132224.8188
MAPE: 15.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t1: importance=0.0008, rank=1
   2. Feature_9_t3: importance=0.0008, rank=2
   3. Feature_18_t3: importance=0.0007, rank=3
   4. Feature_3_t3: importance=0.0007, rank=4
   5. Feature_3_t0: importance=0.0006, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -0.71%

📈 Current best MAPE: 14.43%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data - high importance in previous iterations
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest momentum (normalized by volume)
        # High importance in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 4. IMPROVED: Price momentum with adaptive weighting
        # Weights recent price movements more heavily when volatility is high
        if len(close_prices) >= 10:
            # Calculate recent volatility
            returns = np.diff(close_prices[-10:]) / np.maximum(np.abs(close_prices[-11:-1]), 1e-8)
            volatility = np.std(returns)
            
            # Create adaptive weights that increase with volatility
            weights = np.exp(np.linspace(0, 1 + volatility, 5))
            weights = weights / np.sum(weights)  # Normalize weights
            
            weighted_close = np.sum(close_prices[-5:] * weights)
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = weighted_close / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. IMPROVED: Volatility-adjusted range with trend direction
        # Combines price range with trend direction for better context
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            avg_price = np.mean(close_prices[-5:])
            denom = max(abs(avg_price), 1e-8)
            
            # Calculate normalized range
            normalized_range = (recent_high - recent_low) / denom
            
            # Incorporate trend direction
            trend_direction = np.sign(close_prices[-1] - close_prices[-5])
            directional_range = normalized_range * trend_direction
        else:
            directional_range = 0
        eng.append(directional_range)
        
        # 6. NEW: Squeeze Intensity Index
        # Combines days to cover, short interest ratio, and price momentum in a non-linear way
        # Higher values indicate higher potential for a short squeeze
        squeeze_intensity = np.log1p(days_to_cover) * short_interest_to_float * (1 + np.abs(momentum_5d))
        eng.append(squeeze_intensity)
        
        # 7. IMPROVED: Short Cost Pressure with Volatility Adjustment
        # Incorporates implied volatility to better reflect market risk perception
        vol_adjusted_short_cost = options_synthetic_short_cost * options_avg_implied_volatility * np.log1p(days_to_cover)
        eng.append(vol_adjusted_short_cost)
        
        # 8. IMPROVED: RSI with volume weighting
        # Weights price movements by their volume for more accurate overbought/oversold signals
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            deltas = np.diff(close_prices[-15:])
            volume_weights = total_volume[-14:] / np.maximum(np.mean(total_volume[-14:]), 1e-8)
            
            up_moves = deltas.copy()
            up_moves[up_moves < 0] = 0
            down_moves = -deltas.copy()
            down_moves[down_moves < 0] = 0
            
            weighted_up = np.sum(up_moves * volume_weights) / np.sum(volume_weights)
            weighted_down = np.sum(down_moves * volume_weights) / np.sum(volume_weights)
            
            if weighted_down > 0:
                rs = weighted_up / max(weighted_down, 1e-8)
                vol_weighted_rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                vol_weighted_rsi = 100.0
        else:
            vol_weighted_rsi = 50.0
        eng.append(vol_weighted_rsi)
        
        # 9. NEW: Short Interest Velocity and Acceleration
        # Measures both first and second derivatives of short interest
        if len(short_volume) >= 10:
            # Calculate short volume moving averages for different periods
            short_vol_3d = np.mean(short_volume[-3:])
            short_vol_6d = np.mean(short_volume[-6:-3])
            short_vol_10d = np.mean(short_volume[-10:-6])
            
            # First derivative (velocity)
            denom_v = max(abs(short_vol_6d), 1e-8)
            short_velocity = (short_vol_3d - short_vol_6d) / denom_v
            
            # Second derivative (acceleration)
            first_diff_recent = short_vol_3d - short_vol_6d
            first_diff_earlier = short_vol_6d - short_vol_10d
            denom_a = max(abs(first_diff_earlier), 1e-8)
            short_acceleration = (first_diff_recent - first_diff_earlier) / denom_a
            
            # Combine into a single metric that emphasizes acceleration when significant
            short_dynamics = short_velocity * (1 + np.abs(short_acceleration))
        else:
            short_dynamics = 0
        eng.append(short_dynamics)
        
        # 10. NEW: Liquidity-adjusted Short Interest Pressure
        # Measures how difficult it would be to cover short positions given current liquidity
        liquidity_factor = avg_volume / max(abs(shares_outstanding), 1e-8)
        short_pressure = short_interest_to_float / max(abs(liquidity_factor), 1e-8)
        eng.append(short_pressure)
        
        # 11. NEW: Options Market Sentiment Index
        # Combines put/call ratio with implied volatility and synthetic short cost
        options_sentiment = np.log1p(options_put_call_ratio) * options_avg_implied_volatility * np.tanh(options_synthetic_short_cost)
        eng.append(options_sentiment)
        
        # 12. NEW: Short Interest Divergence from Price
        # Identifies when short interest moves against price trend (potential squeeze indicator)
        if len(close_prices) >= 10 and len(short_volume) >= 10:
            # Calculate price trend
            price_change = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
            
            # Calculate short volume trend
            short_vol_change = np.mean(short_volume[-3:]) / max(abs(np.mean(short_volume[-10:-3])), 1e-8) - 1
            
            # Divergence is high when signs are opposite (one positive, one negative)
            divergence = -1 * price_change * short_vol_change
            
            # Apply sigmoid-like transformation to bound the values
            si_price_divergence = np.tanh(divergence * 3)  # Scale factor to make tanh more sensitive
        else:
            si_price_divergence = 0
        eng.append(si_price_divergence)
        
        # 13. NEW: Abnormal Short Volume Detection
        # Uses z-score to identify unusual short volume patterns
        if len(short_volume) >= 10:
            recent_short_vol = np.mean(short_volume[-3:])
            historical_short_vol = np.mean(short_volume[:-3])
            historical_std = np.std(short_volume[:-3])
            
            if historical_std > 0:
                z_score = (recent_short_vol - historical_short_vol) / max(abs(historical_std), 1e-8)
                abnormal_short_vol = np.tanh(z_score)  # Bounded between -1 and 1
            else:
                abnormal_short_vol = 0
        else:
            abnormal_short_vol = 0
        eng.append(abnormal_short_vol)
        
        # 14. NEW: Price Gap Analysis
        # Identifies significant overnight gaps which can trigger short covering
        if len(open_prices) >= 5 and len(close_prices) >= 5:
            # Calculate overnight gaps (today's open vs yesterday's close)
            gaps = []
            for i in range(1, 5):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                gap = (open_prices[-i] - close_prices[-i-1]) / denom
                gaps.append(gap)
            
            # Weight recent gaps more heavily
            weights = np.array([0.4, 0.3, 0.2, 0.1])  # More weight to recent gaps
            weighted_gap_sum = np.sum(np.array(gaps) * weights)
            
            # Apply non-linear transformation to emphasize large gaps
            gap_impact = np.sign(weighted_gap_sum) * np.power(np.abs(weighted_gap_sum), 0.7)
        else:
            gap_impact = 0
        eng.append(gap_impact)
        
        # 15. NEW: Short Interest Efficiency
        # Measures how effectively short sellers are timing their positions
        if len(close_prices) >= 10:
            # Calculate 10-day return
            return_10d = close_prices[-1] / max(abs(close_prices[-10]), 1e-8) - 1
            
            # Short sellers are "efficient" if high short interest precedes price drops
            # Negative correlation between short interest and returns is the goal
            si_efficiency = short_interest_to_float * (-1 * return_10d)
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 16. NEW: Volatility-adjusted Short Volume
        # Normalizes short volume by market volatility to identify true shorting pressure
        if len(close_prices) >= 10 and len(short_volume) >= 5:
            # Calculate price volatility
            returns = np.diff(close_prices[-10:]) / np.maximum(np.abs(close_prices[-11:-1]), 1e-8)
            volatility = np.std(returns)
            
            # Normalize recent short volume by volatility
            recent_short_vol = np.mean(short_volume[-5:])
            denom = max(abs(volatility), 1e-8)
            vol_adjusted_short = recent_short_vol / denom
        else:
            vol_adjusted_short = 0
        eng.append(vol_adjusted_short)
        
        # 17. NEW: Short Interest Concentration
        # Measures how concentrated short interest is relative to normal trading patterns
        si_concentration = short_interest / max(abs(avg_volume * days_to_cover), 1e-8)
        eng.append(si_concentration)
        
        # 18. NEW: Mean Reversion Potential
        # Identifies potential for price mean reversion based on short interest and price extremes
        if len(close_prices) >= 15:
            # Calculate z-score of current price relative to recent history
            price_mean = np.mean(close_prices[:-1])
            price_std = np.std(close_prices[:-1])
            current_price = close_prices[-1]
            
            if price_std > 0:
                price_z_score = (current_price - price_mean) / max(abs(price_std), 1e-8)
            else:
                price_z_score = 0
            
            # Mean reversion potential is high when price is at extreme and short interest is high
            mean_reversion = -1 * price_z_score * short_interest_to_float
        else:
            mean_reversion = 0
        eng.append(mean_reversion)
        
        # 19. NEW: Short Squeeze Risk Score
        # Comprehensive metric combining multiple factors that contribute to squeeze risk
        squeeze_risk = (
            np.log1p(days_to_cover) *                 # Higher days to cover increases risk
            short_interest_to_float *                 # Higher short % of float increases risk
            (1 + np.abs(directional_range)) *         # Higher volatility increases risk
            (1 + options_avg_implied_volatility) /    # Higher implied volatility increases risk
            max(abs(liquidity_factor), 1e-8)          # Lower liquidity increases risk
        )
        eng.append(squeeze_risk)
        
        # 20. NEW: Technical Breakout Indicator
        # Identifies potential technical breakouts that could trigger short covering
        if len(close_prices) >= 15 and len(high_prices) >= 15:
            # Find recent resistance level (highest high in past 10-15 days)
            resistance = np.max(high_prices[-15:-5])
            
            # Calculate proximity to resistance
            proximity = close_prices[-1] / max(abs(resistance), 1e-8)
            
            # Breakout potential is higher when price is near resistance with high short interest
            breakout_potential = proximity * short_interest_to_float
        else:
            breakout_potential = 0
        eng.append(breakout_potential)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
❌ Error executing generated code: Function failed test execution: operands could not be broadcast together with shapes (9,) (10,) 
⚠️ Function execution failed (attempt 1/5)
🔄 Retrying function execution with error feedback...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data - high importance in previous iterations
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)
        raw_keep.append(options_put_call_ratio)
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest momentum (normalized by volume)
        # High importance in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 4. Price momentum: 5-day return with exponential weighting
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))  # Exponential weights for recency
            weights = weights / np.sum(weights)  # Normalize weights
            weighted_close = np.sum(close_prices[-5:] * weights)
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = weighted_close / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price volatility: normalized range
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            denom = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / denom
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 6. Options sentiment indicator (combining put/call ratio with implied volatility)
        # Refined calculation based on previous high importance
        options_sentiment = np.log1p(options_put_call_ratio) * options_avg_implied_volatility
        eng.append(options_sentiment)
        
        # 7. Short cost pressure
        # Combines synthetic short cost with days to cover
        short_cost_pressure = options_synthetic_short_cost * np.log1p(days_to_cover)
        eng.append(short_cost_pressure)
        
        # 8. RSI (14-day) - improved calculation with proper smoothing
        if len(close_prices) >= 15:
            deltas = np.diff(close_prices)
            seed = deltas[:14]
            up = seed[seed >= 0].sum() / 14.0
            down = -seed[seed < 0].sum() / 14.0
            
            if down != 0:
                rs = up / max(down, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                rsi = 100.0
        else:
            rsi = 50.0  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # 9. Short volume acceleration (improved calculation)
        if len(short_volume) >= 9:
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            # Second derivative approximation
            first_diff = recent_short_vol - mid_short_vol
            second_diff = (recent_short_vol - mid_short_vol) - (mid_short_vol - early_short_vol)
            
            denom = max(abs(mid_short_vol), 1e-8)
            short_vol_accel = second_diff / denom
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 10. Volatility-adjusted short interest
        vol_adjusted_si = short_interest * normalized_range
        eng.append(vol_adjusted_si)
        
        # 11. Short Interest Efficiency Ratio
        # Measures how effectively short sellers are timing their positions
        if len(close_prices) >= 5:
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            si_efficiency = short_interest_to_float * (-1 * price_change)
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 12. Short Squeeze Potential Score
        # Combines days to cover, short interest ratio, and price momentum
        squeeze_potential = days_to_cover * short_interest_to_float * (1 + momentum_5d)
        eng.append(squeeze_potential)
        
        # 13. NEW: MACD-based Short Interest Signal
        # Combines technical analysis with short interest
        if len(close_prices) >= 12:
            ema_12 = np.mean(close_prices[-12:])  # Simple approximation of EMA
            ema_26 = np.mean(close_prices)  # Use all available data as longer-term average
            macd = ema_12 - ema_26
            
            # Normalize MACD by price level
            denom = max(abs(ema_26), 1e-8)
            norm_macd = macd / denom
            
            # Combine with short interest for a signal
            macd_si_signal = norm_macd * short_interest_to_float
        else:
            macd_si_signal = 0
        eng.append(macd_si_signal)
        
        # 14. NEW: Short Interest Rate of Change
        # Measures acceleration in short interest buildup
        si_roc = 0
        if t > 0 and data[t-1, 0] > 0:  # Check if we have previous data
            si_roc = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
        eng.append(si_roc)
        
        # 15. NEW: Volume-Weighted Price Momentum
        # Gives more weight to price moves with higher volume
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate returns
            returns = np.zeros(4)
            for i in range(4):
                returns[i] = close_prices[-i-1] / max(abs(close_prices[-i-2]), 1e-8) - 1
            
            # Get corresponding volumes
            vols = total_volume[-5:-1]
            
            # Normalize volumes
            vol_sum = np.sum(vols)
            if vol_sum > 0:
                weights = vols / max(abs(vol_sum), 1e-8)
                vwpm = np.sum(returns * weights)
            else:
                vwpm = 0
        else:
            vwpm = 0
        eng.append(vwpm)
        
        # 16. NEW: Short Interest Concentration Index (Improved)
        # Measures how concentrated short interest is relative to float and volume
        # Using logarithmic scaling to better capture relationships
        si_concentration = np.log1p(short_interest_to_float) / np.log1p(max(avg_volume / max(abs(shares_outstanding), 1e-8), 1e-8))
        eng.append(si_concentration)
        
        # 17. NEW: Bollinger Band Position
        # Indicates where current price is relative to volatility bands
        if len(close_prices) >= 10:
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            
            if std_price > 0:
                # Calculate position within bands (-1 to 1 scale)
                bb_position = (close_prices[-1] - mean_price) / max(abs(std_price * 2), 1e-8)
                # Clamp to -1 to 1 range
                bb_position = max(min(bb_position, 1), -1)
            else:
                bb_position = 0
                
            # Combine with short interest for a signal
            bb_si_signal = bb_position * short_interest_to_float
        else:
            bb_si_signal = 0
        eng.append(bb_si_signal)
        
        # 18. NEW: Short Volume Trend Consistency
        # Measures how consistent the short volume trend has been
        if len(short_volume) >= 10:
            # Calculate trend direction for each day
            trend_dirs = np.sign(np.diff(short_volume[-10:]))
            # Count direction changes (sign flips)
            direction_changes = np.sum(np.abs(np.diff(trend_dirs))) / 2
            # Normalize to 0-1 range (0 = very consistent, 1 = very inconsistent)
            trend_consistency = 1 - (direction_changes / 8)  # Max possible changes is 8
        else:
            trend_consistency = 0.5  # Neutral when not enough data
        eng.append(trend_consistency)
        
        # 19. NEW: Relative Short Volume Intensity
        # Compares recent short volume to longer-term average
        if len(short_volume) >= 10:
            recent_short = np.mean(short_volume[-3:])
            longer_short = np.mean(short_volume[-10:])
            
            denom = max(abs(longer_short), 1e-8)
            rel_short_intensity = recent_short / denom - 1
            
            # Apply sigmoid-like transformation to bound extreme values
            rel_short_intensity = np.tanh(rel_short_intensity * 2)  # Scale factor 2 to make it more sensitive
        else:
            rel_short_intensity = 0
        eng.append(rel_short_intensity)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 108826.8858
RMSE: 131535.1140
MAPE: 14.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 88

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t3: importance=0.0009, rank=1
   2. Feature_9_t3: importance=0.0006, rank=2
   3. Feature_19_t1: importance=0.0006, rank=3
   4. Feature_6_t0: importance=0.0005, rank=4
   5. Feature_3_t2: importance=0.0005, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.38%

📈 Current best MAPE: 14.43%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data - high importance in previous iterations
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)  # High importance in previous iterations
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest momentum (normalized by volume)
        # High importance in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 4. Price momentum: 5-day return with exponential weighting
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))  # Exponential weights for recency
            weights = weights / np.sum(weights)  # Normalize weights
            weighted_close = np.sum(close_prices[-5:] * weights)
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = weighted_close / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price volatility: normalized range
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            denom = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_range = (recent_high - recent_low) / denom
        else:
            normalized_range = 0
        eng.append(normalized_range)
        
        # 6. Short Squeeze Potential Score - refined calculation
        # Combines days to cover, short interest ratio, and price momentum
        # Improved with volatility component which showed high importance
        squeeze_potential = days_to_cover * short_interest_to_float * (1 + momentum_5d) * (1 + normalized_range)
        eng.append(squeeze_potential)
        
        # 7. Short cost pressure - refined with volatility component
        # Combines synthetic short cost with days to cover and implied volatility
        short_cost_pressure = options_synthetic_short_cost * np.log1p(days_to_cover) * options_avg_implied_volatility
        eng.append(short_cost_pressure)
        
        # 8. RSI (14-day) - improved calculation with proper smoothing
        if len(close_prices) >= 15:
            deltas = np.diff(close_prices)
            seed = deltas[:14]
            up = seed[seed >= 0].sum() / 14.0
            down = -seed[seed < 0].sum() / 14.0
            
            if down != 0:
                rs = up / max(down, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                rsi = 100.0
        else:
            rsi = 50.0  # Neutral RSI when not enough data
        eng.append(rsi)
        
        # 9. Short Volume Trend Strength - improved calculation
        # Measures the strength and consistency of short volume trend
        if len(short_volume) >= 10:
            # Linear regression slope approximation for trend strength
            x = np.arange(10)
            y = short_volume[-10:]
            x_mean = np.mean(x)
            y_mean = np.mean(y)
            
            # Calculate slope using covariance formula
            numerator = np.sum((x - x_mean) * (y - y_mean))
            denominator = max(np.sum((x - x_mean) ** 2), 1e-8)
            slope = numerator / denominator
            
            # Normalize by average short volume
            denom = max(abs(y_mean), 1e-8)
            normalized_slope = slope / denom
            
            # Apply tanh to bound extreme values
            short_vol_trend = np.tanh(normalized_slope * 5)  # Scale factor to make it more sensitive
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 10. Volatility-adjusted short interest - refined calculation
        # Combines short interest with price volatility for better signal
        vol_adjusted_si = short_interest_to_float * (1 + normalized_range)
        eng.append(vol_adjusted_si)
        
        # 11. Short Interest Efficiency Ratio - improved with momentum
        # Measures how effectively short sellers are timing their positions
        if len(close_prices) >= 5:
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            si_efficiency = short_interest_to_float * (-1 * price_change) * (1 + abs(momentum_5d))
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 12. NEW: Relative Short Interest Position
        # Compares current short interest to its recent range
        if t >= 2:  # Need at least 3 points for a meaningful range
            si_values = [data[max(0, t-i), 0] for i in range(3)]
            si_min = min(si_values)
            si_max = max(si_values)
            si_range = max(abs(si_max - si_min), 1e-8)
            
            # Position within range (0 to 1)
            si_position = (short_interest - si_min) / si_range
            
            # Transform to -1 to 1 scale (centered at middle of range)
            si_position = 2 * si_position - 1
        else:
            si_position = 0
        eng.append(si_position)
        
        # 13. NEW: Short Volume Acceleration with Momentum
        # Improved calculation that incorporates price momentum
        if len(short_volume) >= 9 and len(close_prices) >= 9:
            # Short volume acceleration
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            # First and second derivatives
            first_diff = recent_short_vol - mid_short_vol
            second_diff = (recent_short_vol - mid_short_vol) - (mid_short_vol - early_short_vol)
            
            denom = max(abs(mid_short_vol), 1e-8)
            short_vol_accel = second_diff / denom
            
            # Price momentum over same periods
            recent_price = np.mean(close_prices[-3:])
            mid_price = np.mean(close_prices[-6:-3])
            
            denom = max(abs(mid_price), 1e-8)
            price_momentum = recent_price / denom - 1
            
            # Combine: acceleration is more significant when against price trend
            # (shorts increasing while price rises or shorts decreasing while price falls)
            combined_signal = short_vol_accel * (1 - np.sign(short_vol_accel) * np.sign(price_momentum))
        else:
            combined_signal = 0
        eng.append(combined_signal)
        
        # 14. NEW: Options-Adjusted Short Interest
        # Combines short interest with options data for a more complete picture
        options_adjusted_si = short_interest_to_float * (1 + options_put_call_ratio) * options_avg_implied_volatility
        eng.append(options_adjusted_si)
        
        # 15. NEW: Short Interest Rate of Change with Volatility Adjustment
        # Measures acceleration in short interest buildup, adjusted for volatility
        si_roc_vol = 0
        if t > 0 and data[t-1, 0] > 0:  # Check if we have previous data
            si_roc = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
            si_roc_vol = si_roc * (1 + normalized_range)  # Adjust for volatility
        eng.append(si_roc_vol)
        
        # 16. NEW: Bollinger Band Squeeze with Short Interest
        # Identifies potential breakout situations combined with short interest
        if len(close_prices) >= 10:
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            
            # Bollinger Band width (normalized)
            denom = max(abs(mean_price), 1e-8)
            bb_width = (2 * std_price) / denom
            
            # Squeeze indicator (inverse of width) - higher means tighter bands
            bb_squeeze = 1 / max(bb_width, 1e-8)
            
            # Normalize to reasonable range with sigmoid
            bb_squeeze = np.tanh(bb_squeeze / 10)
            
            # Combine with short interest for signal
            squeeze_si_signal = bb_squeeze * short_interest_to_float
        else:
            squeeze_si_signal = 0
        eng.append(squeeze_si_signal)
        
        # 17. NEW: Volume-Price Divergence with Short Interest
        # Identifies situations where volume and price are moving in opposite directions
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Price trend
            price_change = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            
            # Volume trend
            recent_vol = np.mean(total_volume[-2:])
            earlier_vol = np.mean(total_volume[-5:-2])
            denom = max(abs(earlier_vol), 1e-8)
            vol_change = recent_vol / denom - 1
            
            # Divergence occurs when signs are opposite
            divergence = -1 * np.sign(price_change) * np.sign(vol_change) * min(abs(price_change), abs(vol_change))
            
            # Combine with short interest
            divergence_si = divergence * short_interest_to_float
        else:
            divergence_si = 0
        eng.append(divergence_si)
        
        # 18. NEW: Short Interest Concentration Index (Improved)
        # Measures how concentrated short interest is relative to float and volume
        # Using logarithmic scaling to better capture relationships
        si_concentration = np.log1p(short_interest_to_float) / np.log1p(max(avg_volume / max(abs(shares_outstanding), 1e-8), 1e-8))
        eng.append(si_concentration)
        
        # 19. NEW: Short Volume Intensity Relative to Price Moves
        # Compares short volume to price movement magnitude
        if len(short_volume) >= 5 and len(close_prices) >= 5:
            # Average short volume ratio
            recent_svr = np.mean(short_volume_ratio[-5:])
            
            # Price movement magnitude (absolute)
            price_moves = np.abs(np.diff(close_prices[-6:]))
            avg_price_move = np.mean(price_moves)
            denom = max(abs(close_prices[-6]), 1e-8)
            norm_price_move = avg_price_move / denom
            
            # Ratio of short volume to price movement
            # Higher values indicate more shorting relative to price movement
            if norm_price_move > 0:
                short_price_intensity = recent_svr / max(norm_price_move, 1e-8)
                # Apply log transformation to handle extreme values
                short_price_intensity = np.log1p(short_price_intensity)
            else:
                short_price_intensity = 0
        else:
            short_price_intensity = 0
        eng.append(short_price_intensity)
        
        # 20. NEW: Composite Short Pressure Index
        # Combines multiple short-related metrics into a single indicator
        composite_short = (
            short_interest_to_float * 
            (1 + avg_short_volume_ratio) * 
            np.log1p(days_to_cover) * 
            (1 + options_avg_implied_volatility / max(abs(np.mean(options_avg_implied_volatility)), 1e-8))
        )
        # Apply tanh to bound extreme values
        composite_short = np.tanh(composite_short)
        eng.append(composite_short)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 107807.8425
RMSE: 131324.0312
MAPE: 14.71%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t1: importance=0.0008, rank=1
   2. Feature_9_t0: importance=0.0007, rank=2
   3. Feature_13_t3: importance=0.0006, rank=3
   4. Feature_12_t2: importance=0.0006, rank=4
   5. Feature_21_t1: importance=0.0006, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -0.28%

📈 Current best MAPE: 14.43%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data - high importance in previous iterations
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)  # High importance in previous iterations
        raw_keep.append(options_put_call_ratio)  # Added based on importance analysis
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest momentum (normalized by volume)
        # High importance in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 4. Price momentum: 5-day return with exponential weighting
        # Refined with stronger exponential weighting to emphasize recent price action
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 2, 5))  # Stronger exponential weights
            weights = weights / np.sum(weights)  # Normalize weights
            weighted_close = np.sum(close_prices[-5:] * weights)
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = weighted_close / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price volatility: normalized range with Parkinson's volatility estimator
        # Improved volatility calculation using high-low range (Parkinson's method)
        if len(close_prices) >= 5:
            # Parkinson's volatility estimator uses high-low range
            hl_ranges = np.log(high_prices[-5:] / low_prices[-5:])
            parkinson_vol = np.sqrt(np.sum(hl_ranges**2) / (4 * 5 * np.log(2)))
            # Normalize by average price
            denom = max(abs(np.mean(close_prices[-5:])), 1e-8)
            normalized_vol = parkinson_vol / denom
        else:
            normalized_vol = 0
        eng.append(normalized_vol)
        
        # 6. Short Squeeze Potential Score - refined calculation
        # Improved with nonlinear scaling to better capture extreme values
        squeeze_potential = np.tanh(days_to_cover * short_interest_to_float * (1 + momentum_5d) * (1 + normalized_vol))
        eng.append(squeeze_potential)
        
        # 7. Short cost pressure - refined with volatility component
        # Improved with log scaling to handle extreme values better
        short_cost_pressure = np.log1p(options_synthetic_short_cost) * np.log1p(days_to_cover) * options_avg_implied_volatility
        short_cost_pressure = np.tanh(short_cost_pressure)  # Bound extreme values
        eng.append(short_cost_pressure)
        
        # 8. RSI (14-day) - improved calculation with proper smoothing
        if len(close_prices) >= 15:
            deltas = np.diff(close_prices)
            gains = deltas.copy()
            losses = deltas.copy()
            gains[gains < 0] = 0
            losses[losses > 0] = 0
            losses = abs(losses)
            
            avg_gain = np.mean(gains)
            avg_loss = np.mean(losses)
            
            if avg_loss != 0:
                rs = avg_gain / max(avg_loss, 1e-8)
                rsi = 100.0 - (100.0 / (1.0 + rs))
            else:
                rsi = 100.0
                
            # Transform RSI to be centered at 0 (-1 to 1 scale)
            rsi_centered = (rsi - 50) / 50
        else:
            rsi_centered = 0.0
        eng.append(rsi_centered)
        
        # 9. NEW: VWAP Deviation Ratio
        # Measures price deviation from volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate VWAP
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            # Deviation from VWAP
            vwap_deviation = (close_prices[-1] / max(abs(vwap), 1e-8)) - 1
            # Scale with short interest
            vwap_si_signal = vwap_deviation * short_interest_to_float
        else:
            vwap_si_signal = 0
        eng.append(vwap_si_signal)
        
        # 10. NEW: Short Interest Efficiency with Price Momentum
        # Improved calculation that better captures the relationship between
        # short interest and price movements
        if len(close_prices) >= 5:
            # Calculate price momentum over different timeframes
            price_change_3d = close_prices[-1] / max(abs(close_prices[-3]), 1e-8) - 1
            price_change_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
            
            # Weight recent price changes more heavily
            weighted_price_change = (0.7 * price_change_3d) + (0.3 * price_change_5d)
            
            # Short interest efficiency: higher when shorts are correct (negative price)
            si_efficiency = short_interest_to_float * (-1 * weighted_price_change) * (1 + abs(momentum_5d))
            si_efficiency = np.tanh(si_efficiency * 3)  # Scale and bound
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 11. NEW: Relative Short Interest Position with Z-score
        # Improved statistical approach using z-score normalization
        if t >= 3:  # Need at least 4 points for meaningful statistics
            si_values = np.array([data[max(0, t-i), 0] for i in range(4)])
            si_mean = np.mean(si_values)
            si_std = max(np.std(si_values), 1e-8)
            
            # Z-score of current short interest
            si_zscore = (short_interest - si_mean) / si_std
            # Bound extreme values
            si_zscore = np.tanh(si_zscore)
        else:
            si_zscore = 0
        eng.append(si_zscore)
        
        # 12. NEW: Short Volume Acceleration with Price Divergence
        # Improved to capture divergence between short volume and price
        if len(short_volume) >= 9 and len(close_prices) >= 9:
            # Short volume acceleration (second derivative)
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            first_diff = (recent_short_vol - mid_short_vol) / max(abs(mid_short_vol), 1e-8)
            second_diff = first_diff - ((mid_short_vol - early_short_vol) / max(abs(early_short_vol), 1e-8))
            
            # Price momentum over same periods
            recent_price = np.mean(close_prices[-3:])
            mid_price = np.mean(close_prices[-6:-3])
            early_price = np.mean(close_prices[-9:-6])
            
            price_first_diff = (recent_price - mid_price) / max(abs(mid_price), 1e-8)
            
            # Divergence signal: short volume accelerating while price moves opposite
            divergence = second_diff * (-1 * np.sign(second_diff) * np.sign(price_first_diff))
            divergence = np.tanh(divergence * 2)  # Scale and bound
        else:
            divergence = 0
        eng.append(divergence)
        
        # 13. NEW: Garman-Klass Volatility Estimator with Short Interest
        # More accurate volatility estimation using open, high, low, close prices
        if len(open_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # Calculate Garman-Klass volatility
            log_hl = np.log(high_prices[-5:] / low_prices[-5:])
            log_co = np.log(close_prices[-5:] / open_prices[-5:])
            
            gk_vol = np.mean(0.5 * log_hl**2 - (2*np.log(2)-1) * log_co**2)
            gk_vol = np.sqrt(gk_vol)
            
            # Combine with short interest
            gk_vol_si = gk_vol * short_interest_to_float
            gk_vol_si = np.tanh(gk_vol_si * 3)  # Scale and bound
        else:
            gk_vol_si = 0
        eng.append(gk_vol_si)
        
        # 14. NEW: Options-Adjusted Short Interest with Volatility Skew
        # Improved to incorporate options market sentiment more effectively
        options_adjusted_si = short_interest_to_float * (1 + np.log1p(options_put_call_ratio)) * options_avg_implied_volatility
        options_adjusted_si = np.tanh(options_adjusted_si)  # Bound extreme values
        eng.append(options_adjusted_si)
        
        # 15. NEW: Short Interest Rate of Change with Momentum
        # Improved calculation that captures acceleration in short interest
        si_roc = 0
        if t > 1 and data[t-1, 0] > 0 and data[t-2, 0] > 0:
            # First derivative of short interest
            si_roc_1 = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
            # Second derivative (acceleration)
            si_roc_2 = si_roc_1 - ((data[t-1, 0] / max(abs(data[t-2, 0]), 1e-8)) - 1)
            # Combine with price momentum for signal
            si_roc = si_roc_2 * (1 + abs(momentum_5d)) * np.sign(momentum_5d * -1)
            si_roc = np.tanh(si_roc * 2)  # Scale and bound
        eng.append(si_roc)
        
        # 16. NEW: Bollinger Band Position with Short Interest
        # Identifies potential breakout situations combined with short interest
        if len(close_prices) >= 10:
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            
            # Calculate upper and lower bands
            upper_band = mean_price + (2 * std_price)
            lower_band = mean_price - (2 * std_price)
            
            # Position within bands (-1 to 1 scale)
            band_range = max(abs(upper_band - lower_band), 1e-8)
            bb_position = (close_prices[-1] - lower_band) / band_range * 2 - 1
            
            # Combine with short interest for signal
            # Higher signal when price is near bands and short interest is high
            bb_si_signal = bb_position * short_interest_to_float
            bb_si_signal = np.tanh(bb_si_signal)  # Bound extreme values
        else:
            bb_si_signal = 0
        eng.append(bb_si_signal)
        
        # 17. NEW: Volume-Price Trend with Short Interest
        # Improved indicator that captures volume-price relationship
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate price changes
            price_changes = np.diff(close_prices[-5:])
            
            # Calculate VPT (Volume-Price Trend)
            vpt = 0
            for i in range(len(price_changes)):
                price_change_pct = price_changes[i] / max(abs(close_prices[-5+i]), 1e-8)
                vpt += total_volume[-5+i+1] * price_change_pct
            
            # Normalize by average volume
            avg_vol = np.mean(total_volume[-5:])
            vpt_norm = vpt / max(abs(avg_vol), 1e-8)
            
            # Combine with short interest
            vpt_si = vpt_norm * short_interest_to_float * -1  # Inverse relationship
            vpt_si = np.tanh(vpt_si)  # Bound extreme values
        else:
            vpt_si = 0
        eng.append(vpt_si)
        
        # 18. NEW: Short Interest Concentration Index with Volume Profile
        # Improved to incorporate volume distribution
        if len(total_volume) >= 5:
            # Calculate volume profile
            vol_profile = total_volume[-5:] / max(np.sum(total_volume[-5:]), 1e-8)
            vol_std = np.std(vol_profile)  # Higher means more concentrated volume
            
            # Combine with short interest
            si_concentration = np.log1p(short_interest_to_float) * (1 + vol_std)
            si_concentration = np.tanh(si_concentration * 2)  # Scale and bound
        else:
            si_concentration = 0
        eng.append(si_concentration)
        
        # 19. NEW: Composite Short Pressure Index with Market Impact
        # Improved composite indicator that better captures market impact
        composite_short = (
            short_interest_to_float * 
            np.sqrt(1 + avg_short_volume_ratio) * 
            np.log1p(days_to_cover) * 
            (1 + options_avg_implied_volatility / max(abs(np.mean([options_avg_implied_volatility, 1])), 1e-8))
        )
        # Apply sigmoid to bound extreme values
        composite_short = np.tanh(composite_short)
        eng.append(composite_short)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 109296.3355
RMSE: 132986.0323
MAPE: 14.73%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0013, rank=1
   2. Feature_3_t3: importance=0.0008, rank=2
   3. Feature_17_t0: importance=0.0008, rank=3
   4. Feature_10_t2: importance=0.0007, rank=4
   5. Feature_13_t2: importance=0.0006, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -0.31%

📈 Current best MAPE: 14.43%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Always keep these critical raw features
        raw_keep.append(short_interest)  # Target-related feature
        raw_keep.append(avg_volume)      # Key volume metric
        raw_keep.append(days_to_cover)   # Important short interest context
        
        # Extract options data - high importance in previous iterations
        options_put_call_ratio = data[t, 63]
        options_synthetic_short_cost = data[t, 64]
        options_avg_implied_volatility = data[t, 65]
        shares_outstanding = data[t, 66]
        
        # Keep high-importance options data
        raw_keep.append(options_avg_implied_volatility)  # High importance in previous iterations
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep last day's close price as compact summary
        raw_keep.append(close_prices[-1])  # Last close price
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW after determining raw features to keep
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (daily short volume / total volume)
        # High importance in previous iterations
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio over the past 15 days
        avg_short_volume_ratio = np.mean(short_volume_ratio)
        eng.append(avg_short_volume_ratio)
        
        # 2. Short interest to float ratio (key fundamental metric)
        denom = max(abs(shares_outstanding), 1e-8)
        short_interest_to_float = short_interest / denom
        eng.append(short_interest_to_float)
        
        # 3. Short interest momentum (normalized by volume)
        # High importance in previous iterations
        short_interest_momentum = short_interest / max(abs(avg_volume), 1e-8)
        eng.append(short_interest_momentum)
        
        # 4. Price momentum: 5-day return with exponential weighting
        # Refined with stronger exponential weighting to emphasize recent price action
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 2, 5))  # Stronger exponential weights
            weights = weights / np.sum(weights)  # Normalize weights
            weighted_close = np.sum(close_prices[-5:] * weights)
            denom = max(abs(close_prices[-5]), 1e-8)
            momentum_5d = weighted_close / denom - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Garman-Klass Volatility Estimator with Short Interest
        # More accurate volatility estimation using open, high, low, close prices
        # High importance in previous iterations (Feature_13)
        if len(open_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # Calculate Garman-Klass volatility
            log_hl = np.log(high_prices[-5:] / low_prices[-5:])
            log_co = np.log(close_prices[-5:] / open_prices[-5:])
            
            gk_vol = np.mean(0.5 * log_hl**2 - (2*np.log(2)-1) * log_co**2)
            gk_vol = np.sqrt(gk_vol)
            
            # Combine with short interest
            gk_vol_si = gk_vol * short_interest_to_float
            gk_vol_si = np.tanh(gk_vol_si * 3)  # Scale and bound
        else:
            gk_vol_si = 0
        eng.append(gk_vol_si)
        
        # 6. Short Squeeze Potential Score - refined calculation
        # Improved with nonlinear scaling to better capture extreme values
        if len(close_prices) >= 5:
            # Calculate price volatility using high-low range
            hl_ranges = np.log(high_prices[-5:] / low_prices[-5:])
            price_vol = np.sqrt(np.sum(hl_ranges**2) / (4 * 5 * np.log(2)))
            
            # Calculate squeeze potential with more emphasis on days to cover
            squeeze_potential = np.tanh(days_to_cover**1.5 * short_interest_to_float * (1 + abs(momentum_5d)) * (1 + price_vol))
        else:
            squeeze_potential = np.tanh(days_to_cover**1.5 * short_interest_to_float)
        eng.append(squeeze_potential)
        
        # 7. NEW: Relative Short Interest Position with Exponential Weighting
        # Improved version of previous z-score approach with more emphasis on recent changes
        if t >= 3:  # Need at least 4 points for meaningful statistics
            si_values = np.array([data[max(0, t-i), 0] for i in range(4)])
            # Apply exponential weights to emphasize recent values
            weights = np.exp(np.linspace(0, 1.5, 4))
            weights = weights / np.sum(weights)
            si_weighted_mean = np.sum(si_values * weights)
            
            # Calculate weighted deviation
            si_rel_position = (short_interest - si_weighted_mean) / max(abs(si_weighted_mean), 1e-8)
            # Bound extreme values
            si_rel_position = np.tanh(si_rel_position * 2)
        else:
            si_rel_position = 0
        eng.append(si_rel_position)
        
        # 8. Volume-Price Trend with Short Interest
        # Improved indicator that captures volume-price relationship
        # High importance in previous iterations (Feature_17)
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            # Calculate price changes
            price_changes = np.diff(close_prices[-5:])
            
            # Calculate VPT (Volume-Price Trend)
            vpt = 0
            for i in range(len(price_changes)):
                price_change_pct = price_changes[i] / max(abs(close_prices[-5+i]), 1e-8)
                vpt += total_volume[-5+i+1] * price_change_pct
            
            # Normalize by average volume
            avg_vol = np.mean(total_volume[-5:])
            vpt_norm = vpt / max(abs(avg_vol), 1e-8)
            
            # Combine with short interest
            vpt_si = vpt_norm * short_interest_to_float * -1  # Inverse relationship
            vpt_si = np.tanh(vpt_si * 1.5)  # Bound extreme values with adjusted scaling
        else:
            vpt_si = 0
        eng.append(vpt_si)
        
        # 9. NEW: Short Interest Rate of Change with Volume Confirmation
        # Enhanced version of previous SI ROC feature with volume confirmation
        si_roc_vol = 0
        if t > 1 and data[t-1, 0] > 0:
            # First derivative of short interest
            si_roc = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
            
            # Volume confirmation: higher signal when volume supports the move
            vol_ratio = avg_volume / max(abs(data[t-1, 1]), 1e-8)
            vol_confirmation = np.tanh(vol_ratio - 1)  # Normalized volume change
            
            # Combine SI change with volume confirmation
            si_roc_vol = si_roc * (1 + abs(vol_confirmation)) * np.sign(vol_confirmation)
            si_roc_vol = np.tanh(si_roc_vol * 2)  # Scale and bound
        eng.append(si_roc_vol)
        
        # 10. NEW: Options Market Sentiment Index
        # Comprehensive options market indicator combining multiple signals
        options_sentiment = options_put_call_ratio * options_avg_implied_volatility / max(abs(options_synthetic_short_cost), 1e-8)
        options_sentiment = np.tanh(options_sentiment)  # Bound extreme values
        eng.append(options_sentiment)
        
        # 11. NEW: Short Volume Trend with Price Divergence
        # Captures divergence between short volume trend and price movement
        if len(short_volume) >= 5 and len(close_prices) >= 5:
            # Calculate short volume trend
            short_vol_trend = np.mean(short_volume[-2:]) / max(abs(np.mean(short_volume[-5:-2])), 1e-8) - 1
            
            # Calculate price trend
            price_trend = close_prices[-1] / max(abs(np.mean(close_prices[-4:-1])), 1e-8) - 1
            
            # Divergence signal: short volume increasing while price also increasing (potential reversal)
            divergence = short_vol_trend * price_trend
            # Stronger signal when both move in same direction (unusual)
            divergence = divergence * (1 + abs(short_vol_trend)) * (1 + abs(price_trend))
            divergence = np.tanh(divergence * 2)  # Scale and bound
        else:
            divergence = 0
        eng.append(divergence)
        
        # 12. NEW: Composite Short Pressure Index with Volatility Adjustment
        # Enhanced version of previous composite indicator with better volatility scaling
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            # Calculate normalized volatility using high-low range
            hl_ranges = (high_prices[-5:] - low_prices[-5:]) / low_prices[-5:]
            norm_vol = np.mean(hl_ranges)
            
            # Composite short pressure with volatility adjustment
            composite_short = (
                short_interest_to_float**1.2 *  # Nonlinear scaling of SI
                np.sqrt(1 + avg_short_volume_ratio) * 
                np.log1p(days_to_cover) * 
                (1 + norm_vol)
            )
            # Apply sigmoid to bound extreme values
            composite_short = np.tanh(composite_short * 1.5)
        else:
            composite_short = np.tanh(short_interest_to_float**1.2 * np.sqrt(1 + avg_short_volume_ratio) * np.log1p(days_to_cover))
        eng.append(composite_short)
        
        # 13. NEW: Short Interest Efficiency Ratio
        # Measures how effectively short positions are impacting price
        if len(close_prices) >= 5:
            # Calculate price efficiency (directional movement relative to total movement)
            price_move = close_prices[-1] - close_prices[-5]
            price_path = np.sum(np.abs(np.diff(close_prices[-5:])))
            price_efficiency = price_move / max(abs(price_path), 1e-8)
            
            # Short interest efficiency: higher when price moves more directionally with high SI
            si_efficiency = short_interest_to_float * price_efficiency * -1  # Inverse relationship expected
            si_efficiency = np.tanh(si_efficiency * 3)  # Scale and bound
        else:
            si_efficiency = 0
        eng.append(si_efficiency)
        
        # 14. NEW: Bollinger Band Squeeze with Short Interest
        # Identifies potential volatility expansion situations combined with short interest
        if len(close_prices) >= 10:
            # Calculate Bollinger Band width
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            
            # Normalized BB width (lower values indicate "squeeze")
            bb_width = (2 * std_price) / max(abs(mean_price), 1e-8)
            
            # Inverse of width (higher during squeeze)
            bb_squeeze = 1 / max(abs(bb_width), 1e-8)
            
            # Combine with short interest for signal
            # Higher signal when BB squeeze is happening with high short interest
            bb_squeeze_si = np.tanh(bb_squeeze) * short_interest_to_float
            bb_squeeze_si = np.tanh(bb_squeeze_si * 2)  # Scale and bound
        else:
            bb_squeeze_si = 0
        eng.append(bb_squeeze_si)
        
        # 15. NEW: Short Interest Concentration Index
        # Measures how concentrated short interest is relative to normal trading patterns
        si_concentration = short_interest / max(abs(np.mean(total_volume[-5:])), 1e-8)
        si_concentration = np.log1p(si_concentration)  # Log transform to handle skewness
        si_concentration = np.tanh(si_concentration * 2)  # Scale and bound
        eng.append(si_concentration)
        
        # 16. NEW: Price Momentum Asymmetry with Short Interest
        # Captures asymmetric price movements that might indicate short covering
        if len(close_prices) >= 10:
            # Calculate up and down moves separately
            price_changes = np.diff(close_prices[-10:])
            up_moves = price_changes.copy()
            up_moves[up_moves < 0] = 0
            down_moves = price_changes.copy()
            down_moves[down_moves > 0] = 0
            down_moves = abs(down_moves)
            
            # Calculate asymmetry ratio (higher when up moves are stronger than down moves)
            up_sum = np.sum(up_moves)
            down_sum = np.sum(down_moves)
            
            if down_sum > 0:
                asymmetry = (up_sum / max(abs(down_sum), 1e-8)) - 1
            else:
                asymmetry = 1  # All up moves
                
            # Combine with short interest (higher signal when up moves dominate with high SI)
            momentum_asymmetry = asymmetry * short_interest_to_float
            momentum_asymmetry = np.tanh(momentum_asymmetry * 1.5)  # Scale and bound
        else:
            momentum_asymmetry = 0
        eng.append(momentum_asymmetry)
        
        # 17. NEW: Short Interest to Options Volume Ratio
        # Relates short interest to options activity
        options_volume_proxy = options_put_call_ratio * options_avg_implied_volatility
        si_options_ratio = short_interest_to_float / max(abs(options_volume_proxy), 1e-8)
        si_options_ratio = np.tanh(si_options_ratio)  # Bound extreme values
        eng.append(si_options_ratio)
        
        # 18. NEW: Short Interest Momentum Divergence
        # Captures divergence between short interest momentum and price momentum
        if t > 1 and data[t-1, 0] > 0 and len(close_prices) >= 5:
            # Short interest momentum
            si_momentum = (short_interest / max(abs(data[t-1, 0]), 1e-8)) - 1
            
            # Price momentum
            price_momentum = (close_prices[-1] / max(abs(close_prices[-5]), 1e-8)) - 1
            
            # Divergence (higher when SI increases but price also increases)
            si_price_divergence = si_momentum * price_momentum
            si_price_divergence = np.tanh(si_price_divergence * 3)  # Scale and bound
        else:
            si_price_divergence = 0
        eng.append(si_price_divergence)
        
        # 19. NEW: Short Volume Acceleration
        # Second derivative of short volume to capture acceleration
        if len(short_volume) >= 9:
            # Short volume acceleration (second derivative)
            recent_short_vol = np.mean(short_volume[-3:])
            mid_short_vol = np.mean(short_volume[-6:-3])
            early_short_vol = np.mean(short_volume[-9:-6])
            
            first_diff = (recent_short_vol - mid_short_vol) / max(abs(mid_short_vol), 1e-8)
            second_diff = first_diff - ((mid_short_vol - early_short_vol) / max(abs(early_short_vol), 1e-8))
            
            # Scale and bound
            short_vol_accel = np.tanh(second_diff * 2)
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 20. NEW: Relative Short Interest Position (RSIP)
        # Measures current short interest relative to its historical range
        if t >= 5:
            # Get historical short interest values
            hist_si = np.array([data[max(0, t-i), 0] for i in range(6)])
            
            # Calculate min and max
            si_min = np.min(hist_si)
            si_max = np.max(hist_si)
            si_range = max(abs(si_max - si_min), 1e-8)
            
            # Calculate relative position (0 to 1 scale)
            rsip = (short_interest - si_min) / si_range
            
            # Transform to -1 to 1 scale and center at 0.5
            rsip = (rsip - 0.5) * 2
        else:
            rsip = 0
        eng.append(rsip)
        
        # Truncate eng list if it exceeds MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure row has exactly MAX_TOTAL elements
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Convert to numpy array and handle NaN values
    result_array = np.array(result, dtype=np.float32)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 109008.5127
RMSE: 130117.3224
MAPE: 15.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t3: importance=0.0013, rank=1
   2. Feature_21_t2: importance=0.0011, rank=2
   3. Feature_8_t1: importance=0.0008, rank=3
   4. Feature_13_t3: importance=0.0007, rank=4
   5. Feature_15_t2: importance=0.0006, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
📊 No significant improvement. Change: -0.59%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 96444.9026
RMSE: 132965.5732
MAPE: 13.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 280
   • Highly important features (top 5%): 173

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0005, rank=1
   2. Feature_0_t3: importance=0.0004, rank=2
   3. Feature_78_t2: importance=0.0004, rank=3
   4. Feature_70_t3: importance=0.0003, rank=4
   5. Feature_89_t3: importance=0.0003, rank=5
   Baseline MAPE: 13.70%
   Baseline MAE: 96444.9026
   Baseline RMSE: 132965.5732

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 91304.9805
RMSE: 122732.1433
MAPE: 12.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t3: importance=0.0009, rank=1
   2. Feature_10_t1: importance=0.0008, rank=2
   3. Feature_1_t2: importance=0.0007, rank=3
   4. Feature_19_t2: importance=0.0007, rank=4
   5. Feature_20_t3: importance=0.0007, rank=5

📊 Best Model Test Set Performance:
   MAPE: 12.80%
   MAE: 91304.9805
   RMSE: 122732.1433

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 13.70%
   Best Model MAPE: 12.80%
   Absolute Improvement: 0.90%
   Relative Improvement: 6.5%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  15.28           N/A                 
1          Iteration 1               15.09           +0.19%              
2          Iteration 2               14.43           +0.67%              
3          Iteration 3               15.13           -0.71%              
4          Iteration 4               14.80           -0.38%              
5          Iteration 5               14.71           -0.28%              
6          Iteration 6               14.73           -0.31%              
7          Iteration 7               15.01           -0.59%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 2 - MAPE: 14.43%
✅ Saved ANDE results to cache/ANDE_iterative_results_enhanced.pkl
✅ Summary report saved for ANDE

🎉 Process completed successfully for ANDE!

================================================================================
PROCESSING TICKER 14/14: AROC
================================================================================
🚀 Starting Iterative Agent-Based Feature Selection Process for AROC
======================================================================
📊 Loading data from parquet file...
📊 Loading data for AROC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AROC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data integrity validation passed
✅ Data loaded successfully!
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
Features per timestep: 97
Lookback window: 4

🎯 Step 1: Running baseline model on validation set...

==================================================
Training Baseline (All 97 Features) (SVM)
==================================================
Training SVM model...

Baseline (All 97 Features) Performance:
MAE: 454892.2948
RMSE: 553447.6698
MAPE: 10.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 337
   • Highly important features (top 5%): 222

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t3: importance=0.0018, rank=1
   2. Feature_71_t3: importance=0.0017, rank=2
   3. Feature_70_t3: importance=0.0015, rank=3
   4. Feature_72_t3: importance=0.0014, rank=4
   5. Feature_74_t3: importance=0.0008, rank=5

📊 Baseline Performance: MAPE = 10.54%

🔄 Starting iterative improvement process...
Max iterations: 10
Min improvement threshold: 0.1%
Patience: 5 iterations without improvement

======================================================================
ITERATION 1
======================================================================
🤖 Calling Claude for iteration 1...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
            data[t, 63], # options_put_call_volume_ratio
            data[t, 64], # options_synthetic_short_cost
            data[t, 65], # options_avg_implied_volatility
            data[t, 66]  # shares_outstanding
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Recent price trend (last 5 days vs previous 5 days)
        recent_close_avg = np.mean(close_prices[-5:])
        prev_close_avg = np.mean(close_prices[-10:-5])
        denom = max(abs(prev_close_avg), 1e-8)
        price_trend = (recent_close_avg / denom) - 1
        eng.append(price_trend)
        
        # 2. Volatility (standard deviation of returns over past 10 days)
        returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
        volatility = np.std(returns) if len(returns) > 1 else 0
        eng.append(volatility)
        
        # 3. Short volume ratio (average of last 5 days)
        short_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        eng.append(short_ratio)
        
        # 4. Short volume trend (last 5 days vs previous 5 days)
        recent_short_avg = np.mean(short_volume[-5:])
        prev_short_avg = np.mean(short_volume[-10:-5])
        denom = max(abs(prev_short_avg), 1e-8)
        short_trend = (recent_short_avg / denom) - 1
        eng.append(short_trend)
        
        # 5. Price momentum (rate of change over 10 days)
        if len(close_prices) >= 10:
            momentum = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1
        else:
            momentum = 0
        eng.append(momentum)
        
        # 6. High-Low range relative to price (average of last 5 days)
        hl_range = np.mean((high_prices[-5:] - low_prices[-5:]) / np.maximum(close_prices[-5:], 1e-8))
        eng.append(hl_range)
        
        # 7. RSI (14-day)
        if len(close_prices) >= 15:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            denom = max(avg_loss, 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default neutral value
        eng.append(rsi)
        
        # 8. Short interest to float ratio
        si_float_ratio = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_float_ratio)
        
        # 9. Short volume acceleration (change in short volume trend)
        if len(short_volume) >= 15:
            recent_change = short_volume[-1] - short_volume[-5]
            prev_change = short_volume[-6] - short_volume[-10]
            denom = max(abs(prev_change), 1e-8)
            short_accel = (recent_change / denom) - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 10. Volume trend (last 5 days vs previous 5 days)
        recent_vol_avg = np.mean(total_volume[-5:])
        prev_vol_avg = np.mean(total_volume[-10:-5])
        denom = max(abs(prev_vol_avg), 1e-8)
        vol_trend = (recent_vol_avg / denom) - 1
        eng.append(vol_trend)
        
        # 11. Price to volume correlation (last 10 days)
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_changes = np.diff(close_prices[-10:])
            vol_changes = np.diff(total_volume[-10:])
            if len(price_changes) > 1 and len(vol_changes) > 1 and np.std(price_changes) > 0 and np.std(vol_changes) > 0:
                price_vol_corr = np.corrcoef(price_changes, vol_changes)[0, 1]
            else:
                price_vol_corr = 0
        else:
            price_vol_corr = 0
        eng.append(price_vol_corr)
        
        # 12. Short interest to average daily volume ratio
        si_adv_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_adv_ratio)
        
        # 13. Options implied volatility to historical volatility ratio
        iv_hv_ratio = data[t, 65] / max(volatility, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 14. Short cost to volatility ratio
        cost_vol_ratio = data[t, 64] / max(data[t, 65], 1e-8)
        eng.append(cost_vol_ratio)
        
        # 15. Recent closing price relative to range
        if len(close_prices) >= 5:
            recent_high = np.max(high_prices[-5:])
            recent_low = np.min(low_prices[-5:])
            range_size = max(recent_high - recent_low, 1e-8)
            close_in_range = (close_prices[-1] - recent_low) / range_size
        else:
            close_in_range = 0.5  # Default middle value
        eng.append(close_in_range)
        
        # 16. Short volume to total volume ratio trend
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
            prev_ratio = np.mean(short_volume[-10:-5] / np.maximum(total_volume[-10:-5], 1e-8))
            denom = max(abs(prev_ratio), 1e-8)
            ratio_trend = (recent_ratio / denom) - 1
        else:
            ratio_trend = 0
        eng.append(ratio_trend)
        
        # 17. Short interest growth rate
        if t > 0:
            prev_si = data[t-1, 0]
            denom = max(abs(prev_si), 1e-8)
            si_growth = (data[t, 0] / denom) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 18. Put-call ratio trend
        if t > 0:
            prev_pc_ratio = data[t-1, 63]
            denom = max(abs(prev_pc_ratio), 1e-8)
            pc_ratio_trend = (data[t, 63] / denom) - 1
        else:
            pc_ratio_trend = 0
        eng.append(pc_ratio_trend)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 1 (claude) (SVM)
==================================================
Training SVM model...

Iteration 1 (claude) Performance:
MAE: 428395.0323
RMSE: 517388.6848
MAPE: 9.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0041, rank=1
   2. Feature_14_t1: importance=0.0024, rank=2
   3. Feature_3_t0: importance=0.0018, rank=3
   4. Feature_6_t1: importance=0.0013, rank=4
   5. Feature_21_t0: importance=0.0013, rank=5
💾 Saved code for iteration 1 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 0.58%

📈 Current best MAPE: 9.95%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 2
======================================================================
🤖 Calling Claude for iteration 2...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, we're keeping the most important raw features
        # and dropping those with low importance
        raw_keep = [
            data[t, 0],  # short interest - critical target-related feature
            data[t, 1],  # average daily volume - high importance in previous iteration
            data[t, 2],  # days to cover - key short interest metric
            data[t, 63], # options_put_call_volume_ratio - options sentiment indicator
            data[t, 64], # options_synthetic_short_cost - cost of shorting
            data[t, 65], # options_avg_implied_volatility - market's volatility expectation
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - key metric for short squeeze potential
        si_float_ratio = data[t, 0] / max(data[t, 66], 1e-8)  # shares_outstanding is at index 66
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - improved version of days to cover
        si_adv_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Short volume ratio (average of last 5 days) - recent shorting intensity
        short_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        eng.append(short_ratio)
        
        # 4. Short volume trend (last 5 days vs previous 5 days) - acceleration in shorting
        if len(short_volume) >= 10:
            recent_short_avg = np.mean(short_volume[-5:])
            prev_short_avg = np.mean(short_volume[-10:-5])
            denom = max(abs(prev_short_avg), 1e-8)
            short_trend = (recent_short_avg / denom) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 5. Short interest growth rate - rate of change in reported short interest
        if t > 0:
            prev_si = data[t-1, 0]
            denom = max(abs(prev_si), 1e-8)
            si_growth = (data[t, 0] / denom) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 6. Volatility (standard deviation of returns over past 10 days)
        if len(close_prices) >= 11:
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 1 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 7. Options implied volatility to historical volatility ratio - market vs realized volatility
        iv_hv_ratio = data[t, 65] / max(volatility, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 8. Short cost to implied volatility ratio - cost efficiency of shorting
        cost_vol_ratio = data[t, 64] / max(data[t, 65], 1e-8)
        eng.append(cost_vol_ratio)
        
        # 9. RSI (14-day) - oversold/overbought indicator
        if len(close_prices) >= 15:
            delta = np.diff(close_prices)
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain)
            avg_loss = np.mean(loss)
            denom = max(avg_loss, 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default neutral value
        eng.append(rsi)
        
        # 10. Bollinger Band Width - volatility measure
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)  # Normalized by price level
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 11. VWAP ratio - price relative to volume-weighted average price
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            vwap_ratio = close_prices[-1] / max(vwap, 1e-8)
        else:
            vwap_ratio = 1
        eng.append(vwap_ratio)
        
        # 12. Short volume to total volume ratio trend - change in shorting intensity
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
            prev_ratio = np.mean(short_volume[-10:-5] / np.maximum(total_volume[-10:-5], 1e-8))
            denom = max(abs(prev_ratio), 1e-8)
            ratio_trend = (recent_ratio / denom) - 1
        else:
            ratio_trend = 0
        eng.append(ratio_trend)
        
        # 13. Put-call ratio trend - options sentiment change
        if t > 0:
            prev_pc_ratio = data[t-1, 63]
            denom = max(abs(prev_pc_ratio), 1e-8)
            pc_ratio_trend = (data[t, 63] / denom) - 1
        else:
            pc_ratio_trend = 0
        eng.append(pc_ratio_trend)
        
        # 14. Price momentum (rate of change over 10 days)
        if len(close_prices) >= 10:
            momentum = (close_prices[-1] / max(abs(close_prices[-10]), 1e-8)) - 1
        else:
            momentum = 0
        eng.append(momentum)
        
        # 15. Average True Range (ATR) - volatility measure
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            tr_values = []
            for i in range(1, 5):
                high_low = high_prices[-i] - low_prices[-i]
                high_close = abs(high_prices[-i] - close_prices[-(i+1)] if i < len(close_prices)-1 else 0)
                low_close = abs(low_prices[-i] - close_prices[-(i+1)] if i < len(close_prices)-1 else 0)
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            atr = np.mean(tr_values)
            # Normalize by price
            atr_normalized = atr / max(close_prices[-1], 1e-8)
        else:
            atr_normalized = 0
        eng.append(atr_normalized)
        
        # 16. Short volume acceleration - second derivative of short volume
        if len(short_volume) >= 15:
            recent_change = np.mean(short_volume[-5:]) - np.mean(short_volume[-10:-5])
            prev_change = np.mean(short_volume[-10:-5]) - np.mean(short_volume[-15:-10])
            denom = max(abs(prev_change), 1e-8)
            short_accel = (recent_change / denom) - 1
        else:
            short_accel = 0
        eng.append(short_accel)
        
        # 17. MACD Signal - trend strength and direction
        if len(close_prices) >= 15:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA
            ema26 = np.mean(close_prices[-15:])  # Using available data
            macd = ema12 - ema26
            # Normalize by price
            macd_normalized = macd / max(close_prices[-1], 1e-8)
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 18. Volume Oscillator - volume trend
        if len(total_volume) >= 10:
            short_vol_ma = np.mean(total_volume[-5:])
            long_vol_ma = np.mean(total_volume[-10:])
            vol_osc = (short_vol_ma / max(long_vol_ma, 1e-8)) - 1
        else:
            vol_osc = 0
        eng.append(vol_osc)
        
        # 19. High-Low range relative to price (average of last 5 days)
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            hl_range = np.mean((high_prices[-5:] - low_prices[-5:]) / np.maximum(close_prices[-5:], 1e-8))
        else:
            hl_range = 0
        eng.append(hl_range)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 2 (claude) (SVM)
==================================================
Training SVM model...

Iteration 2 (claude) Performance:
MAE: 389345.9565
RMSE: 461670.0629
MAPE: 8.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 70
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0040, rank=1
   2. Feature_3_t0: importance=0.0023, rank=2
   3. Feature_6_t1: importance=0.0020, rank=3
   4. Feature_8_t2: importance=0.0017, rank=4
   5. Feature_6_t3: importance=0.0015, rank=5
💾 Saved code for iteration 2 to iteration_codes dictionary
🎉 IMPROVEMENT! MAPE improved by 1.02%

📈 Current best MAPE: 8.94%
🔄 Iterations without improvement: 0/5

======================================================================
ITERATION 3
======================================================================
🤖 Calling Claude for iteration 3...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, keeping the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - critical target-related feature
            data[t, 1],  # average daily volume - high importance in previous iteration
            data[t, 2],  # days to cover - key short interest metric
            data[t, 63], # options_put_call_volume_ratio - options sentiment indicator
            data[t, 64], # options_synthetic_short_cost - cost of shorting
            data[t, 65], # options_avg_implied_volatility - market's volatility expectation
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - key metric for short squeeze potential
        # High feature importance in previous iteration
        si_float_ratio = data[t, 0] / max(shares_outstanding, 1e-8)
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - improved version of days to cover
        # High feature importance in previous iteration
        si_adv_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Short volume ratio (average of last 5 days) - recent shorting intensity
        # Refined to use weighted average giving more importance to recent days
        weights = np.array([0.1, 0.15, 0.2, 0.25, 0.3])  # More weight to recent days
        if len(short_volume) >= 5 and len(total_volume) >= 5:
            short_ratios = short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8)
            short_ratio = np.sum(weights * short_ratios) if len(short_ratios) == 5 else np.mean(short_ratios)
        else:
            short_ratio = 0
        eng.append(short_ratio)
        
        # 4. Exponential short volume trend - captures acceleration in shorting with more emphasis on recent data
        # Improved version of short volume trend from previous iteration
        if len(short_volume) >= 10:
            # Use exponential weighting for more emphasis on recent changes
            recent_weights = np.array([0.1, 0.15, 0.2, 0.25, 0.3])
            prev_weights = np.array([0.3, 0.25, 0.2, 0.15, 0.1])
            
            recent_short_avg = np.sum(recent_weights * short_volume[-5:]) if len(short_volume[-5:]) == 5 else np.mean(short_volume[-5:])
            prev_short_avg = np.sum(prev_weights * short_volume[-10:-5]) if len(short_volume[-10:-5]) == 5 else np.mean(short_volume[-10:-5])
            
            denom = max(abs(prev_short_avg), 1e-8)
            short_trend = (recent_short_avg / denom) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 5. Short interest growth rate with smoothing - rate of change in reported short interest
        # Added smoothing to reduce noise
        if t > 1:
            # Use 2-period average for smoother trend
            current_si = data[t, 0]
            prev_si = (data[t-1, 0] + (data[t-2, 0] if t > 1 else data[t-1, 0])) / 2
            denom = max(abs(prev_si), 1e-8)
            si_growth = (current_si / denom) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 6. Parkinson's Volatility - better volatility estimate using high-low range
        # More accurate than standard deviation of returns
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            # Parkinson's volatility formula
            hl_ratio = np.log(high_prices[-5:] / np.maximum(low_prices[-5:], 1e-8))
            park_vol = np.sqrt(np.sum(hl_ratio**2) / (4 * np.log(2) * 5))
        else:
            park_vol = 0
        eng.append(park_vol)
        
        # 7. Options implied volatility to historical volatility ratio - market vs realized volatility
        # High feature importance in previous iteration
        iv_hv_ratio = data[t, 65] / max(park_vol, 1e-8)
        eng.append(iv_hv_ratio)
        
        # 8. Short cost efficiency - cost of shorting relative to potential volatility gain
        # Improved version of cost_vol_ratio from previous iteration
        cost_efficiency = data[t, 64] / max(data[t, 65] * si_float_ratio, 1e-8)
        eng.append(cost_efficiency)
        
        # 9. Improved RSI with volume weighting - oversold/overbought indicator with volume context
        # Volume-weighted RSI provides better signal quality
        if len(close_prices) >= 14 and len(total_volume) >= 14:
            delta = np.diff(close_prices[-15:])
            volume_slice = total_volume[-14:]
            
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            
            # Weight by volume
            vol_gain = np.sum(gain * volume_slice) / max(np.sum(volume_slice), 1e-8)
            vol_loss = np.sum(loss * volume_slice) / max(np.sum(volume_slice), 1e-8)
            
            denom = max(vol_loss, 1e-8)
            rs = vol_gain / denom
            vol_rsi = 100 - (100 / (1 + rs))
        else:
            vol_rsi = 50  # Default neutral value
        eng.append(vol_rsi)
        
        # 10. Bollinger Band Squeeze - volatility contraction/expansion indicator
        # Better than simple BB width, indicates potential breakouts
        if len(close_prices) >= 20:
            # Calculate two different BB widths to see if they're contracting
            sma20 = np.mean(close_prices[-20:])
            sma10 = np.mean(close_prices[-10:])
            std20 = np.std(close_prices[-20:])
            std10 = np.std(close_prices[-10:])
            
            bb_width20 = (2 * std20) / max(sma20, 1e-8)
            bb_width10 = (2 * std10) / max(sma10, 1e-8)
            
            # Squeeze indicator: ratio of recent to longer-term width
            bb_squeeze = bb_width10 / max(bb_width20, 1e-8)
        else:
            bb_squeeze = 1  # Neutral value
        eng.append(bb_squeeze)
        
        # 11. VWAP distance - price relative to volume-weighted average price with normalization
        # Improved version of VWAP ratio from previous iteration
        if len(close_prices) >= 5 and len(total_volume) >= 5:
            vwap = np.sum(close_prices[-5:] * total_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
            # Normalize by ATR to get relative distance
            atr5 = np.mean(high_prices[-5:] - low_prices[-5:])
            vwap_distance = (close_prices[-1] - vwap) / max(atr5, 1e-8)
        else:
            vwap_distance = 0
        eng.append(vwap_distance)
        
        # 12. Short volume intensity - short volume relative to historical average
        # Measures abnormal shorting activity
        if len(short_volume) >= 15:
            recent_short = np.mean(short_volume[-5:])
            historical_short = np.mean(short_volume[-15:])
            short_intensity = recent_short / max(historical_short, 1e-8) - 1
        else:
            short_intensity = 0
        eng.append(short_intensity)
        
        # 13. Options sentiment momentum - change in put-call ratio trend
        # Second derivative of options sentiment
        if t > 1:
            current_pc = data[t, 63]
            prev_pc = data[t-1, 63]
            prev2_pc = data[t-2, 63] if t > 1 else prev_pc
            
            current_change = current_pc - prev_pc
            prev_change = prev_pc - prev2_pc
            
            denom = max(abs(prev_change), 1e-8)
            pc_momentum = current_change / denom
        else:
            pc_momentum = 0
        eng.append(pc_momentum)
        
        # 14. Price momentum with volume confirmation - price trend with volume support
        # More reliable than simple price momentum
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            price_change = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            volume_change = (np.mean(total_volume[-3:]) / max(np.mean(total_volume[-10:-3]), 1e-8)) - 1
            
            # Momentum is stronger when confirmed by volume
            vol_price_momentum = price_change * (1 + volume_change)
        else:
            vol_price_momentum = 0
        eng.append(vol_price_momentum)
        
        # 15. Garman-Klass Volatility - more accurate volatility using OHLC data
        # Superior to simple standard deviation or Parkinson's in many cases
        if len(open_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # Garman-Klass volatility formula
            log_hl = np.log(high_prices[-5:] / np.maximum(low_prices[-5:], 1e-8))**2
            log_co = np.log(close_prices[-5:] / np.maximum(open_prices[-5:], 1e-8))**2
            gk_vol = np.sqrt(np.mean(0.5 * log_hl - (2 * np.log(2) - 1) * log_co))
        else:
            gk_vol = 0
        eng.append(gk_vol)
        
        # 16. Short squeeze potential score - composite indicator of squeeze conditions
        # Combines multiple factors that contribute to short squeeze potential
        short_squeeze_score = (si_float_ratio * 0.4 +  # Short interest to float
                              si_adv_ratio * 0.3 +     # Short interest to volume
                              short_ratio * 0.2 +      # Recent short volume ratio
                              vol_price_momentum * 0.1) # Price momentum with volume
        eng.append(short_squeeze_score)
        
        # 17. Abnormal options activity - unusual options behavior relative to historical
        if t > 0:
            current_options = data[t, 63] * data[t, 65]  # put-call ratio * implied vol
            prev_options = data[t-1, 63] * data[t-1, 65]
            abnormal_options = current_options / max(prev_options, 1e-8) - 1
        else:
            abnormal_options = 0
        eng.append(abnormal_options)
        
        # 18. Short interest to institutional ownership ratio - measures potential for institutional squeeze
        # New feature: approximating institutional ownership as 70% of outstanding shares
        inst_ownership = 0.7 * shares_outstanding  # Approximation of institutional ownership
        si_inst_ratio = data[t, 0] / max(inst_ownership, 1e-8)
        eng.append(si_inst_ratio)
        
        # 19. Liquidity-adjusted short ratio - short interest adjusted for market liquidity
        liquidity_adj_short = si_adv_ratio * (1 + gk_vol)  # Higher volatility makes covering harder
        eng.append(liquidity_adj_short)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 3 (claude) (SVM)
==================================================
Training SVM model...

Iteration 3 (claude) Performance:
MAE: 413143.1293
RMSE: 497559.9556
MAPE: 9.45%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_18_t3: importance=0.0072, rank=1
   2. Feature_1_t3: importance=0.0039, rank=2
   3. Feature_23_t1: importance=0.0027, rank=3
   4. Feature_6_t1: importance=0.0022, rank=4
   5. Feature_17_t3: importance=0.0022, rank=5
💾 Saved code for iteration 3 to iteration_codes dictionary
📊 No significant improvement. Change: -0.51%

📈 Current best MAPE: 8.94%
🔄 Iterations without improvement: 1/5

======================================================================
ITERATION 4
======================================================================
🤖 Calling Claude for iteration 4...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Start with essential raw features to keep
        # Based on feature importance analysis, keeping the most important raw features
        raw_keep = [
            data[t, 0],  # short interest - critical target-related feature
            data[t, 1],  # average daily volume - high importance in previous iteration
            data[t, 2],  # days to cover - key short interest metric
            data[t, 63], # options_put_call_volume_ratio - options sentiment indicator
            data[t, 64], # options_synthetic_short_cost - cost of shorting
            data[t, 65], # options_avg_implied_volatility - market's volatility expectation
            data[t, 66], # shares_outstanding - needed for float-based calculations
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        shares_outstanding = data[t, 66]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - key metric for short squeeze potential
        # High feature importance in previous iteration (Feature_18_t3)
        si_float_ratio = data[t, 0] / max(shares_outstanding, 1e-8)
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - improved version of days to cover
        # High feature importance in previous iteration (Feature_1_t3)
        si_adv_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Weighted short volume ratio - recent shorting intensity with more weight on recent days
        # Improved version with exponential weighting for better recency bias
        if len(short_volume) >= 5 and len(total_volume) >= 5:
            # Exponential weights (sum to 1)
            weights = np.array([0.05, 0.1, 0.15, 0.3, 0.4])
            short_ratios = short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8)
            weighted_short_ratio = np.sum(weights * short_ratios) if len(short_ratios) == 5 else np.mean(short_ratios)
        else:
            weighted_short_ratio = 0
        eng.append(weighted_short_ratio)
        
        # 4. Short interest growth acceleration - second derivative of short interest
        # Captures acceleration in short interest buildup, which is more predictive than simple growth
        if t > 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            growth_current = (si_t / max(si_t1, 1e-8)) - 1
            growth_prev = (si_t1 / max(si_t2, 1e-8)) - 1
            
            si_acceleration = growth_current - growth_prev
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # 5. Relative short volume trend - normalized short volume trend
        # Improved to use ratio of ratios for better normalization
        if len(short_volume) >= 10 and len(total_volume) >= 10:
            recent_ratio = np.mean(short_volume[-5:]) / max(np.mean(total_volume[-5:]), 1e-8)
            prev_ratio = np.mean(short_volume[-10:-5]) / max(np.mean(total_volume[-10:-5]), 1e-8)
            rel_short_trend = recent_ratio / max(prev_ratio, 1e-8) - 1
        else:
            rel_short_trend = 0
        eng.append(rel_short_trend)
        
        # 6. Yang-Zhang Volatility - most comprehensive volatility estimator using OHLC
        # Superior to both Parkinson and Garman-Klass for capturing overnight jumps
        if len(open_prices) >= 5 and len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # Calculate overnight (close-to-open) volatility
            if len(close_prices) > 5:
                overnight_returns = np.log(open_prices[-5:] / np.maximum(np.roll(close_prices, 1)[-5:], 1e-8))
                overnight_vol = np.sum(overnight_returns**2) / 4  # n-1 degrees of freedom
            else:
                overnight_vol = 0
                
            # Calculate open-to-close volatility
            open_close_returns = np.log(close_prices[-5:] / np.maximum(open_prices[-5:], 1e-8))
            open_close_vol = np.sum(open_close_returns**2) / 4  # n-1 degrees of freedom
            
            # Calculate high-low volatility (Parkinson component)
            hl_ratio = np.log(high_prices[-5:] / np.maximum(low_prices[-5:], 1e-8))**2
            hl_vol = np.sum(hl_ratio) / (4 * np.log(2) * 5)
            
            # Yang-Zhang combines these components with optimal weights
            k = 0.34 / (1.34 + (5 + 1) / (5 - 1))  # Optimal k value
            yz_vol = np.sqrt(overnight_vol + k * open_close_vol + (1 - k) * hl_vol)
        else:
            yz_vol = 0
        eng.append(yz_vol)
        
        # 7. Implied volatility to Yang-Zhang volatility ratio - market vs sophisticated realized volatility
        # More accurate than previous IV/HV ratio by using better historical volatility estimate
        iv_yz_ratio = data[t, 65] / max(yz_vol, 1e-8)
        eng.append(iv_yz_ratio)
        
        # 8. Normalized short cost - short cost relative to stock price
        # Better normalization than previous cost efficiency metric
        if len(close_prices) > 0:
            norm_short_cost = data[t, 64] / max(close_prices[-1], 1e-8)
        else:
            norm_short_cost = data[t, 64]
        eng.append(norm_short_cost)
        
        # 9. Connors RSI - enhanced RSI that incorporates streak and percentile rank
        # More responsive than standard RSI for detecting potential reversals
        if len(close_prices) >= 14:
            # Standard RSI calculation
            delta = np.diff(np.append([close_prices[0]], close_prices))
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            
            # Streak calculation
            streak = 0
            for i in range(len(close_prices)-1, 0, -1):
                if close_prices[i] > close_prices[i-1]:
                    if streak >= 0:
                        streak += 1
                    else:
                        streak = 1
                elif close_prices[i] < close_prices[i-1]:
                    if streak <= 0:
                        streak -= 1
                    else:
                        streak = -1
                else:
                    streak = 0
                    
            # Normalize streak to 0-100 scale
            streak_rsi = 50 * (streak + 5) / 10 if abs(streak) <= 5 else 100 if streak > 5 else 0
            
            # Percentile rank of current close
            if len(close_prices) >= 100:
                lookback = 100
            else:
                lookback = len(close_prices)
            
            sorted_closes = np.sort(close_prices[-lookback:])
            rank = np.searchsorted(sorted_closes, close_prices[-1])
            pct_rank = 100 * rank / max(lookback - 1, 1)
            
            # Combine the components (standard formula for Connors RSI)
            connors_rsi = (rsi + streak_rsi + pct_rank) / 3
        else:
            connors_rsi = 50  # Default neutral value
        eng.append(connors_rsi)
        
        # 10. Bollinger Band Width Percentile - relative volatility contraction/expansion
        # Improved version of BB squeeze that provides historical context
        if len(close_prices) >= 20:
            # Calculate current BB width
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            current_bb_width = (2 * std20) / max(sma20, 1e-8)
            
            # Calculate historical BB widths for percentile ranking
            if len(close_prices) >= 60:  # Need enough history for meaningful percentile
                hist_widths = []
                for i in range(min(40, len(close_prices)-20)):
                    window = close_prices[-(20+i+1):-(i+1)]
                    sma = np.mean(window)
                    std = np.std(window)
                    hist_widths.append((2 * std) / max(sma, 1e-8))
                
                # Calculate percentile of current width
                if hist_widths:
                    sorted_widths = np.sort(hist_widths)
                    rank = np.searchsorted(sorted_widths, current_bb_width)
                    bb_width_percentile = 100 * rank / max(len(hist_widths), 1)
                else:
                    bb_width_percentile = 50
            else:
                bb_width_percentile = 50
        else:
            bb_width_percentile = 50  # Neutral value
        eng.append(bb_width_percentile)
        
        # 11. Anchored VWAP distance - price relative to significant VWAP level
        # Uses more significant price points for VWAP calculation
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Find significant price point (local min/max) in the first 5 days
            first_5_high = np.max(high_prices[-10:-5])
            first_5_low = np.min(low_prices[-10:-5])
            last_5_close = close_prices[-5]
            
            # Determine if we should anchor to high or low based on current price
            if last_5_close > first_5_high:
                anchor_price = first_5_high  # Breakout above resistance
            elif last_5_close < first_5_low:
                anchor_price = first_5_low   # Breakdown below support
            else:
                anchor_price = (first_5_high + first_5_low) / 2  # In range
            
            # Calculate VWAP from the anchor point
            vwap_sum = anchor_price * total_volume[-10]  # Initialize with anchor
            vol_sum = total_volume[-10]
            
            for i in range(-9, 0):
                vwap_sum += close_prices[i] * total_volume[i]
                vol_sum += total_volume[i]
            
            anchored_vwap = vwap_sum / max(vol_sum, 1e-8)
            
            # Normalize by ATR
            atr10 = np.mean(high_prices[-10:] - low_prices[-10:])
            anchored_vwap_distance = (close_prices[-1] - anchored_vwap) / max(atr10, 1e-8)
        else:
            anchored_vwap_distance = 0
        eng.append(anchored_vwap_distance)
        
        # 12. Short volume intensity relative to price movement - detects divergence
        # Improved to incorporate price direction for better signal quality
        if len(short_volume) >= 10 and len(close_prices) >= 10:
            recent_short_vol = np.mean(short_volume[-5:])
            prev_short_vol = np.mean(short_volume[-10:-5])
            short_vol_change = recent_short_vol / max(prev_short_vol, 1e-8) - 1
            
            price_change = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
            
            # Divergence occurs when short volume increases but price also increases
            # or when short volume decreases but price also decreases
            short_price_divergence = short_vol_change * price_change
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # 13. Options sentiment change velocity - rate of change in options sentiment
        # Improved to use ratio of ratios for better normalization
        if t > 1:
            current_pc = data[t, 63]
            prev_pc = data[t-1, 63]
            
            # Use ratio instead of difference for better scaling
            pc_velocity = current_pc / max(prev_pc, 1e-8) - 1
        else:
            pc_velocity = 0
        eng.append(pc_velocity)
        
        # 14. Volume-weighted price momentum - price trend with volume confirmation
        # Improved to use log returns and better volume weighting
        if len(close_prices) >= 10 and len(total_volume) >= 10:
            # Calculate log returns
            returns = np.log(close_prices[-10:] / np.maximum(np.roll(close_prices[-10:], 1), 1e-8))[1:]
            
            # Weight returns by relative volume
            vol_weights = total_volume[-9:] / max(np.mean(total_volume[-9:]), 1e-8)
            weighted_returns = returns * vol_weights
            
            # Sum weighted returns for momentum
            vw_momentum = np.sum(weighted_returns)
        else:
            vw_momentum = 0
        eng.append(vw_momentum)
        
        # 15. Short squeeze potential composite - improved composite indicator
        # Refined weights based on feature importance analysis
        short_squeeze_potential = (
            si_float_ratio * 0.35 +           # Short interest to float (high importance)
            si_adv_ratio * 0.25 +             # Short interest to volume (high importance)
            weighted_short_ratio * 0.15 +     # Recent short volume ratio
            (100 - connors_rsi) / 100 * 0.15 + # Oversold indicator (inverted RSI)
            vw_momentum * 0.1                 # Price momentum
        )
        eng.append(short_squeeze_potential)
        
        # 16. Institutional ownership pressure - measures potential for institutional action
        # Improved to incorporate shares outstanding and average volume
        inst_ownership_est = 0.7 * shares_outstanding  # Estimated institutional ownership
        inst_pressure = (data[t, 0] / max(inst_ownership_est, 1e-8)) * (data[t, 1] / max(shares_outstanding, 1e-8))
        eng.append(inst_pressure)
        
        # 17. Liquidity-adjusted short ratio with volatility - short interest adjusted for market conditions
        # Improved to incorporate both volume and volatility
        liquidity_adj_short = si_adv_ratio * (1 + yz_vol) * (1 + weighted_short_ratio)
        eng.append(liquidity_adj_short)
        
        # 18. Short interest to market cap ratio - economic significance of short position
        # New feature that normalizes short interest by company value
        if len(close_prices) > 0:
            market_cap = shares_outstanding * close_prices[-1]
            si_mcap_ratio = data[t, 0] * close_prices[-1] / max(market_cap, 1e-8)
        else:
            si_mcap_ratio = 0
        eng.append(si_mcap_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 4 (claude) (SVM)
==================================================
Training SVM model...

Iteration 4 (claude) Performance:
MAE: 410678.3317
RMSE: 526714.9307
MAPE: 9.50%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 71
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0066, rank=1
   2. Feature_1_t3: importance=0.0038, rank=2
   3. Feature_7_t1: importance=0.0022, rank=3
   4. Feature_24_t1: importance=0.0021, rank=4
   5. Feature_3_t0: importance=0.0017, rank=5
💾 Saved code for iteration 4 to iteration_codes dictionary
📊 No significant improvement. Change: -0.56%

📈 Current best MAPE: 8.94%
🔄 Iterations without improvement: 2/5

======================================================================
ITERATION 5
======================================================================
🤖 Calling Claude for iteration 5...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Keep essential raw features based on feature importance analysis
        raw_keep = [
            data[t, 0],   # short interest - critical target feature
            data[t, 1],   # average daily volume - high importance
            data[t, 2],   # days to cover - key short interest metric
            data[t, 63],  # options_put_call_volume_ratio - options sentiment
            data[t, 64],  # options_synthetic_short_cost - cost of shorting
            data[t, 65],  # options_avg_implied_volatility - volatility expectation
            data[t, 66],  # shares_outstanding - needed for float calculations
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract short interest volume and total trading volume
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - consistently high importance
        # Key metric for short squeeze potential
        si_float_ratio = data[t, 0] / max(data[t, 66], 1e-8)
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - high importance in previous iterations
        # More stable version of days to cover
        si_adv_ratio = data[t, 0] / max(data[t, 1], 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Exponentially weighted short volume ratio - recent shorting intensity
        # Improved with more weight on most recent days for better signal
        if len(short_volume) >= 5 and len(total_volume) >= 5:
            weights = np.array([0.05, 0.1, 0.15, 0.3, 0.4])
            short_ratios = short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8)
            weighted_short_ratio = np.sum(weights * short_ratios) if len(short_ratios) == 5 else np.mean(short_ratios)
        else:
            weighted_short_ratio = 0
        eng.append(weighted_short_ratio)
        
        # 4. Short interest growth rate - first derivative of short interest
        # Captures momentum in short interest buildup
        if t > 0:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_growth = (si_t / max(si_t1, 1e-8)) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 5. Short interest growth acceleration - second derivative
        # Captures acceleration in short interest buildup
        if t > 2:
            si_t = data[t, 0]
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            growth_current = (si_t / max(si_t1, 1e-8)) - 1
            growth_prev = (si_t1 / max(si_t2, 1e-8)) - 1
            
            si_acceleration = growth_current - growth_prev
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # 6. Recent price trend - normalized price change over last 5 days
        # Captures recent momentum that might trigger short covering
        if len(close_prices) >= 5:
            price_change_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        else:
            price_change_5d = 0
        eng.append(price_change_5d)
        
        # 7. Price volatility (ATR-based) - measure of recent price volatility
        # Higher volatility can trigger short covering
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # True Range calculation
            tr_values = []
            for i in range(-5, -1):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1]) if i > -5 else 0
                low_close = abs(low_prices[i] - close_prices[i-1]) if i > -5 else 0
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            atr = np.mean(tr_values) if tr_values else 0
            # Normalize by price
            norm_atr = atr / max(close_prices[-1], 1e-8)
        else:
            norm_atr = 0
        eng.append(norm_atr)
        
        # 8. Short volume intensity relative to price movement
        # Detects divergence between shorting activity and price movement
        if len(short_volume) >= 10 and len(close_prices) >= 10 and len(total_volume) >= 10:
            recent_short_ratio = np.mean(short_volume[-5:]) / max(np.mean(total_volume[-5:]), 1e-8)
            prev_short_ratio = np.mean(short_volume[-10:-5]) / max(np.mean(total_volume[-10:-5]), 1e-8)
            short_ratio_change = recent_short_ratio / max(prev_short_ratio, 1e-8) - 1
            
            price_change = close_prices[-1] / max(close_prices[-5], 1e-8) - 1
            
            # Positive value indicates divergence (more shorting but price rising, or less shorting but price falling)
            short_price_divergence = short_ratio_change * price_change
        else:
            short_price_divergence = 0
        eng.append(short_price_divergence)
        
        # 9. Relative volume trend - volume surge detection
        # Volume surges often precede short squeezes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = np.mean(total_volume[-10:-5])
            rel_vol_trend = recent_vol / max(prev_vol, 1e-8) - 1
        else:
            rel_vol_trend = 0
        eng.append(rel_vol_trend)
        
        # 10. Implied volatility to historical volatility ratio
        # Market's expectation vs. realized volatility - predictive of future moves
        if len(high_prices) >= 10 and len(low_prices) >= 10:
            # Calculate historical volatility (simple version)
            price_range = np.mean(high_prices[-10:] - low_prices[-10:])
            avg_price = np.mean(close_prices[-10:])
            hist_vol = price_range / max(avg_price, 1e-8)
            
            # Ratio of implied to historical
            iv_hv_ratio = data[t, 65] / max(hist_vol, 1e-8)
        else:
            iv_hv_ratio = 1  # Neutral value
        eng.append(iv_hv_ratio)
        
        # 11. RSI (Relative Strength Index) - momentum oscillator
        # Extreme values can indicate potential reversals
        if len(close_prices) >= 14:
            delta = np.diff(np.append([close_prices[0]], close_prices))
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value
        eng.append(rsi)
        
        # 12. Bollinger Band Width - volatility contraction/expansion
        # Tight bands often precede significant price moves
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            bb_width = (2 * std20) / max(sma20, 1e-8)
        else:
            bb_width = 0.1  # Default value
        eng.append(bb_width)
        
        # 13. Short squeeze potential composite - combined indicator
        # Weighted combination of key short squeeze factors
        if len(eng) >= 12:  # Make sure all required components exist
            short_squeeze_potential = (
                si_float_ratio * 0.3 +              # Short interest to float
                si_adv_ratio * 0.2 +                # Short interest to volume
                weighted_short_ratio * 0.15 +       # Recent short volume ratio
                (100 - rsi) / 100 * 0.15 +          # Oversold indicator (inverted RSI)
                price_change_5d * 0.1 +             # Recent price momentum
                rel_vol_trend * 0.1                 # Volume trend
            )
        else:
            short_squeeze_potential = 0
        eng.append(short_squeeze_potential)
        
        # 14. Institutional ownership pressure
        # Measures potential for institutional action based on short interest and float
        shares_outstanding = data[t, 66]
        inst_ownership_est = 0.7 * shares_outstanding  # Estimated institutional ownership
        inst_pressure = (data[t, 0] / max(inst_ownership_est, 1e-8)) * (data[t, 1] / max(shares_outstanding, 1e-8))
        eng.append(inst_pressure)
        
        # 15. Short interest to market cap ratio
        # Economic significance of short position relative to company value
        if len(close_prices) > 0:
            market_cap = shares_outstanding * close_prices[-1]
            si_mcap_ratio = data[t, 0] * close_prices[-1] / max(market_cap, 1e-8)
        else:
            si_mcap_ratio = 0
        eng.append(si_mcap_ratio)
        
        # 16. Options sentiment change - rate of change in put/call ratio
        # Rapid changes in options sentiment can precede short squeezes
        if t > 0:
            current_pc = data[t, 63]
            prev_pc = data[t-1, 63]
            pc_change = current_pc / max(prev_pc, 1e-8) - 1
        else:
            pc_change = 0
        eng.append(pc_change)
        
        # 17. Short cost efficiency - cost of shorting relative to potential profit
        # Higher values indicate more expensive shorting relative to expected movement
        short_cost = data[t, 64]
        if len(close_prices) > 0 and data[t, 65] > 0:  # Use implied vol to estimate potential movement
            expected_move = close_prices[-1] * data[t, 65] * np.sqrt(30/365)  # Expected 30-day move
            cost_efficiency = short_cost / max(expected_move, 1e-8)
        else:
            cost_efficiency = short_cost
        eng.append(cost_efficiency)
        
        # 18. Liquidity-adjusted short ratio
        # Short interest adjusted for market liquidity conditions
        liquidity_adj_short = si_adv_ratio * (1 + bb_width) * (1 + weighted_short_ratio)
        eng.append(liquidity_adj_short)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 5 (claude) (SVM)
==================================================
Training SVM model...

Iteration 5 (claude) Performance:
MAE: 434311.0230
RMSE: 546540.0561
MAPE: 10.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0063, rank=1
   2. Feature_1_t3: importance=0.0037, rank=2
   3. Feature_22_t3: importance=0.0020, rank=3
   4. Feature_7_t1: importance=0.0020, rank=4
   5. Feature_9_t2: importance=0.0018, rank=5
💾 Saved code for iteration 5 to iteration_codes dictionary
📊 No significant improvement. Change: -1.16%

📈 Current best MAPE: 8.94%
🔄 Iterations without improvement: 3/5

======================================================================
ITERATION 6
======================================================================
🤖 Calling Claude for iteration 6...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Extract key data components for easier access
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        put_call_ratio = data[t, 63]
        short_cost = data[t, 64]
        implied_vol = data[t, 65]
        shares_outstanding = data[t, 66]
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features based on feature importance analysis
        # Feature_20_t3, Feature_1_t3, and Feature_22_t3 were top performers
        raw_keep = [
            short_interest,                # Critical target feature
            avg_daily_volume,              # High importance in previous iterations
            days_to_cover,                 # Key short interest metric
            put_call_ratio,                # Options sentiment indicator
            short_cost,                    # Cost of shorting
            implied_vol,                   # Market's volatility expectation
            shares_outstanding,            # Needed for float calculations
            close_prices[-1],              # Latest closing price
        ]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - consistently high importance
        # Key metric for short squeeze potential
        si_float_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - high importance
        # More stable version of days to cover
        si_adv_ratio = short_interest / max(avg_daily_volume, 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Exponentially weighted short volume ratio - recent shorting intensity
        # Improved with more weight on most recent days
        if len(short_volume) >= 5 and len(total_volume) >= 5:
            weights = np.array([0.05, 0.1, 0.15, 0.3, 0.4])
            short_ratios = short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8)
            weighted_short_ratio = np.sum(weights * short_ratios) if len(short_ratios) == 5 else np.mean(short_ratios)
        else:
            weighted_short_ratio = 0
        eng.append(weighted_short_ratio)
        
        # 4. Short interest growth rate - first derivative of short interest
        # Captures momentum in short interest buildup
        if t > 0:
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_growth = (si_t / max(si_t1, 1e-8)) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 5. Short interest growth acceleration - second derivative
        # Captures acceleration in short interest buildup
        if t > 2:
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            growth_current = (si_t / max(si_t1, 1e-8)) - 1
            growth_prev = (si_t1 / max(si_t2, 1e-8)) - 1
            
            si_acceleration = growth_current - growth_prev
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # 6. Recent price trend - normalized price change over last 5 days
        # Captures recent momentum that might trigger short covering
        if len(close_prices) >= 5:
            price_change_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        else:
            price_change_5d = 0
        eng.append(price_change_5d)
        
        # 7. Price volatility (ATR-based) - measure of recent price volatility
        # Higher volatility can trigger short covering
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # True Range calculation
            tr_values = []
            for i in range(-5, -1):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1]) if i > -5 else 0
                low_close = abs(low_prices[i] - close_prices[i-1]) if i > -5 else 0
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            atr = np.mean(tr_values) if tr_values else 0
            # Normalize by price
            norm_atr = atr / max(close_prices[-1], 1e-8)
        else:
            norm_atr = 0
        eng.append(norm_atr)
        
        # 8. Relative volume trend - volume surge detection
        # Volume surges often precede short squeezes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = np.mean(total_volume[-10:-5])
            rel_vol_trend = recent_vol / max(prev_vol, 1e-8) - 1
        else:
            rel_vol_trend = 0
        eng.append(rel_vol_trend)
        
        # 9. RSI (Relative Strength Index) - momentum oscillator
        # Extreme values can indicate potential reversals
        if len(close_prices) >= 14:
            delta = np.diff(np.append([close_prices[0]], close_prices))
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value
        eng.append(rsi)
        
        # 10. Bollinger Band Width - volatility contraction/expansion
        # Tight bands often precede significant price moves
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            bb_width = (2 * std20) / max(sma20, 1e-8)
        else:
            bb_width = 0.1  # Default value
        eng.append(bb_width)
        
        # 11. Short squeeze potential composite - combined indicator
        # Weighted combination of key short squeeze factors
        short_squeeze_potential = (
            si_float_ratio * 0.3 +              # Short interest to float
            si_adv_ratio * 0.2 +                # Short interest to volume
            weighted_short_ratio * 0.15 +       # Recent short volume ratio
            (100 - min(max(rsi, 0), 100)) / 100 * 0.15 +  # Oversold indicator (inverted RSI)
            price_change_5d * 0.1 +             # Recent price momentum
            rel_vol_trend * 0.1                 # Volume trend
        )
        eng.append(short_squeeze_potential)
        
        # 12. Short interest to market cap ratio
        # Economic significance of short position relative to company value
        if len(close_prices) > 0:
            market_cap = shares_outstanding * close_prices[-1]
            si_mcap_ratio = short_interest * close_prices[-1] / max(market_cap, 1e-8)
        else:
            si_mcap_ratio = 0
        eng.append(si_mcap_ratio)
        
        # 13. Options sentiment change - rate of change in put/call ratio
        # Rapid changes in options sentiment can precede short squeezes
        if t > 0:
            current_pc = put_call_ratio
            prev_pc = data[t-1, 63]
            pc_change = current_pc / max(prev_pc, 1e-8) - 1
        else:
            pc_change = 0
        eng.append(pc_change)
        
        # 14. Short cost efficiency - cost of shorting relative to potential profit
        # Higher values indicate more expensive shorting relative to expected movement
        if len(close_prices) > 0 and implied_vol > 0:  # Use implied vol to estimate potential movement
            expected_move = close_prices[-1] * implied_vol * np.sqrt(30/365)  # Expected 30-day move
            cost_efficiency = short_cost / max(expected_move, 1e-8)
        else:
            cost_efficiency = short_cost
        eng.append(cost_efficiency)
        
        # 15. Short volume trend - acceleration in shorting activity
        # Captures changes in shorting behavior
        if len(short_volume) >= 10:
            recent_short = np.mean(short_volume[-5:])
            prev_short = np.mean(short_volume[-10:-5])
            short_trend = recent_short / max(prev_short, 1e-8) - 1
        else:
            short_trend = 0
        eng.append(short_trend)
        
        # 16. Price momentum relative to short interest - divergence indicator
        # Captures potential short squeeze setup when price rises despite high short interest
        if t > 0 and len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            price_si_divergence = price_momentum - si_change
        else:
            price_si_divergence = 0
        eng.append(price_si_divergence)
        
        # 17. MACD-based momentum signal - trend strength indicator
        # Captures strength and direction of price trend
        if len(close_prices) >= 26:
            ema12 = np.mean(close_prices[-12:])  # Simplified EMA
            ema26 = np.mean(close_prices[-26:])
            macd = ema12 - ema26
            signal = np.mean(close_prices[-9:]) - ema26  # Simplified signal line
            macd_histogram = macd - signal
            # Normalize by price
            norm_macd = macd_histogram / max(close_prices[-1], 1e-8)
        else:
            norm_macd = 0
        eng.append(norm_macd)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 6 (claude) (SVM)
==================================================
Training SVM model...

Iteration 6 (claude) Performance:
MAE: 405717.5018
RMSE: 493417.1233
MAPE: 9.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 68
   • Highly important features (top 5%): 44

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0044, rank=1
   2. Feature_1_t1: importance=0.0032, rank=2
   3. Feature_8_t1: importance=0.0029, rank=3
   4. Feature_3_t3: importance=0.0022, rank=4
   5. Feature_3_t0: importance=0.0021, rank=5
💾 Saved code for iteration 6 to iteration_codes dictionary
📊 No significant improvement. Change: -0.35%

📈 Current best MAPE: 8.94%
🔄 Iterations without improvement: 4/5

======================================================================
ITERATION 7
======================================================================
🤖 Calling Claude for iteration 7...
✅ Claude response received!

📝 Claude's Response:
--------------------------------------------------
```python
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Extract key data components for easier access
        short_interest = data[t, 0]
        avg_daily_volume = data[t, 1]
        days_to_cover = data[t, 2]
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        put_call_ratio = data[t, 63]
        short_cost = data[t, 64]
        implied_vol = data[t, 65]
        shares_outstanding = data[t, 66]
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Keep essential raw features based on feature importance analysis
        # Feature_1_t3 and Feature_1_t1 were top performers in iteration 6
        raw_keep = [
            short_interest,                # Critical target feature
            avg_daily_volume,              # High importance in previous iterations
            days_to_cover,                 # Key short interest metric
            put_call_ratio,                # Options sentiment indicator
            short_cost,                    # Cost of shorting
            implied_vol,                   # Market's volatility expectation
            close_prices[-1],              # Latest closing price
        ]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to float ratio - consistently high importance
        # Key metric for short squeeze potential
        si_float_ratio = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_float_ratio)
        
        # 2. Short interest to average daily volume ratio - high importance
        # More stable version of days to cover
        si_adv_ratio = short_interest / max(avg_daily_volume, 1e-8)
        eng.append(si_adv_ratio)
        
        # 3. Exponentially weighted short volume ratio - recent shorting intensity
        # Improved with more weight on most recent days
        if len(short_volume) >= 5 and len(total_volume) >= 5:
            weights = np.array([0.05, 0.1, 0.15, 0.3, 0.4])
            short_ratios = short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8)
            weighted_short_ratio = np.sum(weights * short_ratios) if len(short_ratios) == 5 else np.mean(short_ratios)
        else:
            weighted_short_ratio = 0
        eng.append(weighted_short_ratio)
        
        # 4. Short interest growth rate - first derivative of short interest
        # Captures momentum in short interest buildup
        if t > 0:
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_growth = (si_t / max(si_t1, 1e-8)) - 1
        else:
            si_growth = 0
        eng.append(si_growth)
        
        # 5. Short interest growth acceleration - second derivative
        # Captures acceleration in short interest buildup
        if t > 2:
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            growth_current = (si_t / max(si_t1, 1e-8)) - 1
            growth_prev = (si_t1 / max(si_t2, 1e-8)) - 1
            
            si_acceleration = growth_current - growth_prev
        else:
            si_acceleration = 0
        eng.append(si_acceleration)
        
        # 6. Recent price trend - normalized price change over last 5 days
        # Captures recent momentum that might trigger short covering
        if len(close_prices) >= 5:
            price_change_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        else:
            price_change_5d = 0
        eng.append(price_change_5d)
        
        # 7. Price volatility (ATR-based) - measure of recent price volatility
        # Higher volatility can trigger short covering
        if len(high_prices) >= 5 and len(low_prices) >= 5 and len(close_prices) >= 5:
            # True Range calculation
            tr_values = []
            for i in range(-5, -1):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1]) if i > -5 else 0
                low_close = abs(low_prices[i] - close_prices[i-1]) if i > -5 else 0
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            atr = np.mean(tr_values) if tr_values else 0
            # Normalize by price
            norm_atr = atr / max(close_prices[-1], 1e-8)
        else:
            norm_atr = 0
        eng.append(norm_atr)
        
        # 8. Relative volume trend - volume surge detection
        # Volume surges often precede short squeezes
        if len(total_volume) >= 10:
            recent_vol = np.mean(total_volume[-5:])
            prev_vol = np.mean(total_volume[-10:-5])
            rel_vol_trend = recent_vol / max(prev_vol, 1e-8) - 1
        else:
            rel_vol_trend = 0
        eng.append(rel_vol_trend)
        
        # 9. RSI (Relative Strength Index) - momentum oscillator
        # Extreme values can indicate potential reversals
        if len(close_prices) >= 14:
            delta = np.diff(np.append([close_prices[0]], close_prices))
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain[-14:])
            avg_loss = np.mean(loss[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value
        eng.append(rsi)
        
        # 10. Short squeeze potential composite - combined indicator
        # Weighted combination of key short squeeze factors
        short_squeeze_potential = (
            si_float_ratio * 0.3 +              # Short interest to float
            si_adv_ratio * 0.2 +                # Short interest to volume
            weighted_short_ratio * 0.15 +       # Recent short volume ratio
            (100 - min(max(rsi, 0), 100)) / 100 * 0.15 +  # Oversold indicator (inverted RSI)
            price_change_5d * 0.1 +             # Recent price momentum
            rel_vol_trend * 0.1                 # Volume trend
        )
        eng.append(short_squeeze_potential)
        
        # 11. Short interest to market cap ratio
        # Economic significance of short position relative to company value
        if len(close_prices) > 0:
            market_cap = shares_outstanding * close_prices[-1]
            si_mcap_ratio = short_interest * close_prices[-1] / max(market_cap, 1e-8)
        else:
            si_mcap_ratio = 0
        eng.append(si_mcap_ratio)
        
        # 12. Options sentiment change - rate of change in put/call ratio
        # Rapid changes in options sentiment can precede short squeezes
        if t > 0:
            current_pc = put_call_ratio
            prev_pc = data[t-1, 63]
            pc_change = current_pc / max(prev_pc, 1e-8) - 1
        else:
            pc_change = 0
        eng.append(pc_change)
        
        # 13. Price momentum relative to short interest - divergence indicator
        # Captures potential short squeeze setup when price rises despite high short interest
        if t > 0 and len(close_prices) >= 5:
            price_momentum = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            si_change = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            price_si_divergence = price_momentum - si_change
        else:
            price_si_divergence = 0
        eng.append(price_si_divergence)
        
        # 14. Short volume intensity - ratio of short volume to total volume
        # Direct measure of shorting activity intensity
        if len(short_volume) >= 5 and len(total_volume) >= 5:
            short_intensity = np.sum(short_volume[-5:]) / max(np.sum(total_volume[-5:]), 1e-8)
        else:
            short_intensity = 0
        eng.append(short_intensity)
        
        # 15. Short cost to implied volatility ratio
        # Measures if shorting cost is justified by expected volatility
        cost_vol_ratio = short_cost / max(implied_vol, 1e-8)
        eng.append(cost_vol_ratio)
        
        # 16. Short interest concentration - how much of float is shorted
        # Higher concentration increases squeeze risk
        si_concentration = short_interest / max(shares_outstanding - short_interest, 1e-8)
        eng.append(si_concentration)
        
        # 17. Price momentum strength - normalized by volatility
        # Stronger momentum relative to volatility increases squeeze probability
        if len(close_prices) >= 10 and norm_atr > 0:
            price_change_10d = (close_prices[-1] / max(close_prices[-10], 1e-8)) - 1
            momentum_strength = price_change_10d / max(norm_atr, 1e-8)
        else:
            momentum_strength = 0
        eng.append(momentum_strength)
        
        # 18. NEW: Bollinger Band Squeeze Indicator
        # Detects periods of low volatility that often precede significant moves
        if len(close_prices) >= 20:
            sma20 = np.mean(close_prices[-20:])
            std20 = np.std(close_prices[-20:])
            upper_band = sma20 + 2 * std20
            lower_band = sma20 - 2 * std20
            band_width = (upper_band - lower_band) / max(sma20, 1e-8)
            
            # Normalize to 0-1 range where lower values indicate tighter squeeze
            bb_squeeze = 1 - min(band_width / 0.1, 1.0)  # 0.1 is a typical width threshold
        else:
            bb_squeeze = 0.5  # Neutral value
        eng.append(bb_squeeze)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
--------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Function executed successfully and passed validation!

🔧 Applying feature selection using claude function...
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Training data shape: (106, 4, 97) -> (106, 4, 25)
Validation data shape: (36, 4, 97) -> (36, 4, 25)

==================================================
Training Iteration 7 (claude) (SVM)
==================================================
Training SVM model...

Iteration 7 (claude) Performance:
MAE: 427598.6142
RMSE: 506372.8683
MAPE: 9.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 61
   • Highly important features (top 5%): 27

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0044, rank=1
   2. Feature_9_t0: importance=0.0043, rank=2
   3. Feature_22_t1: importance=0.0021, rank=3
   4. Feature_22_t3: importance=0.0021, rank=4
   5. Feature_7_t1: importance=0.0021, rank=5
💾 Saved code for iteration 7 to iteration_codes dictionary
📊 No significant improvement. Change: -0.91%

🛑 Stopping: No improvement for 5 consecutive iterations

🎯 Final Evaluation on Test Set (Unseen Data)
======================================================================
Using train+validation data for final model training to maximize data usage
Combined train+val data shape: (142, 4, 97)
Test data shape: (36, 4, 97)

📊 BASELINE EVALUATION (Raw Features, Train+Val → Test):

==================================================
Training Baseline Final (Raw Features) (SVM)
==================================================
Training SVM model...

Baseline Final (Raw Features) Performance:
MAE: 494427.6401
RMSE: 646601.0801
MAPE: 9.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 315
   • Highly important features (top 5%): 175

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0015, rank=1
   2. Feature_69_t3: importance=0.0014, rank=2
   3. Feature_72_t3: importance=0.0013, rank=3
   4. Feature_71_t3: importance=0.0013, rank=4
   5. Feature_73_t3: importance=0.0007, rank=5
   Baseline MAPE: 9.53%
   Baseline MAE: 494427.6401
   Baseline RMSE: 646601.0801

🔧 BEST MODEL EVALUATION (Processed Features, Train+Val → Test):
Applying best feature engineering to all data...
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Processed train+val shape: (142, 4, 25)
Processed test shape: (36, 4, 25)

==================================================
Training Best Model Final (Processed Features) (SVM)
==================================================
Training SVM model...

Best Model Final (Processed Features) Performance:
MAE: 493083.3228
RMSE: 644183.6246
MAPE: 9.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0036, rank=1
   2. Feature_6_t1: importance=0.0025, rank=2
   3. Feature_3_t0: importance=0.0017, rank=3
   4. Feature_6_t0: importance=0.0012, rank=4
   5. Feature_6_t2: importance=0.0011, rank=5

📊 Best Model Test Set Performance:
   MAPE: 9.44%
   MAE: 493083.3228
   RMSE: 644183.6246

🎯 IMPROVEMENT OVER BASELINE:
   Baseline MAPE: 9.53%
   Best Model MAPE: 9.44%
   Absolute Improvement: 0.09%
   Relative Improvement: 0.9%

======================================================================
ITERATION PERFORMANCE SUMMARY
======================================================================

📊 VALIDATION MAPE TREND:
--------------------------------------------------------------------------------
Iteration  Model                     Validation MAPE Improvement from Last
--------------------------------------------------------------------------------
0          Baseline                  10.54           N/A                 
1          Iteration 1               9.95            +0.58%              
2          Iteration 2               8.94            +1.02%              
3          Iteration 3               9.45            -0.51%              
4          Iteration 4               9.50            -0.56%              
5          Iteration 5               10.10           -1.16%              
6          Iteration 6               9.28            -0.35%              
7          Iteration 7               9.84            -0.91%              
--------------------------------------------------------------------------------
🏆 Best: Iteration 2 - MAPE: 8.94%
✅ Saved AROC results to cache/AROC_iterative_results_enhanced.pkl
✅ Summary report saved for AROC

🎉 Process completed successfully for AROC!

================================================================================
GENERATING UNIVERSAL FEATURE ENGINEERING CODE
================================================================================
Successfully processed 12 tickers: ABCB, EIG, FSS, ABM, IART, SRPT, EXTR, SCSC, SLG, HL, ANDE, AROC

🤖 Calling Claude to generate universal feature engineering code...
❌ Universal function execution failed: operands could not be broadcast together with shapes (4,) (5,) 
⚠️ Universal code validation failed on attempt 1. Retrying...
✅ Universal function validation passed! Output shape: (4, 25)
✅ Universal code generated and validated successfully!
✅ Universal code response received!

📝 Claude's Universal Feature Engineering Code:
------------------------------------------------------------
```python
def construct_features(data):
    """
    Universal feature construction function for short interest prediction.
    
    Args:
        data: numpy array of shape (lookback_window, 97)
        
    Returns:
        numpy array of shape (lookback_window, 25)
    """
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Essential raw features to keep (consistently important across tickers)
        raw_keep = [
            data[t, 0],  # short interest
            data[t, 1],  # average daily volume
            data[t, 2],  # days to cover
        ]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep most recent close price
        raw_keep.append(close_prices[-1])
        
        # Keep key options data
        raw_keep.append(data[t, 63])  # options_put_call_volume_ratio
        raw_keep.append(data[t, 65])  # options_avg_implied_volatility
        raw_keep.append(data[t, 66])  # shares_outstanding
        
        # Extract short volume and total volume data
        short_volume = data[t, 67:82]
        total_volume = data[t, 82:97]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short Volume Ratio (daily short volume / daily total volume)
        short_volume_ratio = np.zeros_like(short_volume)
        for i in range(len(short_volume)):
            denom = max(abs(total_volume[i]), 1e-8)
            short_volume_ratio[i] = short_volume[i] / denom
        
        # Average short volume ratio (recent days weighted more)
        if len(short_volume_ratio) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            weighted_svr = np.sum(weights * short_volume_ratio[-5:])
            eng.append(weighted_svr)
        else:
            eng.append(np.mean(short_volume_ratio))
        
        # 2. Short Interest to Float Ratio
        si_to_float = data[t, 0] / max(abs(data[t, 66]), 1e-8)
        eng.append(si_to_float)
        
        # 3. Short Interest to Volume Ratio
        si_to_volume = data[t, 0] / max(abs(data[t, 1]), 1e-8)
        eng.append(si_to_volume)
        
        # 4. Price Momentum (5-day)
        if len(close_prices) >= 5:
            momentum_5d = close_prices[-1] / max(abs(close_prices[-5]), 1e-8) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Price Volatility
        if len(close_prices) >= 5:
            returns = np.diff(close_prices[-5:]) / np.maximum(close_prices[-5:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. RSI (Relative Strength Index)
        if len(close_prices) >= 5:
            delta = np.diff(close_prices[-5:])
            gain = np.where(delta > 0, delta, 0)
            loss = np.where(delta < 0, -delta, 0)
            avg_gain = np.mean(gain) if len(gain) > 0 else 0
            avg_loss = np.mean(loss) if len(loss) > 0 else 0
            denom = max(abs(avg_loss), 1e-8)
            rs = avg_gain / denom
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Default value if not enough data
        eng.append(rsi)
        
        # 7. Short Volume Trend
        if len(short_volume) >= 5:
            recent_short = np.mean(short_volume[-3:])
            prev_short = np.mean(short_volume[-5:-2])
            denom = max(abs(prev_short), 1e-8)
            short_vol_trend = recent_short / denom - 1
        else:
            short_vol_trend = 0
        eng.append(short_vol_trend)
        
        # 8. Bollinger Band Position
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            upper_band = sma + 2 * std
            lower_band = sma - 2 * std
            band_width = upper_band - lower_band
            denom = max(abs(band_width), 1e-8)
            bb_position = (close_prices[-1] - lower_band) / denom
            bb_position = 2 * bb_position - 1  # Normalize to [-1, 1]
        else:
            bb_position = 0
        eng.append(bb_position)
        
        # 9. Short Interest Momentum
        if t > 0:
            prev_si = data[t-1, 0]
            denom = max(abs(prev_si), 1e-8)
            si_momentum = (data[t, 0] / denom) - 1
        else:
            si_momentum = 0
        eng.append(si_momentum)
        
        # 10. Options Pressure Indicator
        put_call_ratio = data[t, 63]
        implied_vol = data[t, 65]
        options_pressure = (put_call_ratio - 1.0) * (1 + implied_vol/100)
        eng.append(options_pressure)
        
        # 11. Volume Spike Indicator
        if len(total_volume) >= 5:
            recent_vol = total_volume[-1]
            avg_vol = np.mean(total_volume[-5:])
            denom = max(abs(avg_vol), 1e-8)
            vol_spike = recent_vol / denom - 1
        else:
            vol_spike = 0
        eng.append(vol_spike)
        
        # 12. Short Squeeze Potential
        squeeze_potential = si_to_float * data[t, 2] * (1 + volatility)
        eng.append(squeeze_potential)
        
        # 13. MACD Signal
        if len(close_prices) >= 12:
            ema12 = np.mean(close_prices[-12:])
            ema26 = np.mean(close_prices[-min(26, len(close_prices)):])
            macd = ema12 - ema26
            denom = max(abs(np.mean(close_prices[-12:])), 1e-8)
            macd_normalized = macd / denom
        else:
            macd_normalized = 0
        eng.append(macd_normalized)
        
        # 14. Short Volume Acceleration
        if len(short_volume) >= 3:
            diff1 = short_volume[-1] - short_volume[-2]
            diff2 = short_volume[-2] - short_volume[-3]
            short_vol_accel = diff1 - diff2
            denom = max(abs(np.mean(short_volume[-3:])), 1e-8)
            short_vol_accel_norm = short_vol_accel / denom
        else:
            short_vol_accel_norm = 0
        eng.append(short_vol_accel_norm)
        
        # 15. Short Interest to Implied Volatility Ratio
        si_to_iv_ratio = data[t, 0] / max(abs(data[t, 65]), 1e-8)
        eng.append(si_to_iv_ratio)
        
        # 16. Price Gap Analysis
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            denom = max(abs(close_prices[-2]), 1e-8)
            gap = open_prices[-1] / denom - 1
            gap_indicator = np.tanh(gap * 10)  # Scale to emphasize significant gaps
        else:
            gap_indicator = 0
        eng.append(gap_indicator)
        
        # 17. Short Interest Efficiency Ratio
        if len(close_prices) >= 5 and len(short_volume) >= 5:
            returns = []
            for i in range(1, 5):
                denom = max(abs(close_prices[-i-1]), 1e-8)
                ret = close_prices[-i] / denom - 1
                returns.append(ret)
            
            short_vol_norm = short_volume[-5:-1] / np.mean(short_volume[-5:-1])
            returns_norm = np.array(returns)
            
            # Simple dot product as correlation proxy
            efficiency = -np.sum(short_vol_norm * returns_norm) / 4
            short_efficiency = np.tanh(efficiency * 3)
        else:
            short_efficiency = 0
        eng.append(short_efficiency)
        
        # 18. Intraday Range Volatility
        if len(high_prices) >= 5 and len(low_prices) >= 5:
            ranges = []
            for i in range(5):
                denom = max(abs(low_prices[-i-1]), 1e-8)
                daily_range = (high_prices[-i-1] - low_prices[-i-1]) / denom
                ranges.append(daily_range)
            
            range_volatility = np.mean(ranges)
        else:
            range_volatility = 0
        eng.append(range_volatility)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size by padding or truncating
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        features[t] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
```
------------------------------------------------------------
✅ Successfully Extracted Function Code!
Test output shape: (4, 25)
✅ Universal function extracted and validated successfully!
💾 Universal code saved to: cache/universal_feature_engineering_code.py
💾 Comprehensive results saved to: cache/comprehensive_multi_ticker_results.pkl

================================================================================
ITERATIVE PROCESS SUMMARY
================================================================================

ABCB:
  Best MAPE: 8.30%
  Improvement: 0.44%
  Feature count: 25
  Iterations: 10

EIG:
  Best MAPE: 14.81%
  Improvement: 1.01%
  Feature count: 25
  Iterations: 8

FSS:
  Best MAPE: 11.69%
  Improvement: -0.61%
  Feature count: 25
  Iterations: 5

ABM:
  Best MAPE: 13.58%
  Improvement: 2.33%
  Feature count: 25
  Iterations: 10

IART:
  Best MAPE: 8.51%
  Improvement: 1.52%
  Feature count: 25
  Iterations: 10

SRPT:
  Best MAPE: 8.05%
  Improvement: 1.33%
  Feature count: 25
  Iterations: 6

EXTR:
  Best MAPE: 7.34%
  Improvement: 0.30%
  Feature count: 25
  Iterations: 6

SCSC:
  Best MAPE: 14.78%
  Improvement: -0.63%
  Feature count: 25
  Iterations: 5

SLG:
  Best MAPE: 5.75%
  Improvement: -0.06%
  Feature count: 25
  Iterations: 5

HL:
  Best MAPE: 9.87%
  Improvement: 1.08%
  Feature count: 25
  Iterations: 8

ANDE:
  Best MAPE: 14.43%
  Improvement: 0.86%
  Feature count: 25
  Iterations: 7

AROC:
  Best MAPE: 8.94%
  Improvement: 1.60%
  Feature count: 25
  Iterations: 7

================================================================================
STARTING VALIDATION PHASE
================================================================================
Testing universal feature engineering on all available tickers...

================================================================================
TESTING UNIVERSAL FEATURE ENGINEERING ON MULTIPLE TICKERS
================================================================================
Testing on 464 tickers: AAP, AAT, ABCB, ABG, ABM, ABR, ACAD, ACHC, ACIW, ACLS, ADMA, ADNT, ADUS, AEIS, AEO, AGO, AGYS, AHH, AIN, AIR, AKR, AL, ALEX, ALG, ALGT, ALKS, ALRM, AMN, AMPH, AMSF, AMWD, ANDE, ANGI, ANIP, AOSL, APAM, APLE, APOG, ARCB, ARI, AROC, ARR, ARWR, ASIX, ASTE, ATEN, ATGE, AVA, AWI, AWR, AXL, AZZ, BANC, BANF, BANR, BCC, BCPC, BDN, BFS, BHE, BJRI, BKE, BKU, BL, BLFS, BLMN, BMI, BOH, BOOT, BOX, BRC, BTU, BWA, BXMT, CABO, CAKE, CAL, CALM, CALX, CARG, CARS, CASH, CATY, CBRL, CBU, CC, CCOI, CCS, CE, CENT, CENTA, CENX, CEVA, CFFN, CHCO, CHEF, CLB, CNK, CNMD, CNS, CNXN, COHU, COLL, CORT, CPF, CPK, CPRX, CRI, CRK, CRVL, CSGS, CTRE, CTS, CUBI, CVBF, CVCO, CVI, CWT, CXW, CZR, DAN, DCOM, DEA, DEI, DFIN, DGII, DIOD, DLX, DNOW, DORM, DRH, DVAX, DXC, DXPE, DY, EAT, ECPG, EFC, EGBN, EIG, ENPH, ENR, ENVA, EPC, ESE, ETSY, EVTC, EXPI, EXTR, EYE, EZPW, FBK, FBNC, FBP, FCF, FCPT, FDP, FELE, FFBC, FHB, FIZZ, FMC, FORM, FOXF, FRPT, FSS, FUL, FULT, FUN, FWRD, GBX, GDEN, GEO, GES, GFF, GIII, GKOS, GNL, GNW, GOGO, GOLF, GPI, GRBK, GTY, GVA, HAFC, HASI, HBI, HCC, HCI, HCSG, HELE, HFWA, HI, HIW, HL, HLIT, HLX, HMN, HNI, HOPE, HP, HSII, HSTM, HTH, HTLD, HUBG, HWKN, HZO, IAC, IART, IBP, ICHR, ICUI, IDCC, IIIN, IIPR, INDB, INN, INSW, INVA, IOSP, IPAR, ITGR, ITRI, JBGS, JBLU, JBSS, JJSF, JOE, KAI, KALU, KAR, KFY, KLIC, KMT, KN, KOP, KREF, KRYS, KSS, KW, KWR, LCII, LEG, LGIH, LGND, LKFN, LMAT, LNC, LNN, LPG, LQDT, LRN, LTC, LXP, LZB, MAC, MAN, MARA, MATW, MATX, MC, MCRI, MCY, MD, MDU, MGEE, MGPI, MHO, MKTX, MMI, MMSI, MNRO, MPW, MRCY, MRTN, MSEX, MTH, MTRN, MTX, MWA, MXL, MYGN, MYRG, NAVI, NBHC, NBTB, NEO, NEOG, NGVT, NHC, NMIH, NOG, NPK, NPO, NSIT, NTCT, NWBI, NWL, NWN, NX, NXRT, OFG, OI, OII, OMCL, OSIS, OTTR, OUT, OXM, PAHC, PARR, PATK, PBH, PBI, PCRX, PDFS, PEB, PENN, PFBC, PFS, PI, PINC, PJT, PLAB, PLAY, PLUS, PLXS, PMT, POWL, PRA, PRAA, PRGS, PRK, PRLB, PSMT, PTEN, PTGX, PZZA, QDEL, QNST, QRVO, QTWO, RDN, RDNT, RES, REX, RGR, RHI, RHP, RNST, ROCK, ROG, RUN, RUSHA, RWT, SAFE, SABR, SAFT, SAH, SANM, SBCF, SBH, SBSI, SCHL, SCL, SCSC, SCVL, SEDG, SEE, SEM, SFBS, SFNC, SHAK, SHEN, SHO, SHOO, SIG, SKT, SKY, SKYW, SLG, SM, SMP, SMPL, SMTC, SNDR, SPSC, SPXC, SRPT, SSTK, STAA, STBA, STC, STRA, STRL, SUPN, SXC, SXI, SXT, TBBK, TDC, TDS, TDW, TFX, TGNA, TGTX, THRM, THS, TILE, TMP, TNC, TNDM, TPH, TR, TRIP, TRMK, TRN, TRNO, TRST, TRUP, TTMI, TWI, TWO, UCTT, UE, UFCS, UFPT, UHT, UNF, UNFI, UNIT, URBN, USNA, USPH, UTL, UVV, VBTX, VCEL, VCYT, VECO, VIAV, VICR, VIRT, VRTS, VSAT, VSH, WABC, WAFD, WD, WDFC, WEN, WERN, WGO, WOR, WRLD, WSC, WSFS, WSR, WWW, XHR, XNCR, YELP

============================================================
TESTING TICKER 1/464: AAP
============================================================
📊 Loading data for AAP...
📊 Loading data for AAP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing AAP: 'AAP'

============================================================
TESTING TICKER 2/464: AAT
============================================================
📊 Loading data for AAT...
📊 Loading data for AAT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AAT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AAT...

==================================================
Training Baseline AAT (SVM)
==================================================
Training SVM model...

Baseline AAT Performance:
MAE: 140893.9384
RMSE: 197656.6948
MAPE: 13.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 156
   • Highly important features (top 5%): 104

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t1: importance=0.0012, rank=1
   2. Feature_2_t3: importance=0.0006, rank=2
   3. Feature_64_t1: importance=0.0005, rank=3
   4. Feature_64_t3: importance=0.0005, rank=4
   5. Feature_71_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for AAT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AAT...

==================================================
Training Enhanced AAT (SVM)
==================================================
Training SVM model...

Enhanced AAT Performance:
MAE: 125600.8483
RMSE: 177957.9605
MAPE: 12.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0011, rank=1
   2. Feature_15_t1: importance=0.0009, rank=2
   3. Feature_17_t0: importance=0.0009, rank=3
   4. Feature_21_t3: importance=0.0008, rank=4
   5. Feature_2_t1: importance=0.0008, rank=5

📊 AAT Results:
  Baseline MAPE: 13.28%
  Enhanced MAPE: 12.02%
  MAPE Improvement: +1.26% (+9.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 3/464: ABCB
============================================================
📊 Loading data for ABCB...
📊 Loading data for ABCB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ABCB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ABCB...

==================================================
Training Baseline ABCB (SVM)
==================================================
Training SVM model...

Baseline ABCB Performance:
MAE: 129751.4220
RMSE: 162121.3225
MAPE: 12.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 261
   • Highly important features (top 5%): 121

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0002, rank=1
   2. Feature_75_t0: importance=0.0001, rank=2
   3. Feature_94_t0: importance=0.0001, rank=3
   4. Feature_0_t3: importance=0.0001, rank=4
   5. Feature_83_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for ABCB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ABCB...

==================================================
Training Enhanced ABCB (SVM)
==================================================
Training SVM model...

Enhanced ABCB Performance:
MAE: 124684.2813
RMSE: 154647.7588
MAPE: 11.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t0: importance=0.0003, rank=1
   2. Feature_15_t1: importance=0.0002, rank=2
   3. Feature_1_t3: importance=0.0002, rank=3
   4. Feature_24_t1: importance=0.0002, rank=4
   5. Feature_10_t1: importance=0.0002, rank=5

📊 ABCB Results:
  Baseline MAPE: 12.17%
  Enhanced MAPE: 11.94%
  MAPE Improvement: +0.23% (+1.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 4/464: ABG
============================================================
📊 Loading data for ABG...
📊 Loading data for ABG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ABG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ABG...

==================================================
Training Baseline ABG (SVM)
==================================================
Training SVM model...

Baseline ABG Performance:
MAE: 80934.0509
RMSE: 109833.9063
MAPE: 4.76%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 194
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t1: importance=0.0000, rank=1
   2. Feature_94_t0: importance=0.0000, rank=2
   3. Feature_64_t3: importance=0.0000, rank=3
   4. Feature_2_t0: importance=0.0000, rank=4
   5. Feature_0_t2: importance=0.0000, rank=5

🔧 Applying universal feature engineering for ABG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ABG...

==================================================
Training Enhanced ABG (SVM)
==================================================
Training SVM model...

Enhanced ABG Performance:
MAE: 83631.2996
RMSE: 110322.8434
MAPE: 4.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0001, rank=1
   2. Feature_8_t2: importance=0.0001, rank=2
   3. Feature_8_t0: importance=0.0000, rank=3
   4. Feature_11_t3: importance=0.0000, rank=4
   5. Feature_17_t3: importance=0.0000, rank=5

📊 ABG Results:
  Baseline MAPE: 4.76%
  Enhanced MAPE: 4.88%
  MAPE Improvement: -0.12% (-2.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 5/464: ABM
============================================================
📊 Loading data for ABM...
📊 Loading data for ABM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ABM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ABM...

==================================================
Training Baseline ABM (SVM)
==================================================
Training SVM model...

Baseline ABM Performance:
MAE: 243256.9853
RMSE: 309317.1754
MAPE: 14.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 310
   • Highly important features (top 5%): 156

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0003, rank=1
   2. Feature_63_t2: importance=0.0003, rank=2
   3. Feature_64_t0: importance=0.0003, rank=3
   4. Feature_92_t1: importance=0.0003, rank=4
   5. Feature_81_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ABM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ABM...

==================================================
Training Enhanced ABM (SVM)
==================================================
Training SVM model...

Enhanced ABM Performance:
MAE: 252307.7741
RMSE: 304717.6467
MAPE: 15.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0011, rank=1
   2. Feature_15_t1: importance=0.0010, rank=2
   3. Feature_20_t1: importance=0.0010, rank=3
   4. Feature_15_t3: importance=0.0010, rank=4
   5. Feature_14_t3: importance=0.0006, rank=5

📊 ABM Results:
  Baseline MAPE: 14.65%
  Enhanced MAPE: 15.09%
  MAPE Improvement: -0.44% (-3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 6/464: ABR
============================================================
📊 Loading data for ABR...
📊 Loading data for ABR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ABR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ABR...

==================================================
Training Baseline ABR (SVM)
==================================================
Training SVM model...

Baseline ABR Performance:
MAE: 4701050.0388
RMSE: 5500051.5279
MAPE: 7.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 353
   • Highly important features (top 5%): 240

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0008, rank=1
   2. Feature_65_t2: importance=0.0003, rank=2
   3. Feature_65_t1: importance=0.0003, rank=3
   4. Feature_63_t3: importance=0.0003, rank=4
   5. Feature_77_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ABR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ABR...

==================================================
Training Enhanced ABR (SVM)
==================================================
Training SVM model...

Enhanced ABR Performance:
MAE: 3340640.2483
RMSE: 3740856.0553
MAPE: 5.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0015, rank=1
   2. Feature_19_t3: importance=0.0009, rank=2
   3. Feature_5_t1: importance=0.0008, rank=3
   4. Feature_19_t1: importance=0.0007, rank=4
   5. Feature_11_t2: importance=0.0007, rank=5

📊 ABR Results:
  Baseline MAPE: 7.40%
  Enhanced MAPE: 5.32%
  MAPE Improvement: +2.08% (+28.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 7/464: ACAD
============================================================
📊 Loading data for ACAD...
📊 Loading data for ACAD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing ACAD: 'ACAD'

============================================================
TESTING TICKER 8/464: ACHC
============================================================
📊 Loading data for ACHC...
📊 Loading data for ACHC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ACHC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ACHC...

==================================================
Training Baseline ACHC (SVM)
==================================================
Training SVM model...

Baseline ACHC Performance:
MAE: 479796.4464
RMSE: 654871.0911
MAPE: 8.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 152
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0001, rank=1
   2. Feature_70_t3: importance=0.0001, rank=2
   3. Feature_67_t2: importance=0.0001, rank=3
   4. Feature_90_t0: importance=0.0001, rank=4
   5. Feature_75_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for ACHC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ACHC...

==================================================
Training Enhanced ACHC (SVM)
==================================================
Training SVM model...

Enhanced ACHC Performance:
MAE: 474161.2086
RMSE: 654514.7874
MAPE: 8.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 60
   • Highly important features (top 5%): 42

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t2: importance=0.0003, rank=1
   2. Feature_15_t2: importance=0.0002, rank=2
   3. Feature_17_t3: importance=0.0001, rank=3
   4. Feature_15_t3: importance=0.0001, rank=4
   5. Feature_11_t1: importance=0.0001, rank=5

📊 ACHC Results:
  Baseline MAPE: 8.47%
  Enhanced MAPE: 8.30%
  MAPE Improvement: +0.17% (+2.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 9/464: ACIW
============================================================
📊 Loading data for ACIW...
📊 Loading data for ACIW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ACIW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ACIW...

==================================================
Training Baseline ACIW (SVM)
==================================================
Training SVM model...

Baseline ACIW Performance:
MAE: 142225.0009
RMSE: 183058.1556
MAPE: 5.82%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 204
   • Highly important features (top 5%): 110

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0011, rank=1
   2. Feature_63_t1: importance=0.0003, rank=2
   3. Feature_85_t3: importance=0.0002, rank=3
   4. Feature_86_t3: importance=0.0002, rank=4
   5. Feature_18_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ACIW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ACIW...

==================================================
Training Enhanced ACIW (SVM)
==================================================
Training SVM model...

Enhanced ACIW Performance:
MAE: 153935.3276
RMSE: 199286.1005
MAPE: 6.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0005, rank=1
   2. Feature_16_t3: importance=0.0004, rank=2
   3. Feature_19_t3: importance=0.0003, rank=3
   4. Feature_14_t2: importance=0.0003, rank=4
   5. Feature_7_t1: importance=0.0003, rank=5

📊 ACIW Results:
  Baseline MAPE: 5.82%
  Enhanced MAPE: 6.27%
  MAPE Improvement: -0.45% (-7.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 10/464: ACLS
============================================================
📊 Loading data for ACLS...
📊 Loading data for ACLS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ACLS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ACLS...

==================================================
Training Baseline ACLS (SVM)
==================================================
Training SVM model...

Baseline ACLS Performance:
MAE: 271324.7126
RMSE: 486498.5573
MAPE: 8.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 231
   • Highly important features (top 5%): 128

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t1: importance=0.0005, rank=1
   2. Feature_63_t2: importance=0.0004, rank=2
   3. Feature_81_t1: importance=0.0003, rank=3
   4. Feature_67_t0: importance=0.0003, rank=4
   5. Feature_68_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ACLS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ACLS...

==================================================
Training Enhanced ACLS (SVM)
==================================================
Training SVM model...

Enhanced ACLS Performance:
MAE: 253811.0431
RMSE: 484177.7910
MAPE: 7.97%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t1: importance=0.0007, rank=1
   2. Feature_10_t1: importance=0.0006, rank=2
   3. Feature_17_t0: importance=0.0005, rank=3
   4. Feature_13_t1: importance=0.0005, rank=4
   5. Feature_20_t1: importance=0.0005, rank=5

📊 ACLS Results:
  Baseline MAPE: 8.81%
  Enhanced MAPE: 7.97%
  MAPE Improvement: +0.85% (+9.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 11/464: ADMA
============================================================
📊 Loading data for ADMA...
📊 Loading data for ADMA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing ADMA: 'ADMA'

============================================================
TESTING TICKER 12/464: ADNT
============================================================
📊 Loading data for ADNT...
📊 Loading data for ADNT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing ADNT: 'ADNT'

============================================================
TESTING TICKER 13/464: ADUS
============================================================
📊 Loading data for ADUS...
📊 Loading data for ADUS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ADUS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'ADUS' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ADUS...

==================================================
Training Baseline ADUS (SVM)
==================================================
Training SVM model...

Baseline ADUS Performance:
MAE: 51351.3655
RMSE: 62842.5580
MAPE: 10.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 53
   • Highly important features (top 5%): 15

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0024, rank=1
   2. Feature_65_t0: importance=0.0019, rank=2
   3. Feature_0_t3: importance=0.0016, rank=3
   4. Feature_0_t0: importance=0.0014, rank=4
   5. Feature_2_t3: importance=0.0012, rank=5

🔧 Applying universal feature engineering for ADUS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ADUS...

==================================================
Training Enhanced ADUS (SVM)
==================================================
Training SVM model...

Enhanced ADUS Performance:
MAE: 67275.3367
RMSE: 81026.4230
MAPE: 13.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 54

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t1: importance=0.0022, rank=1
   2. Feature_1_t3: importance=0.0018, rank=2
   3. Feature_15_t1: importance=0.0017, rank=3
   4. Feature_15_t3: importance=0.0016, rank=4
   5. Feature_24_t2: importance=0.0015, rank=5

📊 ADUS Results:
  Baseline MAPE: 10.70%
  Enhanced MAPE: 13.51%
  MAPE Improvement: -2.81% (-26.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 14/464: AEIS
============================================================
📊 Loading data for AEIS...
📊 Loading data for AEIS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AEIS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AEIS...

==================================================
Training Baseline AEIS (SVM)
==================================================
Training SVM model...

Baseline AEIS Performance:
MAE: 148971.3535
RMSE: 184198.9808
MAPE: 6.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 255
   • Highly important features (top 5%): 128

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0002, rank=1
   2. Feature_92_t0: importance=0.0002, rank=2
   3. Feature_71_t0: importance=0.0002, rank=3
   4. Feature_91_t0: importance=0.0002, rank=4
   5. Feature_95_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for AEIS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AEIS...

==================================================
Training Enhanced AEIS (SVM)
==================================================
Training SVM model...

Enhanced AEIS Performance:
MAE: 125094.4251
RMSE: 166179.2024
MAPE: 5.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t2: importance=0.0004, rank=1
   2. Feature_20_t1: importance=0.0004, rank=2
   3. Feature_14_t1: importance=0.0004, rank=3
   4. Feature_19_t3: importance=0.0003, rank=4
   5. Feature_14_t2: importance=0.0003, rank=5

📊 AEIS Results:
  Baseline MAPE: 6.09%
  Enhanced MAPE: 5.02%
  MAPE Improvement: +1.07% (+17.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 15/464: AEO
============================================================
📊 Loading data for AEO...
📊 Loading data for AEO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AEO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AEO...

==================================================
Training Baseline AEO (SVM)
==================================================
Training SVM model...

Baseline AEO Performance:
MAE: 1955760.6697
RMSE: 2711903.9663
MAPE: 11.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 133
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t1: importance=0.0004, rank=1
   2. Feature_65_t3: importance=0.0003, rank=2
   3. Feature_64_t3: importance=0.0003, rank=3
   4. Feature_0_t2: importance=0.0003, rank=4
   5. Feature_0_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for AEO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AEO...

==================================================
Training Enhanced AEO (SVM)
==================================================
Training SVM model...

Enhanced AEO Performance:
MAE: 1915966.5220
RMSE: 2479309.3356
MAPE: 11.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 75
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t2: importance=0.0015, rank=1
   2. Feature_11_t2: importance=0.0011, rank=2
   3. Feature_11_t3: importance=0.0004, rank=3
   4. Feature_22_t1: importance=0.0004, rank=4
   5. Feature_17_t2: importance=0.0004, rank=5

📊 AEO Results:
  Baseline MAPE: 11.29%
  Enhanced MAPE: 11.10%
  MAPE Improvement: +0.20% (+1.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 16/464: AGO
============================================================
📊 Loading data for AGO...
📊 Loading data for AGO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AGO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AGO...

==================================================
Training Baseline AGO (SVM)
==================================================
Training SVM model...

Baseline AGO Performance:
MAE: 115552.6199
RMSE: 152179.5279
MAPE: 11.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 260
   • Highly important features (top 5%): 169

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t0: importance=0.0006, rank=1
   2. Feature_96_t3: importance=0.0006, rank=2
   3. Feature_78_t0: importance=0.0006, rank=3
   4. Feature_87_t0: importance=0.0004, rank=4
   5. Feature_70_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for AGO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AGO...

==================================================
Training Enhanced AGO (SVM)
==================================================
Training SVM model...

Enhanced AGO Performance:
MAE: 106573.6573
RMSE: 138082.6271
MAPE: 10.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 10
   • Highly important features (top 5%): 7

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0062, rank=1
   2. Feature_19_t2: importance=0.0010, rank=2
   3. Feature_19_t3: importance=0.0007, rank=3
   4. Feature_23_t1: importance=0.0006, rank=4
   5. Feature_7_t1: importance=0.0006, rank=5

📊 AGO Results:
  Baseline MAPE: 11.95%
  Enhanced MAPE: 10.64%
  MAPE Improvement: +1.31% (+11.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 17/464: AGYS
============================================================
📊 Loading data for AGYS...
📊 Loading data for AGYS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AGYS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AGYS...

==================================================
Training Baseline AGYS (SVM)
==================================================
Training SVM model...

Baseline AGYS Performance:
MAE: 85949.7377
RMSE: 113746.6145
MAPE: 11.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 227
   • Highly important features (top 5%): 118

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t1: importance=0.0004, rank=1
   2. Feature_67_t3: importance=0.0003, rank=2
   3. Feature_81_t1: importance=0.0003, rank=3
   4. Feature_2_t3: importance=0.0003, rank=4
   5. Feature_93_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for AGYS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AGYS...

==================================================
Training Enhanced AGYS (SVM)
==================================================
Training SVM model...

Enhanced AGYS Performance:
MAE: 88574.9153
RMSE: 118396.4527
MAPE: 11.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 92

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t1: importance=0.0004, rank=1
   2. Feature_12_t2: importance=0.0004, rank=2
   3. Feature_20_t1: importance=0.0004, rank=3
   4. Feature_11_t3: importance=0.0004, rank=4
   5. Feature_15_t3: importance=0.0003, rank=5

📊 AGYS Results:
  Baseline MAPE: 11.66%
  Enhanced MAPE: 11.80%
  MAPE Improvement: -0.14% (-1.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 18/464: AHH
============================================================
📊 Loading data for AHH...
📊 Loading data for AHH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AHH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AHH...

==================================================
Training Baseline AHH (SVM)
==================================================
Training SVM model...

Baseline AHH Performance:
MAE: 229752.7251
RMSE: 311560.4948
MAPE: 16.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 296
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_87_t0: importance=0.0010, rank=1
   2. Feature_84_t3: importance=0.0009, rank=2
   3. Feature_72_t0: importance=0.0009, rank=3
   4. Feature_76_t3: importance=0.0008, rank=4
   5. Feature_81_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for AHH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AHH...

==================================================
Training Enhanced AHH (SVM)
==================================================
Training SVM model...

Enhanced AHH Performance:
MAE: 196263.3988
RMSE: 286493.0344
MAPE: 14.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t1: importance=0.0020, rank=1
   2. Feature_22_t0: importance=0.0014, rank=2
   3. Feature_1_t3: importance=0.0013, rank=3
   4. Feature_24_t0: importance=0.0011, rank=4
   5. Feature_11_t0: importance=0.0011, rank=5

📊 AHH Results:
  Baseline MAPE: 16.91%
  Enhanced MAPE: 14.27%
  MAPE Improvement: +2.64% (+15.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 19/464: AIN
============================================================
📊 Loading data for AIN...
📊 Loading data for AIN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing AIN: 'AIN'

============================================================
TESTING TICKER 20/464: AIR
============================================================
📊 Loading data for AIR...
📊 Loading data for AIR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AIR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AIR...

==================================================
Training Baseline AIR (SVM)
==================================================
Training SVM model...

Baseline AIR Performance:
MAE: 101031.8834
RMSE: 124222.2561
MAPE: 13.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 271
   • Highly important features (top 5%): 108

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t3: importance=0.0002, rank=1
   2. Feature_83_t3: importance=0.0002, rank=2
   3. Feature_2_t0: importance=0.0002, rank=3
   4. Feature_63_t3: importance=0.0002, rank=4
   5. Feature_70_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for AIR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AIR...

==================================================
Training Enhanced AIR (SVM)
==================================================
Training SVM model...

Enhanced AIR Performance:
MAE: 77253.1142
RMSE: 98780.6277
MAPE: 10.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0009, rank=1
   2. Feature_19_t1: importance=0.0006, rank=2
   3. Feature_17_t1: importance=0.0004, rank=3
   4. Feature_16_t3: importance=0.0004, rank=4
   5. Feature_2_t0: importance=0.0004, rank=5

📊 AIR Results:
  Baseline MAPE: 13.60%
  Enhanced MAPE: 10.30%
  MAPE Improvement: +3.30% (+24.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 21/464: AKR
============================================================
📊 Loading data for AKR...
📊 Loading data for AKR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AKR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AKR...

==================================================
Training Baseline AKR (SVM)
==================================================
Training SVM model...

Baseline AKR Performance:
MAE: 1081543.8579
RMSE: 2266526.3131
MAPE: 20.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 322
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t1: importance=0.0005, rank=1
   2. Feature_67_t1: importance=0.0005, rank=2
   3. Feature_0_t3: importance=0.0004, rank=3
   4. Feature_67_t0: importance=0.0003, rank=4
   5. Feature_67_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for AKR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AKR...

==================================================
Training Enhanced AKR (SVM)
==================================================
Training SVM model...

Enhanced AKR Performance:
MAE: 1167869.9192
RMSE: 2217930.0688
MAPE: 20.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0012, rank=1
   2. Feature_12_t0: importance=0.0010, rank=2
   3. Feature_17_t3: importance=0.0008, rank=3
   4. Feature_10_t3: importance=0.0007, rank=4
   5. Feature_13_t0: importance=0.0007, rank=5

📊 AKR Results:
  Baseline MAPE: 20.18%
  Enhanced MAPE: 20.70%
  MAPE Improvement: -0.52% (-2.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 22/464: AL
============================================================
📊 Loading data for AL...
📊 Loading data for AL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AL...

==================================================
Training Baseline AL (SVM)
==================================================
Training SVM model...

Baseline AL Performance:
MAE: 406539.2583
RMSE: 607169.4741
MAPE: 12.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 243
   • Highly important features (top 5%): 137

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_94_t2: importance=0.0008, rank=1
   2. Feature_78_t2: importance=0.0005, rank=2
   3. Feature_63_t1: importance=0.0004, rank=3
   4. Feature_67_t3: importance=0.0004, rank=4
   5. Feature_88_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for AL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AL...

==================================================
Training Enhanced AL (SVM)
==================================================
Training SVM model...

Enhanced AL Performance:
MAE: 425835.7080
RMSE: 615832.0722
MAPE: 12.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t1: importance=0.0011, rank=1
   2. Feature_15_t3: importance=0.0010, rank=2
   3. Feature_17_t2: importance=0.0009, rank=3
   4. Feature_1_t3: importance=0.0008, rank=4
   5. Feature_14_t3: importance=0.0006, rank=5

📊 AL Results:
  Baseline MAPE: 12.15%
  Enhanced MAPE: 12.91%
  MAPE Improvement: -0.76% (-6.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 23/464: ALEX
============================================================
📊 Loading data for ALEX...
📊 Loading data for ALEX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ALEX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ALEX...

==================================================
Training Baseline ALEX (SVM)
==================================================
Training SVM model...

Baseline ALEX Performance:
MAE: 90158.0219
RMSE: 114443.8643
MAPE: 13.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 352
   • Highly important features (top 5%): 191

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0006, rank=1
   2. Feature_65_t3: importance=0.0006, rank=2
   3. Feature_63_t0: importance=0.0006, rank=3
   4. Feature_68_t0: importance=0.0006, rank=4
   5. Feature_76_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for ALEX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ALEX...

==================================================
Training Enhanced ALEX (SVM)
==================================================
Training SVM model...

Enhanced ALEX Performance:
MAE: 93976.8109
RMSE: 111240.4726
MAPE: 15.73%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t0: importance=0.0014, rank=1
   2. Feature_19_t1: importance=0.0014, rank=2
   3. Feature_17_t3: importance=0.0014, rank=3
   4. Feature_5_t3: importance=0.0012, rank=4
   5. Feature_5_t1: importance=0.0012, rank=5

📊 ALEX Results:
  Baseline MAPE: 13.93%
  Enhanced MAPE: 15.73%
  MAPE Improvement: -1.80% (-12.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 24/464: ALG
============================================================
📊 Loading data for ALG...
📊 Loading data for ALG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ALG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ALG...

==================================================
Training Baseline ALG (SVM)
==================================================
Training SVM model...

Baseline ALG Performance:
MAE: 27604.2884
RMSE: 33626.2750
MAPE: 8.39%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 319
   • Highly important features (top 5%): 174

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0006, rank=1
   2. Feature_63_t1: importance=0.0005, rank=2
   3. Feature_75_t2: importance=0.0004, rank=3
   4. Feature_2_t3: importance=0.0004, rank=4
   5. Feature_86_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for ALG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ALG...

==================================================
Training Enhanced ALG (SVM)
==================================================
Training SVM model...

Enhanced ALG Performance:
MAE: 28001.5675
RMSE: 32584.8426
MAPE: 9.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t2: importance=0.0011, rank=1
   2. Feature_17_t0: importance=0.0010, rank=2
   3. Feature_20_t3: importance=0.0008, rank=3
   4. Feature_16_t3: importance=0.0007, rank=4
   5. Feature_1_t0: importance=0.0007, rank=5

📊 ALG Results:
  Baseline MAPE: 8.39%
  Enhanced MAPE: 9.08%
  MAPE Improvement: -0.69% (-8.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 25/464: ALGT
============================================================
📊 Loading data for ALGT...
📊 Loading data for ALGT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ALGT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ALGT...

==================================================
Training Baseline ALGT (SVM)
==================================================
Training SVM model...

Baseline ALGT Performance:
MAE: 146515.4483
RMSE: 178665.7064
MAPE: 11.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 215
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0015, rank=1
   2. Feature_73_t0: importance=0.0014, rank=2
   3. Feature_0_t3: importance=0.0013, rank=3
   4. Feature_67_t2: importance=0.0011, rank=4
   5. Feature_82_t1: importance=0.0010, rank=5

🔧 Applying universal feature engineering for ALGT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ALGT...

==================================================
Training Enhanced ALGT (SVM)
==================================================
Training SVM model...

Enhanced ALGT Performance:
MAE: 160744.4857
RMSE: 210831.4475
MAPE: 12.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0048, rank=1
   2. Feature_7_t1: importance=0.0032, rank=2
   3. Feature_15_t2: importance=0.0030, rank=3
   4. Feature_5_t2: importance=0.0028, rank=4
   5. Feature_13_t0: importance=0.0026, rank=5

📊 ALGT Results:
  Baseline MAPE: 11.72%
  Enhanced MAPE: 12.25%
  MAPE Improvement: -0.53% (-4.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 26/464: ALKS
============================================================
📊 Loading data for ALKS...
📊 Loading data for ALKS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ALKS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'ALKS' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ALKS...

==================================================
Training Baseline ALKS (SVM)
==================================================
Training SVM model...

Baseline ALKS Performance:
MAE: 1067127.2665
RMSE: 1306325.3096
MAPE: 7.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 32
   • Highly important features (top 5%): 13

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0010, rank=1
   2. Feature_65_t3: importance=0.0008, rank=2
   3. Feature_1_t3: importance=0.0006, rank=3
   4. Feature_1_t0: importance=0.0003, rank=4
   5. Feature_65_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ALKS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ALKS...

==================================================
Training Enhanced ALKS (SVM)
==================================================
Training SVM model...

Enhanced ALKS Performance:
MAE: 1099695.9416
RMSE: 1325148.7978
MAPE: 8.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0003, rank=1
   2. Feature_5_t2: importance=0.0003, rank=2
   3. Feature_11_t1: importance=0.0003, rank=3
   4. Feature_22_t2: importance=0.0002, rank=4
   5. Feature_9_t3: importance=0.0002, rank=5

📊 ALKS Results:
  Baseline MAPE: 7.79%
  Enhanced MAPE: 8.18%
  MAPE Improvement: -0.38% (-4.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 27/464: ALRM
============================================================
📊 Loading data for ALRM...
📊 Loading data for ALRM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ALRM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ALRM...

==================================================
Training Baseline ALRM (SVM)
==================================================
Training SVM model...

Baseline ALRM Performance:
MAE: 141114.3049
RMSE: 224522.2885
MAPE: 6.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 241
   • Highly important features (top 5%): 138

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t3: importance=0.0001, rank=1
   2. Feature_87_t3: importance=0.0001, rank=2
   3. Feature_67_t3: importance=0.0001, rank=3
   4. Feature_83_t0: importance=0.0000, rank=4
   5. Feature_68_t3: importance=0.0000, rank=5

🔧 Applying universal feature engineering for ALRM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ALRM...

==================================================
Training Enhanced ALRM (SVM)
==================================================
Training SVM model...

Enhanced ALRM Performance:
MAE: 136995.2269
RMSE: 217269.3503
MAPE: 6.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0001, rank=1
   2. Feature_4_t3: importance=0.0001, rank=2
   3. Feature_13_t2: importance=0.0001, rank=3
   4. Feature_17_t0: importance=0.0001, rank=4
   5. Feature_6_t0: importance=0.0001, rank=5

📊 ALRM Results:
  Baseline MAPE: 6.94%
  Enhanced MAPE: 6.80%
  MAPE Improvement: +0.14% (+2.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 28/464: AMN
============================================================
📊 Loading data for AMN...
📊 Loading data for AMN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AMN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AMN...

==================================================
Training Baseline AMN (SVM)
==================================================
Training SVM model...

Baseline AMN Performance:
MAE: 484885.3100
RMSE: 555109.4668
MAPE: 10.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 167
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0006, rank=1
   2. Feature_76_t2: importance=0.0004, rank=2
   3. Feature_74_t2: importance=0.0004, rank=3
   4. Feature_63_t2: importance=0.0003, rank=4
   5. Feature_91_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for AMN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AMN...

==================================================
Training Enhanced AMN (SVM)
==================================================
Training SVM model...

Enhanced AMN Performance:
MAE: 412709.8388
RMSE: 500162.6811
MAPE: 9.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t2: importance=0.0013, rank=1
   2. Feature_4_t2: importance=0.0011, rank=2
   3. Feature_19_t2: importance=0.0010, rank=3
   4. Feature_11_t2: importance=0.0009, rank=4
   5. Feature_22_t0: importance=0.0005, rank=5

📊 AMN Results:
  Baseline MAPE: 10.74%
  Enhanced MAPE: 9.19%
  MAPE Improvement: +1.54% (+14.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 29/464: AMPH
============================================================
📊 Loading data for AMPH...
📊 Loading data for AMPH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AMPH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AMPH...

==================================================
Training Baseline AMPH (SVM)
==================================================
Training SVM model...

Baseline AMPH Performance:
MAE: 268324.1678
RMSE: 333650.4617
MAPE: 6.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 308
   • Highly important features (top 5%): 249

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t2: importance=0.0001, rank=1
   2. Feature_92_t2: importance=0.0001, rank=2
   3. Feature_80_t2: importance=0.0001, rank=3
   4. Feature_87_t2: importance=0.0001, rank=4
   5. Feature_86_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for AMPH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AMPH...

==================================================
Training Enhanced AMPH (SVM)
==================================================
Training SVM model...

Enhanced AMPH Performance:
MAE: 272208.6712
RMSE: 344296.4496
MAPE: 6.97%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t1: importance=0.0004, rank=1
   2. Feature_10_t1: importance=0.0003, rank=2
   3. Feature_15_t1: importance=0.0003, rank=3
   4. Feature_22_t2: importance=0.0002, rank=4
   5. Feature_3_t2: importance=0.0002, rank=5

📊 AMPH Results:
  Baseline MAPE: 6.89%
  Enhanced MAPE: 6.97%
  MAPE Improvement: -0.08% (-1.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 30/464: AMSF
============================================================
📊 Loading data for AMSF...
📊 Loading data for AMSF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AMSF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AMSF...

==================================================
Training Baseline AMSF (SVM)
==================================================
Training SVM model...

Baseline AMSF Performance:
MAE: 34746.1150
RMSE: 48800.2418
MAPE: 16.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 298
   • Highly important features (top 5%): 157

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t1: importance=0.0004, rank=1
   2. Feature_80_t1: importance=0.0004, rank=2
   3. Feature_77_t0: importance=0.0003, rank=3
   4. Feature_81_t1: importance=0.0003, rank=4
   5. Feature_70_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for AMSF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AMSF...

==================================================
Training Enhanced AMSF (SVM)
==================================================
Training SVM model...

Enhanced AMSF Performance:
MAE: 33254.5493
RMSE: 46036.4084
MAPE: 16.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0020, rank=1
   2. Feature_17_t0: importance=0.0010, rank=2
   3. Feature_5_t3: importance=0.0010, rank=3
   4. Feature_15_t2: importance=0.0009, rank=4
   5. Feature_7_t1: importance=0.0009, rank=5

📊 AMSF Results:
  Baseline MAPE: 16.89%
  Enhanced MAPE: 16.65%
  MAPE Improvement: +0.25% (+1.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 31/464: AMWD
============================================================
📊 Loading data for AMWD...
📊 Loading data for AMWD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AMWD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AMWD...

==================================================
Training Baseline AMWD (SVM)
==================================================
Training SVM model...

Baseline AMWD Performance:
MAE: 48258.5218
RMSE: 67413.8527
MAPE: 11.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 319
   • Highly important features (top 5%): 197

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_77_t1: importance=0.0006, rank=1
   2. Feature_67_t3: importance=0.0005, rank=2
   3. Feature_78_t1: importance=0.0005, rank=3
   4. Feature_65_t2: importance=0.0004, rank=4
   5. Feature_2_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for AMWD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AMWD...

==================================================
Training Enhanced AMWD (SVM)
==================================================
Training SVM model...

Enhanced AMWD Performance:
MAE: 52149.7284
RMSE: 74997.4191
MAPE: 12.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t2: importance=0.0010, rank=1
   2. Feature_11_t2: importance=0.0010, rank=2
   3. Feature_7_t1: importance=0.0009, rank=3
   4. Feature_23_t2: importance=0.0009, rank=4
   5. Feature_15_t2: importance=0.0008, rank=5

📊 AMWD Results:
  Baseline MAPE: 11.41%
  Enhanced MAPE: 12.67%
  MAPE Improvement: -1.27% (-11.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 32/464: ANDE
============================================================
📊 Loading data for ANDE...
📊 Loading data for ANDE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ANDE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ANDE...

==================================================
Training Baseline ANDE (SVM)
==================================================
Training SVM model...

Baseline ANDE Performance:
MAE: 96444.9026
RMSE: 132965.5732
MAPE: 13.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 271
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0004, rank=1
   2. Feature_69_t3: importance=0.0003, rank=2
   3. Feature_2_t0: importance=0.0003, rank=3
   4. Feature_65_t3: importance=0.0003, rank=4
   5. Feature_73_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ANDE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ANDE...

==================================================
Training Enhanced ANDE (SVM)
==================================================
Training SVM model...

Enhanced ANDE Performance:
MAE: 95057.5535
RMSE: 125791.9210
MAPE: 13.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t2: importance=0.0009, rank=1
   2. Feature_17_t2: importance=0.0007, rank=2
   3. Feature_12_t1: importance=0.0006, rank=3
   4. Feature_20_t1: importance=0.0005, rank=4
   5. Feature_5_t3: importance=0.0005, rank=5

📊 ANDE Results:
  Baseline MAPE: 13.70%
  Enhanced MAPE: 13.58%
  MAPE Improvement: +0.12% (+0.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 33/464: ANGI
============================================================
📊 Loading data for ANGI...
📊 Loading data for ANGI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ANGI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ANGI...

==================================================
Training Baseline ANGI (SVM)
==================================================
Training SVM model...

Baseline ANGI Performance:
MAE: 817343.8123
RMSE: 2022541.0995
MAPE: 27.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 209
   • Highly important features (top 5%): 134

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t2: importance=0.0006, rank=1
   2. Feature_63_t3: importance=0.0004, rank=2
   3. Feature_63_t2: importance=0.0003, rank=3
   4. Feature_74_t2: importance=0.0003, rank=4
   5. Feature_63_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ANGI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ANGI...

==================================================
Training Enhanced ANGI (SVM)
==================================================
Training SVM model...

Enhanced ANGI Performance:
MAE: 828082.6475
RMSE: 1967843.9229
MAPE: 27.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t2: importance=0.0005, rank=1
   2. Feature_19_t2: importance=0.0004, rank=2
   3. Feature_16_t2: importance=0.0004, rank=3
   4. Feature_9_t0: importance=0.0003, rank=4
   5. Feature_16_t3: importance=0.0003, rank=5

📊 ANGI Results:
  Baseline MAPE: 27.47%
  Enhanced MAPE: 27.11%
  MAPE Improvement: +0.36% (+1.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 34/464: ANIP
============================================================
📊 Loading data for ANIP...
📊 Loading data for ANIP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ANIP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ANIP...

==================================================
Training Baseline ANIP (SVM)
==================================================
Training SVM model...

Baseline ANIP Performance:
MAE: 181079.0796
RMSE: 314007.1613
MAPE: 12.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 211
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_95_t3: importance=0.0003, rank=1
   2. Feature_79_t1: importance=0.0003, rank=2
   3. Feature_68_t0: importance=0.0003, rank=3
   4. Feature_80_t1: importance=0.0003, rank=4
   5. Feature_82_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ANIP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ANIP...

==================================================
Training Enhanced ANIP (SVM)
==================================================
Training SVM model...

Enhanced ANIP Performance:
MAE: 195371.6680
RMSE: 321933.1392
MAPE: 14.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0010, rank=1
   2. Feature_7_t3: importance=0.0007, rank=2
   3. Feature_20_t0: importance=0.0007, rank=3
   4. Feature_15_t1: importance=0.0006, rank=4
   5. Feature_17_t1: importance=0.0005, rank=5

📊 ANIP Results:
  Baseline MAPE: 12.83%
  Enhanced MAPE: 14.65%
  MAPE Improvement: -1.82% (-14.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 35/464: AOSL
============================================================
📊 Loading data for AOSL...
📊 Loading data for AOSL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AOSL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AOSL...

==================================================
Training Baseline AOSL (SVM)
==================================================
Training SVM model...

Baseline AOSL Performance:
MAE: 130680.1799
RMSE: 184863.4008
MAPE: 9.50%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 111
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0012, rank=1
   2. Feature_69_t3: importance=0.0007, rank=2
   3. Feature_2_t0: importance=0.0007, rank=3
   4. Feature_69_t2: importance=0.0007, rank=4
   5. Feature_70_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for AOSL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AOSL...

==================================================
Training Enhanced AOSL (SVM)
==================================================
Training SVM model...

Enhanced AOSL Performance:
MAE: 137425.1336
RMSE: 184803.8376
MAPE: 10.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0023, rank=1
   2. Feature_16_t0: importance=0.0014, rank=2
   3. Feature_16_t1: importance=0.0014, rank=3
   4. Feature_7_t2: importance=0.0013, rank=4
   5. Feature_4_t3: importance=0.0008, rank=5

📊 AOSL Results:
  Baseline MAPE: 9.50%
  Enhanced MAPE: 10.05%
  MAPE Improvement: -0.55% (-5.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 36/464: APAM
============================================================
📊 Loading data for APAM...
📊 Loading data for APAM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for APAM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for APAM...

==================================================
Training Baseline APAM (SVM)
==================================================
Training SVM model...

Baseline APAM Performance:
MAE: 235049.3411
RMSE: 287342.2151
MAPE: 8.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 269
   • Highly important features (top 5%): 141

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t3: importance=0.0012, rank=1
   2. Feature_74_t3: importance=0.0005, rank=2
   3. Feature_90_t2: importance=0.0005, rank=3
   4. Feature_70_t3: importance=0.0004, rank=4
   5. Feature_67_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for APAM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for APAM...

==================================================
Training Enhanced APAM (SVM)
==================================================
Training SVM model...

Enhanced APAM Performance:
MAE: 215024.6343
RMSE: 253026.9371
MAPE: 7.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t1: importance=0.0010, rank=1
   2. Feature_13_t0: importance=0.0008, rank=2
   3. Feature_15_t1: importance=0.0007, rank=3
   4. Feature_13_t2: importance=0.0007, rank=4
   5. Feature_7_t2: importance=0.0006, rank=5

📊 APAM Results:
  Baseline MAPE: 8.60%
  Enhanced MAPE: 7.84%
  MAPE Improvement: +0.76% (+8.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 37/464: APLE
============================================================
📊 Loading data for APLE...
📊 Loading data for APLE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing APLE: 'APLE'

============================================================
TESTING TICKER 38/464: APOG
============================================================
📊 Loading data for APOG...
📊 Loading data for APOG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for APOG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for APOG...

==================================================
Training Baseline APOG (SVM)
==================================================
Training SVM model...

Baseline APOG Performance:
MAE: 72888.7481
RMSE: 90775.9306
MAPE: 9.35%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 228
   • Highly important features (top 5%): 120

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0005, rank=1
   2. Feature_73_t3: importance=0.0003, rank=2
   3. Feature_63_t0: importance=0.0003, rank=3
   4. Feature_89_t3: importance=0.0002, rank=4
   5. Feature_93_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for APOG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for APOG...

==================================================
Training Enhanced APOG (SVM)
==================================================
Training SVM model...

Enhanced APOG Performance:
MAE: 86973.7614
RMSE: 104973.3118
MAPE: 11.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t1: importance=0.0011, rank=1
   2. Feature_23_t0: importance=0.0011, rank=2
   3. Feature_23_t3: importance=0.0010, rank=3
   4. Feature_19_t0: importance=0.0009, rank=4
   5. Feature_17_t3: importance=0.0007, rank=5

📊 APOG Results:
  Baseline MAPE: 9.35%
  Enhanced MAPE: 11.32%
  MAPE Improvement: -1.97% (-21.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 39/464: ARCB
============================================================
📊 Loading data for ARCB...
📊 Loading data for ARCB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ARCB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ARCB...

==================================================
Training Baseline ARCB (SVM)
==================================================
Training SVM model...

Baseline ARCB Performance:
MAE: 113488.3515
RMSE: 144998.7987
MAPE: 8.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 193
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0005, rank=1
   2. Feature_63_t2: importance=0.0005, rank=2
   3. Feature_65_t0: importance=0.0005, rank=3
   4. Feature_69_t1: importance=0.0004, rank=4
   5. Feature_63_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ARCB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ARCB...

==================================================
Training Enhanced ARCB (SVM)
==================================================
Training SVM model...

Enhanced ARCB Performance:
MAE: 114286.1451
RMSE: 147457.0187
MAPE: 8.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0009, rank=1
   2. Feature_16_t1: importance=0.0007, rank=2
   3. Feature_4_t1: importance=0.0007, rank=3
   4. Feature_20_t3: importance=0.0006, rank=4
   5. Feature_19_t3: importance=0.0005, rank=5

📊 ARCB Results:
  Baseline MAPE: 8.23%
  Enhanced MAPE: 8.44%
  MAPE Improvement: -0.21% (-2.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 40/464: ARI
============================================================
📊 Loading data for ARI...
📊 Loading data for ARI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ARI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ARI...

==================================================
Training Baseline ARI (SVM)
==================================================
Training SVM model...

Baseline ARI Performance:
MAE: 344079.6948
RMSE: 441441.9705
MAPE: 8.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 331
   • Highly important features (top 5%): 210

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t3: importance=0.0005, rank=1
   2. Feature_93_t3: importance=0.0003, rank=2
   3. Feature_69_t2: importance=0.0003, rank=3
   4. Feature_67_t3: importance=0.0002, rank=4
   5. Feature_89_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ARI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ARI...

==================================================
Training Enhanced ARI (SVM)
==================================================
Training SVM model...

Enhanced ARI Performance:
MAE: 368702.1732
RMSE: 449667.5945
MAPE: 9.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t0: importance=0.0007, rank=1
   2. Feature_20_t1: importance=0.0007, rank=2
   3. Feature_22_t1: importance=0.0006, rank=3
   4. Feature_13_t1: importance=0.0005, rank=4
   5. Feature_20_t3: importance=0.0005, rank=5

📊 ARI Results:
  Baseline MAPE: 8.68%
  Enhanced MAPE: 9.29%
  MAPE Improvement: -0.62% (-7.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 41/464: AROC
============================================================
📊 Loading data for AROC...
📊 Loading data for AROC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AROC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AROC...

==================================================
Training Baseline AROC (SVM)
==================================================
Training SVM model...

Baseline AROC Performance:
MAE: 494427.6401
RMSE: 646601.0801
MAPE: 9.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 327
   • Highly important features (top 5%): 160

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0015, rank=1
   2. Feature_69_t3: importance=0.0014, rank=2
   3. Feature_72_t3: importance=0.0014, rank=3
   4. Feature_71_t3: importance=0.0014, rank=4
   5. Feature_74_t3: importance=0.0009, rank=5

🔧 Applying universal feature engineering for AROC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AROC...

==================================================
Training Enhanced AROC (SVM)
==================================================
Training SVM model...

Enhanced AROC Performance:
MAE: 475886.6569
RMSE: 610551.1196
MAPE: 9.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 51

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0031, rank=1
   2. Feature_18_t1: importance=0.0017, rank=2
   3. Feature_8_t1: importance=0.0016, rank=3
   4. Feature_4_t0: importance=0.0012, rank=4
   5. Feature_8_t2: importance=0.0011, rank=5

📊 AROC Results:
  Baseline MAPE: 9.53%
  Enhanced MAPE: 9.16%
  MAPE Improvement: +0.37% (+3.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 42/464: ARR
============================================================
📊 Loading data for ARR...
📊 Loading data for ARR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ARR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ARR...

==================================================
Training Baseline ARR (SVM)
==================================================
Training SVM model...

Baseline ARR Performance:
MAE: 987392.0938
RMSE: 1339876.7169
MAPE: 17.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 183
   • Highly important features (top 5%): 99

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0019, rank=1
   2. Feature_89_t0: importance=0.0019, rank=2
   3. Feature_65_t2: importance=0.0018, rank=3
   4. Feature_68_t1: importance=0.0015, rank=4
   5. Feature_71_t3: importance=0.0012, rank=5

🔧 Applying universal feature engineering for ARR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ARR...

==================================================
Training Enhanced ARR (SVM)
==================================================
Training SVM model...

Enhanced ARR Performance:
MAE: 863849.8283
RMSE: 1170430.4301
MAPE: 16.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t3: importance=0.0054, rank=1
   2. Feature_15_t3: importance=0.0037, rank=2
   3. Feature_8_t3: importance=0.0036, rank=3
   4. Feature_0_t3: importance=0.0023, rank=4
   5. Feature_13_t3: importance=0.0022, rank=5

📊 ARR Results:
  Baseline MAPE: 17.72%
  Enhanced MAPE: 16.02%
  MAPE Improvement: +1.70% (+9.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 43/464: ARWR
============================================================
📊 Loading data for ARWR...
📊 Loading data for ARWR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ARWR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ARWR...

==================================================
Training Baseline ARWR (SVM)
==================================================
Training SVM model...

Baseline ARWR Performance:
MAE: 612348.1903
RMSE: 738534.7043
MAPE: 6.36%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 120
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t1: importance=0.0001, rank=1
   2. Feature_69_t1: importance=0.0001, rank=2
   3. Feature_64_t3: importance=0.0001, rank=3
   4. Feature_0_t1: importance=0.0001, rank=4
   5. Feature_0_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for ARWR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ARWR...

==================================================
Training Enhanced ARWR (SVM)
==================================================
Training SVM model...

Enhanced ARWR Performance:
MAE: 560105.7858
RMSE: 697863.6450
MAPE: 5.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0004, rank=1
   2. Feature_3_t3: importance=0.0002, rank=2
   3. Feature_6_t0: importance=0.0002, rank=3
   4. Feature_20_t2: importance=0.0001, rank=4
   5. Feature_21_t3: importance=0.0001, rank=5

📊 ARWR Results:
  Baseline MAPE: 6.36%
  Enhanced MAPE: 5.78%
  MAPE Improvement: +0.59% (+9.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 44/464: ASIX
============================================================
📊 Loading data for ASIX...
📊 Loading data for ASIX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ASIX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ASIX...

==================================================
Training Baseline ASIX (SVM)
==================================================
Training SVM model...

Baseline ASIX Performance:
MAE: 37811.3317
RMSE: 46272.3256
MAPE: 11.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 199
   • Highly important features (top 5%): 97

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t1: importance=0.0012, rank=1
   2. Feature_65_t2: importance=0.0008, rank=2
   3. Feature_63_t0: importance=0.0006, rank=3
   4. Feature_63_t1: importance=0.0006, rank=4
   5. Feature_93_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for ASIX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ASIX...

==================================================
Training Enhanced ASIX (SVM)
==================================================
Training SVM model...

Enhanced ASIX Performance:
MAE: 32284.4853
RMSE: 39046.0016
MAPE: 9.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0012, rank=1
   2. Feature_5_t2: importance=0.0009, rank=2
   3. Feature_15_t2: importance=0.0009, rank=3
   4. Feature_5_t3: importance=0.0008, rank=4
   5. Feature_4_t3: importance=0.0007, rank=5

📊 ASIX Results:
  Baseline MAPE: 11.77%
  Enhanced MAPE: 9.30%
  MAPE Improvement: +2.47% (+21.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 45/464: ASTE
============================================================
📊 Loading data for ASTE...
📊 Loading data for ASTE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ASTE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ASTE...

==================================================
Training Baseline ASTE (SVM)
==================================================
Training SVM model...

Baseline ASTE Performance:
MAE: 50791.6298
RMSE: 60943.0233
MAPE: 12.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 168
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_95_t0: importance=0.0006, rank=1
   2. Feature_88_t1: importance=0.0005, rank=2
   3. Feature_87_t1: importance=0.0003, rank=3
   4. Feature_85_t1: importance=0.0003, rank=4
   5. Feature_96_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ASTE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ASTE...

==================================================
Training Enhanced ASTE (SVM)
==================================================
Training SVM model...

Enhanced ASTE Performance:
MAE: 48687.7860
RMSE: 62186.8766
MAPE: 11.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0012, rank=1
   2. Feature_17_t0: importance=0.0011, rank=2
   3. Feature_17_t3: importance=0.0007, rank=3
   4. Feature_22_t3: importance=0.0006, rank=4
   5. Feature_20_t3: importance=0.0005, rank=5

📊 ASTE Results:
  Baseline MAPE: 12.31%
  Enhanced MAPE: 11.25%
  MAPE Improvement: +1.06% (+8.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 46/464: ATEN
============================================================
📊 Loading data for ATEN...
📊 Loading data for ATEN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ATEN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ATEN...

==================================================
Training Baseline ATEN (SVM)
==================================================
Training SVM model...

Baseline ATEN Performance:
MAE: 463846.0877
RMSE: 633462.8777
MAPE: 16.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 175
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t3: importance=0.0010, rank=1
   2. Feature_67_t1: importance=0.0009, rank=2
   3. Feature_92_t0: importance=0.0007, rank=3
   4. Feature_63_t1: importance=0.0007, rank=4
   5. Feature_63_t0: importance=0.0007, rank=5

🔧 Applying universal feature engineering for ATEN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ATEN...

==================================================
Training Enhanced ATEN (SVM)
==================================================
Training SVM model...

Enhanced ATEN Performance:
MAE: 470174.0018
RMSE: 653645.2305
MAPE: 16.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0019, rank=1
   2. Feature_22_t2: importance=0.0019, rank=2
   3. Feature_2_t0: importance=0.0018, rank=3
   4. Feature_7_t1: importance=0.0017, rank=4
   5. Feature_15_t2: importance=0.0013, rank=5

📊 ATEN Results:
  Baseline MAPE: 16.60%
  Enhanced MAPE: 16.89%
  MAPE Improvement: -0.29% (-1.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 47/464: ATGE
============================================================
📊 Loading data for ATGE...
📊 Loading data for ATGE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ATGE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ATGE...

==================================================
Training Baseline ATGE (SVM)
==================================================
Training SVM model...

Baseline ATGE Performance:
MAE: 200590.8620
RMSE: 279451.9818
MAPE: 15.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 219
   • Highly important features (top 5%): 104

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t2: importance=0.0009, rank=1
   2. Feature_81_t1: importance=0.0007, rank=2
   3. Feature_79_t1: importance=0.0007, rank=3
   4. Feature_75_t2: importance=0.0005, rank=4
   5. Feature_73_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for ATGE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ATGE...

==================================================
Training Enhanced ATGE (SVM)
==================================================
Training SVM model...

Enhanced ATGE Performance:
MAE: 190274.0681
RMSE: 253179.6189
MAPE: 14.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0012, rank=1
   2. Feature_6_t2: importance=0.0012, rank=2
   3. Feature_23_t3: importance=0.0008, rank=3
   4. Feature_17_t1: importance=0.0008, rank=4
   5. Feature_5_t1: importance=0.0008, rank=5

📊 ATGE Results:
  Baseline MAPE: 15.44%
  Enhanced MAPE: 14.24%
  MAPE Improvement: +1.20% (+7.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 48/464: AVA
============================================================
📊 Loading data for AVA...
📊 Loading data for AVA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AVA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AVA...

==================================================
Training Baseline AVA (SVM)
==================================================
Training SVM model...

Baseline AVA Performance:
MAE: 204944.8282
RMSE: 257769.2224
MAPE: 6.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 263
   • Highly important features (top 5%): 136

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0006, rank=1
   2. Feature_0_t3: importance=0.0005, rank=2
   3. Feature_73_t0: importance=0.0004, rank=3
   4. Feature_69_t3: importance=0.0004, rank=4
   5. Feature_94_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for AVA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AVA...

==================================================
Training Enhanced AVA (SVM)
==================================================
Training SVM model...

Enhanced AVA Performance:
MAE: 263291.2025
RMSE: 325683.6035
MAPE: 8.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0014, rank=1
   2. Feature_7_t1: importance=0.0013, rank=2
   3. Feature_7_t0: importance=0.0011, rank=3
   4. Feature_7_t2: importance=0.0011, rank=4
   5. Feature_17_t0: importance=0.0010, rank=5

📊 AVA Results:
  Baseline MAPE: 6.98%
  Enhanced MAPE: 8.67%
  MAPE Improvement: -1.68% (-24.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 49/464: AWI
============================================================
📊 Loading data for AWI...
📊 Loading data for AWI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AWI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AWI...

==================================================
Training Baseline AWI (SVM)
==================================================
Training SVM model...

Baseline AWI Performance:
MAE: 129762.2305
RMSE: 172386.4790
MAPE: 19.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 339
   • Highly important features (top 5%): 197

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t3: importance=0.0009, rank=1
   2. Feature_74_t3: importance=0.0006, rank=2
   3. Feature_0_t2: importance=0.0005, rank=3
   4. Feature_90_t2: importance=0.0005, rank=4
   5. Feature_72_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for AWI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AWI...

==================================================
Training Enhanced AWI (SVM)
==================================================
Training SVM model...

Enhanced AWI Performance:
MAE: 113552.3801
RMSE: 162341.2952
MAPE: 16.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0013, rank=1
   2. Feature_1_t3: importance=0.0011, rank=2
   3. Feature_22_t1: importance=0.0008, rank=3
   4. Feature_13_t1: importance=0.0008, rank=4
   5. Feature_13_t3: importance=0.0007, rank=5

📊 AWI Results:
  Baseline MAPE: 19.19%
  Enhanced MAPE: 16.30%
  MAPE Improvement: +2.89% (+15.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 50/464: AWR
============================================================
📊 Loading data for AWR...
📊 Loading data for AWR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AWR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AWR...

==================================================
Training Baseline AWR (SVM)
==================================================
Training SVM model...

Baseline AWR Performance:
MAE: 58962.7989
RMSE: 78794.6604
MAPE: 11.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 281
   • Highly important features (top 5%): 141

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t3: importance=0.0007, rank=1
   2. Feature_67_t0: importance=0.0006, rank=2
   3. Feature_92_t3: importance=0.0005, rank=3
   4. Feature_65_t3: importance=0.0005, rank=4
   5. Feature_73_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for AWR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AWR...

==================================================
Training Enhanced AWR (SVM)
==================================================
Training SVM model...

Enhanced AWR Performance:
MAE: 60495.0652
RMSE: 78176.3732
MAPE: 11.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0024, rank=1
   2. Feature_20_t3: importance=0.0011, rank=2
   3. Feature_7_t2: importance=0.0010, rank=3
   4. Feature_5_t3: importance=0.0009, rank=4
   5. Feature_17_t0: importance=0.0009, rank=5

📊 AWR Results:
  Baseline MAPE: 11.59%
  Enhanced MAPE: 11.98%
  MAPE Improvement: -0.40% (-3.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 51/464: AXL
============================================================
📊 Loading data for AXL...
📊 Loading data for AXL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing AXL: 'AXL'

============================================================
TESTING TICKER 52/464: AZZ
============================================================
📊 Loading data for AZZ...
📊 Loading data for AZZ from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for AZZ...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for AZZ...

==================================================
Training Baseline AZZ (SVM)
==================================================
Training SVM model...

Baseline AZZ Performance:
MAE: 81425.2466
RMSE: 124878.5800
MAPE: 13.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 242
   • Highly important features (top 5%): 125

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0012, rank=1
   2. Feature_80_t0: importance=0.0012, rank=2
   3. Feature_68_t0: importance=0.0008, rank=3
   4. Feature_94_t0: importance=0.0008, rank=4
   5. Feature_0_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for AZZ...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for AZZ...

==================================================
Training Enhanced AZZ (SVM)
==================================================
Training SVM model...

Enhanced AZZ Performance:
MAE: 82733.3759
RMSE: 126784.4724
MAPE: 12.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0019, rank=1
   2. Feature_22_t2: importance=0.0018, rank=2
   3. Feature_13_t1: importance=0.0018, rank=3
   4. Feature_5_t2: importance=0.0016, rank=4
   5. Feature_4_t1: importance=0.0016, rank=5

📊 AZZ Results:
  Baseline MAPE: 13.16%
  Enhanced MAPE: 12.75%
  MAPE Improvement: +0.41% (+3.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 53/464: BANC
============================================================
📊 Loading data for BANC...
📊 Loading data for BANC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BANC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BANC...

==================================================
Training Baseline BANC (SVM)
==================================================
Training SVM model...

Baseline BANC Performance:
MAE: 1020227.4181
RMSE: 1443680.1117
MAPE: 8.71%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 182
   • Highly important features (top 5%): 99

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t1: importance=0.0006, rank=1
   2. Feature_93_t0: importance=0.0005, rank=2
   3. Feature_92_t0: importance=0.0005, rank=3
   4. Feature_65_t1: importance=0.0005, rank=4
   5. Feature_65_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for BANC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BANC...

==================================================
Training Enhanced BANC (SVM)
==================================================
Training SVM model...

Enhanced BANC Performance:
MAE: 1057028.1391
RMSE: 1461264.5792
MAPE: 8.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0022, rank=1
   2. Feature_14_t0: importance=0.0012, rank=2
   3. Feature_19_t1: importance=0.0009, rank=3
   4. Feature_12_t1: importance=0.0009, rank=4
   5. Feature_7_t2: importance=0.0009, rank=5

📊 BANC Results:
  Baseline MAPE: 8.71%
  Enhanced MAPE: 8.95%
  MAPE Improvement: -0.24% (-2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 54/464: BANF
============================================================
📊 Loading data for BANF...
📊 Loading data for BANF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing BANF: 'BANF'

============================================================
TESTING TICKER 55/464: BANR
============================================================
📊 Loading data for BANR...
📊 Loading data for BANR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BANR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BANR...

==================================================
Training Baseline BANR (SVM)
==================================================
Training SVM model...

Baseline BANR Performance:
MAE: 65832.5994
RMSE: 86822.3858
MAPE: 7.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 126
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0004, rank=1
   2. Feature_63_t0: importance=0.0003, rank=2
   3. Feature_0_t2: importance=0.0003, rank=3
   4. Feature_78_t0: importance=0.0002, rank=4
   5. Feature_88_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for BANR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BANR...

==================================================
Training Enhanced BANR (SVM)
==================================================
Training SVM model...

Enhanced BANR Performance:
MAE: 73452.2098
RMSE: 93481.8724
MAPE: 8.45%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t0: importance=0.0006, rank=1
   2. Feature_0_t3: importance=0.0004, rank=2
   3. Feature_1_t1: importance=0.0003, rank=3
   4. Feature_7_t0: importance=0.0003, rank=4
   5. Feature_14_t1: importance=0.0003, rank=5

📊 BANR Results:
  Baseline MAPE: 7.72%
  Enhanced MAPE: 8.45%
  MAPE Improvement: -0.73% (-9.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 56/464: BCC
============================================================
📊 Loading data for BCC...
📊 Loading data for BCC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BCC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BCC...

==================================================
Training Baseline BCC (SVM)
==================================================
Training SVM model...

Baseline BCC Performance:
MAE: 127919.0391
RMSE: 182720.2933
MAPE: 11.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 145
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0008, rank=1
   2. Feature_63_t0: importance=0.0008, rank=2
   3. Feature_63_t2: importance=0.0004, rank=3
   4. Feature_65_t2: importance=0.0004, rank=4
   5. Feature_82_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for BCC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BCC...

==================================================
Training Enhanced BCC (SVM)
==================================================
Training SVM model...

Enhanced BCC Performance:
MAE: 134293.5781
RMSE: 182742.1450
MAPE: 12.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0010, rank=1
   2. Feature_16_t0: importance=0.0007, rank=2
   3. Feature_13_t0: importance=0.0007, rank=3
   4. Feature_7_t2: importance=0.0007, rank=4
   5. Feature_15_t3: importance=0.0007, rank=5

📊 BCC Results:
  Baseline MAPE: 11.88%
  Enhanced MAPE: 12.68%
  MAPE Improvement: -0.80% (-6.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 57/464: BCPC
============================================================
📊 Loading data for BCPC...
📊 Loading data for BCPC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BCPC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BCPC...

==================================================
Training Baseline BCPC (SVM)
==================================================
Training SVM model...

Baseline BCPC Performance:
MAE: 38258.5765
RMSE: 47317.8840
MAPE: 9.04%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 173
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t0: importance=0.0003, rank=1
   2. Feature_64_t3: importance=0.0003, rank=2
   3. Feature_1_t1: importance=0.0002, rank=3
   4. Feature_67_t0: importance=0.0002, rank=4
   5. Feature_74_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for BCPC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BCPC...

==================================================
Training Enhanced BCPC (SVM)
==================================================
Training SVM model...

Enhanced BCPC Performance:
MAE: 38744.9386
RMSE: 49158.5948
MAPE: 8.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0005, rank=1
   2. Feature_1_t1: importance=0.0005, rank=2
   3. Feature_16_t1: importance=0.0005, rank=3
   4. Feature_24_t1: importance=0.0004, rank=4
   5. Feature_5_t1: importance=0.0004, rank=5

📊 BCPC Results:
  Baseline MAPE: 9.04%
  Enhanced MAPE: 8.83%
  MAPE Improvement: +0.22% (+2.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 58/464: BDN
============================================================
📊 Loading data for BDN...
📊 Loading data for BDN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BDN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BDN...

==================================================
Training Baseline BDN (SVM)
==================================================
Training SVM model...

Baseline BDN Performance:
MAE: 717720.8356
RMSE: 1140040.5757
MAPE: 5.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 101
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t0: importance=0.0012, rank=1
   2. Feature_81_t0: importance=0.0006, rank=2
   3. Feature_70_t0: importance=0.0006, rank=3
   4. Feature_67_t0: importance=0.0006, rank=4
   5. Feature_95_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for BDN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BDN...

==================================================
Training Enhanced BDN (SVM)
==================================================
Training SVM model...

Enhanced BDN Performance:
MAE: 646598.3348
RMSE: 1070080.8044
MAPE: 5.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0019, rank=1
   2. Feature_20_t3: importance=0.0011, rank=2
   3. Feature_19_t3: importance=0.0010, rank=3
   4. Feature_23_t1: importance=0.0010, rank=4
   5. Feature_17_t3: importance=0.0010, rank=5

📊 BDN Results:
  Baseline MAPE: 5.66%
  Enhanced MAPE: 5.13%
  MAPE Improvement: +0.53% (+9.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 59/464: BFS
============================================================
📊 Loading data for BFS...
📊 Loading data for BFS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing BFS: 'BFS'

============================================================
TESTING TICKER 60/464: BHE
============================================================
📊 Loading data for BHE...
📊 Loading data for BHE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BHE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BHE...

==================================================
Training Baseline BHE (SVM)
==================================================
Training SVM model...

Baseline BHE Performance:
MAE: 117367.9813
RMSE: 146426.7627
MAPE: 11.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 294
   • Highly important features (top 5%): 140

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0015, rank=1
   2. Feature_95_t2: importance=0.0013, rank=2
   3. Feature_71_t3: importance=0.0013, rank=3
   4. Feature_80_t2: importance=0.0009, rank=4
   5. Feature_78_t2: importance=0.0009, rank=5

🔧 Applying universal feature engineering for BHE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BHE...

==================================================
Training Enhanced BHE (SVM)
==================================================
Training SVM model...

Enhanced BHE Performance:
MAE: 121362.5038
RMSE: 156695.4990
MAPE: 11.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 64
   • Highly important features (top 5%): 35

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t1: importance=0.0061, rank=1
   2. Feature_16_t2: importance=0.0042, rank=2
   3. Feature_4_t2: importance=0.0035, rank=3
   4. Feature_19_t0: importance=0.0024, rank=4
   5. Feature_4_t3: importance=0.0019, rank=5

📊 BHE Results:
  Baseline MAPE: 11.75%
  Enhanced MAPE: 11.56%
  MAPE Improvement: +0.19% (+1.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 61/464: BJRI
============================================================
📊 Loading data for BJRI...
📊 Loading data for BJRI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BJRI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BJRI...

==================================================
Training Baseline BJRI (SVM)
==================================================
Training SVM model...

Baseline BJRI Performance:
MAE: 113741.1628
RMSE: 145076.8287
MAPE: 6.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 209
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0005, rank=1
   2. Feature_63_t0: importance=0.0003, rank=2
   3. Feature_93_t2: importance=0.0002, rank=3
   4. Feature_95_t2: importance=0.0002, rank=4
   5. Feature_94_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for BJRI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BJRI...

==================================================
Training Enhanced BJRI (SVM)
==================================================
Training SVM model...

Enhanced BJRI Performance:
MAE: 106143.1285
RMSE: 140687.5367
MAPE: 6.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0005, rank=1
   2. Feature_20_t3: importance=0.0005, rank=2
   3. Feature_22_t0: importance=0.0005, rank=3
   4. Feature_23_t3: importance=0.0003, rank=4
   5. Feature_24_t2: importance=0.0003, rank=5

📊 BJRI Results:
  Baseline MAPE: 6.57%
  Enhanced MAPE: 6.13%
  MAPE Improvement: +0.45% (+6.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 62/464: BKE
============================================================
📊 Loading data for BKE...
📊 Loading data for BKE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BKE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BKE...

==================================================
Training Baseline BKE (SVM)
==================================================
Training SVM model...

Baseline BKE Performance:
MAE: 227310.4418
RMSE: 292715.2720
MAPE: 7.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 197
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0001, rank=1
   2. Feature_73_t3: importance=0.0000, rank=2
   3. Feature_2_t2: importance=0.0000, rank=3
   4. Feature_90_t2: importance=0.0000, rank=4
   5. Feature_2_t0: importance=0.0000, rank=5

🔧 Applying universal feature engineering for BKE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BKE...

==================================================
Training Enhanced BKE (SVM)
==================================================
Training SVM model...

Enhanced BKE Performance:
MAE: 214647.8504
RMSE: 285632.6830
MAPE: 7.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0001, rank=1
   2. Feature_11_t2: importance=0.0001, rank=2
   3. Feature_17_t2: importance=0.0001, rank=3
   4. Feature_3_t2: importance=0.0001, rank=4
   5. Feature_2_t0: importance=0.0001, rank=5

📊 BKE Results:
  Baseline MAPE: 7.87%
  Enhanced MAPE: 7.43%
  MAPE Improvement: +0.44% (+5.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 63/464: BKU
============================================================
📊 Loading data for BKU...
📊 Loading data for BKU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BKU...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BKU...

==================================================
Training Baseline BKU (SVM)
==================================================
Training SVM model...

Baseline BKU Performance:
MAE: 228307.1118
RMSE: 277785.1350
MAPE: 7.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 296
   • Highly important features (top 5%): 112

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t2: importance=0.0004, rank=1
   2. Feature_82_t0: importance=0.0004, rank=2
   3. Feature_74_t2: importance=0.0004, rank=3
   4. Feature_82_t1: importance=0.0003, rank=4
   5. Feature_74_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for BKU...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BKU...

==================================================
Training Enhanced BKU (SVM)
==================================================
Training SVM model...

Enhanced BKU Performance:
MAE: 244941.0400
RMSE: 345463.8284
MAPE: 7.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0012, rank=1
   2. Feature_15_t2: importance=0.0011, rank=2
   3. Feature_1_t3: importance=0.0011, rank=3
   4. Feature_19_t3: importance=0.0007, rank=4
   5. Feature_7_t0: importance=0.0007, rank=5

📊 BKU Results:
  Baseline MAPE: 7.77%
  Enhanced MAPE: 7.96%
  MAPE Improvement: -0.19% (-2.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 64/464: BL
============================================================
📊 Loading data for BL...
📊 Loading data for BL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BL...

==================================================
Training Baseline BL (SVM)
==================================================
Training SVM model...

Baseline BL Performance:
MAE: 398634.5750
RMSE: 536977.8120
MAPE: 9.20%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 172
   • Highly important features (top 5%): 94

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t0: importance=0.0002, rank=1
   2. Feature_77_t1: importance=0.0001, rank=2
   3. Feature_2_t2: importance=0.0001, rank=3
   4. Feature_72_t2: importance=0.0001, rank=4
   5. Feature_86_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for BL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BL...

==================================================
Training Enhanced BL (SVM)
==================================================
Training SVM model...

Enhanced BL Performance:
MAE: 410937.5388
RMSE: 558424.4848
MAPE: 9.45%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0003, rank=1
   2. Feature_16_t3: importance=0.0002, rank=2
   3. Feature_20_t1: importance=0.0002, rank=3
   4. Feature_11_t2: importance=0.0002, rank=4
   5. Feature_13_t0: importance=0.0002, rank=5

📊 BL Results:
  Baseline MAPE: 9.20%
  Enhanced MAPE: 9.45%
  MAPE Improvement: -0.25% (-2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 65/464: BLFS
============================================================
📊 Loading data for BLFS...
📊 Loading data for BLFS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing BLFS: 'BLFS'

============================================================
TESTING TICKER 66/464: BLMN
============================================================
📊 Loading data for BLMN...
📊 Loading data for BLMN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BLMN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BLMN...

==================================================
Training Baseline BLMN (SVM)
==================================================
Training SVM model...

Baseline BLMN Performance:
MAE: 1043235.5495
RMSE: 1425109.4137
MAPE: 13.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 145
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t0: importance=0.0004, rank=1
   2. Feature_2_t2: importance=0.0004, rank=2
   3. Feature_0_t2: importance=0.0004, rank=3
   4. Feature_64_t3: importance=0.0003, rank=4
   5. Feature_84_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for BLMN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BLMN...

==================================================
Training Enhanced BLMN (SVM)
==================================================
Training SVM model...

Enhanced BLMN Performance:
MAE: 744375.4800
RMSE: 1005549.6097
MAPE: 10.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t3: importance=0.0006, rank=1
   2. Feature_15_t2: importance=0.0005, rank=2
   3. Feature_24_t1: importance=0.0005, rank=3
   4. Feature_12_t1: importance=0.0005, rank=4
   5. Feature_5_t3: importance=0.0005, rank=5

📊 BLMN Results:
  Baseline MAPE: 13.88%
  Enhanced MAPE: 10.16%
  MAPE Improvement: +3.72% (+26.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 67/464: BMI
============================================================
📊 Loading data for BMI...
📊 Loading data for BMI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BMI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BMI...

==================================================
Training Baseline BMI (SVM)
==================================================
Training SVM model...

Baseline BMI Performance:
MAE: 69759.4600
RMSE: 107918.2902
MAPE: 4.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 76
   • Highly important features (top 5%): 45

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_87_t2: importance=0.0001, rank=1
   2. Feature_63_t3: importance=0.0000, rank=2
   3. Feature_88_t2: importance=0.0000, rank=3
   4. Feature_2_t0: importance=0.0000, rank=4
   5. Feature_87_t0: importance=0.0000, rank=5

🔧 Applying universal feature engineering for BMI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BMI...

==================================================
Training Enhanced BMI (SVM)
==================================================
Training SVM model...

Enhanced BMI Performance:
MAE: 68260.3465
RMSE: 107543.1757
MAPE: 4.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t0: importance=0.0001, rank=1
   2. Feature_14_t2: importance=0.0001, rank=2
   3. Feature_20_t1: importance=0.0001, rank=3
   4. Feature_19_t3: importance=0.0001, rank=4
   5. Feature_19_t0: importance=0.0001, rank=5

📊 BMI Results:
  Baseline MAPE: 4.92%
  Enhanced MAPE: 4.79%
  MAPE Improvement: +0.13% (+2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 68/464: BOH
============================================================
📊 Loading data for BOH...
📊 Loading data for BOH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BOH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BOH...

==================================================
Training Baseline BOH (SVM)
==================================================
Training SVM model...

Baseline BOH Performance:
MAE: 179415.4940
RMSE: 230257.4058
MAPE: 3.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 153
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0002, rank=1
   2. Feature_93_t0: importance=0.0002, rank=2
   3. Feature_81_t2: importance=0.0002, rank=3
   4. Feature_82_t2: importance=0.0002, rank=4
   5. Feature_65_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for BOH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BOH...

==================================================
Training Enhanced BOH (SVM)
==================================================
Training SVM model...

Enhanced BOH Performance:
MAE: 286176.5004
RMSE: 346490.8505
MAPE: 5.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0004, rank=1
   2. Feature_7_t2: importance=0.0003, rank=2
   3. Feature_6_t0: importance=0.0002, rank=3
   4. Feature_21_t0: importance=0.0002, rank=4
   5. Feature_14_t0: importance=0.0002, rank=5

📊 BOH Results:
  Baseline MAPE: 3.86%
  Enhanced MAPE: 5.99%
  MAPE Improvement: -2.13% (-55.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 69/464: BOOT
============================================================
📊 Loading data for BOOT...
📊 Loading data for BOOT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BOOT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BOOT...

==================================================
Training Baseline BOOT (SVM)
==================================================
Training SVM model...

Baseline BOOT Performance:
MAE: 361007.3361
RMSE: 435027.7966
MAPE: 11.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 274
   • Highly important features (top 5%): 139

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_94_t0: importance=0.0002, rank=1
   2. Feature_63_t1: importance=0.0002, rank=2
   3. Feature_95_t3: importance=0.0001, rank=3
   4. Feature_68_t3: importance=0.0001, rank=4
   5. Feature_77_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for BOOT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BOOT...

==================================================
Training Enhanced BOOT (SVM)
==================================================
Training SVM model...

Enhanced BOOT Performance:
MAE: 291609.7792
RMSE: 366610.8856
MAPE: 9.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0004, rank=1
   2. Feature_14_t0: importance=0.0004, rank=2
   3. Feature_12_t0: importance=0.0003, rank=3
   4. Feature_2_t2: importance=0.0003, rank=4
   5. Feature_9_t2: importance=0.0002, rank=5

📊 BOOT Results:
  Baseline MAPE: 11.62%
  Enhanced MAPE: 9.40%
  MAPE Improvement: +2.22% (+19.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 70/464: BOX
============================================================
📊 Loading data for BOX...
📊 Loading data for BOX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing BOX: 'BOX'

============================================================
TESTING TICKER 71/464: BRC
============================================================
📊 Loading data for BRC...
📊 Loading data for BRC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BRC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BRC...

==================================================
Training Baseline BRC (SVM)
==================================================
Training SVM model...

Baseline BRC Performance:
MAE: 89758.7956
RMSE: 139803.0153
MAPE: 19.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 334
   • Highly important features (top 5%): 222

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t2: importance=0.0013, rank=1
   2. Feature_85_t2: importance=0.0009, rank=2
   3. Feature_86_t2: importance=0.0008, rank=3
   4. Feature_63_t2: importance=0.0007, rank=4
   5. Feature_91_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for BRC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BRC...

==================================================
Training Enhanced BRC (SVM)
==================================================
Training SVM model...

Enhanced BRC Performance:
MAE: 100226.9494
RMSE: 163861.8028
MAPE: 22.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t2: importance=0.0017, rank=1
   2. Feature_23_t2: importance=0.0016, rank=2
   3. Feature_1_t2: importance=0.0016, rank=3
   4. Feature_11_t2: importance=0.0015, rank=4
   5. Feature_17_t1: importance=0.0015, rank=5

📊 BRC Results:
  Baseline MAPE: 19.52%
  Enhanced MAPE: 22.42%
  MAPE Improvement: -2.90% (-14.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 72/464: BTU
============================================================
📊 Loading data for BTU...
📊 Loading data for BTU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing BTU: 'BTU'

============================================================
TESTING TICKER 73/464: BWA
============================================================
📊 Loading data for BWA...
📊 Loading data for BWA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BWA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BWA...

==================================================
Training Baseline BWA (SVM)
==================================================
Training SVM model...

Baseline BWA Performance:
MAE: 846638.0752
RMSE: 1138647.7820
MAPE: 8.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 244
   • Highly important features (top 5%): 128

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0003, rank=1
   2. Feature_1_t1: importance=0.0002, rank=2
   3. Feature_78_t3: importance=0.0002, rank=3
   4. Feature_80_t3: importance=0.0002, rank=4
   5. Feature_69_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for BWA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BWA...

==================================================
Training Enhanced BWA (SVM)
==================================================
Training SVM model...

Enhanced BWA Performance:
MAE: 926947.7988
RMSE: 1118247.4318
MAPE: 9.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0005, rank=1
   2. Feature_7_t1: importance=0.0005, rank=2
   3. Feature_16_t3: importance=0.0003, rank=3
   4. Feature_3_t2: importance=0.0003, rank=4
   5. Feature_19_t1: importance=0.0003, rank=5

📊 BWA Results:
  Baseline MAPE: 8.86%
  Enhanced MAPE: 9.43%
  MAPE Improvement: -0.57% (-6.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 74/464: BXMT
============================================================
📊 Loading data for BXMT...
📊 Loading data for BXMT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for BXMT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for BXMT...

==================================================
Training Baseline BXMT (SVM)
==================================================
Training SVM model...

Baseline BXMT Performance:
MAE: 1632856.2397
RMSE: 2088279.8306
MAPE: 8.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 243
   • Highly important features (top 5%): 157

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0003, rank=1
   2. Feature_94_t3: importance=0.0002, rank=2
   3. Feature_77_t2: importance=0.0002, rank=3
   4. Feature_79_t3: importance=0.0002, rank=4
   5. Feature_91_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for BXMT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for BXMT...

==================================================
Training Enhanced BXMT (SVM)
==================================================
Training SVM model...

Enhanced BXMT Performance:
MAE: 1615256.1888
RMSE: 1940721.4977
MAPE: 9.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0013, rank=1
   2. Feature_1_t3: importance=0.0004, rank=2
   3. Feature_20_t3: importance=0.0004, rank=3
   4. Feature_5_t3: importance=0.0004, rank=4
   5. Feature_15_t3: importance=0.0004, rank=5

📊 BXMT Results:
  Baseline MAPE: 8.70%
  Enhanced MAPE: 9.28%
  MAPE Improvement: -0.58% (-6.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 75/464: CABO
============================================================
📊 Loading data for CABO...
📊 Loading data for CABO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CABO: 'CABO'

============================================================
TESTING TICKER 76/464: CAKE
============================================================
📊 Loading data for CAKE...
📊 Loading data for CAKE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CAKE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CAKE...

==================================================
Training Baseline CAKE (SVM)
==================================================
Training SVM model...

Baseline CAKE Performance:
MAE: 376774.3232
RMSE: 502590.6484
MAPE: 5.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 122
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0002, rank=1
   2. Feature_63_t1: importance=0.0001, rank=2
   3. Feature_95_t1: importance=0.0001, rank=3
   4. Feature_84_t1: importance=0.0001, rank=4
   5. Feature_63_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CAKE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CAKE...

==================================================
Training Enhanced CAKE (SVM)
==================================================
Training SVM model...

Enhanced CAKE Performance:
MAE: 383822.5292
RMSE: 494182.1943
MAPE: 5.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 71
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t3: importance=0.0002, rank=1
   2. Feature_14_t2: importance=0.0001, rank=2
   3. Feature_4_t2: importance=0.0001, rank=3
   4. Feature_11_t0: importance=0.0001, rank=4
   5. Feature_6_t0: importance=0.0001, rank=5

📊 CAKE Results:
  Baseline MAPE: 5.27%
  Enhanced MAPE: 5.44%
  MAPE Improvement: -0.16% (-3.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 77/464: CAL
============================================================
📊 Loading data for CAL...
📊 Loading data for CAL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CAL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CAL...

==================================================
Training Baseline CAL (SVM)
==================================================
Training SVM model...

Baseline CAL Performance:
MAE: 320680.3261
RMSE: 407010.0089
MAPE: 8.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 305
   • Highly important features (top 5%): 200

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t3: importance=0.0002, rank=1
   2. Feature_83_t1: importance=0.0002, rank=2
   3. Feature_71_t3: importance=0.0001, rank=3
   4. Feature_66_t0: importance=0.0001, rank=4
   5. Feature_91_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CAL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CAL...

==================================================
Training Enhanced CAL (SVM)
==================================================
Training SVM model...

Enhanced CAL Performance:
MAE: 333471.7443
RMSE: 396272.0777
MAPE: 8.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0006, rank=1
   2. Feature_17_t2: importance=0.0004, rank=2
   3. Feature_24_t3: importance=0.0004, rank=3
   4. Feature_11_t3: importance=0.0003, rank=4
   5. Feature_3_t3: importance=0.0003, rank=5

📊 CAL Results:
  Baseline MAPE: 8.22%
  Enhanced MAPE: 8.72%
  MAPE Improvement: -0.50% (-6.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 78/464: CALM
============================================================
📊 Loading data for CALM...
📊 Loading data for CALM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CALM: 'CALM'

============================================================
TESTING TICKER 79/464: CALX
============================================================
📊 Loading data for CALX...
📊 Loading data for CALX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CALX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CALX...

==================================================
Training Baseline CALX (SVM)
==================================================
Training SVM model...

Baseline CALX Performance:
MAE: 302724.5220
RMSE: 374962.8621
MAPE: 11.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 186
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_93_t2: importance=0.0006, rank=1
   2. Feature_2_t2: importance=0.0006, rank=2
   3. Feature_72_t0: importance=0.0005, rank=3
   4. Feature_94_t2: importance=0.0004, rank=4
   5. Feature_78_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for CALX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CALX...

==================================================
Training Enhanced CALX (SVM)
==================================================
Training SVM model...

Enhanced CALX Performance:
MAE: 259135.9176
RMSE: 325955.5544
MAPE: 9.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t2: importance=0.0009, rank=1
   2. Feature_2_t2: importance=0.0006, rank=2
   3. Feature_5_t2: importance=0.0005, rank=3
   4. Feature_12_t2: importance=0.0005, rank=4
   5. Feature_4_t1: importance=0.0005, rank=5

📊 CALX Results:
  Baseline MAPE: 11.43%
  Enhanced MAPE: 9.32%
  MAPE Improvement: +2.11% (+18.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 80/464: CARG
============================================================
📊 Loading data for CARG...
📊 Loading data for CARG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CARG: 'CARG'

============================================================
TESTING TICKER 81/464: CARS
============================================================
📊 Loading data for CARS...
📊 Loading data for CARS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CARS: 'CARS'

============================================================
TESTING TICKER 82/464: CASH
============================================================
📊 Loading data for CASH...
📊 Loading data for CASH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CASH: 'CASH'

============================================================
TESTING TICKER 83/464: CATY
============================================================
📊 Loading data for CATY...
📊 Loading data for CATY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CATY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CATY...

==================================================
Training Baseline CATY (SVM)
==================================================
Training SVM model...

Baseline CATY Performance:
MAE: 197429.1019
RMSE: 234300.7265
MAPE: 10.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 259
   • Highly important features (top 5%): 161

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0008, rank=1
   2. Feature_71_t3: importance=0.0003, rank=2
   3. Feature_70_t3: importance=0.0003, rank=3
   4. Feature_0_t3: importance=0.0002, rank=4
   5. Feature_0_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CATY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CATY...

==================================================
Training Enhanced CATY (SVM)
==================================================
Training SVM model...

Enhanced CATY Performance:
MAE: 174251.1002
RMSE: 218913.6020
MAPE: 9.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0013, rank=1
   2. Feature_15_t2: importance=0.0004, rank=2
   3. Feature_7_t2: importance=0.0004, rank=3
   4. Feature_17_t1: importance=0.0004, rank=4
   5. Feature_9_t1: importance=0.0004, rank=5

📊 CATY Results:
  Baseline MAPE: 10.00%
  Enhanced MAPE: 9.06%
  MAPE Improvement: +0.94% (+9.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 84/464: CBRL
============================================================
📊 Loading data for CBRL...
📊 Loading data for CBRL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CBRL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CBRL...

==================================================
Training Baseline CBRL (SVM)
==================================================
Training SVM model...

Baseline CBRL Performance:
MAE: 361681.1430
RMSE: 469875.0912
MAPE: 11.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 214
   • Highly important features (top 5%): 94

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0002, rank=1
   2. Feature_83_t1: importance=0.0001, rank=2
   3. Feature_70_t3: importance=0.0001, rank=3
   4. Feature_65_t3: importance=0.0001, rank=4
   5. Feature_76_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CBRL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CBRL...

==================================================
Training Enhanced CBRL (SVM)
==================================================
Training SVM model...

Enhanced CBRL Performance:
MAE: 358550.4424
RMSE: 468989.3414
MAPE: 11.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t1: importance=0.0003, rank=1
   2. Feature_20_t3: importance=0.0002, rank=2
   3. Feature_17_t1: importance=0.0002, rank=3
   4. Feature_19_t3: importance=0.0002, rank=4
   5. Feature_22_t0: importance=0.0002, rank=5

📊 CBRL Results:
  Baseline MAPE: 11.60%
  Enhanced MAPE: 11.54%
  MAPE Improvement: +0.06% (+0.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 85/464: CBU
============================================================
📊 Loading data for CBU...
📊 Loading data for CBU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CBU...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CBU...

==================================================
Training Baseline CBU (SVM)
==================================================
Training SVM model...

Baseline CBU Performance:
MAE: 88551.8768
RMSE: 108458.9963
MAPE: 5.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 176
   • Highly important features (top 5%): 93

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t0: importance=0.0001, rank=1
   2. Feature_1_t3: importance=0.0001, rank=2
   3. Feature_77_t2: importance=0.0001, rank=3
   4. Feature_81_t3: importance=0.0001, rank=4
   5. Feature_74_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CBU...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CBU...

==================================================
Training Enhanced CBU (SVM)
==================================================
Training SVM model...

Enhanced CBU Performance:
MAE: 90597.1303
RMSE: 113432.0162
MAPE: 6.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0002, rank=1
   2. Feature_12_t3: importance=0.0001, rank=2
   3. Feature_19_t1: importance=0.0001, rank=3
   4. Feature_10_t1: importance=0.0001, rank=4
   5. Feature_23_t1: importance=0.0001, rank=5

📊 CBU Results:
  Baseline MAPE: 5.84%
  Enhanced MAPE: 6.05%
  MAPE Improvement: -0.21% (-3.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 86/464: CC
============================================================
📊 Loading data for CC...
📊 Loading data for CC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CC...

==================================================
Training Baseline CC (SVM)
==================================================
Training SVM model...

Baseline CC Performance:
MAE: 590013.9648
RMSE: 957455.3626
MAPE: 6.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 294
   • Highly important features (top 5%): 160

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0003, rank=1
   2. Feature_69_t3: importance=0.0002, rank=2
   3. Feature_66_t2: importance=0.0001, rank=3
   4. Feature_79_t2: importance=0.0001, rank=4
   5. Feature_91_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CC...

==================================================
Training Enhanced CC (SVM)
==================================================
Training SVM model...

Enhanced CC Performance:
MAE: 623162.9211
RMSE: 965395.4995
MAPE: 6.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0002, rank=1
   2. Feature_16_t1: importance=0.0002, rank=2
   3. Feature_19_t0: importance=0.0002, rank=3
   4. Feature_23_t3: importance=0.0002, rank=4
   5. Feature_13_t3: importance=0.0002, rank=5

📊 CC Results:
  Baseline MAPE: 6.23%
  Enhanced MAPE: 6.74%
  MAPE Improvement: -0.50% (-8.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 87/464: CCOI
============================================================
📊 Loading data for CCOI...
📊 Loading data for CCOI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CCOI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CCOI...

==================================================
Training Baseline CCOI (SVM)
==================================================
Training SVM model...

Baseline CCOI Performance:
MAE: 322520.5422
RMSE: 415123.1182
MAPE: 8.71%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 248
   • Highly important features (top 5%): 118

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_94_t0: importance=0.0003, rank=1
   2. Feature_92_t0: importance=0.0002, rank=2
   3. Feature_70_t3: importance=0.0002, rank=3
   4. Feature_63_t0: importance=0.0002, rank=4
   5. Feature_90_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CCOI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CCOI...

==================================================
Training Enhanced CCOI (SVM)
==================================================
Training SVM model...

Enhanced CCOI Performance:
MAE: 299964.1636
RMSE: 405571.6437
MAPE: 8.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t0: importance=0.0005, rank=1
   2. Feature_11_t1: importance=0.0003, rank=2
   3. Feature_23_t2: importance=0.0003, rank=3
   4. Feature_15_t1: importance=0.0003, rank=4
   5. Feature_1_t0: importance=0.0003, rank=5

📊 CCOI Results:
  Baseline MAPE: 8.71%
  Enhanced MAPE: 8.02%
  MAPE Improvement: +0.70% (+8.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 88/464: CCS
============================================================
📊 Loading data for CCS...
📊 Loading data for CCS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CCS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CCS...

==================================================
Training Baseline CCS (SVM)
==================================================
Training SVM model...

Baseline CCS Performance:
MAE: 151382.9995
RMSE: 211381.2043
MAPE: 9.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 145
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t3: importance=0.0001, rank=1
   2. Feature_67_t3: importance=0.0001, rank=2
   3. Feature_2_t1: importance=0.0001, rank=3
   4. Feature_0_t0: importance=0.0001, rank=4
   5. Feature_0_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CCS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CCS...

==================================================
Training Enhanced CCS (SVM)
==================================================
Training SVM model...

Enhanced CCS Performance:
MAE: 166894.7506
RMSE: 226493.5745
MAPE: 10.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 72
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0003, rank=1
   2. Feature_15_t3: importance=0.0003, rank=2
   3. Feature_24_t2: importance=0.0002, rank=3
   4. Feature_15_t1: importance=0.0002, rank=4
   5. Feature_17_t1: importance=0.0002, rank=5

📊 CCS Results:
  Baseline MAPE: 9.94%
  Enhanced MAPE: 10.91%
  MAPE Improvement: -0.96% (-9.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 89/464: CE
============================================================
📊 Loading data for CE...
📊 Loading data for CE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CE...

==================================================
Training Baseline CE (SVM)
==================================================
Training SVM model...

Baseline CE Performance:
MAE: 487260.0178
RMSE: 685188.8250
MAPE: 7.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 319
   • Highly important features (top 5%): 188

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t2: importance=0.0009, rank=1
   2. Feature_73_t2: importance=0.0007, rank=2
   3. Feature_80_t3: importance=0.0007, rank=3
   4. Feature_94_t3: importance=0.0006, rank=4
   5. Feature_94_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for CE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CE...

==================================================
Training Enhanced CE (SVM)
==================================================
Training SVM model...

Enhanced CE Performance:
MAE: 456268.9259
RMSE: 635820.8487
MAPE: 7.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0021, rank=1
   2. Feature_15_t2: importance=0.0019, rank=2
   3. Feature_7_t1: importance=0.0016, rank=3
   4. Feature_1_t1: importance=0.0014, rank=4
   5. Feature_13_t3: importance=0.0011, rank=5

📊 CE Results:
  Baseline MAPE: 7.68%
  Enhanced MAPE: 7.19%
  MAPE Improvement: +0.49% (+6.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 90/464: CENT
============================================================
📊 Loading data for CENT...
📊 Loading data for CENT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CENT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CENT...

==================================================
Training Baseline CENT (SVM)
==================================================
Training SVM model...

Baseline CENT Performance:
MAE: 110949.6749
RMSE: 180231.4703
MAPE: 8.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 226
   • Highly important features (top 5%): 109

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t0: importance=0.0005, rank=1
   2. Feature_80_t3: importance=0.0004, rank=2
   3. Feature_67_t3: importance=0.0004, rank=3
   4. Feature_73_t0: importance=0.0004, rank=4
   5. Feature_2_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for CENT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CENT...

==================================================
Training Enhanced CENT (SVM)
==================================================
Training SVM model...

Enhanced CENT Performance:
MAE: 112430.4866
RMSE: 179851.0324
MAPE: 8.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0011, rank=1
   2. Feature_22_t0: importance=0.0009, rank=2
   3. Feature_19_t2: importance=0.0008, rank=3
   4. Feature_17_t1: importance=0.0008, rank=4
   5. Feature_24_t1: importance=0.0008, rank=5

📊 CENT Results:
  Baseline MAPE: 8.01%
  Enhanced MAPE: 8.19%
  MAPE Improvement: -0.18% (-2.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 91/464: CENTA
============================================================
📊 Loading data for CENTA...
📊 Loading data for CENTA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CENTA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CENTA...

==================================================
Training Baseline CENTA (SVM)
==================================================
Training SVM model...

Baseline CENTA Performance:
MAE: 94342.7120
RMSE: 124775.6905
MAPE: 11.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 173
   • Highly important features (top 5%): 95

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_95_t0: importance=0.0006, rank=1
   2. Feature_63_t2: importance=0.0005, rank=2
   3. Feature_96_t0: importance=0.0005, rank=3
   4. Feature_63_t0: importance=0.0005, rank=4
   5. Feature_0_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for CENTA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CENTA...

==================================================
Training Enhanced CENTA (SVM)
==================================================
Training SVM model...

Enhanced CENTA Performance:
MAE: 94402.5980
RMSE: 127140.9581
MAPE: 11.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t1: importance=0.0008, rank=1
   2. Feature_1_t0: importance=0.0007, rank=2
   3. Feature_13_t1: importance=0.0006, rank=3
   4. Feature_5_t2: importance=0.0006, rank=4
   5. Feature_19_t0: importance=0.0005, rank=5

📊 CENTA Results:
  Baseline MAPE: 11.54%
  Enhanced MAPE: 11.54%
  MAPE Improvement: +0.00% (+0.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 92/464: CENX
============================================================
📊 Loading data for CENX...
📊 Loading data for CENX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CENX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CENX...

==================================================
Training Baseline CENX (SVM)
==================================================
Training SVM model...

Baseline CENX Performance:
MAE: 526444.8434
RMSE: 672733.1169
MAPE: 9.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 317
   • Highly important features (top 5%): 185

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t3: importance=0.0003, rank=1
   2. Feature_91_t1: importance=0.0002, rank=2
   3. Feature_85_t0: importance=0.0002, rank=3
   4. Feature_88_t0: importance=0.0002, rank=4
   5. Feature_81_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CENX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CENX...

==================================================
Training Enhanced CENX (SVM)
==================================================
Training SVM model...

Enhanced CENX Performance:
MAE: 475699.9473
RMSE: 617993.2694
MAPE: 8.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t1: importance=0.0004, rank=1
   2. Feature_19_t0: importance=0.0004, rank=2
   3. Feature_17_t0: importance=0.0004, rank=3
   4. Feature_7_t1: importance=0.0004, rank=4
   5. Feature_13_t1: importance=0.0003, rank=5

📊 CENX Results:
  Baseline MAPE: 9.27%
  Enhanced MAPE: 8.56%
  MAPE Improvement: +0.71% (+7.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 93/464: CEVA
============================================================
📊 Loading data for CEVA...
📊 Loading data for CEVA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CEVA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CEVA...

==================================================
Training Baseline CEVA (SVM)
==================================================
Training SVM model...

Baseline CEVA Performance:
MAE: 104121.1299
RMSE: 158977.8143
MAPE: 9.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 149
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0007, rank=1
   2. Feature_96_t3: importance=0.0006, rank=2
   3. Feature_0_t0: importance=0.0005, rank=3
   4. Feature_2_t3: importance=0.0005, rank=4
   5. Feature_65_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for CEVA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CEVA...

==================================================
Training Enhanced CEVA (SVM)
==================================================
Training SVM model...

Enhanced CEVA Performance:
MAE: 105884.4918
RMSE: 161370.1099
MAPE: 9.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t2: importance=0.0008, rank=1
   2. Feature_13_t2: importance=0.0007, rank=2
   3. Feature_5_t0: importance=0.0006, rank=3
   4. Feature_17_t3: importance=0.0006, rank=4
   5. Feature_14_t1: importance=0.0006, rank=5

📊 CEVA Results:
  Baseline MAPE: 9.62%
  Enhanced MAPE: 9.69%
  MAPE Improvement: -0.07% (-0.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 94/464: CFFN
============================================================
📊 Loading data for CFFN...
📊 Loading data for CFFN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CFFN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CFFN...

==================================================
Training Baseline CFFN (SVM)
==================================================
Training SVM model...

Baseline CFFN Performance:
MAE: 262374.9506
RMSE: 335003.6031
MAPE: 5.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 77
   • Highly important features (top 5%): 25

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t2: importance=0.0012, rank=1
   2. Feature_92_t3: importance=0.0010, rank=2
   3. Feature_63_t2: importance=0.0008, rank=3
   4. Feature_63_t1: importance=0.0007, rank=4
   5. Feature_0_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for CFFN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CFFN...

==================================================
Training Enhanced CFFN (SVM)
==================================================
Training SVM model...

Enhanced CFFN Performance:
MAE: 258939.4616
RMSE: 335044.2139
MAPE: 5.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 57
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0053, rank=1
   2. Feature_7_t2: importance=0.0010, rank=2
   3. Feature_4_t2: importance=0.0009, rank=3
   4. Feature_16_t2: importance=0.0009, rank=4
   5. Feature_9_t3: importance=0.0007, rank=5

📊 CFFN Results:
  Baseline MAPE: 5.87%
  Enhanced MAPE: 5.88%
  MAPE Improvement: -0.01% (-0.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 95/464: CHCO
============================================================
📊 Loading data for CHCO...
📊 Loading data for CHCO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CHCO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CHCO...

==================================================
Training Baseline CHCO (SVM)
==================================================
Training SVM model...

Baseline CHCO Performance:
MAE: 29202.0376
RMSE: 41073.4198
MAPE: 3.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 158
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t2: importance=0.0001, rank=1
   2. Feature_72_t2: importance=0.0001, rank=2
   3. Feature_68_t1: importance=0.0001, rank=3
   4. Feature_83_t1: importance=0.0000, rank=4
   5. Feature_65_t0: importance=0.0000, rank=5

🔧 Applying universal feature engineering for CHCO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CHCO...

==================================================
Training Enhanced CHCO (SVM)
==================================================
Training SVM model...

Enhanced CHCO Performance:
MAE: 41218.7495
RMSE: 51997.8303
MAPE: 4.36%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0003, rank=1
   2. Feature_5_t3: importance=0.0002, rank=2
   3. Feature_1_t2: importance=0.0001, rank=3
   4. Feature_20_t2: importance=0.0001, rank=4
   5. Feature_20_t0: importance=0.0001, rank=5

📊 CHCO Results:
  Baseline MAPE: 3.09%
  Enhanced MAPE: 4.36%
  MAPE Improvement: -1.27% (-41.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 96/464: CHEF
============================================================
📊 Loading data for CHEF...
📊 Loading data for CHEF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CHEF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CHEF...

==================================================
Training Baseline CHEF (SVM)
==================================================
Training SVM model...

Baseline CHEF Performance:
MAE: 204281.1127
RMSE: 247532.7276
MAPE: 6.45%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 206
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t3: importance=0.0001, rank=1
   2. Feature_81_t1: importance=0.0001, rank=2
   3. Feature_2_t1: importance=0.0001, rank=3
   4. Feature_0_t3: importance=0.0001, rank=4
   5. Feature_90_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CHEF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CHEF...

==================================================
Training Enhanced CHEF (SVM)
==================================================
Training SVM model...

Enhanced CHEF Performance:
MAE: 194682.9797
RMSE: 249756.1725
MAPE: 6.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 54
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t1: importance=0.0003, rank=1
   2. Feature_24_t1: importance=0.0003, rank=2
   3. Feature_10_t3: importance=0.0003, rank=3
   4. Feature_10_t1: importance=0.0002, rank=4
   5. Feature_23_t0: importance=0.0002, rank=5

📊 CHEF Results:
  Baseline MAPE: 6.45%
  Enhanced MAPE: 6.21%
  MAPE Improvement: +0.24% (+3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 97/464: CLB
============================================================
📊 Loading data for CLB...
📊 Loading data for CLB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CLB: 'CLB'

============================================================
TESTING TICKER 98/464: CNK
============================================================
📊 Loading data for CNK...
📊 Loading data for CNK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CNK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CNK...

==================================================
Training Baseline CNK (SVM)
==================================================
Training SVM model...

Baseline CNK Performance:
MAE: 1409498.8871
RMSE: 1767695.6463
MAPE: 5.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 172
   • Highly important features (top 5%): 104

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0005, rank=1
   2. Feature_63_t1: importance=0.0002, rank=2
   3. Feature_94_t1: importance=0.0001, rank=3
   4. Feature_63_t2: importance=0.0001, rank=4
   5. Feature_65_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for CNK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CNK...

==================================================
Training Enhanced CNK (SVM)
==================================================
Training SVM model...

Enhanced CNK Performance:
MAE: 1279264.3008
RMSE: 1542243.3652
MAPE: 5.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t3: importance=0.0003, rank=1
   2. Feature_2_t1: importance=0.0003, rank=2
   3. Feature_18_t1: importance=0.0003, rank=3
   4. Feature_17_t1: importance=0.0002, rank=4
   5. Feature_1_t0: importance=0.0002, rank=5

📊 CNK Results:
  Baseline MAPE: 5.85%
  Enhanced MAPE: 5.27%
  MAPE Improvement: +0.58% (+9.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 99/464: CNMD
============================================================
📊 Loading data for CNMD...
📊 Loading data for CNMD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CNMD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CNMD...

==================================================
Training Baseline CNMD (SVM)
==================================================
Training SVM model...

Baseline CNMD Performance:
MAE: 230389.1937
RMSE: 291576.6250
MAPE: 7.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 177
   • Highly important features (top 5%): 95

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_94_t3: importance=0.0006, rank=1
   2. Feature_68_t1: importance=0.0005, rank=2
   3. Feature_2_t2: importance=0.0005, rank=3
   4. Feature_82_t3: importance=0.0004, rank=4
   5. Feature_88_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CNMD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CNMD...

==================================================
Training Enhanced CNMD (SVM)
==================================================
Training SVM model...

Enhanced CNMD Performance:
MAE: 207770.3900
RMSE: 272169.9999
MAPE: 6.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0009, rank=1
   2. Feature_15_t1: importance=0.0007, rank=2
   3. Feature_7_t1: importance=0.0005, rank=3
   4. Feature_7_t2: importance=0.0005, rank=4
   5. Feature_13_t3: importance=0.0005, rank=5

📊 CNMD Results:
  Baseline MAPE: 7.57%
  Enhanced MAPE: 6.87%
  MAPE Improvement: +0.71% (+9.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 100/464: CNS
============================================================
📊 Loading data for CNS...
📊 Loading data for CNS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CNS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CNS...

==================================================
Training Baseline CNS (SVM)
==================================================
Training SVM model...

Baseline CNS Performance:
MAE: 177907.2439
RMSE: 238265.1411
MAPE: 9.33%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 169
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_85_t0: importance=0.0004, rank=1
   2. Feature_74_t1: importance=0.0003, rank=2
   3. Feature_76_t0: importance=0.0003, rank=3
   4. Feature_81_t2: importance=0.0003, rank=4
   5. Feature_71_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CNS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CNS...

==================================================
Training Enhanced CNS (SVM)
==================================================
Training SVM model...

Enhanced CNS Performance:
MAE: 150378.9837
RMSE: 209853.3534
MAPE: 7.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 59
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0010, rank=1
   2. Feature_14_t2: importance=0.0009, rank=2
   3. Feature_19_t2: importance=0.0008, rank=3
   4. Feature_15_t2: importance=0.0007, rank=4
   5. Feature_17_t0: importance=0.0006, rank=5

📊 CNS Results:
  Baseline MAPE: 9.33%
  Enhanced MAPE: 7.86%
  MAPE Improvement: +1.47% (+15.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 101/464: CNXN
============================================================
📊 Loading data for CNXN...
📊 Loading data for CNXN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CNXN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CNXN...

==================================================
Training Baseline CNXN (SVM)
==================================================
Training SVM model...

Baseline CNXN Performance:
MAE: 35800.9210
RMSE: 50606.9554
MAPE: 13.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 146
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t1: importance=0.0006, rank=1
   2. Feature_96_t0: importance=0.0006, rank=2
   3. Feature_85_t0: importance=0.0004, rank=3
   4. Feature_68_t3: importance=0.0004, rank=4
   5. Feature_73_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CNXN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CNXN...

==================================================
Training Enhanced CNXN (SVM)
==================================================
Training SVM model...

Enhanced CNXN Performance:
MAE: 36587.2220
RMSE: 51125.2084
MAPE: 14.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 56
   • Highly important features (top 5%): 27

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0017, rank=1
   2. Feature_13_t2: importance=0.0008, rank=2
   3. Feature_14_t2: importance=0.0008, rank=3
   4. Feature_16_t1: importance=0.0006, rank=4
   5. Feature_20_t3: importance=0.0005, rank=5

📊 CNXN Results:
  Baseline MAPE: 13.66%
  Enhanced MAPE: 14.52%
  MAPE Improvement: -0.86% (-6.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 102/464: COHU
============================================================
📊 Loading data for COHU...
📊 Loading data for COHU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for COHU...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for COHU...

==================================================
Training Baseline COHU (SVM)
==================================================
Training SVM model...

Baseline COHU Performance:
MAE: 145135.4029
RMSE: 188832.8142
MAPE: 10.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 272
   • Highly important features (top 5%): 146

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0004, rank=1
   2. Feature_69_t3: importance=0.0003, rank=2
   3. Feature_63_t0: importance=0.0003, rank=3
   4. Feature_0_t3: importance=0.0003, rank=4
   5. Feature_91_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for COHU...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for COHU...

==================================================
Training Enhanced COHU (SVM)
==================================================
Training SVM model...

Enhanced COHU Performance:
MAE: 145520.6263
RMSE: 182965.8000
MAPE: 11.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 27

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0013, rank=1
   2. Feature_5_t0: importance=0.0007, rank=2
   3. Feature_20_t2: importance=0.0007, rank=3
   4. Feature_21_t0: importance=0.0005, rank=4
   5. Feature_7_t3: importance=0.0005, rank=5

📊 COHU Results:
  Baseline MAPE: 10.99%
  Enhanced MAPE: 11.00%
  MAPE Improvement: -0.00% (-0.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 103/464: COLL
============================================================
📊 Loading data for COLL...
📊 Loading data for COLL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for COLL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for COLL...

==================================================
Training Baseline COLL (SVM)
==================================================
Training SVM model...

Baseline COLL Performance:
MAE: 223788.6530
RMSE: 293996.6031
MAPE: 3.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 121
   • Highly important features (top 5%): 54

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t3: importance=0.0005, rank=1
   2. Feature_87_t2: importance=0.0003, rank=2
   3. Feature_0_t0: importance=0.0002, rank=3
   4. Feature_2_t1: importance=0.0002, rank=4
   5. Feature_74_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for COLL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for COLL...

==================================================
Training Enhanced COLL (SVM)
==================================================
Training SVM model...

Enhanced COLL Performance:
MAE: 266373.1620
RMSE: 342372.7329
MAPE: 4.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0004, rank=1
   2. Feature_17_t1: importance=0.0003, rank=2
   3. Feature_12_t0: importance=0.0002, rank=3
   4. Feature_17_t3: importance=0.0002, rank=4
   5. Feature_20_t2: importance=0.0002, rank=5

📊 COLL Results:
  Baseline MAPE: 3.94%
  Enhanced MAPE: 4.79%
  MAPE Improvement: -0.85% (-21.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 104/464: CORT
============================================================
📊 Loading data for CORT...
📊 Loading data for CORT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CORT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CORT...

==================================================
Training Baseline CORT (SVM)
==================================================
Training SVM model...

Baseline CORT Performance:
MAE: 864503.5084
RMSE: 1230965.4833
MAPE: 5.07%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 91
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t2: importance=0.0004, rank=1
   2. Feature_81_t2: importance=0.0003, rank=2
   3. Feature_85_t1: importance=0.0002, rank=3
   4. Feature_63_t0: importance=0.0002, rank=4
   5. Feature_71_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CORT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CORT...

==================================================
Training Enhanced CORT (SVM)
==================================================
Training SVM model...

Enhanced CORT Performance:
MAE: 841710.3237
RMSE: 1259103.6418
MAPE: 5.26%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 54
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0004, rank=1
   2. Feature_10_t3: importance=0.0003, rank=2
   3. Feature_15_t3: importance=0.0002, rank=3
   4. Feature_10_t2: importance=0.0002, rank=4
   5. Feature_13_t3: importance=0.0002, rank=5

📊 CORT Results:
  Baseline MAPE: 5.07%
  Enhanced MAPE: 5.26%
  MAPE Improvement: -0.19% (-3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 105/464: CPF
============================================================
📊 Loading data for CPF...
📊 Loading data for CPF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CPF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CPF...

==================================================
Training Baseline CPF (SVM)
==================================================
Training SVM model...

Baseline CPF Performance:
MAE: 98740.5738
RMSE: 129460.7523
MAPE: 17.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 238
   • Highly important features (top 5%): 126

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_85_t0: importance=0.0008, rank=1
   2. Feature_68_t2: importance=0.0006, rank=2
   3. Feature_84_t0: importance=0.0004, rank=3
   4. Feature_0_t3: importance=0.0004, rank=4
   5. Feature_88_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for CPF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CPF...

==================================================
Training Enhanced CPF (SVM)
==================================================
Training SVM model...

Enhanced CPF Performance:
MAE: 95783.9736
RMSE: 117143.8620
MAPE: 17.26%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0012, rank=1
   2. Feature_15_t3: importance=0.0009, rank=2
   3. Feature_17_t1: importance=0.0009, rank=3
   4. Feature_19_t2: importance=0.0009, rank=4
   5. Feature_13_t3: importance=0.0008, rank=5

📊 CPF Results:
  Baseline MAPE: 17.72%
  Enhanced MAPE: 17.26%
  MAPE Improvement: +0.46% (+2.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 106/464: CPK
============================================================
📊 Loading data for CPK...
📊 Loading data for CPK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CPK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CPK...

==================================================
Training Baseline CPK (SVM)
==================================================
Training SVM model...

Baseline CPK Performance:
MAE: 50248.7246
RMSE: 70728.6356
MAPE: 12.39%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 136
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0029, rank=1
   2. Feature_65_t3: importance=0.0027, rank=2
   3. Feature_65_t0: importance=0.0021, rank=3
   4. Feature_65_t1: importance=0.0013, rank=4
   5. Feature_64_t3: importance=0.0010, rank=5

🔧 Applying universal feature engineering for CPK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CPK...

==================================================
Training Enhanced CPK (SVM)
==================================================
Training SVM model...

Enhanced CPK Performance:
MAE: 49386.8655
RMSE: 70179.6869
MAPE: 12.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t0: importance=0.0029, rank=1
   2. Feature_12_t1: importance=0.0026, rank=2
   3. Feature_17_t3: importance=0.0023, rank=3
   4. Feature_15_t3: importance=0.0022, rank=4
   5. Feature_8_t3: importance=0.0017, rank=5

📊 CPK Results:
  Baseline MAPE: 12.39%
  Enhanced MAPE: 12.02%
  MAPE Improvement: +0.37% (+3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 107/464: CPRX
============================================================
📊 Loading data for CPRX...
📊 Loading data for CPRX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing CPRX: 'CPRX'

============================================================
TESTING TICKER 108/464: CRI
============================================================
📊 Loading data for CRI...
📊 Loading data for CRI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CRI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CRI...

==================================================
Training Baseline CRI (SVM)
==================================================
Training SVM model...

Baseline CRI Performance:
MAE: 479042.9307
RMSE: 575526.5154
MAPE: 10.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 352
   • Highly important features (top 5%): 235

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t1: importance=0.0003, rank=1
   2. Feature_80_t3: importance=0.0002, rank=2
   3. Feature_67_t1: importance=0.0002, rank=3
   4. Feature_70_t0: importance=0.0002, rank=4
   5. Feature_64_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CRI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CRI...

==================================================
Training Enhanced CRI (SVM)
==================================================
Training SVM model...

Enhanced CRI Performance:
MAE: 457493.2119
RMSE: 545727.9580
MAPE: 10.20%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0009, rank=1
   2. Feature_19_t3: importance=0.0008, rank=2
   3. Feature_17_t0: importance=0.0007, rank=3
   4. Feature_14_t3: importance=0.0005, rank=4
   5. Feature_11_t2: importance=0.0005, rank=5

📊 CRI Results:
  Baseline MAPE: 10.85%
  Enhanced MAPE: 10.20%
  MAPE Improvement: +0.65% (+6.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 109/464: CRK
============================================================
📊 Loading data for CRK...
📊 Loading data for CRK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CRK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CRK...

==================================================
Training Baseline CRK (SVM)
==================================================
Training SVM model...

Baseline CRK Performance:
MAE: 1793518.5677
RMSE: 2219731.4360
MAPE: 7.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 142
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t0: importance=0.0007, rank=1
   2. Feature_73_t2: importance=0.0004, rank=2
   3. Feature_2_t3: importance=0.0004, rank=3
   4. Feature_72_t2: importance=0.0004, rank=4
   5. Feature_70_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CRK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CRK...

==================================================
Training Enhanced CRK (SVM)
==================================================
Training SVM model...

Enhanced CRK Performance:
MAE: 1844443.4330
RMSE: 2273630.2150
MAPE: 7.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0007, rank=1
   2. Feature_13_t1: importance=0.0006, rank=2
   3. Feature_19_t3: importance=0.0006, rank=3
   4. Feature_13_t0: importance=0.0005, rank=4
   5. Feature_20_t0: importance=0.0005, rank=5

📊 CRK Results:
  Baseline MAPE: 7.30%
  Enhanced MAPE: 7.72%
  MAPE Improvement: -0.41% (-5.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 110/464: CRVL
============================================================
📊 Loading data for CRVL...
📊 Loading data for CRVL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CRVL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CRVL...

==================================================
Training Baseline CRVL (SVM)
==================================================
Training SVM model...

Baseline CRVL Performance:
MAE: 56999.3255
RMSE: 130729.4132
MAPE: 8.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 196
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0009, rank=1
   2. Feature_95_t1: importance=0.0008, rank=2
   3. Feature_84_t3: importance=0.0007, rank=3
   4. Feature_69_t3: importance=0.0006, rank=4
   5. Feature_0_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for CRVL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CRVL...

==================================================
Training Enhanced CRVL (SVM)
==================================================
Training SVM model...

Enhanced CRVL Performance:
MAE: 49315.6078
RMSE: 127601.2510
MAPE: 6.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0011, rank=1
   2. Feature_23_t2: importance=0.0009, rank=2
   3. Feature_19_t2: importance=0.0008, rank=3
   4. Feature_17_t1: importance=0.0008, rank=4
   5. Feature_7_t2: importance=0.0008, rank=5

📊 CRVL Results:
  Baseline MAPE: 8.13%
  Enhanced MAPE: 6.68%
  MAPE Improvement: +1.45% (+17.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 111/464: CSGS
============================================================
📊 Loading data for CSGS...
📊 Loading data for CSGS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CSGS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CSGS...

==================================================
Training Baseline CSGS (SVM)
==================================================
Training SVM model...

Baseline CSGS Performance:
MAE: 198780.2638
RMSE: 295178.7267
MAPE: 8.48%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 144
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t2: importance=0.0028, rank=1
   2. Feature_86_t2: importance=0.0016, rank=2
   3. Feature_79_t1: importance=0.0012, rank=3
   4. Feature_85_t2: importance=0.0007, rank=4
   5. Feature_77_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for CSGS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CSGS...

==================================================
Training Enhanced CSGS (SVM)
==================================================
Training SVM model...

Enhanced CSGS Performance:
MAE: 212679.3199
RMSE: 334670.9514
MAPE: 8.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 34
   • Highly important features (top 5%): 22

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t2: importance=0.0073, rank=1
   2. Feature_11_t1: importance=0.0032, rank=2
   3. Feature_24_t2: importance=0.0023, rank=3
   4. Feature_0_t0: importance=0.0012, rank=4
   5. Feature_0_t2: importance=0.0012, rank=5

📊 CSGS Results:
  Baseline MAPE: 8.48%
  Enhanced MAPE: 8.54%
  MAPE Improvement: -0.06% (-0.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 112/464: CTRE
============================================================
📊 Loading data for CTRE...
📊 Loading data for CTRE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CTRE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CTRE...

==================================================
Training Baseline CTRE (SVM)
==================================================
Training SVM model...

Baseline CTRE Performance:
MAE: 753162.7624
RMSE: 1048613.7688
MAPE: 16.76%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 286
   • Highly important features (top 5%): 161

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0005, rank=1
   2. Feature_90_t1: importance=0.0004, rank=2
   3. Feature_69_t3: importance=0.0003, rank=3
   4. Feature_65_t3: importance=0.0003, rank=4
   5. Feature_95_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CTRE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CTRE...

==================================================
Training Enhanced CTRE (SVM)
==================================================
Training SVM model...

Enhanced CTRE Performance:
MAE: 730992.2985
RMSE: 1041843.2223
MAPE: 15.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t2: importance=0.0010, rank=1
   2. Feature_7_t0: importance=0.0007, rank=2
   3. Feature_9_t1: importance=0.0007, rank=3
   4. Feature_13_t1: importance=0.0007, rank=4
   5. Feature_17_t1: importance=0.0007, rank=5

📊 CTRE Results:
  Baseline MAPE: 16.76%
  Enhanced MAPE: 15.96%
  MAPE Improvement: +0.80% (+4.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 113/464: CTS
============================================================
📊 Loading data for CTS...
📊 Loading data for CTS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CTS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CTS...

==================================================
Training Baseline CTS (SVM)
==================================================
Training SVM model...

Baseline CTS Performance:
MAE: 65683.7847
RMSE: 91844.1707
MAPE: 8.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 207
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0023, rank=1
   2. Feature_2_t3: importance=0.0011, rank=2
   3. Feature_65_t0: importance=0.0009, rank=3
   4. Feature_65_t3: importance=0.0009, rank=4
   5. Feature_70_t0: importance=0.0008, rank=5

🔧 Applying universal feature engineering for CTS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CTS...

==================================================
Training Enhanced CTS (SVM)
==================================================
Training SVM model...

Enhanced CTS Performance:
MAE: 72353.3257
RMSE: 95146.8640
MAPE: 10.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t0: importance=0.0019, rank=1
   2. Feature_16_t0: importance=0.0014, rank=2
   3. Feature_0_t3: importance=0.0013, rank=3
   4. Feature_19_t0: importance=0.0012, rank=4
   5. Feature_17_t0: importance=0.0012, rank=5

📊 CTS Results:
  Baseline MAPE: 8.75%
  Enhanced MAPE: 10.81%
  MAPE Improvement: -2.06% (-23.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 114/464: CUBI
============================================================
📊 Loading data for CUBI...
📊 Loading data for CUBI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CUBI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CUBI...

==================================================
Training Baseline CUBI (SVM)
==================================================
Training SVM model...

Baseline CUBI Performance:
MAE: 225763.4647
RMSE: 269019.3811
MAPE: 11.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 212
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t2: importance=0.0005, rank=1
   2. Feature_80_t2: importance=0.0004, rank=2
   3. Feature_2_t1: importance=0.0003, rank=3
   4. Feature_94_t0: importance=0.0003, rank=4
   5. Feature_88_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CUBI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CUBI...

==================================================
Training Enhanced CUBI (SVM)
==================================================
Training SVM model...

Enhanced CUBI Performance:
MAE: 152817.9545
RMSE: 201655.4042
MAPE: 7.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 36

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0014, rank=1
   2. Feature_15_t2: importance=0.0011, rank=2
   3. Feature_17_t0: importance=0.0010, rank=3
   4. Feature_7_t0: importance=0.0006, rank=4
   5. Feature_12_t1: importance=0.0006, rank=5

📊 CUBI Results:
  Baseline MAPE: 11.37%
  Enhanced MAPE: 7.08%
  MAPE Improvement: +4.29% (+37.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 115/464: CVBF
============================================================
📊 Loading data for CVBF...
📊 Loading data for CVBF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CVBF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CVBF...

==================================================
Training Baseline CVBF (SVM)
==================================================
Training SVM model...

Baseline CVBF Performance:
MAE: 499957.8818
RMSE: 765625.6292
MAPE: 10.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 238
   • Highly important features (top 5%): 135

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0003, rank=1
   2. Feature_96_t1: importance=0.0002, rank=2
   3. Feature_90_t2: importance=0.0002, rank=3
   4. Feature_70_t0: importance=0.0002, rank=4
   5. Feature_64_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CVBF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CVBF...

==================================================
Training Enhanced CVBF (SVM)
==================================================
Training SVM model...

Enhanced CVBF Performance:
MAE: 516456.1255
RMSE: 830748.8899
MAPE: 11.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0014, rank=1
   2. Feature_15_t2: importance=0.0009, rank=2
   3. Feature_14_t1: importance=0.0009, rank=3
   4. Feature_0_t2: importance=0.0007, rank=4
   5. Feature_1_t0: importance=0.0006, rank=5

📊 CVBF Results:
  Baseline MAPE: 10.70%
  Enhanced MAPE: 11.69%
  MAPE Improvement: -0.99% (-9.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 116/464: CVCO
============================================================
📊 Loading data for CVCO...
📊 Loading data for CVCO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CVCO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CVCO...

==================================================
Training Baseline CVCO (SVM)
==================================================
Training SVM model...

Baseline CVCO Performance:
MAE: 23361.4482
RMSE: 30512.4143
MAPE: 12.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 269
   • Highly important features (top 5%): 139

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_74_t1: importance=0.0004, rank=1
   2. Feature_95_t3: importance=0.0003, rank=2
   3. Feature_65_t3: importance=0.0003, rank=3
   4. Feature_68_t0: importance=0.0003, rank=4
   5. Feature_94_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CVCO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CVCO...

==================================================
Training Enhanced CVCO (SVM)
==================================================
Training SVM model...

Enhanced CVCO Performance:
MAE: 19792.8642
RMSE: 26583.0964
MAPE: 10.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 91

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t3: importance=0.0006, rank=1
   2. Feature_24_t0: importance=0.0006, rank=2
   3. Feature_19_t1: importance=0.0005, rank=3
   4. Feature_24_t1: importance=0.0005, rank=4
   5. Feature_18_t0: importance=0.0005, rank=5

📊 CVCO Results:
  Baseline MAPE: 12.77%
  Enhanced MAPE: 10.98%
  MAPE Improvement: +1.79% (+14.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 117/464: CVI
============================================================
📊 Loading data for CVI...
📊 Loading data for CVI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CVI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CVI...

==================================================
Training Baseline CVI (SVM)
==================================================
Training SVM model...

Baseline CVI Performance:
MAE: 499218.8525
RMSE: 652444.9805
MAPE: 9.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 157
   • Highly important features (top 5%): 99

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_95_t0: importance=0.0006, rank=1
   2. Feature_65_t1: importance=0.0003, rank=2
   3. Feature_96_t0: importance=0.0003, rank=3
   4. Feature_78_t3: importance=0.0003, rank=4
   5. Feature_95_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for CVI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CVI...

==================================================
Training Enhanced CVI (SVM)
==================================================
Training SVM model...

Enhanced CVI Performance:
MAE: 512109.1849
RMSE: 644579.9595
MAPE: 10.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 43

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t0: importance=0.0012, rank=1
   2. Feature_20_t2: importance=0.0006, rank=2
   3. Feature_7_t3: importance=0.0005, rank=3
   4. Feature_16_t3: importance=0.0005, rank=4
   5. Feature_5_t1: importance=0.0004, rank=5

📊 CVI Results:
  Baseline MAPE: 9.64%
  Enhanced MAPE: 10.08%
  MAPE Improvement: -0.43% (-4.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 118/464: CWT
============================================================
📊 Loading data for CWT...
📊 Loading data for CWT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CWT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CWT...

==================================================
Training Baseline CWT (SVM)
==================================================
Training SVM model...

Baseline CWT Performance:
MAE: 113211.4557
RMSE: 137634.5449
MAPE: 15.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 196
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t0: importance=0.0005, rank=1
   2. Feature_74_t0: importance=0.0003, rank=2
   3. Feature_83_t1: importance=0.0003, rank=3
   4. Feature_72_t3: importance=0.0003, rank=4
   5. Feature_85_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for CWT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CWT...

==================================================
Training Enhanced CWT (SVM)
==================================================
Training SVM model...

Enhanced CWT Performance:
MAE: 115378.3275
RMSE: 138124.5258
MAPE: 16.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 93

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0007, rank=1
   2. Feature_22_t1: importance=0.0006, rank=2
   3. Feature_22_t3: importance=0.0006, rank=3
   4. Feature_1_t3: importance=0.0006, rank=4
   5. Feature_11_t1: importance=0.0005, rank=5

📊 CWT Results:
  Baseline MAPE: 15.54%
  Enhanced MAPE: 16.37%
  MAPE Improvement: -0.83% (-5.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 119/464: CXW
============================================================
📊 Loading data for CXW...
📊 Loading data for CXW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CXW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CXW...

==================================================
Training Baseline CXW (SVM)
==================================================
Training SVM model...

Baseline CXW Performance:
MAE: 467509.0078
RMSE: 585250.9115
MAPE: 12.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 204
   • Highly important features (top 5%): 108

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0024, rank=1
   2. Feature_73_t2: importance=0.0011, rank=2
   3. Feature_95_t3: importance=0.0009, rank=3
   4. Feature_90_t2: importance=0.0007, rank=4
   5. Feature_75_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for CXW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CXW...

==================================================
Training Enhanced CXW (SVM)
==================================================
Training SVM model...

Enhanced CXW Performance:
MAE: 389890.4176
RMSE: 481584.6110
MAPE: 10.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0019, rank=1
   2. Feature_13_t2: importance=0.0015, rank=2
   3. Feature_16_t3: importance=0.0014, rank=3
   4. Feature_12_t3: importance=0.0012, rank=4
   5. Feature_22_t2: importance=0.0012, rank=5

📊 CXW Results:
  Baseline MAPE: 12.56%
  Enhanced MAPE: 10.46%
  MAPE Improvement: +2.10% (+16.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 120/464: CZR
============================================================
📊 Loading data for CZR...
📊 Loading data for CZR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for CZR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for CZR...

==================================================
Training Baseline CZR (SVM)
==================================================
Training SVM model...

Baseline CZR Performance:
MAE: 1642559.0824
RMSE: 2287769.8329
MAPE: 9.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 187
   • Highly important features (top 5%): 103

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t3: importance=0.0008, rank=1
   2. Feature_80_t2: importance=0.0008, rank=2
   3. Feature_81_t3: importance=0.0008, rank=3
   4. Feature_85_t2: importance=0.0005, rank=4
   5. Feature_64_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for CZR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for CZR...

==================================================
Training Enhanced CZR (SVM)
==================================================
Training SVM model...

Enhanced CZR Performance:
MAE: 1777024.1253
RMSE: 2412943.9099
MAPE: 9.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0011, rank=1
   2. Feature_13_t3: importance=0.0006, rank=2
   3. Feature_19_t3: importance=0.0006, rank=3
   4. Feature_11_t0: importance=0.0006, rank=4
   5. Feature_17_t0: importance=0.0005, rank=5

📊 CZR Results:
  Baseline MAPE: 9.14%
  Enhanced MAPE: 9.41%
  MAPE Improvement: -0.26% (-2.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 121/464: DAN
============================================================
📊 Loading data for DAN...
📊 Loading data for DAN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DAN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DAN...

==================================================
Training Baseline DAN (SVM)
==================================================
Training SVM model...

Baseline DAN Performance:
MAE: 393371.7414
RMSE: 552692.8135
MAPE: 7.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 303
   • Highly important features (top 5%): 188

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t2: importance=0.0010, rank=1
   2. Feature_63_t2: importance=0.0007, rank=2
   3. Feature_0_t3: importance=0.0005, rank=3
   4. Feature_74_t3: importance=0.0004, rank=4
   5. Feature_75_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for DAN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DAN...

==================================================
Training Enhanced DAN (SVM)
==================================================
Training SVM model...

Enhanced DAN Performance:
MAE: 473534.4378
RMSE: 608051.0236
MAPE: 9.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0011, rank=1
   2. Feature_21_t1: importance=0.0010, rank=2
   3. Feature_16_t1: importance=0.0010, rank=3
   4. Feature_12_t2: importance=0.0009, rank=4
   5. Feature_15_t2: importance=0.0009, rank=5

📊 DAN Results:
  Baseline MAPE: 7.59%
  Enhanced MAPE: 9.42%
  MAPE Improvement: -1.83% (-24.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 122/464: DCOM
============================================================
📊 Loading data for DCOM...
📊 Loading data for DCOM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DCOM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DCOM...

==================================================
Training Baseline DCOM (SVM)
==================================================
Training SVM model...

Baseline DCOM Performance:
MAE: 139761.2851
RMSE: 201417.3448
MAPE: 6.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 122
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t0: importance=0.0010, rank=1
   2. Feature_84_t0: importance=0.0007, rank=2
   3. Feature_63_t3: importance=0.0006, rank=3
   4. Feature_87_t1: importance=0.0005, rank=4
   5. Feature_83_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for DCOM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DCOM...

==================================================
Training Enhanced DCOM (SVM)
==================================================
Training SVM model...

Enhanced DCOM Performance:
MAE: 141421.6664
RMSE: 215294.4681
MAPE: 6.48%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0019, rank=1
   2. Feature_7_t1: importance=0.0012, rank=2
   3. Feature_20_t3: importance=0.0010, rank=3
   4. Feature_19_t3: importance=0.0009, rank=4
   5. Feature_12_t3: importance=0.0007, rank=5

📊 DCOM Results:
  Baseline MAPE: 6.25%
  Enhanced MAPE: 6.48%
  MAPE Improvement: -0.23% (-3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 123/464: DEA
============================================================
📊 Loading data for DEA...
📊 Loading data for DEA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DEA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DEA...

==================================================
Training Baseline DEA (SVM)
==================================================
Training SVM model...

Baseline DEA Performance:
MAE: 591252.2259
RMSE: 847349.9783
MAPE: 18.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 137
   • Highly important features (top 5%): 97

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t0: importance=0.0013, rank=1
   2. Feature_71_t2: importance=0.0011, rank=2
   3. Feature_94_t1: importance=0.0007, rank=3
   4. Feature_92_t2: importance=0.0007, rank=4
   5. Feature_82_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for DEA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DEA...

==================================================
Training Enhanced DEA (SVM)
==================================================
Training SVM model...

Enhanced DEA Performance:
MAE: 594498.9026
RMSE: 835339.9705
MAPE: 18.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0017, rank=1
   2. Feature_11_t3: importance=0.0017, rank=2
   3. Feature_5_t0: importance=0.0016, rank=3
   4. Feature_19_t3: importance=0.0013, rank=4
   5. Feature_14_t1: importance=0.0013, rank=5

📊 DEA Results:
  Baseline MAPE: 18.11%
  Enhanced MAPE: 18.16%
  MAPE Improvement: -0.05% (-0.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 124/464: DEI
============================================================
📊 Loading data for DEI...
📊 Loading data for DEI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DEI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DEI...

==================================================
Training Baseline DEI (SVM)
==================================================
Training SVM model...

Baseline DEI Performance:
MAE: 1520361.0510
RMSE: 1777991.2425
MAPE: 7.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 233
   • Highly important features (top 5%): 134

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t0: importance=0.0003, rank=1
   2. Feature_70_t2: importance=0.0003, rank=2
   3. Feature_82_t2: importance=0.0003, rank=3
   4. Feature_82_t1: importance=0.0003, rank=4
   5. Feature_71_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for DEI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DEI...

==================================================
Training Enhanced DEI (SVM)
==================================================
Training SVM model...

Enhanced DEI Performance:
MAE: 1462123.5145
RMSE: 1822023.4085
MAPE: 7.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0008, rank=1
   2. Feature_13_t1: importance=0.0006, rank=2
   3. Feature_20_t2: importance=0.0006, rank=3
   4. Feature_1_t1: importance=0.0005, rank=4
   5. Feature_20_t1: importance=0.0005, rank=5

📊 DEI Results:
  Baseline MAPE: 7.61%
  Enhanced MAPE: 7.29%
  MAPE Improvement: +0.33% (+4.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 125/464: DFIN
============================================================
📊 Loading data for DFIN...
📊 Loading data for DFIN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DFIN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DFIN...

==================================================
Training Baseline DFIN (SVM)
==================================================
Training SVM model...

Baseline DFIN Performance:
MAE: 122202.5488
RMSE: 156889.7493
MAPE: 11.45%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 293
   • Highly important features (top 5%): 139

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_93_t2: importance=0.0007, rank=1
   2. Feature_94_t0: importance=0.0005, rank=2
   3. Feature_77_t1: importance=0.0004, rank=3
   4. Feature_63_t1: importance=0.0004, rank=4
   5. Feature_74_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for DFIN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DFIN...

==================================================
Training Enhanced DFIN (SVM)
==================================================
Training SVM model...

Enhanced DFIN Performance:
MAE: 97783.7348
RMSE: 141548.8445
MAPE: 9.35%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0008, rank=1
   2. Feature_17_t3: importance=0.0007, rank=2
   3. Feature_1_t2: importance=0.0007, rank=3
   4. Feature_19_t0: importance=0.0007, rank=4
   5. Feature_15_t2: importance=0.0006, rank=5

📊 DFIN Results:
  Baseline MAPE: 11.45%
  Enhanced MAPE: 9.35%
  MAPE Improvement: +2.10% (+18.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 126/464: DGII
============================================================
📊 Loading data for DGII...
📊 Loading data for DGII from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DGII...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DGII...

==================================================
Training Baseline DGII (SVM)
==================================================
Training SVM model...

Baseline DGII Performance:
MAE: 138989.9808
RMSE: 173499.0140
MAPE: 5.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 181
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0010, rank=1
   2. Feature_68_t1: importance=0.0008, rank=2
   3. Feature_67_t3: importance=0.0006, rank=3
   4. Feature_96_t2: importance=0.0005, rank=4
   5. Feature_65_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for DGII...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DGII...

==================================================
Training Enhanced DGII (SVM)
==================================================
Training SVM model...

Enhanced DGII Performance:
MAE: 135266.1278
RMSE: 174814.5546
MAPE: 5.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 30

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t1: importance=0.0033, rank=1
   2. Feature_13_t0: importance=0.0022, rank=2
   3. Feature_24_t2: importance=0.0020, rank=3
   4. Feature_20_t0: importance=0.0019, rank=4
   5. Feature_17_t3: importance=0.0012, rank=5

📊 DGII Results:
  Baseline MAPE: 5.83%
  Enhanced MAPE: 5.91%
  MAPE Improvement: -0.08% (-1.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 127/464: DIOD
============================================================
📊 Loading data for DIOD...
📊 Loading data for DIOD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DIOD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DIOD...

==================================================
Training Baseline DIOD (SVM)
==================================================
Training SVM model...

Baseline DIOD Performance:
MAE: 149567.0680
RMSE: 189038.1447
MAPE: 7.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 293
   • Highly important features (top 5%): 164

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t1: importance=0.0004, rank=1
   2. Feature_94_t1: importance=0.0004, rank=2
   3. Feature_76_t1: importance=0.0003, rank=3
   4. Feature_1_t3: importance=0.0003, rank=4
   5. Feature_65_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for DIOD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DIOD...

==================================================
Training Enhanced DIOD (SVM)
==================================================
Training SVM model...

Enhanced DIOD Performance:
MAE: 150473.9019
RMSE: 181800.3690
MAPE: 7.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0008, rank=1
   2. Feature_15_t1: importance=0.0008, rank=2
   3. Feature_19_t3: importance=0.0005, rank=3
   4. Feature_14_t0: importance=0.0005, rank=4
   5. Feature_15_t2: importance=0.0004, rank=5

📊 DIOD Results:
  Baseline MAPE: 7.28%
  Enhanced MAPE: 7.17%
  MAPE Improvement: +0.11% (+1.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 128/464: DLX
============================================================
📊 Loading data for DLX...
📊 Loading data for DLX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DLX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DLX...

==================================================
Training Baseline DLX (SVM)
==================================================
Training SVM model...

Baseline DLX Performance:
MAE: 97282.8505
RMSE: 126022.6864
MAPE: 3.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 137
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0002, rank=1
   2. Feature_78_t0: importance=0.0001, rank=2
   3. Feature_1_t3: importance=0.0001, rank=3
   4. Feature_85_t1: importance=0.0001, rank=4
   5. Feature_64_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for DLX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DLX...

==================================================
Training Enhanced DLX (SVM)
==================================================
Training SVM model...

Enhanced DLX Performance:
MAE: 100017.8674
RMSE: 130866.7025
MAPE: 3.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t0: importance=0.0003, rank=1
   2. Feature_7_t0: importance=0.0002, rank=2
   3. Feature_16_t3: importance=0.0001, rank=3
   4. Feature_24_t3: importance=0.0001, rank=4
   5. Feature_14_t1: importance=0.0001, rank=5

📊 DLX Results:
  Baseline MAPE: 3.70%
  Enhanced MAPE: 3.78%
  MAPE Improvement: -0.08% (-2.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 129/464: DNOW
============================================================
📊 Loading data for DNOW...
📊 Loading data for DNOW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DNOW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DNOW...

==================================================
Training Baseline DNOW (SVM)
==================================================
Training SVM model...

Baseline DNOW Performance:
MAE: 486286.1002
RMSE: 611294.9058
MAPE: 16.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 313
   • Highly important features (top 5%): 209

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t3: importance=0.0024, rank=1
   2. Feature_63_t3: importance=0.0019, rank=2
   3. Feature_69_t3: importance=0.0013, rank=3
   4. Feature_72_t3: importance=0.0006, rank=4
   5. Feature_70_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for DNOW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DNOW...

==================================================
Training Enhanced DNOW (SVM)
==================================================
Training SVM model...

Enhanced DNOW Performance:
MAE: 551792.1526
RMSE: 671719.6637
MAPE: 18.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t1: importance=0.0026, rank=1
   2. Feature_7_t3: importance=0.0023, rank=2
   3. Feature_13_t2: importance=0.0016, rank=3
   4. Feature_13_t0: importance=0.0016, rank=4
   5. Feature_4_t3: importance=0.0015, rank=5

📊 DNOW Results:
  Baseline MAPE: 16.30%
  Enhanced MAPE: 18.29%
  MAPE Improvement: -1.99% (-12.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 130/464: DORM
============================================================
📊 Loading data for DORM...
📊 Loading data for DORM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DORM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DORM...

==================================================
Training Baseline DORM (SVM)
==================================================
Training SVM model...

Baseline DORM Performance:
MAE: 60066.6163
RMSE: 88627.4839
MAPE: 11.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 182
   • Highly important features (top 5%): 95

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t0: importance=0.0002, rank=1
   2. Feature_65_t3: importance=0.0002, rank=2
   3. Feature_65_t2: importance=0.0002, rank=3
   4. Feature_80_t3: importance=0.0001, rank=4
   5. Feature_90_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for DORM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DORM...

==================================================
Training Enhanced DORM (SVM)
==================================================
Training SVM model...

Enhanced DORM Performance:
MAE: 63548.7885
RMSE: 90333.3324
MAPE: 11.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0003, rank=1
   2. Feature_20_t1: importance=0.0003, rank=2
   3. Feature_7_t1: importance=0.0003, rank=3
   4. Feature_19_t0: importance=0.0002, rank=4
   5. Feature_12_t3: importance=0.0002, rank=5

📊 DORM Results:
  Baseline MAPE: 11.44%
  Enhanced MAPE: 11.87%
  MAPE Improvement: -0.43% (-3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 131/464: DRH
============================================================
📊 Loading data for DRH...
📊 Loading data for DRH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DRH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DRH...

==================================================
Training Baseline DRH (SVM)
==================================================
Training SVM model...

Baseline DRH Performance:
MAE: 1334784.2705
RMSE: 1648386.6144
MAPE: 7.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 307
   • Highly important features (top 5%): 216

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0006, rank=1
   2. Feature_65_t2: importance=0.0006, rank=2
   3. Feature_1_t3: importance=0.0004, rank=3
   4. Feature_80_t3: importance=0.0004, rank=4
   5. Feature_0_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for DRH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DRH...

==================================================
Training Enhanced DRH (SVM)
==================================================
Training SVM model...

Enhanced DRH Performance:
MAE: 1176469.9895
RMSE: 1496651.2593
MAPE: 7.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0015, rank=1
   2. Feature_11_t3: importance=0.0013, rank=2
   3. Feature_24_t3: importance=0.0012, rank=3
   4. Feature_5_t2: importance=0.0010, rank=4
   5. Feature_7_t1: importance=0.0009, rank=5

📊 DRH Results:
  Baseline MAPE: 7.99%
  Enhanced MAPE: 7.05%
  MAPE Improvement: +0.95% (+11.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 132/464: DVAX
============================================================
📊 Loading data for DVAX...
📊 Loading data for DVAX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing DVAX: 'DVAX'

============================================================
TESTING TICKER 133/464: DXC
============================================================
📊 Loading data for DXC...
📊 Loading data for DXC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing DXC: 'DXC'

============================================================
TESTING TICKER 134/464: DXPE
============================================================
📊 Loading data for DXPE...
📊 Loading data for DXPE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DXPE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DXPE...

==================================================
Training Baseline DXPE (SVM)
==================================================
Training SVM model...

Baseline DXPE Performance:
MAE: 57660.8308
RMSE: 78232.6922
MAPE: 9.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 242
   • Highly important features (top 5%): 103

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_89_t2: importance=0.0002, rank=1
   2. Feature_0_t2: importance=0.0002, rank=2
   3. Feature_84_t1: importance=0.0001, rank=3
   4. Feature_0_t3: importance=0.0001, rank=4
   5. Feature_76_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for DXPE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DXPE...

==================================================
Training Enhanced DXPE (SVM)
==================================================
Training SVM model...

Enhanced DXPE Performance:
MAE: 61134.9804
RMSE: 81987.8726
MAPE: 10.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0005, rank=1
   2. Feature_20_t0: importance=0.0003, rank=2
   3. Feature_14_t2: importance=0.0002, rank=3
   4. Feature_18_t3: importance=0.0002, rank=4
   5. Feature_9_t3: importance=0.0002, rank=5

📊 DXPE Results:
  Baseline MAPE: 9.72%
  Enhanced MAPE: 10.31%
  MAPE Improvement: -0.59% (-6.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 135/464: DY
============================================================
📊 Loading data for DY...
📊 Loading data for DY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for DY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for DY...

==================================================
Training Baseline DY (SVM)
==================================================
Training SVM model...

Baseline DY Performance:
MAE: 129388.0127
RMSE: 175772.9402
MAPE: 10.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 223
   • Highly important features (top 5%): 133

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t2: importance=0.0004, rank=1
   2. Feature_0_t3: importance=0.0004, rank=2
   3. Feature_79_t2: importance=0.0003, rank=3
   4. Feature_82_t2: importance=0.0003, rank=4
   5. Feature_92_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for DY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for DY...

==================================================
Training Enhanced DY (SVM)
==================================================
Training SVM model...

Enhanced DY Performance:
MAE: 141617.4617
RMSE: 191478.9111
MAPE: 12.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0009, rank=1
   2. Feature_15_t2: importance=0.0005, rank=2
   3. Feature_20_t2: importance=0.0005, rank=3
   4. Feature_14_t3: importance=0.0004, rank=4
   5. Feature_19_t3: importance=0.0004, rank=5

📊 DY Results:
  Baseline MAPE: 10.92%
  Enhanced MAPE: 12.08%
  MAPE Improvement: -1.16% (-10.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 136/464: EAT
============================================================
📊 Loading data for EAT...
📊 Loading data for EAT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EAT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EAT...

==================================================
Training Baseline EAT (SVM)
==================================================
Training SVM model...

Baseline EAT Performance:
MAE: 454891.8872
RMSE: 636680.2895
MAPE: 7.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 258
   • Highly important features (top 5%): 136

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t3: importance=0.0002, rank=1
   2. Feature_96_t1: importance=0.0002, rank=2
   3. Feature_38_t0: importance=0.0001, rank=3
   4. Feature_71_t2: importance=0.0001, rank=4
   5. Feature_91_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for EAT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EAT...

==================================================
Training Enhanced EAT (SVM)
==================================================
Training SVM model...

Enhanced EAT Performance:
MAE: 394114.5405
RMSE: 597135.3082
MAPE: 6.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0007, rank=1
   2. Feature_23_t3: importance=0.0007, rank=2
   3. Feature_22_t2: importance=0.0005, rank=3
   4. Feature_17_t1: importance=0.0004, rank=4
   5. Feature_17_t2: importance=0.0004, rank=5

📊 EAT Results:
  Baseline MAPE: 7.16%
  Enhanced MAPE: 6.11%
  MAPE Improvement: +1.05% (+14.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 137/464: ECPG
============================================================
📊 Loading data for ECPG...
📊 Loading data for ECPG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ECPG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ECPG...

==================================================
Training Baseline ECPG (SVM)
==================================================
Training SVM model...

Baseline ECPG Performance:
MAE: 80186.4960
RMSE: 132782.5314
MAPE: 4.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 198
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t3: importance=0.0001, rank=1
   2. Feature_87_t2: importance=0.0000, rank=2
   3. Feature_81_t3: importance=0.0000, rank=3
   4. Feature_67_t3: importance=0.0000, rank=4
   5. Feature_80_t3: importance=0.0000, rank=5

🔧 Applying universal feature engineering for ECPG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ECPG...

==================================================
Training Enhanced ECPG (SVM)
==================================================
Training SVM model...

Enhanced ECPG Performance:
MAE: 72627.5956
RMSE: 121880.9147
MAPE: 4.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 64
   • Highly important features (top 5%): 43

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t1: importance=0.0001, rank=1
   2. Feature_1_t3: importance=0.0001, rank=2
   3. Feature_24_t0: importance=0.0001, rank=3
   4. Feature_15_t3: importance=0.0001, rank=4
   5. Feature_19_t2: importance=0.0001, rank=5

📊 ECPG Results:
  Baseline MAPE: 4.88%
  Enhanced MAPE: 4.37%
  MAPE Improvement: +0.51% (+10.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 138/464: EFC
============================================================
📊 Loading data for EFC...
📊 Loading data for EFC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing EFC: 'EFC'

============================================================
TESTING TICKER 139/464: EGBN
============================================================
📊 Loading data for EGBN...
📊 Loading data for EGBN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EGBN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EGBN...

==================================================
Training Baseline EGBN (SVM)
==================================================
Training SVM model...

Baseline EGBN Performance:
MAE: 203992.4600
RMSE: 248642.4223
MAPE: 10.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 111
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0030, rank=1
   2. Feature_67_t3: importance=0.0026, rank=2
   3. Feature_86_t0: importance=0.0018, rank=3
   4. Feature_93_t2: importance=0.0014, rank=4
   5. Feature_94_t2: importance=0.0010, rank=5

🔧 Applying universal feature engineering for EGBN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EGBN...

==================================================
Training Enhanced EGBN (SVM)
==================================================
Training SVM model...

Enhanced EGBN Performance:
MAE: 181708.1307
RMSE: 216943.8251
MAPE: 9.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 31
   • Highly important features (top 5%): 15

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0039, rank=1
   2. Feature_21_t3: importance=0.0019, rank=2
   3. Feature_17_t2: importance=0.0011, rank=3
   4. Feature_17_t0: importance=0.0010, rank=4
   5. Feature_20_t0: importance=0.0010, rank=5

📊 EGBN Results:
  Baseline MAPE: 10.69%
  Enhanced MAPE: 9.03%
  MAPE Improvement: +1.66% (+15.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 140/464: EIG
============================================================
📊 Loading data for EIG...
📊 Loading data for EIG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EIG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EIG...

==================================================
Training Baseline EIG (SVM)
==================================================
Training SVM model...

Baseline EIG Performance:
MAE: 56505.4862
RMSE: 73103.6878
MAPE: 15.07%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 304
   • Highly important features (top 5%): 162

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t2: importance=0.0006, rank=1
   2. Feature_91_t0: importance=0.0003, rank=2
   3. Feature_93_t3: importance=0.0003, rank=3
   4. Feature_74_t3: importance=0.0003, rank=4
   5. Feature_92_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for EIG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EIG...

==================================================
Training Enhanced EIG (SVM)
==================================================
Training SVM model...

Enhanced EIG Performance:
MAE: 57517.5992
RMSE: 71951.3411
MAPE: 15.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 61
   • Highly important features (top 5%): 30

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0023, rank=1
   2. Feature_20_t1: importance=0.0010, rank=2
   3. Feature_13_t0: importance=0.0009, rank=3
   4. Feature_19_t0: importance=0.0006, rank=4
   5. Feature_17_t3: importance=0.0005, rank=5

📊 EIG Results:
  Baseline MAPE: 15.07%
  Enhanced MAPE: 15.40%
  MAPE Improvement: -0.33% (-2.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 141/464: ENPH
============================================================
📊 Loading data for ENPH...
📊 Loading data for ENPH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ENPH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ENPH...

==================================================
Training Baseline ENPH (SVM)
==================================================
Training SVM model...

Baseline ENPH Performance:
MAE: 1395644.1865
RMSE: 1955881.4941
MAPE: 7.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 248
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t1: importance=0.0002, rank=1
   2. Feature_68_t0: importance=0.0002, rank=2
   3. Feature_2_t0: importance=0.0002, rank=3
   4. Feature_95_t0: importance=0.0002, rank=4
   5. Feature_64_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ENPH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ENPH...

==================================================
Training Enhanced ENPH (SVM)
==================================================
Training SVM model...

Enhanced ENPH Performance:
MAE: 1386578.0756
RMSE: 1853752.6080
MAPE: 7.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t2: importance=0.0004, rank=1
   2. Feature_23_t1: importance=0.0004, rank=2
   3. Feature_11_t1: importance=0.0004, rank=3
   4. Feature_13_t3: importance=0.0004, rank=4
   5. Feature_14_t2: importance=0.0003, rank=5

📊 ENPH Results:
  Baseline MAPE: 7.67%
  Enhanced MAPE: 7.96%
  MAPE Improvement: -0.29% (-3.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 142/464: ENR
============================================================
📊 Loading data for ENR...
📊 Loading data for ENR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ENR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ENR...

==================================================
Training Baseline ENR (SVM)
==================================================
Training SVM model...

Baseline ENR Performance:
MAE: 179737.8802
RMSE: 231894.6501
MAPE: 5.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 211
   • Highly important features (top 5%): 118

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t2: importance=0.0005, rank=1
   2. Feature_79_t2: importance=0.0003, rank=2
   3. Feature_69_t2: importance=0.0002, rank=3
   4. Feature_83_t1: importance=0.0002, rank=4
   5. Feature_69_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ENR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ENR...

==================================================
Training Enhanced ENR (SVM)
==================================================
Training SVM model...

Enhanced ENR Performance:
MAE: 225819.6025
RMSE: 268609.3516
MAPE: 7.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0006, rank=1
   2. Feature_13_t1: importance=0.0003, rank=2
   3. Feature_23_t1: importance=0.0003, rank=3
   4. Feature_13_t0: importance=0.0003, rank=4
   5. Feature_14_t0: importance=0.0003, rank=5

📊 ENR Results:
  Baseline MAPE: 5.62%
  Enhanced MAPE: 7.38%
  MAPE Improvement: -1.77% (-31.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 143/464: ENVA
============================================================
📊 Loading data for ENVA...
📊 Loading data for ENVA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ENVA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ENVA...

==================================================
Training Baseline ENVA (SVM)
==================================================
Training SVM model...

Baseline ENVA Performance:
MAE: 88490.6250
RMSE: 120428.9493
MAPE: 5.39%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 176
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0007, rank=1
   2. Feature_93_t1: importance=0.0004, rank=2
   3. Feature_63_t1: importance=0.0003, rank=3
   4. Feature_68_t3: importance=0.0003, rank=4
   5. Feature_96_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ENVA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ENVA...

==================================================
Training Enhanced ENVA (SVM)
==================================================
Training SVM model...

Enhanced ENVA Performance:
MAE: 103760.6359
RMSE: 129718.0892
MAPE: 6.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t3: importance=0.0011, rank=1
   2. Feature_12_t3: importance=0.0008, rank=2
   3. Feature_17_t2: importance=0.0007, rank=3
   4. Feature_13_t1: importance=0.0005, rank=4
   5. Feature_14_t2: importance=0.0004, rank=5

📊 ENVA Results:
  Baseline MAPE: 5.39%
  Enhanced MAPE: 6.34%
  MAPE Improvement: -0.94% (-17.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 144/464: EPC
============================================================
📊 Loading data for EPC...
📊 Loading data for EPC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EPC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EPC...

==================================================
Training Baseline EPC (SVM)
==================================================
Training SVM model...

Baseline EPC Performance:
MAE: 140368.8135
RMSE: 184891.6388
MAPE: 6.07%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 260
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t1: importance=0.0002, rank=1
   2. Feature_74_t1: importance=0.0001, rank=2
   3. Feature_2_t2: importance=0.0001, rank=3
   4. Feature_75_t1: importance=0.0001, rank=4
   5. Feature_73_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for EPC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EPC...

==================================================
Training Enhanced EPC (SVM)
==================================================
Training SVM model...

Enhanced EPC Performance:
MAE: 151917.9392
RMSE: 209823.1002
MAPE: 6.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t1: importance=0.0003, rank=1
   2. Feature_24_t1: importance=0.0003, rank=2
   3. Feature_11_t2: importance=0.0003, rank=3
   4. Feature_2_t2: importance=0.0002, rank=4
   5. Feature_15_t3: importance=0.0002, rank=5

📊 EPC Results:
  Baseline MAPE: 6.07%
  Enhanced MAPE: 6.64%
  MAPE Improvement: -0.57% (-9.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 145/464: ESE
============================================================
📊 Loading data for ESE...
📊 Loading data for ESE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ESE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ESE...

==================================================
Training Baseline ESE (SVM)
==================================================
Training SVM model...

Baseline ESE Performance:
MAE: 36424.7804
RMSE: 48223.9630
MAPE: 14.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 118
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0011, rank=1
   2. Feature_0_t3: importance=0.0004, rank=2
   3. Feature_68_t0: importance=0.0004, rank=3
   4. Feature_90_t3: importance=0.0004, rank=4
   5. Feature_67_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for ESE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ESE...

==================================================
Training Enhanced ESE (SVM)
==================================================
Training SVM model...

Enhanced ESE Performance:
MAE: 36960.1677
RMSE: 45839.4218
MAPE: 14.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0010, rank=1
   2. Feature_17_t2: importance=0.0008, rank=2
   3. Feature_4_t1: importance=0.0006, rank=3
   4. Feature_16_t0: importance=0.0006, rank=4
   5. Feature_5_t0: importance=0.0006, rank=5

📊 ESE Results:
  Baseline MAPE: 14.10%
  Enhanced MAPE: 14.02%
  MAPE Improvement: +0.08% (+0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 146/464: ETSY
============================================================
📊 Loading data for ETSY...
📊 Loading data for ETSY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ETSY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ETSY...

==================================================
Training Baseline ETSY (SVM)
==================================================
Training SVM model...

Baseline ETSY Performance:
MAE: 1525814.3684
RMSE: 1944639.8762
MAPE: 8.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 190
   • Highly important features (top 5%): 131

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0003, rank=1
   2. Feature_88_t1: importance=0.0002, rank=2
   3. Feature_84_t0: importance=0.0002, rank=3
   4. Feature_83_t3: importance=0.0002, rank=4
   5. Feature_78_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ETSY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ETSY...

==================================================
Training Enhanced ETSY (SVM)
==================================================
Training SVM model...

Enhanced ETSY Performance:
MAE: 897694.0511
RMSE: 1225264.7235
MAPE: 5.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0007, rank=1
   2. Feature_23_t0: importance=0.0005, rank=2
   3. Feature_16_t0: importance=0.0004, rank=3
   4. Feature_10_t0: importance=0.0003, rank=4
   5. Feature_13_t1: importance=0.0003, rank=5

📊 ETSY Results:
  Baseline MAPE: 8.28%
  Enhanced MAPE: 5.03%
  MAPE Improvement: +3.25% (+39.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 147/464: EVTC
============================================================
📊 Loading data for EVTC...
📊 Loading data for EVTC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EVTC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EVTC...

==================================================
Training Baseline EVTC (SVM)
==================================================
Training SVM model...

Baseline EVTC Performance:
MAE: 238247.0762
RMSE: 284323.9120
MAPE: 11.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 228
   • Highly important features (top 5%): 139

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_89_t1: importance=0.0011, rank=1
   2. Feature_84_t1: importance=0.0007, rank=2
   3. Feature_94_t1: importance=0.0007, rank=3
   4. Feature_87_t1: importance=0.0007, rank=4
   5. Feature_63_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for EVTC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EVTC...

==================================================
Training Enhanced EVTC (SVM)
==================================================
Training SVM model...

Enhanced EVTC Performance:
MAE: 157375.2984
RMSE: 210840.4770
MAPE: 8.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 88

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0016, rank=1
   2. Feature_1_t3: importance=0.0014, rank=2
   3. Feature_14_t3: importance=0.0011, rank=3
   4. Feature_13_t2: importance=0.0010, rank=4
   5. Feature_15_t1: importance=0.0009, rank=5

📊 EVTC Results:
  Baseline MAPE: 11.31%
  Enhanced MAPE: 8.27%
  MAPE Improvement: +3.04% (+26.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 148/464: EXPI
============================================================
📊 Loading data for EXPI...
📊 Loading data for EXPI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing EXPI: 'EXPI'

============================================================
TESTING TICKER 149/464: EXTR
============================================================
📊 Loading data for EXTR...
📊 Loading data for EXTR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EXTR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EXTR...

==================================================
Training Baseline EXTR (SVM)
==================================================
Training SVM model...

Baseline EXTR Performance:
MAE: 604268.4340
RMSE: 814981.7429
MAPE: 7.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 273
   • Highly important features (top 5%): 143

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t3: importance=0.0007, rank=1
   2. Feature_65_t3: importance=0.0006, rank=2
   3. Feature_78_t2: importance=0.0005, rank=3
   4. Feature_92_t2: importance=0.0004, rank=4
   5. Feature_85_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for EXTR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EXTR...

==================================================
Training Enhanced EXTR (SVM)
==================================================
Training SVM model...

Enhanced EXTR Performance:
MAE: 777804.2632
RMSE: 1007576.6469
MAPE: 9.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0021, rank=1
   2. Feature_24_t3: importance=0.0018, rank=2
   3. Feature_11_t3: importance=0.0014, rank=3
   4. Feature_13_t3: importance=0.0008, rank=4
   5. Feature_19_t1: importance=0.0006, rank=5

📊 EXTR Results:
  Baseline MAPE: 7.53%
  Enhanced MAPE: 9.70%
  MAPE Improvement: -2.17% (-28.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 150/464: EYE
============================================================
📊 Loading data for EYE...
📊 Loading data for EYE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing EYE: 'EYE'

============================================================
TESTING TICKER 151/464: EZPW
============================================================
📊 Loading data for EZPW...
📊 Loading data for EZPW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for EZPW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for EZPW...

==================================================
Training Baseline EZPW (SVM)
==================================================
Training SVM model...

Baseline EZPW Performance:
MAE: 544973.3131
RMSE: 704862.5683
MAPE: 6.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 107
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0001, rank=1
   2. Feature_81_t2: importance=0.0001, rank=2
   3. Feature_75_t1: importance=0.0001, rank=3
   4. Feature_70_t0: importance=0.0001, rank=4
   5. Feature_1_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for EZPW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for EZPW...

==================================================
Training Enhanced EZPW (SVM)
==================================================
Training SVM model...

Enhanced EZPW Performance:
MAE: 637732.8799
RMSE: 791651.0579
MAPE: 8.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0002, rank=1
   2. Feature_1_t3: importance=0.0001, rank=2
   3. Feature_21_t2: importance=0.0001, rank=3
   4. Feature_11_t1: importance=0.0001, rank=4
   5. Feature_24_t3: importance=0.0001, rank=5

📊 EZPW Results:
  Baseline MAPE: 6.87%
  Enhanced MAPE: 8.03%
  MAPE Improvement: -1.16% (-16.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 152/464: FBK
============================================================
📊 Loading data for FBK...
📊 Loading data for FBK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing FBK: 'FBK'

============================================================
TESTING TICKER 153/464: FBNC
============================================================
📊 Loading data for FBNC...
📊 Loading data for FBNC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FBNC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FBNC...

==================================================
Training Baseline FBNC (SVM)
==================================================
Training SVM model...

Baseline FBNC Performance:
MAE: 87257.7679
RMSE: 104644.4961
MAPE: 8.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 337
   • Highly important features (top 5%): 187

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t3: importance=0.0005, rank=1
   2. Feature_67_t3: importance=0.0005, rank=2
   3. Feature_74_t3: importance=0.0005, rank=3
   4. Feature_78_t3: importance=0.0005, rank=4
   5. Feature_79_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for FBNC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FBNC...

==================================================
Training Enhanced FBNC (SVM)
==================================================
Training SVM model...

Enhanced FBNC Performance:
MAE: 82143.2084
RMSE: 94971.7299
MAPE: 8.20%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0021, rank=1
   2. Feature_16_t3: importance=0.0021, rank=2
   3. Feature_4_t3: importance=0.0021, rank=3
   4. Feature_7_t3: importance=0.0016, rank=4
   5. Feature_24_t2: importance=0.0015, rank=5

📊 FBNC Results:
  Baseline MAPE: 8.74%
  Enhanced MAPE: 8.20%
  MAPE Improvement: +0.54% (+6.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 154/464: FBP
============================================================
📊 Loading data for FBP...
📊 Loading data for FBP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FBP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FBP...

==================================================
Training Baseline FBP (SVM)
==================================================
Training SVM model...

Baseline FBP Performance:
MAE: 618984.2061
RMSE: 767888.4029
MAPE: 19.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 238
   • Highly important features (top 5%): 132

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t1: importance=0.0009, rank=1
   2. Feature_65_t1: importance=0.0007, rank=2
   3. Feature_65_t3: importance=0.0006, rank=3
   4. Feature_81_t0: importance=0.0005, rank=4
   5. Feature_72_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for FBP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FBP...

==================================================
Training Enhanced FBP (SVM)
==================================================
Training SVM model...

Enhanced FBP Performance:
MAE: 486766.9897
RMSE: 639850.8692
MAPE: 15.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t3: importance=0.0020, rank=1
   2. Feature_7_t1: importance=0.0015, rank=2
   3. Feature_5_t1: importance=0.0011, rank=3
   4. Feature_19_t0: importance=0.0010, rank=4
   5. Feature_5_t2: importance=0.0010, rank=5

📊 FBP Results:
  Baseline MAPE: 19.88%
  Enhanced MAPE: 15.77%
  MAPE Improvement: +4.11% (+20.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 155/464: FCF
============================================================
📊 Loading data for FCF...
📊 Loading data for FCF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FCF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FCF...

==================================================
Training Baseline FCF (SVM)
==================================================
Training SVM model...

Baseline FCF Performance:
MAE: 175617.9423
RMSE: 251126.5073
MAPE: 10.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 312
   • Highly important features (top 5%): 178

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_73_t2: importance=0.0001, rank=1
   2. Feature_0_t3: importance=0.0001, rank=2
   3. Feature_96_t0: importance=0.0001, rank=3
   4. Feature_67_t1: importance=0.0001, rank=4
   5. Feature_95_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for FCF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FCF...

==================================================
Training Enhanced FCF (SVM)
==================================================
Training SVM model...

Enhanced FCF Performance:
MAE: 181671.9134
RMSE: 254812.5544
MAPE: 11.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0004, rank=1
   2. Feature_13_t3: importance=0.0003, rank=2
   3. Feature_23_t3: importance=0.0002, rank=3
   4. Feature_6_t2: importance=0.0002, rank=4
   5. Feature_21_t3: importance=0.0002, rank=5

📊 FCF Results:
  Baseline MAPE: 10.90%
  Enhanced MAPE: 11.23%
  MAPE Improvement: -0.33% (-3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 156/464: FCPT
============================================================
📊 Loading data for FCPT...
📊 Loading data for FCPT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FCPT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FCPT...

==================================================
Training Baseline FCPT (SVM)
==================================================
Training SVM model...

Baseline FCPT Performance:
MAE: 403912.8053
RMSE: 550195.6058
MAPE: 10.49%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 262
   • Highly important features (top 5%): 106

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0005, rank=1
   2. Feature_80_t1: importance=0.0005, rank=2
   3. Feature_89_t1: importance=0.0004, rank=3
   4. Feature_2_t2: importance=0.0004, rank=4
   5. Feature_0_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for FCPT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FCPT...

==================================================
Training Enhanced FCPT (SVM)
==================================================
Training SVM model...

Enhanced FCPT Performance:
MAE: 416559.4521
RMSE: 573485.1281
MAPE: 11.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t2: importance=0.0010, rank=1
   2. Feature_14_t1: importance=0.0009, rank=2
   3. Feature_24_t0: importance=0.0009, rank=3
   4. Feature_5_t3: importance=0.0009, rank=4
   5. Feature_14_t3: importance=0.0008, rank=5

📊 FCPT Results:
  Baseline MAPE: 10.49%
  Enhanced MAPE: 11.17%
  MAPE Improvement: -0.67% (-6.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 157/464: FDP
============================================================
📊 Loading data for FDP...
📊 Loading data for FDP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing FDP: 'FDP'

============================================================
TESTING TICKER 158/464: FELE
============================================================
📊 Loading data for FELE...
📊 Loading data for FELE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FELE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FELE...

==================================================
Training Baseline FELE (SVM)
==================================================
Training SVM model...

Baseline FELE Performance:
MAE: 69002.0719
RMSE: 86614.9886
MAPE: 10.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 270
   • Highly important features (top 5%): 155

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0008, rank=1
   2. Feature_76_t1: importance=0.0004, rank=2
   3. Feature_92_t1: importance=0.0004, rank=3
   4. Feature_74_t3: importance=0.0004, rank=4
   5. Feature_2_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for FELE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FELE...

==================================================
Training Enhanced FELE (SVM)
==================================================
Training SVM model...

Enhanced FELE Performance:
MAE: 67511.4045
RMSE: 81686.7694
MAPE: 10.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 92

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0011, rank=1
   2. Feature_8_t3: importance=0.0007, rank=2
   3. Feature_18_t1: importance=0.0006, rank=3
   4. Feature_13_t2: importance=0.0006, rank=4
   5. Feature_11_t3: importance=0.0006, rank=5

📊 FELE Results:
  Baseline MAPE: 10.86%
  Enhanced MAPE: 10.75%
  MAPE Improvement: +0.11% (+1.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 159/464: FFBC
============================================================
📊 Loading data for FFBC...
📊 Loading data for FFBC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FFBC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FFBC...

==================================================
Training Baseline FFBC (SVM)
==================================================
Training SVM model...

Baseline FFBC Performance:
MAE: 122877.3468
RMSE: 160494.7246
MAPE: 9.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 333
   • Highly important features (top 5%): 253

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t3: importance=0.0002, rank=1
   2. Feature_67_t3: importance=0.0001, rank=2
   3. Feature_68_t3: importance=0.0001, rank=3
   4. Feature_77_t0: importance=0.0001, rank=4
   5. Feature_82_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for FFBC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FFBC...

==================================================
Training Enhanced FFBC (SVM)
==================================================
Training SVM model...

Enhanced FFBC Performance:
MAE: 120736.2525
RMSE: 159076.5211
MAPE: 9.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 49
   • Highly important features (top 5%): 30

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t1: importance=0.0010, rank=1
   2. Feature_1_t1: importance=0.0005, rank=2
   3. Feature_15_t1: importance=0.0003, rank=3
   4. Feature_23_t1: importance=0.0003, rank=4
   5. Feature_7_t1: importance=0.0002, rank=5

📊 FFBC Results:
  Baseline MAPE: 9.05%
  Enhanced MAPE: 9.29%
  MAPE Improvement: -0.24% (-2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 160/464: FHB
============================================================
📊 Loading data for FHB...
📊 Loading data for FHB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FHB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FHB...

==================================================
Training Baseline FHB (SVM)
==================================================
Training SVM model...

Baseline FHB Performance:
MAE: 310452.5381
RMSE: 399886.6617
MAPE: 7.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 331
   • Highly important features (top 5%): 233

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t3: importance=0.0009, rank=1
   2. Feature_76_t3: importance=0.0005, rank=2
   3. Feature_65_t1: importance=0.0004, rank=3
   4. Feature_65_t3: importance=0.0004, rank=4
   5. Feature_71_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for FHB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FHB...

==================================================
Training Enhanced FHB (SVM)
==================================================
Training SVM model...

Enhanced FHB Performance:
MAE: 355315.5147
RMSE: 419629.2390
MAPE: 8.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0020, rank=1
   2. Feature_23_t1: importance=0.0011, rank=2
   3. Feature_7_t2: importance=0.0010, rank=3
   4. Feature_1_t1: importance=0.0010, rank=4
   5. Feature_17_t0: importance=0.0010, rank=5

📊 FHB Results:
  Baseline MAPE: 7.47%
  Enhanced MAPE: 8.87%
  MAPE Improvement: -1.39% (-18.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 161/464: FIZZ
============================================================
📊 Loading data for FIZZ...
📊 Loading data for FIZZ from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FIZZ...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FIZZ...

==================================================
Training Baseline FIZZ (SVM)
==================================================
Training SVM model...

Baseline FIZZ Performance:
MAE: 127111.1073
RMSE: 153695.6396
MAPE: 5.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 210
   • Highly important features (top 5%): 97

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t2: importance=0.0004, rank=1
   2. Feature_70_t2: importance=0.0004, rank=2
   3. Feature_96_t3: importance=0.0004, rank=3
   4. Feature_95_t3: importance=0.0004, rank=4
   5. Feature_94_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for FIZZ...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FIZZ...

==================================================
Training Enhanced FIZZ (SVM)
==================================================
Training SVM model...

Enhanced FIZZ Performance:
MAE: 110730.5445
RMSE: 133959.4884
MAPE: 4.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0013, rank=1
   2. Feature_19_t2: importance=0.0011, rank=2
   3. Feature_1_t2: importance=0.0008, rank=3
   4. Feature_11_t3: importance=0.0006, rank=4
   5. Feature_3_t3: importance=0.0004, rank=5

📊 FIZZ Results:
  Baseline MAPE: 5.15%
  Enhanced MAPE: 4.57%
  MAPE Improvement: +0.58% (+11.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 162/464: FMC
============================================================
📊 Loading data for FMC...
📊 Loading data for FMC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FMC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FMC...

==================================================
Training Baseline FMC (SVM)
==================================================
Training SVM model...

Baseline FMC Performance:
MAE: 481068.7065
RMSE: 607105.4173
MAPE: 6.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 224
   • Highly important features (top 5%): 112

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_89_t0: importance=0.0006, rank=1
   2. Feature_67_t3: importance=0.0005, rank=2
   3. Feature_65_t3: importance=0.0004, rank=3
   4. Feature_88_t2: importance=0.0004, rank=4
   5. Feature_76_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for FMC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FMC...

==================================================
Training Enhanced FMC (SVM)
==================================================
Training SVM model...

Enhanced FMC Performance:
MAE: 497732.8594
RMSE: 644242.2013
MAPE: 6.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0011, rank=1
   2. Feature_15_t3: importance=0.0010, rank=2
   3. Feature_15_t2: importance=0.0008, rank=3
   4. Feature_1_t1: importance=0.0007, rank=4
   5. Feature_21_t3: importance=0.0006, rank=5

📊 FMC Results:
  Baseline MAPE: 6.83%
  Enhanced MAPE: 6.99%
  MAPE Improvement: -0.16% (-2.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 163/464: FORM
============================================================
📊 Loading data for FORM...
📊 Loading data for FORM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FORM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FORM...

==================================================
Training Baseline FORM (SVM)
==================================================
Training SVM model...

Baseline FORM Performance:
MAE: 224356.4888
RMSE: 289286.1503
MAPE: 8.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 193
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t2: importance=0.0005, rank=1
   2. Feature_95_t3: importance=0.0002, rank=2
   3. Feature_70_t1: importance=0.0002, rank=3
   4. Feature_79_t2: importance=0.0002, rank=4
   5. Feature_2_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for FORM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FORM...

==================================================
Training Enhanced FORM (SVM)
==================================================
Training SVM model...

Enhanced FORM Performance:
MAE: 207877.8986
RMSE: 263600.3453
MAPE: 8.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t1: importance=0.0005, rank=1
   2. Feature_7_t2: importance=0.0005, rank=2
   3. Feature_24_t1: importance=0.0005, rank=3
   4. Feature_13_t0: importance=0.0004, rank=4
   5. Feature_14_t3: importance=0.0003, rank=5

📊 FORM Results:
  Baseline MAPE: 8.68%
  Enhanced MAPE: 8.05%
  MAPE Improvement: +0.63% (+7.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 164/464: FOXF
============================================================
📊 Loading data for FOXF...
📊 Loading data for FOXF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FOXF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FOXF...

==================================================
Training Baseline FOXF (SVM)
==================================================
Training SVM model...

Baseline FOXF Performance:
MAE: 210596.2704
RMSE: 286571.2685
MAPE: 9.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 83
   • Highly important features (top 5%): 54

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t0: importance=0.0004, rank=1
   2. Feature_65_t0: importance=0.0004, rank=2
   3. Feature_82_t3: importance=0.0002, rank=3
   4. Feature_91_t0: importance=0.0001, rank=4
   5. Feature_71_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for FOXF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FOXF...

==================================================
Training Enhanced FOXF (SVM)
==================================================
Training SVM model...

Enhanced FOXF Performance:
MAE: 211944.2456
RMSE: 275558.6133
MAPE: 9.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 68
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t0: importance=0.0004, rank=1
   2. Feature_10_t3: importance=0.0003, rank=2
   3. Feature_12_t2: importance=0.0003, rank=3
   4. Feature_20_t2: importance=0.0002, rank=4
   5. Feature_24_t1: importance=0.0002, rank=5

📊 FOXF Results:
  Baseline MAPE: 9.32%
  Enhanced MAPE: 9.30%
  MAPE Improvement: +0.02% (+0.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 165/464: FRPT
============================================================
📊 Loading data for FRPT...
📊 Loading data for FRPT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FRPT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FRPT...

==================================================
Training Baseline FRPT (SVM)
==================================================
Training SVM model...

Baseline FRPT Performance:
MAE: 376740.4483
RMSE: 456983.2241
MAPE: 6.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 241
   • Highly important features (top 5%): 156

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0004, rank=1
   2. Feature_63_t1: importance=0.0002, rank=2
   3. Feature_85_t1: importance=0.0002, rank=3
   4. Feature_67_t3: importance=0.0002, rank=4
   5. Feature_86_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for FRPT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FRPT...

==================================================
Training Enhanced FRPT (SVM)
==================================================
Training SVM model...

Enhanced FRPT Performance:
MAE: 266088.4893
RMSE: 340769.0666
MAPE: 4.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t1: importance=0.0009, rank=1
   2. Feature_24_t1: importance=0.0004, rank=2
   3. Feature_23_t1: importance=0.0003, rank=3
   4. Feature_17_t3: importance=0.0003, rank=4
   5. Feature_20_t2: importance=0.0003, rank=5

📊 FRPT Results:
  Baseline MAPE: 6.92%
  Enhanced MAPE: 4.84%
  MAPE Improvement: +2.08% (+30.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 166/464: FSS
============================================================
📊 Loading data for FSS...
📊 Loading data for FSS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FSS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FSS...

==================================================
Training Baseline FSS (SVM)
==================================================
Training SVM model...

Baseline FSS Performance:
MAE: 256206.1973
RMSE: 343577.1491
MAPE: 13.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 281
   • Highly important features (top 5%): 145

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t3: importance=0.0009, rank=1
   2. Feature_72_t2: importance=0.0008, rank=2
   3. Feature_70_t0: importance=0.0008, rank=3
   4. Feature_78_t0: importance=0.0008, rank=4
   5. Feature_77_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for FSS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FSS...

==================================================
Training Enhanced FSS (SVM)
==================================================
Training SVM model...

Enhanced FSS Performance:
MAE: 237314.0799
RMSE: 329142.1908
MAPE: 12.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0020, rank=1
   2. Feature_15_t3: importance=0.0019, rank=2
   3. Feature_15_t2: importance=0.0019, rank=3
   4. Feature_17_t3: importance=0.0014, rank=4
   5. Feature_14_t2: importance=0.0011, rank=5

📊 FSS Results:
  Baseline MAPE: 13.81%
  Enhanced MAPE: 12.80%
  MAPE Improvement: +1.01% (+7.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 167/464: FUL
============================================================
📊 Loading data for FUL...
📊 Loading data for FUL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FUL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FUL...

==================================================
Training Baseline FUL (SVM)
==================================================
Training SVM model...

Baseline FUL Performance:
MAE: 103633.6545
RMSE: 128316.7766
MAPE: 9.55%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 309
   • Highly important features (top 5%): 154

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_91_t0: importance=0.0002, rank=1
   2. Feature_63_t3: importance=0.0002, rank=2
   3. Feature_67_t3: importance=0.0002, rank=3
   4. Feature_74_t2: importance=0.0002, rank=4
   5. Feature_85_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for FUL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FUL...

==================================================
Training Enhanced FUL (SVM)
==================================================
Training SVM model...

Enhanced FUL Performance:
MAE: 101121.8988
RMSE: 126478.2690
MAPE: 9.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0006, rank=1
   2. Feature_4_t3: importance=0.0004, rank=2
   3. Feature_7_t0: importance=0.0004, rank=3
   4. Feature_15_t3: importance=0.0004, rank=4
   5. Feature_17_t2: importance=0.0003, rank=5

📊 FUL Results:
  Baseline MAPE: 9.55%
  Enhanced MAPE: 9.23%
  MAPE Improvement: +0.32% (+3.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 168/464: FULT
============================================================
📊 Loading data for FULT...
📊 Loading data for FULT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FULT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FULT...

==================================================
Training Baseline FULT (SVM)
==================================================
Training SVM model...

Baseline FULT Performance:
MAE: 478744.3253
RMSE: 618349.5425
MAPE: 7.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 318
   • Highly important features (top 5%): 179

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0001, rank=1
   2. Feature_65_t1: importance=0.0001, rank=2
   3. Feature_73_t2: importance=0.0001, rank=3
   4. Feature_65_t2: importance=0.0001, rank=4
   5. Feature_95_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for FULT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FULT...

==================================================
Training Enhanced FULT (SVM)
==================================================
Training SVM model...

Enhanced FULT Performance:
MAE: 505353.5124
RMSE: 631002.9202
MAPE: 8.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0005, rank=1
   2. Feature_17_t1: importance=0.0003, rank=2
   3. Feature_23_t1: importance=0.0003, rank=3
   4. Feature_13_t1: importance=0.0003, rank=4
   5. Feature_17_t3: importance=0.0003, rank=5

📊 FULT Results:
  Baseline MAPE: 7.94%
  Enhanced MAPE: 8.24%
  MAPE Improvement: -0.29% (-3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 169/464: FUN
============================================================
📊 Loading data for FUN...
📊 Loading data for FUN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing FUN: 'FUN'

============================================================
TESTING TICKER 170/464: FWRD
============================================================
📊 Loading data for FWRD...
📊 Loading data for FWRD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for FWRD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for FWRD...

==================================================
Training Baseline FWRD (SVM)
==================================================
Training SVM model...

Baseline FWRD Performance:
MAE: 575278.5962
RMSE: 708856.5915
MAPE: 14.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 250
   • Highly important features (top 5%): 125

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0013, rank=1
   2. Feature_92_t3: importance=0.0011, rank=2
   3. Feature_74_t3: importance=0.0010, rank=3
   4. Feature_2_t2: importance=0.0009, rank=4
   5. Feature_72_t3: importance=0.0009, rank=5

🔧 Applying universal feature engineering for FWRD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for FWRD...

==================================================
Training Enhanced FWRD (SVM)
==================================================
Training SVM model...

Enhanced FWRD Performance:
MAE: 409227.3741
RMSE: 545836.3886
MAPE: 10.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0020, rank=1
   2. Feature_10_t3: importance=0.0011, rank=2
   3. Feature_13_t0: importance=0.0011, rank=3
   4. Feature_14_t3: importance=0.0011, rank=4
   5. Feature_15_t3: importance=0.0010, rank=5

📊 FWRD Results:
  Baseline MAPE: 14.02%
  Enhanced MAPE: 10.28%
  MAPE Improvement: +3.74% (+26.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 171/464: GBX
============================================================
📊 Loading data for GBX...
📊 Loading data for GBX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GBX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GBX...

==================================================
Training Baseline GBX (SVM)
==================================================
Training SVM model...

Baseline GBX Performance:
MAE: 99882.6544
RMSE: 125008.1071
MAPE: 5.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 147
   • Highly important features (top 5%): 100

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t1: importance=0.0002, rank=1
   2. Feature_77_t3: importance=0.0002, rank=2
   3. Feature_89_t3: importance=0.0002, rank=3
   4. Feature_95_t0: importance=0.0002, rank=4
   5. Feature_88_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for GBX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GBX...

==================================================
Training Enhanced GBX (SVM)
==================================================
Training SVM model...

Enhanced GBX Performance:
MAE: 100651.6426
RMSE: 122260.3244
MAPE: 5.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t0: importance=0.0002, rank=1
   2. Feature_4_t3: importance=0.0002, rank=2
   3. Feature_4_t2: importance=0.0002, rank=3
   4. Feature_14_t0: importance=0.0002, rank=4
   5. Feature_1_t2: importance=0.0002, rank=5

📊 GBX Results:
  Baseline MAPE: 5.25%
  Enhanced MAPE: 5.38%
  MAPE Improvement: -0.13% (-2.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 172/464: GDEN
============================================================
📊 Loading data for GDEN...
📊 Loading data for GDEN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GDEN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GDEN...

==================================================
Training Baseline GDEN (SVM)
==================================================
Training SVM model...

Baseline GDEN Performance:
MAE: 69222.9505
RMSE: 82323.8935
MAPE: 10.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 94
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t0: importance=0.0031, rank=1
   2. Feature_63_t0: importance=0.0013, rank=2
   3. Feature_88_t0: importance=0.0012, rank=3
   4. Feature_89_t1: importance=0.0006, rank=4
   5. Feature_91_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for GDEN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GDEN...

==================================================
Training Enhanced GDEN (SVM)
==================================================
Training SVM model...

Enhanced GDEN Performance:
MAE: 91407.4849
RMSE: 113412.1975
MAPE: 13.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0027, rank=1
   2. Feature_22_t0: importance=0.0022, rank=2
   3. Feature_4_t1: importance=0.0018, rank=3
   4. Feature_19_t1: importance=0.0017, rank=4
   5. Feature_7_t0: importance=0.0016, rank=5

📊 GDEN Results:
  Baseline MAPE: 10.40%
  Enhanced MAPE: 13.01%
  MAPE Improvement: -2.62% (-25.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 173/464: GEO
============================================================
📊 Loading data for GEO...
📊 Loading data for GEO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GEO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GEO...

==================================================
Training Baseline GEO (SVM)
==================================================
Training SVM model...

Baseline GEO Performance:
MAE: 1382629.5469
RMSE: 1924315.3068
MAPE: 13.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 145
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_91_t1: importance=0.0007, rank=1
   2. Feature_95_t2: importance=0.0005, rank=2
   3. Feature_66_t1: importance=0.0005, rank=3
   4. Feature_63_t3: importance=0.0004, rank=4
   5. Feature_64_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for GEO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GEO...

==================================================
Training Enhanced GEO (SVM)
==================================================
Training SVM model...

Enhanced GEO Performance:
MAE: 1301550.7584
RMSE: 1957339.1628
MAPE: 12.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 35

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t1: importance=0.0018, rank=1
   2. Feature_15_t3: importance=0.0018, rank=2
   3. Feature_13_t1: importance=0.0014, rank=3
   4. Feature_12_t1: importance=0.0010, rank=4
   5. Feature_22_t2: importance=0.0009, rank=5

📊 GEO Results:
  Baseline MAPE: 13.18%
  Enhanced MAPE: 12.72%
  MAPE Improvement: +0.46% (+3.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 174/464: GES
============================================================
📊 Loading data for GES...
📊 Loading data for GES from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GES...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GES...

==================================================
Training Baseline GES (SVM)
==================================================
Training SVM model...

Baseline GES Performance:
MAE: 650567.2925
RMSE: 840948.3848
MAPE: 8.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 114
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t2: importance=0.0018, rank=1
   2. Feature_80_t3: importance=0.0008, rank=2
   3. Feature_82_t2: importance=0.0006, rank=3
   4. Feature_67_t1: importance=0.0005, rank=4
   5. Feature_71_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for GES...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GES...

==================================================
Training Enhanced GES (SVM)
==================================================
Training SVM model...

Enhanced GES Performance:
MAE: 512408.4160
RMSE: 727075.1884
MAPE: 6.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 34
   • Highly important features (top 5%): 14

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0014, rank=1
   2. Feature_7_t2: importance=0.0011, rank=2
   3. Feature_1_t0: importance=0.0011, rank=3
   4. Feature_2_t1: importance=0.0008, rank=4
   5. Feature_2_t2: importance=0.0007, rank=5

📊 GES Results:
  Baseline MAPE: 8.10%
  Enhanced MAPE: 6.25%
  MAPE Improvement: +1.85% (+22.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 175/464: GFF
============================================================
📊 Loading data for GFF...
📊 Loading data for GFF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GFF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GFF...

==================================================
Training Baseline GFF (SVM)
==================================================
Training SVM model...

Baseline GFF Performance:
MAE: 216631.6816
RMSE: 277309.2795
MAPE: 10.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 179
   • Highly important features (top 5%): 108

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0009, rank=1
   2. Feature_65_t2: importance=0.0009, rank=2
   3. Feature_82_t1: importance=0.0007, rank=3
   4. Feature_86_t3: importance=0.0005, rank=4
   5. Feature_93_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for GFF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GFF...

==================================================
Training Enhanced GFF (SVM)
==================================================
Training SVM model...

Enhanced GFF Performance:
MAE: 276734.2531
RMSE: 325470.4482
MAPE: 13.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t2: importance=0.0022, rank=1
   2. Feature_11_t3: importance=0.0012, rank=2
   3. Feature_4_t1: importance=0.0012, rank=3
   4. Feature_23_t1: importance=0.0011, rank=4
   5. Feature_17_t0: importance=0.0011, rank=5

📊 GFF Results:
  Baseline MAPE: 10.67%
  Enhanced MAPE: 13.91%
  MAPE Improvement: -3.24% (-30.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 176/464: GIII
============================================================
📊 Loading data for GIII...
📊 Loading data for GIII from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GIII...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GIII...

==================================================
Training Baseline GIII (SVM)
==================================================
Training SVM model...

Baseline GIII Performance:
MAE: 271246.6803
RMSE: 325916.7178
MAPE: 5.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 190
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t0: importance=0.0001, rank=1
   2. Feature_66_t3: importance=0.0001, rank=2
   3. Feature_63_t1: importance=0.0001, rank=3
   4. Feature_68_t0: importance=0.0001, rank=4
   5. Feature_64_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for GIII...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GIII...

==================================================
Training Enhanced GIII (SVM)
==================================================
Training SVM model...

Enhanced GIII Performance:
MAE: 239659.2269
RMSE: 304461.8061
MAPE: 5.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t2: importance=0.0004, rank=1
   2. Feature_7_t3: importance=0.0002, rank=2
   3. Feature_12_t2: importance=0.0002, rank=3
   4. Feature_22_t0: importance=0.0001, rank=4
   5. Feature_6_t2: importance=0.0001, rank=5

📊 GIII Results:
  Baseline MAPE: 5.98%
  Enhanced MAPE: 5.27%
  MAPE Improvement: +0.71% (+11.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 177/464: GKOS
============================================================
📊 Loading data for GKOS...
📊 Loading data for GKOS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GKOS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GKOS...

==================================================
Training Baseline GKOS (SVM)
==================================================
Training SVM model...

Baseline GKOS Performance:
MAE: 376648.7428
RMSE: 646612.1536
MAPE: 11.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 158
   • Highly important features (top 5%): 92

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t3: importance=0.0004, rank=1
   2. Feature_82_t0: importance=0.0003, rank=2
   3. Feature_65_t3: importance=0.0003, rank=3
   4. Feature_68_t3: importance=0.0003, rank=4
   5. Feature_88_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for GKOS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GKOS...

==================================================
Training Enhanced GKOS (SVM)
==================================================
Training SVM model...

Enhanced GKOS Performance:
MAE: 376888.3364
RMSE: 682905.1915
MAPE: 11.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0008, rank=1
   2. Feature_5_t3: importance=0.0006, rank=2
   3. Feature_19_t3: importance=0.0006, rank=3
   4. Feature_1_t0: importance=0.0005, rank=4
   5. Feature_15_t3: importance=0.0005, rank=5

📊 GKOS Results:
  Baseline MAPE: 11.00%
  Enhanced MAPE: 11.09%
  MAPE Improvement: -0.09% (-0.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 178/464: GNL
============================================================
📊 Loading data for GNL...
📊 Loading data for GNL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GNL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GNL...

==================================================
Training Baseline GNL (SVM)
==================================================
Training SVM model...

Baseline GNL Performance:
MAE: 1154755.9995
RMSE: 1693864.6118
MAPE: 14.48%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 188
   • Highly important features (top 5%): 91

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0014, rank=1
   2. Feature_64_t0: importance=0.0006, rank=2
   3. Feature_94_t2: importance=0.0005, rank=3
   4. Feature_69_t0: importance=0.0005, rank=4
   5. Feature_90_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for GNL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GNL...

==================================================
Training Enhanced GNL (SVM)
==================================================
Training SVM model...

Enhanced GNL Performance:
MAE: 1145310.9634
RMSE: 1688816.2430
MAPE: 14.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t1: importance=0.0019, rank=1
   2. Feature_1_t1: importance=0.0013, rank=2
   3. Feature_5_t1: importance=0.0012, rank=3
   4. Feature_11_t3: importance=0.0012, rank=4
   5. Feature_7_t3: importance=0.0011, rank=5

📊 GNL Results:
  Baseline MAPE: 14.48%
  Enhanced MAPE: 14.25%
  MAPE Improvement: +0.22% (+1.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 179/464: GNW
============================================================
📊 Loading data for GNW...
📊 Loading data for GNW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GNW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GNW...

==================================================
Training Baseline GNW (SVM)
==================================================
Training SVM model...

Baseline GNW Performance:
MAE: 719075.3679
RMSE: 931822.8471
MAPE: 9.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 307
   • Highly important features (top 5%): 156

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0004, rank=1
   2. Feature_71_t3: importance=0.0002, rank=2
   3. Feature_2_t0: importance=0.0002, rank=3
   4. Feature_85_t1: importance=0.0002, rank=4
   5. Feature_65_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for GNW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GNW...

==================================================
Training Enhanced GNW (SVM)
==================================================
Training SVM model...

Enhanced GNW Performance:
MAE: 837795.4375
RMSE: 1048842.7783
MAPE: 11.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0009, rank=1
   2. Feature_16_t2: importance=0.0008, rank=2
   3. Feature_13_t2: importance=0.0006, rank=3
   4. Feature_10_t1: importance=0.0005, rank=4
   5. Feature_5_t0: importance=0.0005, rank=5

📊 GNW Results:
  Baseline MAPE: 9.83%
  Enhanced MAPE: 11.46%
  MAPE Improvement: -1.63% (-16.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 180/464: GOGO
============================================================
📊 Loading data for GOGO...
📊 Loading data for GOGO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing GOGO: 'GOGO'

============================================================
TESTING TICKER 181/464: GOLF
============================================================
📊 Loading data for GOLF...
📊 Loading data for GOLF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GOLF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GOLF...

==================================================
Training Baseline GOLF (SVM)
==================================================
Training SVM model...

Baseline GOLF Performance:
MAE: 393954.2907
RMSE: 491153.9049
MAPE: 7.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 134
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t3: importance=0.0004, rank=1
   2. Feature_82_t2: importance=0.0004, rank=2
   3. Feature_84_t3: importance=0.0004, rank=3
   4. Feature_84_t2: importance=0.0003, rank=4
   5. Feature_95_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for GOLF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GOLF...

==================================================
Training Enhanced GOLF (SVM)
==================================================
Training SVM model...

Enhanced GOLF Performance:
MAE: 351732.3521
RMSE: 452181.3104
MAPE: 7.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0008, rank=1
   2. Feature_11_t2: importance=0.0004, rank=2
   3. Feature_19_t1: importance=0.0004, rank=3
   4. Feature_13_t3: importance=0.0004, rank=4
   5. Feature_5_t2: importance=0.0003, rank=5

📊 GOLF Results:
  Baseline MAPE: 7.94%
  Enhanced MAPE: 7.08%
  MAPE Improvement: +0.86% (+10.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 182/464: GPI
============================================================
📊 Loading data for GPI...
📊 Loading data for GPI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GPI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GPI...

==================================================
Training Baseline GPI (SVM)
==================================================
Training SVM model...

Baseline GPI Performance:
MAE: 55553.2008
RMSE: 75311.6245
MAPE: 3.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 143
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t3: importance=0.0000, rank=1
   2. Feature_69_t3: importance=0.0000, rank=2
   3. Feature_80_t0: importance=0.0000, rank=3
   4. Feature_67_t3: importance=0.0000, rank=4
   5. Feature_2_t1: importance=0.0000, rank=5

🔧 Applying universal feature engineering for GPI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GPI...

==================================================
Training Enhanced GPI (SVM)
==================================================
Training SVM model...

Enhanced GPI Performance:
MAE: 54773.9438
RMSE: 71773.1982
MAPE: 3.73%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 46
   • Highly important features (top 5%): 23

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t0: importance=0.0001, rank=1
   2. Feature_4_t0: importance=0.0001, rank=2
   3. Feature_11_t3: importance=0.0000, rank=3
   4. Feature_24_t3: importance=0.0000, rank=4
   5. Feature_5_t3: importance=0.0000, rank=5

📊 GPI Results:
  Baseline MAPE: 3.80%
  Enhanced MAPE: 3.73%
  MAPE Improvement: +0.06% (+1.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 183/464: GRBK
============================================================
📊 Loading data for GRBK...
📊 Loading data for GRBK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GRBK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GRBK...

==================================================
Training Baseline GRBK (SVM)
==================================================
Training SVM model...

Baseline GRBK Performance:
MAE: 164137.8699
RMSE: 234359.7412
MAPE: 11.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 194
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t1: importance=0.0019, rank=1
   2. Feature_74_t1: importance=0.0018, rank=2
   3. Feature_68_t3: importance=0.0016, rank=3
   4. Feature_74_t3: importance=0.0015, rank=4
   5. Feature_72_t1: importance=0.0009, rank=5

🔧 Applying universal feature engineering for GRBK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GRBK...

==================================================
Training Enhanced GRBK (SVM)
==================================================
Training SVM model...

Enhanced GRBK Performance:
MAE: 155713.7419
RMSE: 207347.4180
MAPE: 10.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0024, rank=1
   2. Feature_1_t1: importance=0.0023, rank=2
   3. Feature_7_t1: importance=0.0021, rank=3
   4. Feature_4_t2: importance=0.0019, rank=4
   5. Feature_23_t0: importance=0.0019, rank=5

📊 GRBK Results:
  Baseline MAPE: 11.77%
  Enhanced MAPE: 10.93%
  MAPE Improvement: +0.85% (+7.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 184/464: GTY
============================================================
📊 Loading data for GTY...
📊 Loading data for GTY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GTY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GTY...

==================================================
Training Baseline GTY (SVM)
==================================================
Training SVM model...

Baseline GTY Performance:
MAE: 414470.8500
RMSE: 605212.8205
MAPE: 13.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 142
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0020, rank=1
   2. Feature_86_t1: importance=0.0015, rank=2
   3. Feature_63_t0: importance=0.0010, rank=3
   4. Feature_68_t3: importance=0.0009, rank=4
   5. Feature_86_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for GTY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GTY...

==================================================
Training Enhanced GTY (SVM)
==================================================
Training SVM model...

Enhanced GTY Performance:
MAE: 354187.8767
RMSE: 549532.1033
MAPE: 10.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t0: importance=0.0021, rank=1
   2. Feature_22_t1: importance=0.0017, rank=2
   3. Feature_14_t0: importance=0.0015, rank=3
   4. Feature_10_t0: importance=0.0015, rank=4
   5. Feature_17_t2: importance=0.0013, rank=5

📊 GTY Results:
  Baseline MAPE: 13.37%
  Enhanced MAPE: 10.96%
  MAPE Improvement: +2.41% (+18.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 185/464: GVA
============================================================
📊 Loading data for GVA...
📊 Loading data for GVA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for GVA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for GVA...

==================================================
Training Baseline GVA (SVM)
==================================================
Training SVM model...

Baseline GVA Performance:
MAE: 316147.5286
RMSE: 410846.7661
MAPE: 6.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 253
   • Highly important features (top 5%): 126

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t3: importance=0.0005, rank=1
   2. Feature_82_t2: importance=0.0003, rank=2
   3. Feature_76_t1: importance=0.0002, rank=3
   4. Feature_65_t0: importance=0.0002, rank=4
   5. Feature_2_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for GVA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for GVA...

==================================================
Training Enhanced GVA (SVM)
==================================================
Training SVM model...

Enhanced GVA Performance:
MAE: 231722.7752
RMSE: 302166.0686
MAPE: 5.04%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0008, rank=1
   2. Feature_5_t0: importance=0.0008, rank=2
   3. Feature_12_t0: importance=0.0006, rank=3
   4. Feature_19_t3: importance=0.0004, rank=4
   5. Feature_3_t3: importance=0.0004, rank=5

📊 GVA Results:
  Baseline MAPE: 6.98%
  Enhanced MAPE: 5.04%
  MAPE Improvement: +1.94% (+27.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 186/464: HAFC
============================================================
📊 Loading data for HAFC...
📊 Loading data for HAFC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HAFC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HAFC...

==================================================
Training Baseline HAFC (SVM)
==================================================
Training SVM model...

Baseline HAFC Performance:
MAE: 86436.5512
RMSE: 117367.2498
MAPE: 14.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 281
   • Highly important features (top 5%): 173

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0010, rank=1
   2. Feature_84_t2: importance=0.0008, rank=2
   3. Feature_82_t1: importance=0.0007, rank=3
   4. Feature_71_t3: importance=0.0005, rank=4
   5. Feature_67_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for HAFC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HAFC...

==================================================
Training Enhanced HAFC (SVM)
==================================================
Training SVM model...

Enhanced HAFC Performance:
MAE: 93133.0022
RMSE: 127494.0422
MAPE: 15.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 72
   • Highly important features (top 5%): 40

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t0: importance=0.0021, rank=1
   2. Feature_24_t0: importance=0.0014, rank=2
   3. Feature_17_t3: importance=0.0010, rank=3
   4. Feature_5_t0: importance=0.0009, rank=4
   5. Feature_17_t1: importance=0.0008, rank=5

📊 HAFC Results:
  Baseline MAPE: 14.99%
  Enhanced MAPE: 15.09%
  MAPE Improvement: -0.09% (-0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 187/464: HASI
============================================================
📊 Loading data for HASI...
📊 Loading data for HASI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HASI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HASI...

==================================================
Training Baseline HASI (SVM)
==================================================
Training SVM model...

Baseline HASI Performance:
MAE: 669254.9141
RMSE: 820114.3043
MAPE: 5.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 169
   • Highly important features (top 5%): 118

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0003, rank=1
   2. Feature_67_t1: importance=0.0003, rank=2
   3. Feature_96_t2: importance=0.0002, rank=3
   4. Feature_68_t3: importance=0.0002, rank=4
   5. Feature_63_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HASI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HASI...

==================================================
Training Enhanced HASI (SVM)
==================================================
Training SVM model...

Enhanced HASI Performance:
MAE: 578142.5662
RMSE: 693761.2787
MAPE: 4.39%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0002, rank=1
   2. Feature_19_t3: importance=0.0002, rank=2
   3. Feature_13_t3: importance=0.0001, rank=3
   4. Feature_8_t1: importance=0.0001, rank=4
   5. Feature_4_t0: importance=0.0001, rank=5

📊 HASI Results:
  Baseline MAPE: 5.00%
  Enhanced MAPE: 4.39%
  MAPE Improvement: +0.62% (+12.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 188/464: HBI
============================================================
📊 Loading data for HBI...
📊 Loading data for HBI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HBI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HBI...

==================================================
Training Baseline HBI (SVM)
==================================================
Training SVM model...

Baseline HBI Performance:
MAE: 2349478.4081
RMSE: 3273338.1051
MAPE: 5.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 219
   • Highly important features (top 5%): 93

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_73_t2: importance=0.0001, rank=1
   2. Feature_73_t3: importance=0.0001, rank=2
   3. Feature_93_t2: importance=0.0001, rank=3
   4. Feature_86_t0: importance=0.0001, rank=4
   5. Feature_71_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HBI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HBI...

==================================================
Training Enhanced HBI (SVM)
==================================================
Training SVM model...

Enhanced HBI Performance:
MAE: 2293933.7734
RMSE: 3162245.9362
MAPE: 5.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0005, rank=1
   2. Feature_19_t1: importance=0.0003, rank=2
   3. Feature_19_t2: importance=0.0003, rank=3
   4. Feature_19_t0: importance=0.0002, rank=4
   5. Feature_17_t1: importance=0.0002, rank=5

📊 HBI Results:
  Baseline MAPE: 5.74%
  Enhanced MAPE: 5.58%
  MAPE Improvement: +0.15% (+2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 189/464: HCC
============================================================
📊 Loading data for HCC...
📊 Loading data for HCC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing HCC: 'HCC'

============================================================
TESTING TICKER 190/464: HCI
============================================================
📊 Loading data for HCI...
📊 Loading data for HCI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing HCI: 'HCI'

============================================================
TESTING TICKER 191/464: HCSG
============================================================
📊 Loading data for HCSG...
📊 Loading data for HCSG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HCSG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HCSG...

==================================================
Training Baseline HCSG (SVM)
==================================================
Training SVM model...

Baseline HCSG Performance:
MAE: 183632.0108
RMSE: 240592.0337
MAPE: 7.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 145
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0010, rank=1
   2. Feature_77_t3: importance=0.0002, rank=2
   3. Feature_65_t1: importance=0.0002, rank=3
   4. Feature_93_t2: importance=0.0001, rank=4
   5. Feature_71_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HCSG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HCSG...

==================================================
Training Enhanced HCSG (SVM)
==================================================
Training SVM model...

Enhanced HCSG Performance:
MAE: 196171.6820
RMSE: 256294.5242
MAPE: 7.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 58
   • Highly important features (top 5%): 32

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0003, rank=1
   2. Feature_5_t1: importance=0.0003, rank=2
   3. Feature_17_t1: importance=0.0003, rank=3
   4. Feature_1_t0: importance=0.0003, rank=4
   5. Feature_20_t0: importance=0.0002, rank=5

📊 HCSG Results:
  Baseline MAPE: 7.46%
  Enhanced MAPE: 7.92%
  MAPE Improvement: -0.46% (-6.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 192/464: HELE
============================================================
📊 Loading data for HELE...
📊 Loading data for HELE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HELE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HELE...

==================================================
Training Baseline HELE (SVM)
==================================================
Training SVM model...

Baseline HELE Performance:
MAE: 233570.6037
RMSE: 284232.7080
MAPE: 9.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 131
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t0: importance=0.0006, rank=1
   2. Feature_64_t3: importance=0.0004, rank=2
   3. Feature_90_t0: importance=0.0004, rank=3
   4. Feature_93_t2: importance=0.0003, rank=4
   5. Feature_92_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for HELE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HELE...

==================================================
Training Enhanced HELE (SVM)
==================================================
Training SVM model...

Enhanced HELE Performance:
MAE: 194604.5118
RMSE: 266905.5012
MAPE: 7.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 42

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0017, rank=1
   2. Feature_16_t1: importance=0.0010, rank=2
   3. Feature_7_t0: importance=0.0009, rank=3
   4. Feature_19_t2: importance=0.0008, rank=4
   5. Feature_4_t2: importance=0.0008, rank=5

📊 HELE Results:
  Baseline MAPE: 9.19%
  Enhanced MAPE: 7.89%
  MAPE Improvement: +1.30% (+14.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 193/464: HFWA
============================================================
📊 Loading data for HFWA...
📊 Loading data for HFWA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HFWA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HFWA...

==================================================
Training Baseline HFWA (SVM)
==================================================
Training SVM model...

Baseline HFWA Performance:
MAE: 63617.3311
RMSE: 80433.4092
MAPE: 10.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 263
   • Highly important features (top 5%): 120

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t0: importance=0.0002, rank=1
   2. Feature_65_t0: importance=0.0001, rank=2
   3. Feature_65_t3: importance=0.0001, rank=3
   4. Feature_89_t0: importance=0.0001, rank=4
   5. Feature_83_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HFWA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HFWA...

==================================================
Training Enhanced HFWA (SVM)
==================================================
Training SVM model...

Enhanced HFWA Performance:
MAE: 68081.5377
RMSE: 86869.6244
MAPE: 10.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t1: importance=0.0002, rank=1
   2. Feature_12_t2: importance=0.0002, rank=2
   3. Feature_19_t2: importance=0.0002, rank=3
   4. Feature_15_t1: importance=0.0002, rank=4
   5. Feature_23_t3: importance=0.0002, rank=5

📊 HFWA Results:
  Baseline MAPE: 10.08%
  Enhanced MAPE: 10.62%
  MAPE Improvement: -0.54% (-5.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 194/464: HI
============================================================
📊 Loading data for HI...
📊 Loading data for HI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HI...

==================================================
Training Baseline HI (SVM)
==================================================
Training SVM model...

Baseline HI Performance:
MAE: 179058.1912
RMSE: 232201.4193
MAPE: 9.71%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 128
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t3: importance=0.0014, rank=1
   2. Feature_70_t3: importance=0.0011, rank=2
   3. Feature_2_t3: importance=0.0010, rank=3
   4. Feature_72_t3: importance=0.0010, rank=4
   5. Feature_2_t0: importance=0.0009, rank=5

🔧 Applying universal feature engineering for HI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HI...

==================================================
Training Enhanced HI (SVM)
==================================================
Training SVM model...

Enhanced HI Performance:
MAE: 184579.7254
RMSE: 225844.8710
MAPE: 9.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0024, rank=1
   2. Feature_2_t2: importance=0.0017, rank=2
   3. Feature_20_t3: importance=0.0016, rank=3
   4. Feature_2_t3: importance=0.0016, rank=4
   5. Feature_9_t3: importance=0.0012, rank=5

📊 HI Results:
  Baseline MAPE: 9.71%
  Enhanced MAPE: 9.92%
  MAPE Improvement: -0.20% (-2.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 195/464: HIW
============================================================
📊 Loading data for HIW...
📊 Loading data for HIW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HIW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HIW...

==================================================
Training Baseline HIW (SVM)
==================================================
Training SVM model...

Baseline HIW Performance:
MAE: 753974.0456
RMSE: 977352.3677
MAPE: 14.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 243
   • Highly important features (top 5%): 119

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t2: importance=0.0011, rank=1
   2. Feature_93_t1: importance=0.0008, rank=2
   3. Feature_72_t1: importance=0.0008, rank=3
   4. Feature_84_t2: importance=0.0006, rank=4
   5. Feature_91_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for HIW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HIW...

==================================================
Training Enhanced HIW (SVM)
==================================================
Training SVM model...

Enhanced HIW Performance:
MAE: 788702.1689
RMSE: 1014229.4546
MAPE: 15.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t3: importance=0.0018, rank=1
   2. Feature_14_t1: importance=0.0015, rank=2
   3. Feature_11_t1: importance=0.0014, rank=3
   4. Feature_15_t1: importance=0.0014, rank=4
   5. Feature_4_t0: importance=0.0013, rank=5

📊 HIW Results:
  Baseline MAPE: 14.77%
  Enhanced MAPE: 15.60%
  MAPE Improvement: -0.83% (-5.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 196/464: HL
============================================================
📊 Loading data for HL...
📊 Loading data for HL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HL...

==================================================
Training Baseline HL (SVM)
==================================================
Training SVM model...

Baseline HL Performance:
MAE: 2353785.5622
RMSE: 2830303.8659
MAPE: 11.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 116
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t0: importance=0.0008, rank=1
   2. Feature_65_t2: importance=0.0005, rank=2
   3. Feature_76_t1: importance=0.0004, rank=3
   4. Feature_95_t3: importance=0.0003, rank=4
   5. Feature_71_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for HL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HL...

==================================================
Training Enhanced HL (SVM)
==================================================
Training SVM model...

Enhanced HL Performance:
MAE: 2517019.9563
RMSE: 3060671.6753
MAPE: 12.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0006, rank=1
   2. Feature_17_t1: importance=0.0005, rank=2
   3. Feature_12_t0: importance=0.0005, rank=3
   4. Feature_11_t3: importance=0.0005, rank=4
   5. Feature_5_t2: importance=0.0005, rank=5

📊 HL Results:
  Baseline MAPE: 11.80%
  Enhanced MAPE: 12.32%
  MAPE Improvement: -0.52% (-4.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 197/464: HLIT
============================================================
📊 Loading data for HLIT...
📊 Loading data for HLIT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HLIT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HLIT...

==================================================
Training Baseline HLIT (SVM)
==================================================
Training SVM model...

Baseline HLIT Performance:
MAE: 496337.2135
RMSE: 680578.0265
MAPE: 11.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 170
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0002, rank=1
   2. Feature_2_t3: importance=0.0001, rank=2
   3. Feature_65_t1: importance=0.0001, rank=3
   4. Feature_73_t0: importance=0.0001, rank=4
   5. Feature_75_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HLIT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HLIT...

==================================================
Training Enhanced HLIT (SVM)
==================================================
Training SVM model...

Enhanced HLIT Performance:
MAE: 428387.2273
RMSE: 604562.2400
MAPE: 9.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t1: importance=0.0001, rank=1
   2. Feature_20_t3: importance=0.0001, rank=2
   3. Feature_19_t3: importance=0.0001, rank=3
   4. Feature_19_t2: importance=0.0001, rank=4
   5. Feature_12_t0: importance=0.0001, rank=5

📊 HLIT Results:
  Baseline MAPE: 11.30%
  Enhanced MAPE: 9.54%
  MAPE Improvement: +1.76% (+15.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 198/464: HLX
============================================================
📊 Loading data for HLX...
📊 Loading data for HLX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HLX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HLX...

==================================================
Training Baseline HLX (SVM)
==================================================
Training SVM model...

Baseline HLX Performance:
MAE: 661508.4500
RMSE: 787236.8069
MAPE: 12.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 189
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0007, rank=1
   2. Feature_74_t3: importance=0.0003, rank=2
   3. Feature_68_t3: importance=0.0002, rank=3
   4. Feature_89_t1: importance=0.0002, rank=4
   5. Feature_0_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HLX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HLX...

==================================================
Training Enhanced HLX (SVM)
==================================================
Training SVM model...

Enhanced HLX Performance:
MAE: 602059.0806
RMSE: 779260.9499
MAPE: 11.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 45

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t1: importance=0.0007, rank=1
   2. Feature_13_t2: importance=0.0005, rank=2
   3. Feature_17_t1: importance=0.0003, rank=3
   4. Feature_16_t1: importance=0.0003, rank=4
   5. Feature_5_t2: importance=0.0002, rank=5

📊 HLX Results:
  Baseline MAPE: 12.58%
  Enhanced MAPE: 11.01%
  MAPE Improvement: +1.57% (+12.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 199/464: HMN
============================================================
📊 Loading data for HMN...
📊 Loading data for HMN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HMN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HMN...

==================================================
Training Baseline HMN (SVM)
==================================================
Training SVM model...

Baseline HMN Performance:
MAE: 95799.1083
RMSE: 119012.5424
MAPE: 15.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 333
   • Highly important features (top 5%): 180

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0006, rank=1
   2. Feature_2_t3: importance=0.0006, rank=2
   3. Feature_63_t2: importance=0.0005, rank=3
   4. Feature_63_t1: importance=0.0005, rank=4
   5. Feature_71_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for HMN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HMN...

==================================================
Training Enhanced HMN (SVM)
==================================================
Training SVM model...

Enhanced HMN Performance:
MAE: 96810.0459
RMSE: 119713.9914
MAPE: 15.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0021, rank=1
   2. Feature_22_t1: importance=0.0011, rank=2
   3. Feature_7_t3: importance=0.0010, rank=3
   4. Feature_20_t3: importance=0.0010, rank=4
   5. Feature_16_t3: importance=0.0008, rank=5

📊 HMN Results:
  Baseline MAPE: 15.10%
  Enhanced MAPE: 15.19%
  MAPE Improvement: -0.09% (-0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 200/464: HNI
============================================================
📊 Loading data for HNI...
📊 Loading data for HNI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HNI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HNI...

==================================================
Training Baseline HNI (SVM)
==================================================
Training SVM model...

Baseline HNI Performance:
MAE: 91598.0832
RMSE: 142941.6337
MAPE: 11.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 307
   • Highly important features (top 5%): 170

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t2: importance=0.0004, rank=1
   2. Feature_89_t1: importance=0.0002, rank=2
   3. Feature_70_t3: importance=0.0002, rank=3
   4. Feature_95_t2: importance=0.0002, rank=4
   5. Feature_94_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for HNI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HNI...

==================================================
Training Enhanced HNI (SVM)
==================================================
Training SVM model...

Enhanced HNI Performance:
MAE: 93226.2185
RMSE: 146750.9254
MAPE: 11.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t1: importance=0.0006, rank=1
   2. Feature_13_t2: importance=0.0005, rank=2
   3. Feature_15_t1: importance=0.0005, rank=3
   4. Feature_10_t1: importance=0.0005, rank=4
   5. Feature_1_t3: importance=0.0004, rank=5

📊 HNI Results:
  Baseline MAPE: 11.01%
  Enhanced MAPE: 11.18%
  MAPE Improvement: -0.17% (-1.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 201/464: HOPE
============================================================
📊 Loading data for HOPE...
📊 Loading data for HOPE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HOPE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HOPE...

==================================================
Training Baseline HOPE (SVM)
==================================================
Training SVM model...

Baseline HOPE Performance:
MAE: 300260.1804
RMSE: 390047.5549
MAPE: 12.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 313
   • Highly important features (top 5%): 156

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0003, rank=1
   2. Feature_65_t0: importance=0.0003, rank=2
   3. Feature_65_t2: importance=0.0003, rank=3
   4. Feature_70_t2: importance=0.0003, rank=4
   5. Feature_84_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for HOPE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HOPE...

==================================================
Training Enhanced HOPE (SVM)
==================================================
Training SVM model...

Enhanced HOPE Performance:
MAE: 309798.7635
RMSE: 401790.9469
MAPE: 13.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t2: importance=0.0005, rank=1
   2. Feature_5_t1: importance=0.0005, rank=2
   3. Feature_18_t1: importance=0.0004, rank=3
   4. Feature_5_t0: importance=0.0004, rank=4
   5. Feature_11_t2: importance=0.0004, rank=5

📊 HOPE Results:
  Baseline MAPE: 12.89%
  Enhanced MAPE: 13.28%
  MAPE Improvement: -0.39% (-3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 202/464: HP
============================================================
📊 Loading data for HP...
📊 Loading data for HP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HP...

==================================================
Training Baseline HP (SVM)
==================================================
Training SVM model...

Baseline HP Performance:
MAE: 755520.5487
RMSE: 860802.1848
MAPE: 7.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 309
   • Highly important features (top 5%): 186

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t3: importance=0.0004, rank=1
   2. Feature_80_t3: importance=0.0003, rank=2
   3. Feature_81_t3: importance=0.0002, rank=3
   4. Feature_91_t2: importance=0.0002, rank=4
   5. Feature_91_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for HP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HP...

==================================================
Training Enhanced HP (SVM)
==================================================
Training SVM model...

Enhanced HP Performance:
MAE: 726078.7489
RMSE: 828854.2465
MAPE: 6.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0006, rank=1
   2. Feature_20_t3: importance=0.0005, rank=2
   3. Feature_19_t0: importance=0.0005, rank=3
   4. Feature_12_t1: importance=0.0003, rank=4
   5. Feature_1_t0: importance=0.0002, rank=5

📊 HP Results:
  Baseline MAPE: 7.13%
  Enhanced MAPE: 6.87%
  MAPE Improvement: +0.25% (+3.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 203/464: HSII
============================================================
📊 Loading data for HSII...
📊 Loading data for HSII from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HSII...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HSII...

==================================================
Training Baseline HSII (SVM)
==================================================
Training SVM model...

Baseline HSII Performance:
MAE: 64081.1806
RMSE: 80382.9944
MAPE: 15.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 223
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0028, rank=1
   2. Feature_63_t2: importance=0.0024, rank=2
   3. Feature_63_t3: importance=0.0019, rank=3
   4. Feature_2_t3: importance=0.0015, rank=4
   5. Feature_96_t3: importance=0.0013, rank=5

🔧 Applying universal feature engineering for HSII...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HSII...

==================================================
Training Enhanced HSII (SVM)
==================================================
Training SVM model...

Enhanced HSII Performance:
MAE: 54232.8898
RMSE: 65504.7003
MAPE: 13.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t0: importance=0.0040, rank=1
   2. Feature_4_t2: importance=0.0032, rank=2
   3. Feature_16_t2: importance=0.0030, rank=3
   4. Feature_7_t2: importance=0.0029, rank=4
   5. Feature_8_t3: importance=0.0021, rank=5

📊 HSII Results:
  Baseline MAPE: 15.90%
  Enhanced MAPE: 13.61%
  MAPE Improvement: +2.29% (+14.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 204/464: HSTM
============================================================
📊 Loading data for HSTM...
📊 Loading data for HSTM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HSTM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HSTM...

==================================================
Training Baseline HSTM (SVM)
==================================================
Training SVM model...

Baseline HSTM Performance:
MAE: 50557.4958
RMSE: 67391.8131
MAPE: 11.35%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 179
   • Highly important features (top 5%): 99

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t1: importance=0.0009, rank=1
   2. Feature_1_t1: importance=0.0007, rank=2
   3. Feature_78_t3: importance=0.0007, rank=3
   4. Feature_86_t1: importance=0.0006, rank=4
   5. Feature_71_t0: importance=0.0006, rank=5

🔧 Applying universal feature engineering for HSTM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HSTM...

==================================================
Training Enhanced HSTM (SVM)
==================================================
Training SVM model...

Enhanced HSTM Performance:
MAE: 71519.6673
RMSE: 84368.5561
MAPE: 14.97%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 72
   • Highly important features (top 5%): 51

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0036, rank=1
   2. Feature_7_t0: importance=0.0018, rank=2
   3. Feature_13_t2: importance=0.0014, rank=3
   4. Feature_12_t0: importance=0.0013, rank=4
   5. Feature_13_t3: importance=0.0012, rank=5

📊 HSTM Results:
  Baseline MAPE: 11.35%
  Enhanced MAPE: 14.97%
  MAPE Improvement: -3.61% (-31.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 205/464: HTH
============================================================
📊 Loading data for HTH...
📊 Loading data for HTH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HTH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HTH...

==================================================
Training Baseline HTH (SVM)
==================================================
Training SVM model...

Baseline HTH Performance:
MAE: 134199.5678
RMSE: 174766.4854
MAPE: 11.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 179
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t2: importance=0.0024, rank=1
   2. Feature_89_t3: importance=0.0018, rank=2
   3. Feature_77_t3: importance=0.0018, rank=3
   4. Feature_90_t3: importance=0.0016, rank=4
   5. Feature_70_t2: importance=0.0014, rank=5

🔧 Applying universal feature engineering for HTH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HTH...

==================================================
Training Enhanced HTH (SVM)
==================================================
Training SVM model...

Enhanced HTH Performance:
MAE: 169618.1489
RMSE: 205118.4868
MAPE: 16.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t2: importance=0.0035, rank=1
   2. Feature_7_t2: importance=0.0032, rank=2
   3. Feature_11_t3: importance=0.0026, rank=3
   4. Feature_13_t1: importance=0.0026, rank=4
   5. Feature_16_t2: importance=0.0022, rank=5

📊 HTH Results:
  Baseline MAPE: 11.51%
  Enhanced MAPE: 16.14%
  MAPE Improvement: -4.63% (-40.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 206/464: HTLD
============================================================
📊 Loading data for HTLD...
📊 Loading data for HTLD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HTLD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HTLD...

==================================================
Training Baseline HTLD (SVM)
==================================================
Training SVM model...

Baseline HTLD Performance:
MAE: 135196.9984
RMSE: 184149.2693
MAPE: 9.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 63
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0052, rank=1
   2. Feature_78_t0: importance=0.0011, rank=2
   3. Feature_75_t2: importance=0.0009, rank=3
   4. Feature_73_t3: importance=0.0007, rank=4
   5. Feature_75_t3: importance=0.0007, rank=5

🔧 Applying universal feature engineering for HTLD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HTLD...

==================================================
Training Enhanced HTLD (SVM)
==================================================
Training SVM model...

Enhanced HTLD Performance:
MAE: 154789.6276
RMSE: 201133.4567
MAPE: 10.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0054, rank=1
   2. Feature_11_t0: importance=0.0026, rank=2
   3. Feature_9_t3: importance=0.0024, rank=3
   4. Feature_16_t2: importance=0.0017, rank=4
   5. Feature_5_t0: importance=0.0016, rank=5

📊 HTLD Results:
  Baseline MAPE: 9.59%
  Enhanced MAPE: 10.77%
  MAPE Improvement: -1.18% (-12.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 207/464: HUBG
============================================================
📊 Loading data for HUBG...
📊 Loading data for HUBG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HUBG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HUBG...

==================================================
Training Baseline HUBG (SVM)
==================================================
Training SVM model...

Baseline HUBG Performance:
MAE: 208054.2635
RMSE: 262332.9354
MAPE: 23.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 323
   • Highly important features (top 5%): 173

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t3: importance=0.0007, rank=1
   2. Feature_80_t0: importance=0.0006, rank=2
   3. Feature_68_t1: importance=0.0006, rank=3
   4. Feature_63_t3: importance=0.0006, rank=4
   5. Feature_81_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for HUBG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HUBG...

==================================================
Training Enhanced HUBG (SVM)
==================================================
Training SVM model...

Enhanced HUBG Performance:
MAE: 207637.7369
RMSE: 261374.1454
MAPE: 23.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0018, rank=1
   2. Feature_7_t0: importance=0.0011, rank=2
   3. Feature_5_t3: importance=0.0010, rank=3
   4. Feature_13_t1: importance=0.0010, rank=4
   5. Feature_20_t3: importance=0.0010, rank=5

📊 HUBG Results:
  Baseline MAPE: 23.65%
  Enhanced MAPE: 23.31%
  MAPE Improvement: +0.34% (+1.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 208/464: HWKN
============================================================
📊 Loading data for HWKN...
📊 Loading data for HWKN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HWKN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HWKN...

==================================================
Training Baseline HWKN (SVM)
==================================================
Training SVM model...

Baseline HWKN Performance:
MAE: 102932.0033
RMSE: 146477.9325
MAPE: 18.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 259
   • Highly important features (top 5%): 163

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0023, rank=1
   2. Feature_86_t1: importance=0.0012, rank=2
   3. Feature_63_t3: importance=0.0011, rank=3
   4. Feature_88_t1: importance=0.0009, rank=4
   5. Feature_63_t2: importance=0.0008, rank=5

🔧 Applying universal feature engineering for HWKN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HWKN...

==================================================
Training Enhanced HWKN (SVM)
==================================================
Training SVM model...

Enhanced HWKN Performance:
MAE: 104247.4819
RMSE: 143266.2255
MAPE: 18.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t1: importance=0.0041, rank=1
   2. Feature_7_t1: importance=0.0037, rank=2
   3. Feature_16_t2: importance=0.0026, rank=3
   4. Feature_13_t2: importance=0.0024, rank=4
   5. Feature_15_t3: importance=0.0023, rank=5

📊 HWKN Results:
  Baseline MAPE: 18.51%
  Enhanced MAPE: 18.41%
  MAPE Improvement: +0.10% (+0.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 209/464: HZO
============================================================
📊 Loading data for HZO...
📊 Loading data for HZO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for HZO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for HZO...

==================================================
Training Baseline HZO (SVM)
==================================================
Training SVM model...

Baseline HZO Performance:
MAE: 159232.5466
RMSE: 203315.0286
MAPE: 6.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 146
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0003, rank=1
   2. Feature_87_t0: importance=0.0001, rank=2
   3. Feature_2_t3: importance=0.0001, rank=3
   4. Feature_2_t1: importance=0.0001, rank=4
   5. Feature_65_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for HZO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for HZO...

==================================================
Training Enhanced HZO (SVM)
==================================================
Training SVM model...

Enhanced HZO Performance:
MAE: 146451.9023
RMSE: 191686.8602
MAPE: 6.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0004, rank=1
   2. Feature_16_t3: importance=0.0004, rank=2
   3. Feature_23_t2: importance=0.0002, rank=3
   4. Feature_11_t2: importance=0.0002, rank=4
   5. Feature_20_t2: importance=0.0002, rank=5

📊 HZO Results:
  Baseline MAPE: 6.80%
  Enhanced MAPE: 6.30%
  MAPE Improvement: +0.50% (+7.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 210/464: IAC
============================================================
📊 Loading data for IAC...
📊 Loading data for IAC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing IAC: 'IAC'

============================================================
TESTING TICKER 211/464: IART
============================================================
📊 Loading data for IART...
📊 Loading data for IART from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IART...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for IART...

==================================================
Training Baseline IART (SVM)
==================================================
Training SVM model...

Baseline IART Performance:
MAE: 433260.6397
RMSE: 572048.8168
MAPE: 10.76%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 166
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0005, rank=1
   2. Feature_92_t3: importance=0.0004, rank=2
   3. Feature_70_t2: importance=0.0003, rank=3
   4. Feature_94_t1: importance=0.0002, rank=4
   5. Feature_87_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for IART...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for IART...

==================================================
Training Enhanced IART (SVM)
==================================================
Training SVM model...

Enhanced IART Performance:
MAE: 400460.4019
RMSE: 538027.9925
MAPE: 10.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0009, rank=1
   2. Feature_20_t1: importance=0.0005, rank=2
   3. Feature_13_t1: importance=0.0003, rank=3
   4. Feature_23_t3: importance=0.0003, rank=4
   5. Feature_12_t3: importance=0.0003, rank=5

📊 IART Results:
  Baseline MAPE: 10.76%
  Enhanced MAPE: 10.29%
  MAPE Improvement: +0.47% (+4.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 212/464: IBP
============================================================
📊 Loading data for IBP...
📊 Loading data for IBP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IBP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for IBP...

==================================================
Training Baseline IBP (SVM)
==================================================
Training SVM model...

Baseline IBP Performance:
MAE: 130360.2847
RMSE: 173453.2359
MAPE: 8.20%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 297
   • Highly important features (top 5%): 189

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0008, rank=1
   2. Feature_84_t1: importance=0.0003, rank=2
   3. Feature_89_t2: importance=0.0003, rank=3
   4. Feature_75_t3: importance=0.0003, rank=4
   5. Feature_83_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for IBP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for IBP...

==================================================
Training Enhanced IBP (SVM)
==================================================
Training SVM model...

Enhanced IBP Performance:
MAE: 144486.2120
RMSE: 187466.7296
MAPE: 8.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0013, rank=1
   2. Feature_13_t3: importance=0.0008, rank=2
   3. Feature_8_t3: importance=0.0005, rank=3
   4. Feature_14_t2: importance=0.0005, rank=4
   5. Feature_11_t0: importance=0.0004, rank=5

📊 IBP Results:
  Baseline MAPE: 8.20%
  Enhanced MAPE: 8.74%
  MAPE Improvement: -0.55% (-6.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 213/464: ICHR
============================================================
📊 Loading data for ICHR...
📊 Loading data for ICHR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ICHR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ICHR...

==================================================
Training Baseline ICHR (SVM)
==================================================
Training SVM model...

Baseline ICHR Performance:
MAE: 96423.9588
RMSE: 136122.0121
MAPE: 11.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 227
   • Highly important features (top 5%): 136

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0002, rank=1
   2. Feature_65_t1: importance=0.0002, rank=2
   3. Feature_64_t3: importance=0.0002, rank=3
   4. Feature_65_t2: importance=0.0002, rank=4
   5. Feature_70_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ICHR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ICHR...

==================================================
Training Enhanced ICHR (SVM)
==================================================
Training SVM model...

Enhanced ICHR Performance:
MAE: 96449.1319
RMSE: 124642.2458
MAPE: 10.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0005, rank=1
   2. Feature_16_t3: importance=0.0004, rank=2
   3. Feature_20_t0: importance=0.0003, rank=3
   4. Feature_16_t1: importance=0.0003, rank=4
   5. Feature_19_t3: importance=0.0003, rank=5

📊 ICHR Results:
  Baseline MAPE: 11.01%
  Enhanced MAPE: 10.78%
  MAPE Improvement: +0.23% (+2.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 214/464: ICUI
============================================================
📊 Loading data for ICUI...
📊 Loading data for ICUI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ICUI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ICUI...

==================================================
Training Baseline ICUI (SVM)
==================================================
Training SVM model...

Baseline ICUI Performance:
MAE: 94529.9190
RMSE: 125377.2455
MAPE: 9.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 273
   • Highly important features (top 5%): 155

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t1: importance=0.0003, rank=1
   2. Feature_89_t1: importance=0.0002, rank=2
   3. Feature_96_t3: importance=0.0002, rank=3
   4. Feature_73_t1: importance=0.0002, rank=4
   5. Feature_67_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ICUI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ICUI...

==================================================
Training Enhanced ICUI (SVM)
==================================================
Training SVM model...

Enhanced ICUI Performance:
MAE: 96231.7555
RMSE: 127385.5748
MAPE: 9.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0007, rank=1
   2. Feature_19_t3: importance=0.0004, rank=2
   3. Feature_17_t1: importance=0.0004, rank=3
   4. Feature_12_t2: importance=0.0004, rank=4
   5. Feature_11_t0: importance=0.0003, rank=5

📊 ICUI Results:
  Baseline MAPE: 9.37%
  Enhanced MAPE: 9.74%
  MAPE Improvement: -0.38% (-4.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 215/464: IDCC
============================================================
📊 Loading data for IDCC...
📊 Loading data for IDCC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IDCC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for IDCC...

==================================================
Training Baseline IDCC (SVM)
==================================================
Training SVM model...

Baseline IDCC Performance:
MAE: 189837.0985
RMSE: 267132.5604
MAPE: 5.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 173
   • Highly important features (top 5%): 104

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0003, rank=1
   2. Feature_65_t3: importance=0.0002, rank=2
   3. Feature_69_t1: importance=0.0002, rank=3
   4. Feature_73_t3: importance=0.0002, rank=4
   5. Feature_74_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for IDCC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for IDCC...

==================================================
Training Enhanced IDCC (SVM)
==================================================
Training SVM model...

Enhanced IDCC Performance:
MAE: 208879.8544
RMSE: 283364.8476
MAPE: 5.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 72
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0010, rank=1
   2. Feature_5_t3: importance=0.0005, rank=2
   3. Feature_13_t2: importance=0.0004, rank=3
   4. Feature_7_t2: importance=0.0004, rank=4
   5. Feature_16_t1: importance=0.0004, rank=5

📊 IDCC Results:
  Baseline MAPE: 5.41%
  Enhanced MAPE: 5.96%
  MAPE Improvement: -0.54% (-10.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 216/464: IIIN
============================================================
📊 Loading data for IIIN...
📊 Loading data for IIIN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IIIN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for IIIN...

==================================================
Training Baseline IIIN (SVM)
==================================================
Training SVM model...

Baseline IIIN Performance:
MAE: 69103.6069
RMSE: 86826.7392
MAPE: 13.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 297
   • Highly important features (top 5%): 151

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t3: importance=0.0007, rank=1
   2. Feature_0_t3: importance=0.0005, rank=2
   3. Feature_65_t2: importance=0.0005, rank=3
   4. Feature_73_t3: importance=0.0004, rank=4
   5. Feature_2_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for IIIN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for IIIN...

==================================================
Training Enhanced IIIN (SVM)
==================================================
Training SVM model...

Enhanced IIIN Performance:
MAE: 68439.5200
RMSE: 86364.7345
MAPE: 13.73%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t2: importance=0.0011, rank=1
   2. Feature_5_t0: importance=0.0010, rank=2
   3. Feature_12_t3: importance=0.0008, rank=3
   4. Feature_21_t1: importance=0.0008, rank=4
   5. Feature_12_t0: importance=0.0007, rank=5

📊 IIIN Results:
  Baseline MAPE: 13.11%
  Enhanced MAPE: 13.73%
  MAPE Improvement: -0.62% (-4.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 217/464: IIPR
============================================================
📊 Loading data for IIPR...
📊 Loading data for IIPR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing IIPR: 'IIPR'

============================================================
TESTING TICKER 218/464: INDB
============================================================
📊 Loading data for INDB...
📊 Loading data for INDB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for INDB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for INDB...

==================================================
Training Baseline INDB (SVM)
==================================================
Training SVM model...

Baseline INDB Performance:
MAE: 123275.4826
RMSE: 156807.1337
MAPE: 13.04%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 182
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t3: importance=0.0004, rank=1
   2. Feature_71_t3: importance=0.0003, rank=2
   3. Feature_72_t3: importance=0.0003, rank=3
   4. Feature_1_t3: importance=0.0003, rank=4
   5. Feature_80_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for INDB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for INDB...

==================================================
Training Enhanced INDB (SVM)
==================================================
Training SVM model...

Enhanced INDB Performance:
MAE: 141728.0855
RMSE: 174076.6255
MAPE: 14.33%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 32

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0009, rank=1
   2. Feature_7_t0: importance=0.0007, rank=2
   3. Feature_1_t0: importance=0.0006, rank=3
   4. Feature_11_t2: importance=0.0003, rank=4
   5. Feature_13_t0: importance=0.0003, rank=5

📊 INDB Results:
  Baseline MAPE: 13.04%
  Enhanced MAPE: 14.33%
  MAPE Improvement: -1.29% (-9.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 219/464: INN
============================================================
📊 Loading data for INN...
📊 Loading data for INN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for INN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for INN...

==================================================
Training Baseline INN (SVM)
==================================================
Training SVM model...

Baseline INN Performance:
MAE: 755059.5011
RMSE: 970082.1617
MAPE: 16.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 120
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0010, rank=1
   2. Feature_74_t0: importance=0.0004, rank=2
   3. Feature_83_t0: importance=0.0004, rank=3
   4. Feature_83_t3: importance=0.0003, rank=4
   5. Feature_94_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for INN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for INN...

==================================================
Training Enhanced INN (SVM)
==================================================
Training SVM model...

Enhanced INN Performance:
MAE: 684471.6494
RMSE: 883080.6007
MAPE: 14.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 64
   • Highly important features (top 5%): 34

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t0: importance=0.0013, rank=1
   2. Feature_8_t0: importance=0.0011, rank=2
   3. Feature_17_t0: importance=0.0008, rank=3
   4. Feature_18_t1: importance=0.0007, rank=4
   5. Feature_22_t0: importance=0.0007, rank=5

📊 INN Results:
  Baseline MAPE: 16.30%
  Enhanced MAPE: 14.44%
  MAPE Improvement: +1.86% (+11.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 220/464: INSW
============================================================
📊 Loading data for INSW...
📊 Loading data for INSW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing INSW: 'INSW'

============================================================
TESTING TICKER 221/464: INVA
============================================================
📊 Loading data for INVA...
📊 Loading data for INVA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for INVA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'INVA' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for INVA...

==================================================
Training Baseline INVA (SVM)
==================================================
Training SVM model...

Baseline INVA Performance:
MAE: 396437.7967
RMSE: 550444.3035
MAPE: 3.76%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 32
   • Highly important features (top 5%): 24

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0001, rank=1
   2. Feature_66_t1: importance=0.0000, rank=2
   3. Feature_65_t2: importance=0.0000, rank=3
   4. Feature_64_t3: importance=0.0000, rank=4
   5. Feature_0_t1: importance=0.0000, rank=5

🔧 Applying universal feature engineering for INVA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for INVA...

==================================================
Training Enhanced INVA (SVM)
==================================================
Training SVM model...

Enhanced INVA Performance:
MAE: 413944.3725
RMSE: 566488.0695
MAPE: 3.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 45
   • Highly important features (top 5%): 25

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t0: importance=0.0001, rank=1
   2. Feature_16_t0: importance=0.0001, rank=2
   3. Feature_19_t2: importance=0.0001, rank=3
   4. Feature_22_t0: importance=0.0000, rank=4
   5. Feature_10_t3: importance=0.0000, rank=5

📊 INVA Results:
  Baseline MAPE: 3.76%
  Enhanced MAPE: 3.93%
  MAPE Improvement: -0.17% (-4.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 222/464: IOSP
============================================================
📊 Loading data for IOSP...
📊 Loading data for IOSP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IOSP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for IOSP...

==================================================
Training Baseline IOSP (SVM)
==================================================
Training SVM model...

Baseline IOSP Performance:
MAE: 47384.4607
RMSE: 63736.7816
MAPE: 16.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 345
   • Highly important features (top 5%): 194

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0014, rank=1
   2. Feature_69_t3: importance=0.0008, rank=2
   3. Feature_2_t3: importance=0.0007, rank=3
   4. Feature_82_t0: importance=0.0004, rank=4
   5. Feature_0_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for IOSP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for IOSP...

==================================================
Training Enhanced IOSP (SVM)
==================================================
Training SVM model...

Enhanced IOSP Performance:
MAE: 46802.7776
RMSE: 61503.7464
MAPE: 16.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0020, rank=1
   2. Feature_16_t3: importance=0.0018, rank=2
   3. Feature_5_t3: importance=0.0013, rank=3
   4. Feature_7_t3: importance=0.0012, rank=4
   5. Feature_7_t0: importance=0.0010, rank=5

📊 IOSP Results:
  Baseline MAPE: 16.68%
  Enhanced MAPE: 16.79%
  MAPE Improvement: -0.11% (-0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 223/464: IPAR
============================================================
📊 Loading data for IPAR...
📊 Loading data for IPAR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for IPAR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for IPAR...

==================================================
Training Baseline IPAR (SVM)
==================================================
Training SVM model...

Baseline IPAR Performance:
MAE: 64125.0359
RMSE: 88226.7626
MAPE: 9.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 284
   • Highly important features (top 5%): 151

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0012, rank=1
   2. Feature_0_t3: importance=0.0011, rank=2
   3. Feature_76_t2: importance=0.0006, rank=3
   4. Feature_75_t2: importance=0.0005, rank=4
   5. Feature_76_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for IPAR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for IPAR...

==================================================
Training Enhanced IPAR (SVM)
==================================================
Training SVM model...

Enhanced IPAR Performance:
MAE: 67950.7535
RMSE: 89521.7167
MAPE: 9.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 94

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0010, rank=1
   2. Feature_0_t3: importance=0.0010, rank=2
   3. Feature_24_t2: importance=0.0009, rank=3
   4. Feature_5_t3: importance=0.0009, rank=4
   5. Feature_23_t2: importance=0.0008, rank=5

📊 IPAR Results:
  Baseline MAPE: 9.24%
  Enhanced MAPE: 9.80%
  MAPE Improvement: -0.56% (-6.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 224/464: ITGR
============================================================
📊 Loading data for ITGR...
📊 Loading data for ITGR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ITGR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ITGR...

==================================================
Training Baseline ITGR (SVM)
==================================================
Training SVM model...

Baseline ITGR Performance:
MAE: 182955.7762
RMSE: 226931.3466
MAPE: 7.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 191
   • Highly important features (top 5%): 109

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t2: importance=0.0005, rank=1
   2. Feature_81_t1: importance=0.0004, rank=2
   3. Feature_66_t1: importance=0.0004, rank=3
   4. Feature_83_t0: importance=0.0004, rank=4
   5. Feature_1_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for ITGR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ITGR...

==================================================
Training Enhanced ITGR (SVM)
==================================================
Training SVM model...

Enhanced ITGR Performance:
MAE: 191327.3844
RMSE: 240032.8003
MAPE: 7.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 49
   • Highly important features (top 5%): 36

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t1: importance=0.0026, rank=1
   2. Feature_22_t0: importance=0.0012, rank=2
   3. Feature_11_t1: importance=0.0010, rank=3
   4. Feature_19_t2: importance=0.0009, rank=4
   5. Feature_24_t1: importance=0.0008, rank=5

📊 ITGR Results:
  Baseline MAPE: 7.29%
  Enhanced MAPE: 7.68%
  MAPE Improvement: -0.39% (-5.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 225/464: ITRI
============================================================
📊 Loading data for ITRI...
📊 Loading data for ITRI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ITRI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ITRI...

==================================================
Training Baseline ITRI (SVM)
==================================================
Training SVM model...

Baseline ITRI Performance:
MAE: 215928.0718
RMSE: 268705.8866
MAPE: 7.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 249
   • Highly important features (top 5%): 114

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_86_t1: importance=0.0004, rank=1
   2. Feature_85_t1: importance=0.0003, rank=2
   3. Feature_96_t2: importance=0.0003, rank=3
   4. Feature_74_t3: importance=0.0002, rank=4
   5. Feature_81_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for ITRI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ITRI...

==================================================
Training Enhanced ITRI (SVM)
==================================================
Training SVM model...

Enhanced ITRI Performance:
MAE: 227644.2132
RMSE: 288263.5351
MAPE: 8.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0008, rank=1
   2. Feature_15_t2: importance=0.0006, rank=2
   3. Feature_13_t0: importance=0.0005, rank=3
   4. Feature_19_t2: importance=0.0004, rank=4
   5. Feature_15_t3: importance=0.0004, rank=5

📊 ITRI Results:
  Baseline MAPE: 7.91%
  Enhanced MAPE: 8.31%
  MAPE Improvement: -0.41% (-5.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 226/464: JBGS
============================================================
📊 Loading data for JBGS...
📊 Loading data for JBGS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing JBGS: 'JBGS'

============================================================
TESTING TICKER 227/464: JBLU
============================================================
📊 Loading data for JBLU...
📊 Loading data for JBLU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for JBLU...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for JBLU...

==================================================
Training Baseline JBLU (SVM)
==================================================
Training SVM model...

Baseline JBLU Performance:
MAE: 6519378.0122
RMSE: 7803241.6863
MAPE: 12.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 186
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0008, rank=1
   2. Feature_0_t3: importance=0.0007, rank=2
   3. Feature_2_t2: importance=0.0005, rank=3
   4. Feature_83_t3: importance=0.0004, rank=4
   5. Feature_2_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for JBLU...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for JBLU...

==================================================
Training Enhanced JBLU (SVM)
==================================================
Training SVM model...

Enhanced JBLU Performance:
MAE: 4662527.8828
RMSE: 6364242.2535
MAPE: 8.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0013, rank=1
   2. Feature_24_t1: importance=0.0011, rank=2
   3. Feature_15_t3: importance=0.0009, rank=3
   4. Feature_22_t3: importance=0.0007, rank=4
   5. Feature_15_t2: importance=0.0007, rank=5

📊 JBLU Results:
  Baseline MAPE: 12.15%
  Enhanced MAPE: 8.62%
  MAPE Improvement: +3.53% (+29.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 228/464: JBSS
============================================================
📊 Loading data for JBSS...
📊 Loading data for JBSS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for JBSS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for JBSS...

==================================================
Training Baseline JBSS (SVM)
==================================================
Training SVM model...

Baseline JBSS Performance:
MAE: 24773.8955
RMSE: 40118.6557
MAPE: 14.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 171
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t1: importance=0.0011, rank=1
   2. Feature_63_t1: importance=0.0008, rank=2
   3. Feature_63_t0: importance=0.0005, rank=3
   4. Feature_90_t1: importance=0.0005, rank=4
   5. Feature_79_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for JBSS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for JBSS...

==================================================
Training Enhanced JBSS (SVM)
==================================================
Training SVM model...

Enhanced JBSS Performance:
MAE: 26419.2111
RMSE: 42076.1195
MAPE: 15.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0016, rank=1
   2. Feature_15_t3: importance=0.0009, rank=2
   3. Feature_23_t1: importance=0.0008, rank=3
   4. Feature_5_t3: importance=0.0007, rank=4
   5. Feature_20_t1: importance=0.0007, rank=5

📊 JBSS Results:
  Baseline MAPE: 14.78%
  Enhanced MAPE: 15.32%
  MAPE Improvement: -0.55% (-3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 229/464: JJSF
============================================================
📊 Loading data for JJSF...
📊 Loading data for JJSF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing JJSF: 'JJSF'

============================================================
TESTING TICKER 230/464: JOE
============================================================
📊 Loading data for JOE...
📊 Loading data for JOE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for JOE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for JOE...

==================================================
Training Baseline JOE (SVM)
==================================================
Training SVM model...

Baseline JOE Performance:
MAE: 60029.5307
RMSE: 75761.0114
MAPE: 8.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 132
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0003, rank=1
   2. Feature_90_t1: importance=0.0003, rank=2
   3. Feature_76_t1: importance=0.0002, rank=3
   4. Feature_63_t1: importance=0.0002, rank=4
   5. Feature_67_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for JOE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for JOE...

==================================================
Training Enhanced JOE (SVM)
==================================================
Training SVM model...

Enhanced JOE Performance:
MAE: 62419.3790
RMSE: 79291.6310
MAPE: 9.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0009, rank=1
   2. Feature_7_t1: importance=0.0006, rank=2
   3. Feature_5_t3: importance=0.0005, rank=3
   4. Feature_19_t2: importance=0.0005, rank=4
   5. Feature_15_t1: importance=0.0003, rank=5

📊 JOE Results:
  Baseline MAPE: 8.79%
  Enhanced MAPE: 9.23%
  MAPE Improvement: -0.44% (-5.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 231/464: KAI
============================================================
📊 Loading data for KAI...
📊 Loading data for KAI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KAI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KAI...

==================================================
Training Baseline KAI (SVM)
==================================================
Training SVM model...

Baseline KAI Performance:
MAE: 155577.4691
RMSE: 185351.3182
MAPE: 11.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 185
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0007, rank=1
   2. Feature_65_t1: importance=0.0006, rank=2
   3. Feature_74_t3: importance=0.0003, rank=3
   4. Feature_71_t3: importance=0.0003, rank=4
   5. Feature_86_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for KAI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KAI...

==================================================
Training Enhanced KAI (SVM)
==================================================
Training SVM model...

Enhanced KAI Performance:
MAE: 73063.1800
RMSE: 103455.9118
MAPE: 5.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t3: importance=0.0013, rank=1
   2. Feature_17_t3: importance=0.0009, rank=2
   3. Feature_7_t0: importance=0.0007, rank=3
   4. Feature_20_t3: importance=0.0006, rank=4
   5. Feature_13_t1: importance=0.0006, rank=5

📊 KAI Results:
  Baseline MAPE: 11.15%
  Enhanced MAPE: 5.40%
  MAPE Improvement: +5.75% (+51.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 232/464: KALU
============================================================
📊 Loading data for KALU...
📊 Loading data for KALU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KALU...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KALU...

==================================================
Training Baseline KALU (SVM)
==================================================
Training SVM model...

Baseline KALU Performance:
MAE: 57675.0452
RMSE: 77535.3807
MAPE: 13.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 161
   • Highly important features (top 5%): 111

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t0: importance=0.0006, rank=1
   2. Feature_81_t0: importance=0.0005, rank=2
   3. Feature_88_t0: importance=0.0005, rank=3
   4. Feature_0_t3: importance=0.0004, rank=4
   5. Feature_82_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for KALU...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KALU...

==================================================
Training Enhanced KALU (SVM)
==================================================
Training SVM model...

Enhanced KALU Performance:
MAE: 58740.8272
RMSE: 76761.7706
MAPE: 13.33%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t0: importance=0.0007, rank=1
   2. Feature_20_t0: importance=0.0007, rank=2
   3. Feature_12_t1: importance=0.0006, rank=3
   4. Feature_7_t3: importance=0.0006, rank=4
   5. Feature_15_t3: importance=0.0005, rank=5

📊 KALU Results:
  Baseline MAPE: 13.46%
  Enhanced MAPE: 13.33%
  MAPE Improvement: +0.13% (+1.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 233/464: KAR
============================================================
📊 Loading data for KAR...
📊 Loading data for KAR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing KAR: 'KAR'

============================================================
TESTING TICKER 234/464: KFY
============================================================
📊 Loading data for KFY...
📊 Loading data for KFY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KFY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KFY...

==================================================
Training Baseline KFY (SVM)
==================================================
Training SVM model...

Baseline KFY Performance:
MAE: 137983.8366
RMSE: 186882.2665
MAPE: 16.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 134
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0009, rank=1
   2. Feature_92_t0: importance=0.0009, rank=2
   3. Feature_65_t3: importance=0.0006, rank=3
   4. Feature_93_t0: importance=0.0005, rank=4
   5. Feature_95_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for KFY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KFY...

==================================================
Training Enhanced KFY (SVM)
==================================================
Training SVM model...

Enhanced KFY Performance:
MAE: 141484.1253
RMSE: 180749.1106
MAPE: 15.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0010, rank=1
   2. Feature_13_t3: importance=0.0010, rank=2
   3. Feature_20_t2: importance=0.0010, rank=3
   4. Feature_17_t1: importance=0.0008, rank=4
   5. Feature_0_t3: importance=0.0007, rank=5

📊 KFY Results:
  Baseline MAPE: 16.08%
  Enhanced MAPE: 15.89%
  MAPE Improvement: +0.19% (+1.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 235/464: KLIC
============================================================
📊 Loading data for KLIC...
📊 Loading data for KLIC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KLIC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KLIC...

==================================================
Training Baseline KLIC (SVM)
==================================================
Training SVM model...

Baseline KLIC Performance:
MAE: 204441.1723
RMSE: 255540.4745
MAPE: 6.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 252
   • Highly important features (top 5%): 127

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0011, rank=1
   2. Feature_70_t1: importance=0.0006, rank=2
   3. Feature_84_t2: importance=0.0006, rank=3
   4. Feature_74_t3: importance=0.0005, rank=4
   5. Feature_86_t0: importance=0.0005, rank=5

🔧 Applying universal feature engineering for KLIC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KLIC...

==================================================
Training Enhanced KLIC (SVM)
==================================================
Training SVM model...

Enhanced KLIC Performance:
MAE: 236872.0325
RMSE: 297519.4106
MAPE: 7.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t1: importance=0.0016, rank=1
   2. Feature_19_t1: importance=0.0016, rank=2
   3. Feature_17_t0: importance=0.0012, rank=3
   4. Feature_24_t0: importance=0.0011, rank=4
   5. Feature_14_t0: importance=0.0008, rank=5

📊 KLIC Results:
  Baseline MAPE: 6.53%
  Enhanced MAPE: 7.65%
  MAPE Improvement: -1.13% (-17.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 236/464: KMT
============================================================
📊 Loading data for KMT...
📊 Loading data for KMT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KMT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KMT...

==================================================
Training Baseline KMT (SVM)
==================================================
Training SVM model...

Baseline KMT Performance:
MAE: 413247.5106
RMSE: 490435.6018
MAPE: 8.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 265
   • Highly important features (top 5%): 126

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_73_t0: importance=0.0002, rank=1
   2. Feature_0_t2: importance=0.0002, rank=2
   3. Feature_96_t2: importance=0.0002, rank=3
   4. Feature_90_t2: importance=0.0002, rank=4
   5. Feature_70_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for KMT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KMT...

==================================================
Training Enhanced KMT (SVM)
==================================================
Training SVM model...

Enhanced KMT Performance:
MAE: 387106.3273
RMSE: 484650.7842
MAPE: 8.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0005, rank=1
   2. Feature_11_t2: importance=0.0004, rank=2
   3. Feature_15_t1: importance=0.0003, rank=3
   4. Feature_7_t1: importance=0.0003, rank=4
   5. Feature_17_t2: importance=0.0003, rank=5

📊 KMT Results:
  Baseline MAPE: 8.75%
  Enhanced MAPE: 8.38%
  MAPE Improvement: +0.37% (+4.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 237/464: KN
============================================================
📊 Loading data for KN...
📊 Loading data for KN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KN...

==================================================
Training Baseline KN (SVM)
==================================================
Training SVM model...

Baseline KN Performance:
MAE: 245934.7839
RMSE: 315670.2919
MAPE: 11.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 162
   • Highly important features (top 5%): 91

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t2: importance=0.0003, rank=1
   2. Feature_92_t0: importance=0.0002, rank=2
   3. Feature_84_t3: importance=0.0001, rank=3
   4. Feature_96_t1: importance=0.0001, rank=4
   5. Feature_86_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for KN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KN...

==================================================
Training Enhanced KN (SVM)
==================================================
Training SVM model...

Enhanced KN Performance:
MAE: 240948.3352
RMSE: 305270.9115
MAPE: 11.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0004, rank=1
   2. Feature_14_t1: importance=0.0003, rank=2
   3. Feature_17_t0: importance=0.0003, rank=3
   4. Feature_15_t2: importance=0.0003, rank=4
   5. Feature_3_t0: importance=0.0003, rank=5

📊 KN Results:
  Baseline MAPE: 11.34%
  Enhanced MAPE: 11.21%
  MAPE Improvement: +0.13% (+1.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 238/464: KOP
============================================================
📊 Loading data for KOP...
📊 Loading data for KOP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KOP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KOP...

==================================================
Training Baseline KOP (SVM)
==================================================
Training SVM model...

Baseline KOP Performance:
MAE: 58010.8400
RMSE: 77002.5579
MAPE: 14.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 214
   • Highly important features (top 5%): 109

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0011, rank=1
   2. Feature_91_t0: importance=0.0008, rank=2
   3. Feature_82_t3: importance=0.0007, rank=3
   4. Feature_2_t3: importance=0.0007, rank=4
   5. Feature_65_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for KOP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KOP...

==================================================
Training Enhanced KOP (SVM)
==================================================
Training SVM model...

Enhanced KOP Performance:
MAE: 54519.9535
RMSE: 73131.4779
MAPE: 13.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0013, rank=1
   2. Feature_2_t3: importance=0.0011, rank=2
   3. Feature_9_t3: importance=0.0010, rank=3
   4. Feature_14_t3: importance=0.0010, rank=4
   5. Feature_17_t0: importance=0.0009, rank=5

📊 KOP Results:
  Baseline MAPE: 14.05%
  Enhanced MAPE: 13.03%
  MAPE Improvement: +1.02% (+7.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 239/464: KREF
============================================================
📊 Loading data for KREF...
📊 Loading data for KREF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing KREF: 'KREF'

============================================================
TESTING TICKER 240/464: KRYS
============================================================
📊 Loading data for KRYS...
📊 Loading data for KRYS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing KRYS: 'KRYS'

============================================================
TESTING TICKER 241/464: KSS
============================================================
📊 Loading data for KSS...
📊 Loading data for KSS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KSS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KSS...

==================================================
Training Baseline KSS (SVM)
==================================================
Training SVM model...

Baseline KSS Performance:
MAE: 2869990.2457
RMSE: 3757562.0702
MAPE: 6.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 157
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t2: importance=0.0003, rank=1
   2. Feature_90_t1: importance=0.0003, rank=2
   3. Feature_89_t1: importance=0.0003, rank=3
   4. Feature_95_t2: importance=0.0002, rank=4
   5. Feature_93_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for KSS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KSS...

==================================================
Training Enhanced KSS (SVM)
==================================================
Training SVM model...

Enhanced KSS Performance:
MAE: 2996003.8328
RMSE: 3796080.4896
MAPE: 7.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0007, rank=1
   2. Feature_11_t1: importance=0.0005, rank=2
   3. Feature_14_t3: importance=0.0003, rank=3
   4. Feature_23_t0: importance=0.0003, rank=4
   5. Feature_19_t2: importance=0.0003, rank=5

📊 KSS Results:
  Baseline MAPE: 6.84%
  Enhanced MAPE: 7.08%
  MAPE Improvement: -0.24% (-3.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 242/464: KW
============================================================
📊 Loading data for KW...
📊 Loading data for KW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KW...

==================================================
Training Baseline KW (SVM)
==================================================
Training SVM model...

Baseline KW Performance:
MAE: 512994.4637
RMSE: 609803.2576
MAPE: 10.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 291
   • Highly important features (top 5%): 165

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t3: importance=0.0007, rank=1
   2. Feature_85_t3: importance=0.0006, rank=2
   3. Feature_65_t3: importance=0.0006, rank=3
   4. Feature_86_t3: importance=0.0005, rank=4
   5. Feature_90_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for KW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KW...

==================================================
Training Enhanced KW (SVM)
==================================================
Training SVM model...

Enhanced KW Performance:
MAE: 385174.8656
RMSE: 492649.6819
MAPE: 7.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 47
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0038, rank=1
   2. Feature_1_t3: importance=0.0022, rank=2
   3. Feature_20_t3: importance=0.0014, rank=3
   4. Feature_22_t2: importance=0.0011, rank=4
   5. Feature_5_t1: importance=0.0010, rank=5

📊 KW Results:
  Baseline MAPE: 10.88%
  Enhanced MAPE: 7.62%
  MAPE Improvement: +3.25% (+29.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 243/464: KWR
============================================================
📊 Loading data for KWR...
📊 Loading data for KWR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for KWR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for KWR...

==================================================
Training Baseline KWR (SVM)
==================================================
Training SVM model...

Baseline KWR Performance:
MAE: 73069.5067
RMSE: 110065.0812
MAPE: 5.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 156
   • Highly important features (top 5%): 88

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0001, rank=1
   2. Feature_83_t1: importance=0.0001, rank=2
   3. Feature_91_t1: importance=0.0001, rank=3
   4. Feature_92_t1: importance=0.0001, rank=4
   5. Feature_94_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for KWR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for KWR...

==================================================
Training Enhanced KWR (SVM)
==================================================
Training SVM model...

Enhanced KWR Performance:
MAE: 69531.6551
RMSE: 112756.7411
MAPE: 4.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 51

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t0: importance=0.0002, rank=1
   2. Feature_11_t0: importance=0.0002, rank=2
   3. Feature_17_t1: importance=0.0001, rank=3
   4. Feature_1_t2: importance=0.0001, rank=4
   5. Feature_7_t2: importance=0.0001, rank=5

📊 KWR Results:
  Baseline MAPE: 5.01%
  Enhanced MAPE: 4.81%
  MAPE Improvement: +0.19% (+3.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 244/464: LCII
============================================================
📊 Loading data for LCII...
📊 Loading data for LCII from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LCII...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LCII...

==================================================
Training Baseline LCII (SVM)
==================================================
Training SVM model...

Baseline LCII Performance:
MAE: 146520.4160
RMSE: 197522.0100
MAPE: 7.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 209
   • Highly important features (top 5%): 115

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t1: importance=0.0001, rank=1
   2. Feature_65_t1: importance=0.0001, rank=2
   3. Feature_94_t0: importance=0.0001, rank=3
   4. Feature_68_t0: importance=0.0001, rank=4
   5. Feature_72_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for LCII...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LCII...

==================================================
Training Enhanced LCII (SVM)
==================================================
Training SVM model...

Enhanced LCII Performance:
MAE: 136785.9389
RMSE: 185905.5992
MAPE: 6.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 34

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t0: importance=0.0005, rank=1
   2. Feature_22_t0: importance=0.0003, rank=2
   3. Feature_20_t0: importance=0.0002, rank=3
   4. Feature_4_t2: importance=0.0002, rank=4
   5. Feature_7_t3: importance=0.0002, rank=5

📊 LCII Results:
  Baseline MAPE: 7.46%
  Enhanced MAPE: 6.90%
  MAPE Improvement: +0.57% (+7.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 245/464: LEG
============================================================
📊 Loading data for LEG...
📊 Loading data for LEG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LEG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LEG...

==================================================
Training Baseline LEG (SVM)
==================================================
Training SVM model...

Baseline LEG Performance:
MAE: 1087553.1097
RMSE: 1449666.1090
MAPE: 14.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 131
   • Highly important features (top 5%): 54

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_86_t1: importance=0.0004, rank=1
   2. Feature_75_t0: importance=0.0004, rank=2
   3. Feature_70_t1: importance=0.0003, rank=3
   4. Feature_85_t2: importance=0.0002, rank=4
   5. Feature_85_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for LEG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LEG...

==================================================
Training Enhanced LEG (SVM)
==================================================
Training SVM model...

Enhanced LEG Performance:
MAE: 1082867.0887
RMSE: 1499057.7342
MAPE: 14.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0010, rank=1
   2. Feature_15_t1: importance=0.0008, rank=2
   3. Feature_7_t2: importance=0.0007, rank=3
   4. Feature_20_t1: importance=0.0005, rank=4
   5. Feature_20_t2: importance=0.0005, rank=5

📊 LEG Results:
  Baseline MAPE: 14.24%
  Enhanced MAPE: 14.08%
  MAPE Improvement: +0.16% (+1.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 246/464: LGIH
============================================================
📊 Loading data for LGIH...
📊 Loading data for LGIH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LGIH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LGIH...

==================================================
Training Baseline LGIH (SVM)
==================================================
Training SVM model...

Baseline LGIH Performance:
MAE: 82015.2748
RMSE: 111617.7990
MAPE: 3.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 94
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t1: importance=0.0002, rank=1
   2. Feature_71_t3: importance=0.0001, rank=2
   3. Feature_66_t3: importance=0.0001, rank=3
   4. Feature_72_t3: importance=0.0001, rank=4
   5. Feature_66_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for LGIH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LGIH...

==================================================
Training Enhanced LGIH (SVM)
==================================================
Training SVM model...

Enhanced LGIH Performance:
MAE: 81615.7114
RMSE: 110564.5049
MAPE: 3.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 58
   • Highly important features (top 5%): 26

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0002, rank=1
   2. Feature_17_t2: importance=0.0001, rank=2
   3. Feature_16_t1: importance=0.0001, rank=3
   4. Feature_13_t1: importance=0.0001, rank=4
   5. Feature_21_t0: importance=0.0001, rank=5

📊 LGIH Results:
  Baseline MAPE: 3.34%
  Enhanced MAPE: 3.29%
  MAPE Improvement: +0.05% (+1.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 247/464: LGND
============================================================
📊 Loading data for LGND...
📊 Loading data for LGND from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LGND...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LGND...

==================================================
Training Baseline LGND (SVM)
==================================================
Training SVM model...

Baseline LGND Performance:
MAE: 88393.5143
RMSE: 107240.6249
MAPE: 9.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 273
   • Highly important features (top 5%): 170

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0006, rank=1
   2. Feature_69_t3: importance=0.0005, rank=2
   3. Feature_68_t3: importance=0.0003, rank=3
   4. Feature_76_t3: importance=0.0003, rank=4
   5. Feature_87_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for LGND...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LGND...

==================================================
Training Enhanced LGND (SVM)
==================================================
Training SVM model...

Enhanced LGND Performance:
MAE: 87881.1892
RMSE: 108587.4828
MAPE: 9.45%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 51
   • Highly important features (top 5%): 25

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t0: importance=0.0007, rank=1
   2. Feature_19_t3: importance=0.0005, rank=2
   3. Feature_1_t3: importance=0.0005, rank=3
   4. Feature_15_t3: importance=0.0003, rank=4
   5. Feature_3_t0: importance=0.0002, rank=5

📊 LGND Results:
  Baseline MAPE: 9.47%
  Enhanced MAPE: 9.45%
  MAPE Improvement: +0.03% (+0.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 248/464: LKFN
============================================================
📊 Loading data for LKFN...
📊 Loading data for LKFN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LKFN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LKFN...

==================================================
Training Baseline LKFN (SVM)
==================================================
Training SVM model...

Baseline LKFN Performance:
MAE: 86378.9461
RMSE: 104334.1065
MAPE: 3.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 51
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0014, rank=1
   2. Feature_95_t0: importance=0.0009, rank=2
   3. Feature_69_t3: importance=0.0007, rank=3
   4. Feature_67_t3: importance=0.0004, rank=4
   5. Feature_68_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for LKFN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LKFN...

==================================================
Training Enhanced LKFN (SVM)
==================================================
Training SVM model...

Enhanced LKFN Performance:
MAE: 70123.0882
RMSE: 89104.3927
MAPE: 3.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 40

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0012, rank=1
   2. Feature_15_t1: importance=0.0008, rank=2
   3. Feature_19_t3: importance=0.0007, rank=3
   4. Feature_7_t3: importance=0.0007, rank=4
   5. Feature_13_t1: importance=0.0007, rank=5

📊 LKFN Results:
  Baseline MAPE: 3.96%
  Enhanced MAPE: 3.21%
  MAPE Improvement: +0.74% (+18.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 249/464: LMAT
============================================================
📊 Loading data for LMAT...
📊 Loading data for LMAT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LMAT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LMAT...

==================================================
Training Baseline LMAT (SVM)
==================================================
Training SVM model...

Baseline LMAT Performance:
MAE: 79845.4148
RMSE: 118112.2669
MAPE: 8.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 208
   • Highly important features (top 5%): 114

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t2: importance=0.0003, rank=1
   2. Feature_2_t3: importance=0.0002, rank=2
   3. Feature_68_t1: importance=0.0002, rank=3
   4. Feature_63_t3: importance=0.0002, rank=4
   5. Feature_0_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for LMAT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LMAT...

==================================================
Training Enhanced LMAT (SVM)
==================================================
Training SVM model...

Enhanced LMAT Performance:
MAE: 77251.0059
RMSE: 110358.7137
MAPE: 7.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0004, rank=1
   2. Feature_11_t0: importance=0.0004, rank=2
   3. Feature_4_t3: importance=0.0004, rank=3
   4. Feature_24_t0: importance=0.0003, rank=4
   5. Feature_11_t2: importance=0.0003, rank=5

📊 LMAT Results:
  Baseline MAPE: 8.22%
  Enhanced MAPE: 7.65%
  MAPE Improvement: +0.57% (+6.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 250/464: LNC
============================================================
📊 Loading data for LNC...
📊 Loading data for LNC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LNC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LNC...

==================================================
Training Baseline LNC (SVM)
==================================================
Training SVM model...

Baseline LNC Performance:
MAE: 304120.4823
RMSE: 397922.8614
MAPE: 7.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 147
   • Highly important features (top 5%): 98

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0012, rank=1
   2. Feature_63_t2: importance=0.0007, rank=2
   3. Feature_82_t2: importance=0.0007, rank=3
   4. Feature_85_t1: importance=0.0006, rank=4
   5. Feature_86_t0: importance=0.0005, rank=5

🔧 Applying universal feature engineering for LNC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LNC...

==================================================
Training Enhanced LNC (SVM)
==================================================
Training SVM model...

Enhanced LNC Performance:
MAE: 302924.6033
RMSE: 394285.1082
MAPE: 7.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0010, rank=1
   2. Feature_17_t0: importance=0.0009, rank=2
   3. Feature_12_t1: importance=0.0009, rank=3
   4. Feature_22_t0: importance=0.0008, rank=4
   5. Feature_7_t3: importance=0.0007, rank=5

📊 LNC Results:
  Baseline MAPE: 7.15%
  Enhanced MAPE: 7.23%
  MAPE Improvement: -0.08% (-1.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 251/464: LNN
============================================================
📊 Loading data for LNN...
📊 Loading data for LNN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LNN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LNN...

==================================================
Training Baseline LNN (SVM)
==================================================
Training SVM model...

Baseline LNN Performance:
MAE: 36023.3953
RMSE: 43732.7048
MAPE: 9.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 175
   • Highly important features (top 5%): 115

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t1: importance=0.0007, rank=1
   2. Feature_68_t3: importance=0.0004, rank=2
   3. Feature_67_t3: importance=0.0003, rank=3
   4. Feature_89_t2: importance=0.0003, rank=4
   5. Feature_90_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for LNN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LNN...

==================================================
Training Enhanced LNN (SVM)
==================================================
Training SVM model...

Enhanced LNN Performance:
MAE: 34781.4596
RMSE: 43204.3765
MAPE: 9.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0008, rank=1
   2. Feature_11_t1: importance=0.0007, rank=2
   3. Feature_16_t3: importance=0.0006, rank=3
   4. Feature_20_t1: importance=0.0006, rank=4
   5. Feature_7_t3: importance=0.0005, rank=5

📊 LNN Results:
  Baseline MAPE: 9.79%
  Enhanced MAPE: 9.66%
  MAPE Improvement: +0.13% (+1.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 252/464: LPG
============================================================
📊 Loading data for LPG...
📊 Loading data for LPG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing LPG: 'LPG'

============================================================
TESTING TICKER 253/464: LQDT
============================================================
📊 Loading data for LQDT...
📊 Loading data for LQDT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LQDT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LQDT...

==================================================
Training Baseline LQDT (SVM)
==================================================
Training SVM model...

Baseline LQDT Performance:
MAE: 105366.1218
RMSE: 128738.7671
MAPE: 9.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 117
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0009, rank=1
   2. Feature_72_t0: importance=0.0006, rank=2
   3. Feature_85_t1: importance=0.0004, rank=3
   4. Feature_0_t3: importance=0.0004, rank=4
   5. Feature_76_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for LQDT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LQDT...

==================================================
Training Enhanced LQDT (SVM)
==================================================
Training SVM model...

Enhanced LQDT Performance:
MAE: 86263.5381
RMSE: 99786.7516
MAPE: 8.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0007, rank=1
   2. Feature_19_t0: importance=0.0006, rank=2
   3. Feature_15_t3: importance=0.0005, rank=3
   4. Feature_23_t2: importance=0.0004, rank=4
   5. Feature_19_t1: importance=0.0004, rank=5

📊 LQDT Results:
  Baseline MAPE: 9.86%
  Enhanced MAPE: 8.34%
  MAPE Improvement: +1.52% (+15.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 254/464: LRN
============================================================
📊 Loading data for LRN...
📊 Loading data for LRN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LRN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LRN...

==================================================
Training Baseline LRN (SVM)
==================================================
Training SVM model...

Baseline LRN Performance:
MAE: 400785.3067
RMSE: 608632.7562
MAPE: 7.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 128
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t2: importance=0.0009, rank=1
   2. Feature_65_t2: importance=0.0008, rank=2
   3. Feature_71_t0: importance=0.0006, rank=3
   4. Feature_65_t0: importance=0.0005, rank=4
   5. Feature_80_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for LRN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LRN...

==================================================
Training Enhanced LRN (SVM)
==================================================
Training SVM model...

Enhanced LRN Performance:
MAE: 411494.2145
RMSE: 615082.9157
MAPE: 8.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0009, rank=1
   2. Feature_10_t3: importance=0.0008, rank=2
   3. Feature_24_t3: importance=0.0007, rank=3
   4. Feature_19_t1: importance=0.0007, rank=4
   5. Feature_17_t0: importance=0.0007, rank=5

📊 LRN Results:
  Baseline MAPE: 7.93%
  Enhanced MAPE: 8.14%
  MAPE Improvement: -0.21% (-2.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 255/464: LTC
============================================================
📊 Loading data for LTC...
📊 Loading data for LTC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LTC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LTC...

==================================================
Training Baseline LTC (SVM)
==================================================
Training SVM model...

Baseline LTC Performance:
MAE: 109758.7899
RMSE: 136620.0783
MAPE: 6.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 260
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0005, rank=1
   2. Feature_63_t0: importance=0.0003, rank=2
   3. Feature_91_t1: importance=0.0003, rank=3
   4. Feature_93_t2: importance=0.0003, rank=4
   5. Feature_2_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for LTC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LTC...

==================================================
Training Enhanced LTC (SVM)
==================================================
Training SVM model...

Enhanced LTC Performance:
MAE: 105762.1747
RMSE: 140183.6160
MAPE: 6.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0007, rank=1
   2. Feature_4_t0: importance=0.0007, rank=2
   3. Feature_7_t2: importance=0.0006, rank=3
   4. Feature_19_t2: importance=0.0005, rank=4
   5. Feature_20_t2: importance=0.0005, rank=5

📊 LTC Results:
  Baseline MAPE: 6.80%
  Enhanced MAPE: 6.59%
  MAPE Improvement: +0.21% (+3.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 256/464: LXP
============================================================
📊 Loading data for LXP...
📊 Loading data for LXP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LXP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LXP...

==================================================
Training Baseline LXP (SVM)
==================================================
Training SVM model...

Baseline LXP Performance:
MAE: 978070.0538
RMSE: 1232872.0674
MAPE: 18.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 249
   • Highly important features (top 5%): 130

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_91_t3: importance=0.0012, rank=1
   2. Feature_63_t2: importance=0.0007, rank=2
   3. Feature_91_t1: importance=0.0006, rank=3
   4. Feature_93_t1: importance=0.0006, rank=4
   5. Feature_95_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for LXP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LXP...

==================================================
Training Enhanced LXP (SVM)
==================================================
Training SVM model...

Enhanced LXP Performance:
MAE: 997622.8360
RMSE: 1255399.0210
MAPE: 19.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0025, rank=1
   2. Feature_4_t2: importance=0.0019, rank=2
   3. Feature_17_t2: importance=0.0019, rank=3
   4. Feature_20_t3: importance=0.0016, rank=4
   5. Feature_20_t1: importance=0.0015, rank=5

📊 LXP Results:
  Baseline MAPE: 18.93%
  Enhanced MAPE: 19.89%
  MAPE Improvement: -0.96% (-5.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 257/464: LZB
============================================================
📊 Loading data for LZB...
📊 Loading data for LZB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for LZB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for LZB...

==================================================
Training Baseline LZB (SVM)
==================================================
Training SVM model...

Baseline LZB Performance:
MAE: 220745.0501
RMSE: 278769.0011
MAPE: 9.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 159
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_77_t3: importance=0.0002, rank=1
   2. Feature_68_t3: importance=0.0002, rank=2
   3. Feature_69_t3: importance=0.0002, rank=3
   4. Feature_84_t2: importance=0.0001, rank=4
   5. Feature_0_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for LZB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for LZB...

==================================================
Training Enhanced LZB (SVM)
==================================================
Training SVM model...

Enhanced LZB Performance:
MAE: 193100.4055
RMSE: 249038.7895
MAPE: 8.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0003, rank=1
   2. Feature_13_t3: importance=0.0002, rank=2
   3. Feature_15_t3: importance=0.0002, rank=3
   4. Feature_16_t3: importance=0.0002, rank=4
   5. Feature_21_t2: importance=0.0002, rank=5

📊 LZB Results:
  Baseline MAPE: 9.11%
  Enhanced MAPE: 8.06%
  MAPE Improvement: +1.06% (+11.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 258/464: MAC
============================================================
📊 Loading data for MAC...
📊 Loading data for MAC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MAC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MAC...

==================================================
Training Baseline MAC (SVM)
==================================================
Training SVM model...

Baseline MAC Performance:
MAE: 761527.5301
RMSE: 972679.2086
MAPE: 5.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 218
   • Highly important features (top 5%): 133

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0003, rank=1
   2. Feature_94_t2: importance=0.0003, rank=2
   3. Feature_68_t3: importance=0.0002, rank=3
   4. Feature_65_t0: importance=0.0002, rank=4
   5. Feature_93_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for MAC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MAC...

==================================================
Training Enhanced MAC (SVM)
==================================================
Training SVM model...

Enhanced MAC Performance:
MAE: 765848.5532
RMSE: 953018.7353
MAPE: 5.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0007, rank=1
   2. Feature_7_t1: importance=0.0004, rank=2
   3. Feature_13_t0: importance=0.0004, rank=3
   4. Feature_22_t1: importance=0.0003, rank=4
   5. Feature_17_t3: importance=0.0003, rank=5

📊 MAC Results:
  Baseline MAPE: 5.40%
  Enhanced MAPE: 5.51%
  MAPE Improvement: -0.12% (-2.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 259/464: MAN
============================================================
📊 Loading data for MAN...
📊 Loading data for MAN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MAN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MAN...

==================================================
Training Baseline MAN (SVM)
==================================================
Training SVM model...

Baseline MAN Performance:
MAE: 212625.6135
RMSE: 276025.0238
MAPE: 9.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 344
   • Highly important features (top 5%): 239

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_73_t3: importance=0.0004, rank=1
   2. Feature_86_t3: importance=0.0004, rank=2
   3. Feature_0_t3: importance=0.0004, rank=3
   4. Feature_72_t3: importance=0.0003, rank=4
   5. Feature_84_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for MAN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MAN...

==================================================
Training Enhanced MAN (SVM)
==================================================
Training SVM model...

Enhanced MAN Performance:
MAE: 182982.9912
RMSE: 247179.1359
MAPE: 8.12%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0007, rank=1
   2. Feature_12_t1: importance=0.0006, rank=2
   3. Feature_15_t3: importance=0.0005, rank=3
   4. Feature_15_t2: importance=0.0005, rank=4
   5. Feature_19_t2: importance=0.0005, rank=5

📊 MAN Results:
  Baseline MAPE: 9.66%
  Enhanced MAPE: 8.12%
  MAPE Improvement: +1.54% (+15.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 260/464: MARA
============================================================
📊 Loading data for MARA...
📊 Loading data for MARA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MARA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MARA...

==================================================
Training Baseline MARA (SVM)
==================================================
Training SVM model...

Baseline MARA Performance:
MAE: 5180651.9467
RMSE: 5943838.7786
MAPE: 7.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 65
   • Highly important features (top 5%): 32

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0029, rank=1
   2. Feature_83_t2: importance=0.0010, rank=2
   3. Feature_65_t1: importance=0.0009, rank=3
   4. Feature_67_t1: importance=0.0007, rank=4
   5. Feature_78_t2: importance=0.0007, rank=5

🔧 Applying universal feature engineering for MARA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MARA...

==================================================
Training Enhanced MARA (SVM)
==================================================
Training SVM model...

Enhanced MARA Performance:
MAE: 4873444.8249
RMSE: 5819335.0042
MAPE: 7.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 23

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0026, rank=1
   2. Feature_24_t0: importance=0.0017, rank=2
   3. Feature_5_t2: importance=0.0013, rank=3
   4. Feature_11_t0: importance=0.0013, rank=4
   5. Feature_20_t1: importance=0.0013, rank=5

📊 MARA Results:
  Baseline MAPE: 7.59%
  Enhanced MAPE: 7.06%
  MAPE Improvement: +0.53% (+7.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 261/464: MATW
============================================================
📊 Loading data for MATW...
📊 Loading data for MATW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MATW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MATW...

==================================================
Training Baseline MATW (SVM)
==================================================
Training SVM model...

Baseline MATW Performance:
MAE: 90915.6632
RMSE: 117032.7300
MAPE: 9.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 306
   • Highly important features (top 5%): 165

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0007, rank=1
   2. Feature_74_t3: importance=0.0003, rank=2
   3. Feature_70_t3: importance=0.0003, rank=3
   4. Feature_81_t2: importance=0.0002, rank=4
   5. Feature_76_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for MATW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MATW...

==================================================
Training Enhanced MATW (SVM)
==================================================
Training SVM model...

Enhanced MATW Performance:
MAE: 65001.9746
RMSE: 85790.2168
MAPE: 6.82%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0010, rank=1
   2. Feature_20_t2: importance=0.0005, rank=2
   3. Feature_5_t3: importance=0.0005, rank=3
   4. Feature_17_t3: importance=0.0005, rank=4
   5. Feature_15_t2: importance=0.0005, rank=5

📊 MATW Results:
  Baseline MAPE: 9.41%
  Enhanced MAPE: 6.82%
  MAPE Improvement: +2.59% (+27.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 262/464: MATX
============================================================
📊 Loading data for MATX...
📊 Loading data for MATX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MATX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MATX...

==================================================
Training Baseline MATX (SVM)
==================================================
Training SVM model...

Baseline MATX Performance:
MAE: 163024.8322
RMSE: 236233.6559
MAPE: 15.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 121
   • Highly important features (top 5%): 34

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t0: importance=0.0005, rank=1
   2. Feature_0_t1: importance=0.0004, rank=2
   3. Feature_65_t3: importance=0.0004, rank=3
   4. Feature_90_t3: importance=0.0003, rank=4
   5. Feature_78_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for MATX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MATX...

==================================================
Training Enhanced MATX (SVM)
==================================================
Training SVM model...

Enhanced MATX Performance:
MAE: 150507.0565
RMSE: 231882.2359
MAPE: 14.35%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 75
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0012, rank=1
   2. Feature_22_t2: importance=0.0004, rank=2
   3. Feature_20_t3: importance=0.0004, rank=3
   4. Feature_15_t3: importance=0.0004, rank=4
   5. Feature_5_t3: importance=0.0004, rank=5

📊 MATX Results:
  Baseline MAPE: 15.66%
  Enhanced MAPE: 14.35%
  MAPE Improvement: +1.31% (+8.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 263/464: MC
============================================================
📊 Loading data for MC...
📊 Loading data for MC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing MC: 'MC'

============================================================
TESTING TICKER 264/464: MCRI
============================================================
📊 Loading data for MCRI...
📊 Loading data for MCRI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MCRI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MCRI...

==================================================
Training Baseline MCRI (SVM)
==================================================
Training SVM model...

Baseline MCRI Performance:
MAE: 55115.9856
RMSE: 81999.4455
MAPE: 19.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 210
   • Highly important features (top 5%): 103

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t2: importance=0.0017, rank=1
   2. Feature_85_t1: importance=0.0007, rank=2
   3. Feature_68_t1: importance=0.0007, rank=3
   4. Feature_65_t3: importance=0.0006, rank=4
   5. Feature_64_t3: importance=0.0006, rank=5

🔧 Applying universal feature engineering for MCRI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MCRI...

==================================================
Training Enhanced MCRI (SVM)
==================================================
Training SVM model...

Enhanced MCRI Performance:
MAE: 52514.8655
RMSE: 79071.8430
MAPE: 18.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0018, rank=1
   2. Feature_15_t2: importance=0.0013, rank=2
   3. Feature_15_t3: importance=0.0012, rank=3
   4. Feature_5_t3: importance=0.0010, rank=4
   5. Feature_4_t0: importance=0.0009, rank=5

📊 MCRI Results:
  Baseline MAPE: 19.72%
  Enhanced MAPE: 18.59%
  MAPE Improvement: +1.13% (+5.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 265/464: MCY
============================================================
📊 Loading data for MCY...
📊 Loading data for MCY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MCY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MCY...

==================================================
Training Baseline MCY (SVM)
==================================================
Training SVM model...

Baseline MCY Performance:
MAE: 138536.1906
RMSE: 225966.6388
MAPE: 12.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 274
   • Highly important features (top 5%): 145

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t3: importance=0.0006, rank=1
   2. Feature_63_t0: importance=0.0005, rank=2
   3. Feature_65_t0: importance=0.0005, rank=3
   4. Feature_91_t1: importance=0.0004, rank=4
   5. Feature_68_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for MCY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MCY...

==================================================
Training Enhanced MCY (SVM)
==================================================
Training SVM model...

Enhanced MCY Performance:
MAE: 141528.2183
RMSE: 207619.7908
MAPE: 12.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0015, rank=1
   2. Feature_4_t0: importance=0.0015, rank=2
   3. Feature_11_t2: importance=0.0009, rank=3
   4. Feature_17_t3: importance=0.0009, rank=4
   5. Feature_23_t2: importance=0.0008, rank=5

📊 MCY Results:
  Baseline MAPE: 12.95%
  Enhanced MAPE: 12.99%
  MAPE Improvement: -0.03% (-0.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 266/464: MD
============================================================
📊 Loading data for MD...
📊 Loading data for MD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MD...

==================================================
Training Baseline MD (SVM)
==================================================
Training SVM model...

Baseline MD Performance:
MAE: 457068.5806
RMSE: 708637.2724
MAPE: 13.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 86
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t0: importance=0.0006, rank=1
   2. Feature_70_t0: importance=0.0005, rank=2
   3. Feature_79_t2: importance=0.0004, rank=3
   4. Feature_75_t3: importance=0.0003, rank=4
   5. Feature_63_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for MD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MD...

==================================================
Training Enhanced MD (SVM)
==================================================
Training SVM model...

Enhanced MD Performance:
MAE: 412876.9769
RMSE: 669068.5326
MAPE: 11.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0007, rank=1
   2. Feature_13_t0: importance=0.0007, rank=2
   3. Feature_22_t2: importance=0.0006, rank=3
   4. Feature_19_t2: importance=0.0006, rank=4
   5. Feature_20_t1: importance=0.0005, rank=5

📊 MD Results:
  Baseline MAPE: 13.06%
  Enhanced MAPE: 11.66%
  MAPE Improvement: +1.40% (+10.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 267/464: MDU
============================================================
📊 Loading data for MDU...
📊 Loading data for MDU from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MDU...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MDU...

==================================================
Training Baseline MDU (SVM)
==================================================
Training SVM model...

Baseline MDU Performance:
MAE: 415642.7354
RMSE: 547077.6497
MAPE: 10.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 223
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0015, rank=1
   2. Feature_2_t2: importance=0.0013, rank=2
   3. Feature_0_t2: importance=0.0011, rank=3
   4. Feature_68_t0: importance=0.0008, rank=4
   5. Feature_65_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for MDU...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MDU...

==================================================
Training Enhanced MDU (SVM)
==================================================
Training SVM model...

Enhanced MDU Performance:
MAE: 442231.9855
RMSE: 602460.8305
MAPE: 10.36%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0020, rank=1
   2. Feature_24_t2: importance=0.0018, rank=2
   3. Feature_13_t0: importance=0.0013, rank=3
   4. Feature_5_t3: importance=0.0011, rank=4
   5. Feature_8_t3: importance=0.0011, rank=5

📊 MDU Results:
  Baseline MAPE: 10.42%
  Enhanced MAPE: 10.36%
  MAPE Improvement: +0.06% (+0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 268/464: MGEE
============================================================
📊 Loading data for MGEE...
📊 Loading data for MGEE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MGEE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'MGEE' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MGEE...

==================================================
Training Baseline MGEE (SVM)
==================================================
Training SVM model...

Baseline MGEE Performance:
MAE: 171725.2237
RMSE: 276914.2449
MAPE: 13.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 43
   • Highly important features (top 5%): 15

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0075, rank=1
   2. Feature_1_t3: importance=0.0046, rank=2
   3. Feature_65_t1: importance=0.0042, rank=3
   4. Feature_1_t0: importance=0.0023, rank=4
   5. Feature_2_t3: importance=0.0016, rank=5

🔧 Applying universal feature engineering for MGEE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MGEE...

==================================================
Training Enhanced MGEE (SVM)
==================================================
Training SVM model...

Enhanced MGEE Performance:
MAE: 135555.4640
RMSE: 256873.9645
MAPE: 10.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 74
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0042, rank=1
   2. Feature_15_t3: importance=0.0029, rank=2
   3. Feature_19_t0: importance=0.0026, rank=3
   4. Feature_11_t1: importance=0.0026, rank=4
   5. Feature_14_t3: importance=0.0024, rank=5

📊 MGEE Results:
  Baseline MAPE: 13.65%
  Enhanced MAPE: 10.28%
  MAPE Improvement: +3.38% (+24.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 269/464: MGPI
============================================================
📊 Loading data for MGPI...
📊 Loading data for MGPI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MGPI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MGPI...

==================================================
Training Baseline MGPI (SVM)
==================================================
Training SVM model...

Baseline MGPI Performance:
MAE: 199916.1252
RMSE: 287358.1897
MAPE: 7.49%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 79
   • Highly important features (top 5%): 38

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0001, rank=1
   2. Feature_67_t3: importance=0.0001, rank=2
   3. Feature_63_t3: importance=0.0001, rank=3
   4. Feature_72_t1: importance=0.0001, rank=4
   5. Feature_66_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for MGPI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MGPI...

==================================================
Training Enhanced MGPI (SVM)
==================================================
Training SVM model...

Enhanced MGPI Performance:
MAE: 205046.0364
RMSE: 288977.7801
MAPE: 7.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t0: importance=0.0001, rank=1
   2. Feature_22_t3: importance=0.0001, rank=2
   3. Feature_6_t3: importance=0.0001, rank=3
   4. Feature_6_t2: importance=0.0001, rank=4
   5. Feature_23_t2: importance=0.0001, rank=5

📊 MGPI Results:
  Baseline MAPE: 7.49%
  Enhanced MAPE: 7.96%
  MAPE Improvement: -0.47% (-6.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 270/464: MHO
============================================================
📊 Loading data for MHO...
📊 Loading data for MHO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MHO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MHO...

==================================================
Training Baseline MHO (SVM)
==================================================
Training SVM model...

Baseline MHO Performance:
MAE: 86115.8788
RMSE: 103497.3959
MAPE: 9.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 171
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t1: importance=0.0006, rank=1
   2. Feature_80_t0: importance=0.0005, rank=2
   3. Feature_74_t2: importance=0.0004, rank=3
   4. Feature_77_t2: importance=0.0004, rank=4
   5. Feature_90_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for MHO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MHO...

==================================================
Training Enhanced MHO (SVM)
==================================================
Training SVM model...

Enhanced MHO Performance:
MAE: 84593.7721
RMSE: 107271.2762
MAPE: 10.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t0: importance=0.0010, rank=1
   2. Feature_7_t2: importance=0.0008, rank=2
   3. Feature_15_t3: importance=0.0007, rank=3
   4. Feature_14_t3: importance=0.0006, rank=4
   5. Feature_8_t3: importance=0.0006, rank=5

📊 MHO Results:
  Baseline MAPE: 9.80%
  Enhanced MAPE: 10.25%
  MAPE Improvement: -0.45% (-4.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 271/464: MKTX
============================================================
📊 Loading data for MKTX...
📊 Loading data for MKTX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing MKTX: 'MKTX'

============================================================
TESTING TICKER 272/464: MMI
============================================================
📊 Loading data for MMI...
📊 Loading data for MMI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MMI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MMI...

==================================================
Training Baseline MMI (SVM)
==================================================
Training SVM model...

Baseline MMI Performance:
MAE: 69142.5132
RMSE: 97280.9416
MAPE: 11.53%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 271
   • Highly important features (top 5%): 123

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_74_t3: importance=0.0010, rank=1
   2. Feature_72_t3: importance=0.0005, rank=2
   3. Feature_65_t2: importance=0.0005, rank=3
   4. Feature_2_t0: importance=0.0004, rank=4
   5. Feature_78_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for MMI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MMI...

==================================================
Training Enhanced MMI (SVM)
==================================================
Training SVM model...

Enhanced MMI Performance:
MAE: 54112.9803
RMSE: 71917.6607
MAPE: 10.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0023, rank=1
   2. Feature_19_t2: importance=0.0016, rank=2
   3. Feature_15_t3: importance=0.0010, rank=3
   4. Feature_22_t2: importance=0.0010, rank=4
   5. Feature_14_t3: importance=0.0010, rank=5

📊 MMI Results:
  Baseline MAPE: 11.53%
  Enhanced MAPE: 10.61%
  MAPE Improvement: +0.92% (+7.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 273/464: MMSI
============================================================
📊 Loading data for MMSI...
📊 Loading data for MMSI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MMSI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MMSI...

==================================================
Training Baseline MMSI (SVM)
==================================================
Training SVM model...

Baseline MMSI Performance:
MAE: 219124.4701
RMSE: 263191.3645
MAPE: 8.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 230
   • Highly important features (top 5%): 139

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0006, rank=1
   2. Feature_95_t1: importance=0.0004, rank=2
   3. Feature_68_t3: importance=0.0004, rank=3
   4. Feature_68_t2: importance=0.0003, rank=4
   5. Feature_77_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for MMSI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MMSI...

==================================================
Training Enhanced MMSI (SVM)
==================================================
Training SVM model...

Enhanced MMSI Performance:
MAE: 209757.6039
RMSE: 258862.1451
MAPE: 7.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0010, rank=1
   2. Feature_22_t2: importance=0.0009, rank=2
   3. Feature_13_t2: importance=0.0007, rank=3
   4. Feature_19_t3: importance=0.0006, rank=4
   5. Feature_20_t2: importance=0.0006, rank=5

📊 MMSI Results:
  Baseline MAPE: 8.22%
  Enhanced MAPE: 7.72%
  MAPE Improvement: +0.50% (+6.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 274/464: MNRO
============================================================
📊 Loading data for MNRO...
📊 Loading data for MNRO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MNRO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MNRO...

==================================================
Training Baseline MNRO (SVM)
==================================================
Training SVM model...

Baseline MNRO Performance:
MAE: 271093.4427
RMSE: 339245.4292
MAPE: 6.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 221
   • Highly important features (top 5%): 119

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t0: importance=0.0000, rank=1
   2. Feature_78_t1: importance=0.0000, rank=2
   3. Feature_63_t0: importance=0.0000, rank=3
   4. Feature_84_t3: importance=0.0000, rank=4
   5. Feature_82_t1: importance=0.0000, rank=5

🔧 Applying universal feature engineering for MNRO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MNRO...

==================================================
Training Enhanced MNRO (SVM)
==================================================
Training SVM model...

Enhanced MNRO Performance:
MAE: 268262.4678
RMSE: 339016.5789
MAPE: 6.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0001, rank=1
   2. Feature_22_t1: importance=0.0001, rank=2
   3. Feature_23_t3: importance=0.0001, rank=3
   4. Feature_11_t3: importance=0.0000, rank=4
   5. Feature_24_t3: importance=0.0000, rank=5

📊 MNRO Results:
  Baseline MAPE: 6.93%
  Enhanced MAPE: 6.85%
  MAPE Improvement: +0.08% (+1.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 275/464: MPW
============================================================
📊 Loading data for MPW...
📊 Loading data for MPW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MPW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MPW...

==================================================
Training Baseline MPW (SVM)
==================================================
Training SVM model...

Baseline MPW Performance:
MAE: 11503778.1841
RMSE: 14289704.9379
MAPE: 5.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 61
   • Highly important features (top 5%): 44

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t1: importance=0.0008, rank=1
   2. Feature_65_t1: importance=0.0005, rank=2
   3. Feature_84_t3: importance=0.0004, rank=3
   4. Feature_82_t2: importance=0.0003, rank=4
   5. Feature_63_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for MPW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MPW...

==================================================
Training Enhanced MPW (SVM)
==================================================
Training SVM model...

Enhanced MPW Performance:
MAE: 7625648.2145
RMSE: 10986748.0537
MAPE: 3.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 72
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0006, rank=1
   2. Feature_7_t2: importance=0.0005, rank=2
   3. Feature_5_t1: importance=0.0004, rank=3
   4. Feature_7_t0: importance=0.0003, rank=4
   5. Feature_13_t1: importance=0.0003, rank=5

📊 MPW Results:
  Baseline MAPE: 5.74%
  Enhanced MAPE: 3.75%
  MAPE Improvement: +1.99% (+34.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 276/464: MRCY
============================================================
📊 Loading data for MRCY...
📊 Loading data for MRCY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MRCY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MRCY...

==================================================
Training Baseline MRCY (SVM)
==================================================
Training SVM model...

Baseline MRCY Performance:
MAE: 227371.4532
RMSE: 279053.6404
MAPE: 4.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 207
   • Highly important features (top 5%): 93

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0003, rank=1
   2. Feature_78_t0: importance=0.0002, rank=2
   3. Feature_84_t0: importance=0.0002, rank=3
   4. Feature_80_t0: importance=0.0002, rank=4
   5. Feature_78_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for MRCY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MRCY...

==================================================
Training Enhanced MRCY (SVM)
==================================================
Training SVM model...

Enhanced MRCY Performance:
MAE: 218982.6063
RMSE: 285453.8795
MAPE: 4.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 70
   • Highly important features (top 5%): 42

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t0: importance=0.0007, rank=1
   2. Feature_2_t2: importance=0.0005, rank=2
   3. Feature_3_t3: importance=0.0004, rank=3
   4. Feature_13_t1: importance=0.0003, rank=4
   5. Feature_15_t2: importance=0.0003, rank=5

📊 MRCY Results:
  Baseline MAPE: 4.96%
  Enhanced MAPE: 4.81%
  MAPE Improvement: +0.15% (+2.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 277/464: MRTN
============================================================
📊 Loading data for MRTN...
📊 Loading data for MRTN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing MRTN: 'MRTN'

============================================================
TESTING TICKER 278/464: MSEX
============================================================
📊 Loading data for MSEX...
📊 Loading data for MSEX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MSEX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MSEX...

==================================================
Training Baseline MSEX (SVM)
==================================================
Training SVM model...

Baseline MSEX Performance:
MAE: 58062.6016
RMSE: 86990.1628
MAPE: 10.02%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 152
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t2: importance=0.0023, rank=1
   2. Feature_71_t2: importance=0.0012, rank=2
   3. Feature_88_t3: importance=0.0010, rank=3
   4. Feature_83_t3: importance=0.0006, rank=4
   5. Feature_94_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for MSEX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MSEX...

==================================================
Training Enhanced MSEX (SVM)
==================================================
Training SVM model...

Enhanced MSEX Performance:
MAE: 58358.1720
RMSE: 81520.2807
MAPE: 10.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 69
   • Highly important features (top 5%): 45

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0028, rank=1
   2. Feature_7_t3: importance=0.0017, rank=2
   3. Feature_1_t2: importance=0.0016, rank=3
   4. Feature_13_t0: importance=0.0013, rank=4
   5. Feature_14_t1: importance=0.0012, rank=5

📊 MSEX Results:
  Baseline MAPE: 10.02%
  Enhanced MAPE: 10.32%
  MAPE Improvement: -0.30% (-3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 279/464: MTH
============================================================
📊 Loading data for MTH...
📊 Loading data for MTH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MTH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MTH...

==================================================
Training Baseline MTH (SVM)
==================================================
Training SVM model...

Baseline MTH Performance:
MAE: 210998.7665
RMSE: 342365.5678
MAPE: 13.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 365
   • Highly important features (top 5%): 254

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t3: importance=0.0006, rank=1
   2. Feature_77_t3: importance=0.0005, rank=2
   3. Feature_89_t2: importance=0.0004, rank=3
   4. Feature_92_t2: importance=0.0004, rank=4
   5. Feature_76_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for MTH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MTH...

==================================================
Training Enhanced MTH (SVM)
==================================================
Training SVM model...

Enhanced MTH Performance:
MAE: 218073.5008
RMSE: 334609.7189
MAPE: 13.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0010, rank=1
   2. Feature_14_t0: importance=0.0009, rank=2
   3. Feature_15_t3: importance=0.0008, rank=3
   4. Feature_13_t0: importance=0.0007, rank=4
   5. Feature_11_t2: importance=0.0007, rank=5

📊 MTH Results:
  Baseline MAPE: 13.01%
  Enhanced MAPE: 13.52%
  MAPE Improvement: -0.52% (-4.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 280/464: MTRN
============================================================
📊 Loading data for MTRN...
📊 Loading data for MTRN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MTRN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MTRN...

==================================================
Training Baseline MTRN (SVM)
==================================================
Training SVM model...

Baseline MTRN Performance:
MAE: 29803.8738
RMSE: 42035.0382
MAPE: 8.63%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 147
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_86_t3: importance=0.0015, rank=1
   2. Feature_70_t0: importance=0.0014, rank=2
   3. Feature_96_t2: importance=0.0011, rank=3
   4. Feature_82_t3: importance=0.0009, rank=4
   5. Feature_87_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for MTRN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MTRN...

==================================================
Training Enhanced MTRN (SVM)
==================================================
Training SVM model...

Enhanced MTRN Performance:
MAE: 30370.2919
RMSE: 40029.0245
MAPE: 8.79%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t3: importance=0.0020, rank=1
   2. Feature_7_t1: importance=0.0017, rank=2
   3. Feature_17_t2: importance=0.0014, rank=3
   4. Feature_7_t2: importance=0.0012, rank=4
   5. Feature_0_t3: importance=0.0012, rank=5

📊 MTRN Results:
  Baseline MAPE: 8.63%
  Enhanced MAPE: 8.79%
  MAPE Improvement: -0.16% (-1.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 281/464: MTX
============================================================
📊 Loading data for MTX...
📊 Loading data for MTX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MTX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MTX...

==================================================
Training Baseline MTX (SVM)
==================================================
Training SVM model...

Baseline MTX Performance:
MAE: 46832.2766
RMSE: 56189.9267
MAPE: 12.36%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 295
   • Highly important features (top 5%): 152

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t2: importance=0.0008, rank=1
   2. Feature_78_t1: importance=0.0007, rank=2
   3. Feature_81_t1: importance=0.0006, rank=3
   4. Feature_93_t0: importance=0.0006, rank=4
   5. Feature_93_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for MTX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MTX...

==================================================
Training Enhanced MTX (SVM)
==================================================
Training SVM model...

Enhanced MTX Performance:
MAE: 40762.0742
RMSE: 54724.7208
MAPE: 10.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t1: importance=0.0017, rank=1
   2. Feature_15_t1: importance=0.0011, rank=2
   3. Feature_22_t1: importance=0.0011, rank=3
   4. Feature_15_t3: importance=0.0011, rank=4
   5. Feature_22_t2: importance=0.0010, rank=5

📊 MTX Results:
  Baseline MAPE: 12.36%
  Enhanced MAPE: 10.65%
  MAPE Improvement: +1.71% (+13.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 282/464: MWA
============================================================
📊 Loading data for MWA...
📊 Loading data for MWA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MWA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MWA...

==================================================
Training Baseline MWA (SVM)
==================================================
Training SVM model...

Baseline MWA Performance:
MAE: 511898.8346
RMSE: 778834.7397
MAPE: 13.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 351
   • Highly important features (top 5%): 200

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0004, rank=1
   2. Feature_70_t1: importance=0.0003, rank=2
   3. Feature_69_t1: importance=0.0002, rank=3
   4. Feature_73_t1: importance=0.0002, rank=4
   5. Feature_83_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for MWA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MWA...

==================================================
Training Enhanced MWA (SVM)
==================================================
Training SVM model...

Enhanced MWA Performance:
MAE: 485538.9616
RMSE: 768480.5683
MAPE: 12.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0006, rank=1
   2. Feature_7_t0: importance=0.0006, rank=2
   3. Feature_12_t3: importance=0.0005, rank=3
   4. Feature_22_t0: importance=0.0005, rank=4
   5. Feature_17_t0: importance=0.0004, rank=5

📊 MWA Results:
  Baseline MAPE: 13.66%
  Enhanced MAPE: 12.88%
  MAPE Improvement: +0.78% (+5.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 283/464: MXL
============================================================
📊 Loading data for MXL...
📊 Loading data for MXL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing MXL: 'MXL'

============================================================
TESTING TICKER 284/464: MYGN
============================================================
📊 Loading data for MYGN...
📊 Loading data for MYGN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MYGN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MYGN...

==================================================
Training Baseline MYGN (SVM)
==================================================
Training SVM model...

Baseline MYGN Performance:
MAE: 544015.4218
RMSE: 736301.2770
MAPE: 10.49%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 212
   • Highly important features (top 5%): 129

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_86_t1: importance=0.0002, rank=1
   2. Feature_88_t3: importance=0.0002, rank=2
   3. Feature_85_t1: importance=0.0002, rank=3
   4. Feature_65_t2: importance=0.0002, rank=4
   5. Feature_74_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for MYGN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MYGN...

==================================================
Training Enhanced MYGN (SVM)
==================================================
Training SVM model...

Enhanced MYGN Performance:
MAE: 537658.5799
RMSE: 733540.1876
MAPE: 10.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 75
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t0: importance=0.0004, rank=1
   2. Feature_1_t1: importance=0.0003, rank=2
   3. Feature_7_t1: importance=0.0003, rank=3
   4. Feature_17_t1: importance=0.0003, rank=4
   5. Feature_20_t0: importance=0.0002, rank=5

📊 MYGN Results:
  Baseline MAPE: 10.49%
  Enhanced MAPE: 10.15%
  MAPE Improvement: +0.34% (+3.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 285/464: MYRG
============================================================
📊 Loading data for MYRG...
📊 Loading data for MYRG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for MYRG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for MYRG...

==================================================
Training Baseline MYRG (SVM)
==================================================
Training SVM model...

Baseline MYRG Performance:
MAE: 79742.8888
RMSE: 106336.5007
MAPE: 12.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 230
   • Highly important features (top 5%): 154

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t1: importance=0.0006, rank=1
   2. Feature_82_t1: importance=0.0005, rank=2
   3. Feature_84_t3: importance=0.0005, rank=3
   4. Feature_96_t1: importance=0.0005, rank=4
   5. Feature_73_t0: importance=0.0005, rank=5

🔧 Applying universal feature engineering for MYRG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for MYRG...

==================================================
Training Enhanced MYRG (SVM)
==================================================
Training SVM model...

Enhanced MYRG Performance:
MAE: 78196.2150
RMSE: 102697.2915
MAPE: 11.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t1: importance=0.0014, rank=1
   2. Feature_19_t1: importance=0.0009, rank=2
   3. Feature_23_t3: importance=0.0009, rank=3
   4. Feature_12_t3: importance=0.0008, rank=4
   5. Feature_7_t0: importance=0.0006, rank=5

📊 MYRG Results:
  Baseline MAPE: 12.37%
  Enhanced MAPE: 11.86%
  MAPE Improvement: +0.51% (+4.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 286/464: NAVI
============================================================
📊 Loading data for NAVI...
📊 Loading data for NAVI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NAVI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NAVI...

==================================================
Training Baseline NAVI (SVM)
==================================================
Training SVM model...

Baseline NAVI Performance:
MAE: 433226.6418
RMSE: 554119.8593
MAPE: 5.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 158
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t0: importance=0.0001, rank=1
   2. Feature_82_t2: importance=0.0001, rank=2
   3. Feature_90_t0: importance=0.0001, rank=3
   4. Feature_64_t1: importance=0.0001, rank=4
   5. Feature_69_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for NAVI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NAVI...

==================================================
Training Enhanced NAVI (SVM)
==================================================
Training SVM model...

Enhanced NAVI Performance:
MAE: 434742.3370
RMSE: 551593.1631
MAPE: 5.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0005, rank=1
   2. Feature_15_t2: importance=0.0002, rank=2
   3. Feature_2_t3: importance=0.0002, rank=3
   4. Feature_9_t3: importance=0.0002, rank=4
   5. Feature_11_t3: importance=0.0001, rank=5

📊 NAVI Results:
  Baseline MAPE: 5.32%
  Enhanced MAPE: 5.34%
  MAPE Improvement: -0.03% (-0.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 287/464: NBHC
============================================================
📊 Loading data for NBHC...
📊 Loading data for NBHC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NBHC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NBHC...

==================================================
Training Baseline NBHC (SVM)
==================================================
Training SVM model...

Baseline NBHC Performance:
MAE: 74584.8843
RMSE: 98920.3540
MAPE: 11.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 335
   • Highly important features (top 5%): 182

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_76_t1: importance=0.0005, rank=1
   2. Feature_72_t3: importance=0.0004, rank=2
   3. Feature_68_t2: importance=0.0004, rank=3
   4. Feature_69_t3: importance=0.0004, rank=4
   5. Feature_67_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for NBHC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NBHC...

==================================================
Training Enhanced NBHC (SVM)
==================================================
Training SVM model...

Enhanced NBHC Performance:
MAE: 69336.4363
RMSE: 85316.0471
MAPE: 10.76%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0019, rank=1
   2. Feature_16_t3: importance=0.0018, rank=2
   3. Feature_15_t3: importance=0.0014, rank=3
   4. Feature_13_t0: importance=0.0010, rank=4
   5. Feature_1_t2: importance=0.0009, rank=5

📊 NBHC Results:
  Baseline MAPE: 11.70%
  Enhanced MAPE: 10.76%
  MAPE Improvement: +0.94% (+8.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 288/464: NBTB
============================================================
📊 Loading data for NBTB...
📊 Loading data for NBTB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NBTB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NBTB...

==================================================
Training Baseline NBTB (SVM)
==================================================
Training SVM model...

Baseline NBTB Performance:
MAE: 125092.0934
RMSE: 168731.3410
MAPE: 10.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 252
   • Highly important features (top 5%): 170

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t2: importance=0.0002, rank=1
   2. Feature_73_t3: importance=0.0001, rank=2
   3. Feature_71_t3: importance=0.0001, rank=3
   4. Feature_1_t2: importance=0.0001, rank=4
   5. Feature_69_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for NBTB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NBTB...

==================================================
Training Enhanced NBTB (SVM)
==================================================
Training SVM model...

Enhanced NBTB Performance:
MAE: 122421.7211
RMSE: 168603.8590
MAPE: 9.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t3: importance=0.0004, rank=1
   2. Feature_22_t0: importance=0.0003, rank=2
   3. Feature_7_t2: importance=0.0003, rank=3
   4. Feature_1_t3: importance=0.0002, rank=4
   5. Feature_17_t2: importance=0.0002, rank=5

📊 NBTB Results:
  Baseline MAPE: 10.16%
  Enhanced MAPE: 9.84%
  MAPE Improvement: +0.32% (+3.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 289/464: NEO
============================================================
📊 Loading data for NEO...
📊 Loading data for NEO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NEO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NEO...

==================================================
Training Baseline NEO (SVM)
==================================================
Training SVM model...

Baseline NEO Performance:
MAE: 563765.1393
RMSE: 696134.7352
MAPE: 11.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 158
   • Highly important features (top 5%): 106

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0007, rank=1
   2. Feature_0_t2: importance=0.0006, rank=2
   3. Feature_67_t1: importance=0.0004, rank=3
   4. Feature_67_t0: importance=0.0003, rank=4
   5. Feature_87_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for NEO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NEO...

==================================================
Training Enhanced NEO (SVM)
==================================================
Training SVM model...

Enhanced NEO Performance:
MAE: 449081.5034
RMSE: 588886.2692
MAPE: 9.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t0: importance=0.0007, rank=1
   2. Feature_19_t2: importance=0.0007, rank=2
   3. Feature_7_t1: importance=0.0006, rank=3
   4. Feature_17_t2: importance=0.0005, rank=4
   5. Feature_17_t0: importance=0.0005, rank=5

📊 NEO Results:
  Baseline MAPE: 11.10%
  Enhanced MAPE: 9.18%
  MAPE Improvement: +1.91% (+17.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 290/464: NEOG
============================================================
📊 Loading data for NEOG...
📊 Loading data for NEOG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NEOG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NEOG...

==================================================
Training Baseline NEOG (SVM)
==================================================
Training SVM model...

Baseline NEOG Performance:
MAE: 1600866.2211
RMSE: 2045372.3681
MAPE: 7.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 213
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0014, rank=1
   2. Feature_73_t2: importance=0.0010, rank=2
   3. Feature_2_t2: importance=0.0004, rank=3
   4. Feature_2_t1: importance=0.0004, rank=4
   5. Feature_2_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for NEOG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NEOG...

==================================================
Training Enhanced NEOG (SVM)
==================================================
Training SVM model...

Enhanced NEOG Performance:
MAE: 1486000.1429
RMSE: 1960589.6312
MAPE: 7.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 70
   • Highly important features (top 5%): 44

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t0: importance=0.0015, rank=1
   2. Feature_8_t3: importance=0.0013, rank=2
   3. Feature_24_t1: importance=0.0010, rank=3
   4. Feature_1_t3: importance=0.0009, rank=4
   5. Feature_8_t2: importance=0.0008, rank=5

📊 NEOG Results:
  Baseline MAPE: 7.67%
  Enhanced MAPE: 7.17%
  MAPE Improvement: +0.51% (+6.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 291/464: NGVT
============================================================
📊 Loading data for NGVT...
📊 Loading data for NGVT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NGVT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NGVT...

==================================================
Training Baseline NGVT (SVM)
==================================================
Training SVM model...

Baseline NGVT Performance:
MAE: 59693.1262
RMSE: 81882.3272
MAPE: 6.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 286
   • Highly important features (top 5%): 164

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_79_t3: importance=0.0005, rank=1
   2. Feature_93_t2: importance=0.0003, rank=2
   3. Feature_68_t3: importance=0.0002, rank=3
   4. Feature_75_t2: importance=0.0002, rank=4
   5. Feature_67_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for NGVT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NGVT...

==================================================
Training Enhanced NGVT (SVM)
==================================================
Training SVM model...

Enhanced NGVT Performance:
MAE: 62726.5899
RMSE: 84290.5076
MAPE: 6.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0005, rank=1
   2. Feature_19_t3: importance=0.0005, rank=2
   3. Feature_7_t0: importance=0.0004, rank=3
   4. Feature_19_t1: importance=0.0004, rank=4
   5. Feature_11_t3: importance=0.0003, rank=5

📊 NGVT Results:
  Baseline MAPE: 6.11%
  Enhanced MAPE: 6.34%
  MAPE Improvement: -0.23% (-3.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 292/464: NHC
============================================================
📊 Loading data for NHC...
📊 Loading data for NHC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NHC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NHC...

==================================================
Training Baseline NHC (SVM)
==================================================
Training SVM model...

Baseline NHC Performance:
MAE: 41401.2282
RMSE: 52254.0446
MAPE: 11.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 259
   • Highly important features (top 5%): 142

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t1: importance=0.0007, rank=1
   2. Feature_90_t3: importance=0.0006, rank=2
   3. Feature_70_t3: importance=0.0006, rank=3
   4. Feature_2_t3: importance=0.0005, rank=4
   5. Feature_1_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for NHC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NHC...

==================================================
Training Enhanced NHC (SVM)
==================================================
Training SVM model...

Enhanced NHC Performance:
MAE: 39704.7966
RMSE: 51655.8817
MAPE: 10.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0027, rank=1
   2. Feature_9_t3: importance=0.0013, rank=2
   3. Feature_17_t3: importance=0.0011, rank=3
   4. Feature_13_t1: importance=0.0009, rank=4
   5. Feature_11_t0: importance=0.0007, rank=5

📊 NHC Results:
  Baseline MAPE: 11.40%
  Enhanced MAPE: 10.89%
  MAPE Improvement: +0.51% (+4.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 293/464: NMIH
============================================================
📊 Loading data for NMIH...
📊 Loading data for NMIH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NMIH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NMIH...

==================================================
Training Baseline NMIH (SVM)
==================================================
Training SVM model...

Baseline NMIH Performance:
MAE: 188349.4716
RMSE: 254903.0846
MAPE: 12.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 342
   • Highly important features (top 5%): 192

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t2: importance=0.0006, rank=1
   2. Feature_77_t0: importance=0.0004, rank=2
   3. Feature_92_t3: importance=0.0004, rank=3
   4. Feature_89_t0: importance=0.0004, rank=4
   5. Feature_0_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for NMIH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NMIH...

==================================================
Training Enhanced NMIH (SVM)
==================================================
Training SVM model...

Enhanced NMIH Performance:
MAE: 191610.5637
RMSE: 233995.5157
MAPE: 12.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t0: importance=0.0025, rank=1
   2. Feature_14_t2: importance=0.0012, rank=2
   3. Feature_13_t1: importance=0.0009, rank=3
   4. Feature_17_t1: importance=0.0008, rank=4
   5. Feature_9_t2: importance=0.0008, rank=5

📊 NMIH Results:
  Baseline MAPE: 12.62%
  Enhanced MAPE: 12.78%
  MAPE Improvement: -0.16% (-1.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 294/464: NOG
============================================================
📊 Loading data for NOG...
📊 Loading data for NOG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NOG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NOG...

==================================================
Training Baseline NOG (SVM)
==================================================
Training SVM model...

Baseline NOG Performance:
MAE: 936703.2994
RMSE: 1214630.3810
MAPE: 6.33%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 161
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t3: importance=0.0020, rank=1
   2. Feature_93_t1: importance=0.0018, rank=2
   3. Feature_67_t2: importance=0.0017, rank=3
   4. Feature_65_t3: importance=0.0016, rank=4
   5. Feature_94_t1: importance=0.0015, rank=5

🔧 Applying universal feature engineering for NOG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NOG...

==================================================
Training Enhanced NOG (SVM)
==================================================
Training SVM model...

Enhanced NOG Performance:
MAE: 1049016.7029
RMSE: 1402606.3644
MAPE: 7.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 59
   • Highly important features (top 5%): 26

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0090, rank=1
   2. Feature_8_t1: importance=0.0039, rank=2
   3. Feature_13_t0: importance=0.0034, rank=3
   4. Feature_5_t3: importance=0.0028, rank=4
   5. Feature_17_t1: importance=0.0028, rank=5

📊 NOG Results:
  Baseline MAPE: 6.33%
  Enhanced MAPE: 7.15%
  MAPE Improvement: -0.82% (-13.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 295/464: NPK
============================================================
📊 Loading data for NPK...
📊 Loading data for NPK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing NPK: 'NPK'

============================================================
TESTING TICKER 296/464: NPO
============================================================
📊 Loading data for NPO...
📊 Loading data for NPO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NPO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NPO...

==================================================
Training Baseline NPO (SVM)
==================================================
Training SVM model...

Baseline NPO Performance:
MAE: 52041.3669
RMSE: 80844.0844
MAPE: 11.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 198
   • Highly important features (top 5%): 111

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_86_t2: importance=0.0009, rank=1
   2. Feature_83_t1: importance=0.0006, rank=2
   3. Feature_67_t3: importance=0.0004, rank=3
   4. Feature_80_t2: importance=0.0003, rank=4
   5. Feature_86_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for NPO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NPO...

==================================================
Training Enhanced NPO (SVM)
==================================================
Training SVM model...

Enhanced NPO Performance:
MAE: 52853.4804
RMSE: 82074.3334
MAPE: 11.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 49

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0016, rank=1
   2. Feature_19_t1: importance=0.0011, rank=2
   3. Feature_13_t1: importance=0.0009, rank=3
   4. Feature_13_t2: importance=0.0009, rank=4
   5. Feature_12_t2: importance=0.0008, rank=5

📊 NPO Results:
  Baseline MAPE: 11.23%
  Enhanced MAPE: 11.57%
  MAPE Improvement: -0.34% (-3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 297/464: NSIT
============================================================
📊 Loading data for NSIT...
📊 Loading data for NSIT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NSIT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NSIT...

==================================================
Training Baseline NSIT (SVM)
==================================================
Training SVM model...

Baseline NSIT Performance:
MAE: 187812.4874
RMSE: 308535.1305
MAPE: 9.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 95
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0008, rank=1
   2. Feature_90_t3: importance=0.0007, rank=2
   3. Feature_63_t2: importance=0.0003, rank=3
   4. Feature_69_t3: importance=0.0003, rank=4
   5. Feature_90_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for NSIT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NSIT...

==================================================
Training Enhanced NSIT (SVM)
==================================================
Training SVM model...

Enhanced NSIT Performance:
MAE: 202788.4500
RMSE: 315486.6810
MAPE: 10.82%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0006, rank=1
   2. Feature_24_t0: importance=0.0006, rank=2
   3. Feature_16_t2: importance=0.0005, rank=3
   4. Feature_10_t3: importance=0.0005, rank=4
   5. Feature_7_t1: importance=0.0005, rank=5

📊 NSIT Results:
  Baseline MAPE: 9.91%
  Enhanced MAPE: 10.82%
  MAPE Improvement: -0.90% (-9.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 298/464: NTCT
============================================================
📊 Loading data for NTCT...
📊 Loading data for NTCT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NTCT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NTCT...

==================================================
Training Baseline NTCT (SVM)
==================================================
Training SVM model...

Baseline NTCT Performance:
MAE: 185570.0126
RMSE: 248632.7539
MAPE: 11.33%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 213
   • Highly important features (top 5%): 124

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_93_t1: importance=0.0002, rank=1
   2. Feature_80_t1: importance=0.0002, rank=2
   3. Feature_71_t3: importance=0.0001, rank=3
   4. Feature_60_t0: importance=0.0001, rank=4
   5. Feature_94_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for NTCT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NTCT...

==================================================
Training Enhanced NTCT (SVM)
==================================================
Training SVM model...

Enhanced NTCT Performance:
MAE: 206186.8595
RMSE: 272889.2590
MAPE: 12.63%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0004, rank=1
   2. Feature_19_t2: importance=0.0004, rank=2
   3. Feature_20_t1: importance=0.0004, rank=3
   4. Feature_10_t1: importance=0.0004, rank=4
   5. Feature_20_t3: importance=0.0003, rank=5

📊 NTCT Results:
  Baseline MAPE: 11.33%
  Enhanced MAPE: 12.63%
  MAPE Improvement: -1.30% (-11.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 299/464: NWBI
============================================================
📊 Loading data for NWBI...
📊 Loading data for NWBI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NWBI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NWBI...

==================================================
Training Baseline NWBI (SVM)
==================================================
Training SVM model...

Baseline NWBI Performance:
MAE: 259019.8635
RMSE: 328387.5057
MAPE: 7.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 189
   • Highly important features (top 5%): 119

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t1: importance=0.0001, rank=1
   2. Feature_87_t2: importance=0.0001, rank=2
   3. Feature_66_t0: importance=0.0001, rank=3
   4. Feature_85_t1: importance=0.0001, rank=4
   5. Feature_89_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for NWBI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NWBI...

==================================================
Training Enhanced NWBI (SVM)
==================================================
Training SVM model...

Enhanced NWBI Performance:
MAE: 236013.9065
RMSE: 317931.8804
MAPE: 6.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t2: importance=0.0004, rank=1
   2. Feature_11_t2: importance=0.0003, rank=2
   3. Feature_23_t2: importance=0.0002, rank=3
   4. Feature_17_t3: importance=0.0001, rank=4
   5. Feature_19_t1: importance=0.0001, rank=5

📊 NWBI Results:
  Baseline MAPE: 7.54%
  Enhanced MAPE: 6.83%
  MAPE Improvement: +0.71% (+9.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 300/464: NWL
============================================================
📊 Loading data for NWL...
📊 Loading data for NWL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing NWL: 'NWL'

============================================================
TESTING TICKER 301/464: NWN
============================================================
📊 Loading data for NWN...
📊 Loading data for NWN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NWN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NWN...

==================================================
Training Baseline NWN (SVM)
==================================================
Training SVM model...

Baseline NWN Performance:
MAE: 144668.7140
RMSE: 212204.0940
MAPE: 17.20%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 95
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t1: importance=0.0032, rank=1
   2. Feature_65_t0: importance=0.0026, rank=2
   3. Feature_0_t3: importance=0.0022, rank=3
   4. Feature_86_t2: importance=0.0011, rank=4
   5. Feature_88_t0: importance=0.0011, rank=5

🔧 Applying universal feature engineering for NWN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NWN...

==================================================
Training Enhanced NWN (SVM)
==================================================
Training SVM model...

Enhanced NWN Performance:
MAE: 145516.6447
RMSE: 214352.0110
MAPE: 17.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 26

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t1: importance=0.0036, rank=1
   2. Feature_15_t3: importance=0.0034, rank=2
   3. Feature_5_t0: importance=0.0025, rank=3
   4. Feature_1_t0: importance=0.0019, rank=4
   5. Feature_22_t1: importance=0.0016, rank=5

📊 NWN Results:
  Baseline MAPE: 17.20%
  Enhanced MAPE: 17.31%
  MAPE Improvement: -0.11% (-0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 302/464: NX
============================================================
📊 Loading data for NX...
📊 Loading data for NX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NX...

==================================================
Training Baseline NX (SVM)
==================================================
Training SVM model...

Baseline NX Performance:
MAE: 238287.7542
RMSE: 376878.3070
MAPE: 13.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 283
   • Highly important features (top 5%): 157

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t3: importance=0.0002, rank=1
   2. Feature_65_t1: importance=0.0002, rank=2
   3. Feature_82_t3: importance=0.0002, rank=3
   4. Feature_63_t3: importance=0.0001, rank=4
   5. Feature_68_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for NX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NX...

==================================================
Training Enhanced NX (SVM)
==================================================
Training SVM model...

Enhanced NX Performance:
MAE: 229556.2654
RMSE: 365472.6268
MAPE: 12.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0004, rank=1
   2. Feature_11_t3: importance=0.0002, rank=2
   3. Feature_10_t3: importance=0.0002, rank=3
   4. Feature_23_t3: importance=0.0002, rank=4
   5. Feature_18_t3: importance=0.0002, rank=5

📊 NX Results:
  Baseline MAPE: 13.14%
  Enhanced MAPE: 12.88%
  MAPE Improvement: +0.26% (+2.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 303/464: NXRT
============================================================
📊 Loading data for NXRT...
📊 Loading data for NXRT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for NXRT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for NXRT...

==================================================
Training Baseline NXRT (SVM)
==================================================
Training SVM model...

Baseline NXRT Performance:
MAE: 55018.0133
RMSE: 71165.3271
MAPE: 13.92%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 119
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t1: importance=0.0013, rank=1
   2. Feature_78_t0: importance=0.0009, rank=2
   3. Feature_91_t3: importance=0.0009, rank=3
   4. Feature_90_t3: importance=0.0008, rank=4
   5. Feature_2_t0: importance=0.0008, rank=5

🔧 Applying universal feature engineering for NXRT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for NXRT...

==================================================
Training Enhanced NXRT (SVM)
==================================================
Training SVM model...

Enhanced NXRT Performance:
MAE: 63429.8582
RMSE: 79548.3746
MAPE: 17.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t3: importance=0.0021, rank=1
   2. Feature_17_t2: importance=0.0019, rank=2
   3. Feature_17_t3: importance=0.0017, rank=3
   4. Feature_20_t2: importance=0.0015, rank=4
   5. Feature_21_t2: importance=0.0014, rank=5

📊 NXRT Results:
  Baseline MAPE: 13.92%
  Enhanced MAPE: 17.30%
  MAPE Improvement: -3.37% (-24.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 304/464: OFG
============================================================
📊 Loading data for OFG...
📊 Loading data for OFG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OFG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OFG...

==================================================
Training Baseline OFG (SVM)
==================================================
Training SVM model...

Baseline OFG Performance:
MAE: 119969.4817
RMSE: 170299.9042
MAPE: 23.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 229
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t3: importance=0.0011, rank=1
   2. Feature_93_t0: importance=0.0007, rank=2
   3. Feature_77_t1: importance=0.0007, rank=3
   4. Feature_64_t0: importance=0.0007, rank=4
   5. Feature_79_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for OFG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OFG...

==================================================
Training Enhanced OFG (SVM)
==================================================
Training SVM model...

Enhanced OFG Performance:
MAE: 135306.1160
RMSE: 172620.8398
MAPE: 25.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0022, rank=1
   2. Feature_19_t0: importance=0.0021, rank=2
   3. Feature_12_t0: importance=0.0020, rank=3
   4. Feature_5_t0: importance=0.0019, rank=4
   5. Feature_22_t3: importance=0.0014, rank=5

📊 OFG Results:
  Baseline MAPE: 23.64%
  Enhanced MAPE: 25.19%
  MAPE Improvement: -1.55% (-6.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 305/464: OI
============================================================
📊 Loading data for OI...
📊 Loading data for OI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OI...

==================================================
Training Baseline OI (SVM)
==================================================
Training SVM model...

Baseline OI Performance:
MAE: 586576.9909
RMSE: 770140.0943
MAPE: 10.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 169
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t2: importance=0.0006, rank=1
   2. Feature_2_t3: importance=0.0004, rank=2
   3. Feature_87_t2: importance=0.0003, rank=3
   4. Feature_91_t0: importance=0.0003, rank=4
   5. Feature_2_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for OI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OI...

==================================================
Training Enhanced OI (SVM)
==================================================
Training SVM model...

Enhanced OI Performance:
MAE: 501995.8267
RMSE: 669766.3245
MAPE: 9.32%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0007, rank=1
   2. Feature_7_t1: importance=0.0006, rank=2
   3. Feature_20_t1: importance=0.0005, rank=3
   4. Feature_4_t2: importance=0.0004, rank=4
   5. Feature_2_t0: importance=0.0004, rank=5

📊 OI Results:
  Baseline MAPE: 10.69%
  Enhanced MAPE: 9.32%
  MAPE Improvement: +1.37% (+12.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 306/464: OII
============================================================
📊 Loading data for OII...
📊 Loading data for OII from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OII...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OII...

==================================================
Training Baseline OII (SVM)
==================================================
Training SVM model...

Baseline OII Performance:
MAE: 307827.6696
RMSE: 382780.0576
MAPE: 7.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 238
   • Highly important features (top 5%): 135

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t2: importance=0.0006, rank=1
   2. Feature_89_t1: importance=0.0005, rank=2
   3. Feature_84_t1: importance=0.0004, rank=3
   4. Feature_83_t2: importance=0.0004, rank=4
   5. Feature_82_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for OII...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OII...

==================================================
Training Enhanced OII (SVM)
==================================================
Training SVM model...

Enhanced OII Performance:
MAE: 277702.7258
RMSE: 334408.7950
MAPE: 6.39%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t2: importance=0.0012, rank=1
   2. Feature_11_t3: importance=0.0010, rank=2
   3. Feature_22_t3: importance=0.0009, rank=3
   4. Feature_15_t3: importance=0.0008, rank=4
   5. Feature_5_t1: importance=0.0007, rank=5

📊 OII Results:
  Baseline MAPE: 7.00%
  Enhanced MAPE: 6.39%
  MAPE Improvement: +0.61% (+8.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 307/464: OMCL
============================================================
📊 Loading data for OMCL...
📊 Loading data for OMCL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OMCL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OMCL...

==================================================
Training Baseline OMCL (SVM)
==================================================
Training SVM model...

Baseline OMCL Performance:
MAE: 191083.8494
RMSE: 254423.5227
MAPE: 9.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 81
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t0: importance=0.0002, rank=1
   2. Feature_2_t0: importance=0.0001, rank=2
   3. Feature_90_t2: importance=0.0001, rank=3
   4. Feature_0_t1: importance=0.0001, rank=4
   5. Feature_85_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for OMCL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OMCL...

==================================================
Training Enhanced OMCL (SVM)
==================================================
Training SVM model...

Enhanced OMCL Performance:
MAE: 181111.7945
RMSE: 248296.0709
MAPE: 9.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0002, rank=1
   2. Feature_22_t2: importance=0.0002, rank=2
   3. Feature_20_t2: importance=0.0002, rank=3
   4. Feature_7_t3: importance=0.0001, rank=4
   5. Feature_18_t0: importance=0.0001, rank=5

📊 OMCL Results:
  Baseline MAPE: 9.65%
  Enhanced MAPE: 9.10%
  MAPE Improvement: +0.55% (+5.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 308/464: OSIS
============================================================
📊 Loading data for OSIS...
📊 Loading data for OSIS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OSIS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OSIS...

==================================================
Training Baseline OSIS (SVM)
==================================================
Training SVM model...

Baseline OSIS Performance:
MAE: 103051.1516
RMSE: 160824.6349
MAPE: 8.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 216
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_91_t0: importance=0.0002, rank=1
   2. Feature_80_t1: importance=0.0002, rank=2
   3. Feature_84_t3: importance=0.0001, rank=3
   4. Feature_81_t2: importance=0.0001, rank=4
   5. Feature_73_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for OSIS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OSIS...

==================================================
Training Enhanced OSIS (SVM)
==================================================
Training SVM model...

Enhanced OSIS Performance:
MAE: 103278.7035
RMSE: 163809.9471
MAPE: 9.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 45
   • Highly important features (top 5%): 18

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0008, rank=1
   2. Feature_7_t1: importance=0.0003, rank=2
   3. Feature_20_t2: importance=0.0003, rank=3
   4. Feature_15_t2: importance=0.0003, rank=4
   5. Feature_19_t0: importance=0.0002, rank=5

📊 OSIS Results:
  Baseline MAPE: 8.65%
  Enhanced MAPE: 9.00%
  MAPE Improvement: -0.35% (-4.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 309/464: OTTR
============================================================
📊 Loading data for OTTR...
📊 Loading data for OTTR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OTTR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OTTR...

==================================================
Training Baseline OTTR (SVM)
==================================================
Training SVM model...

Baseline OTTR Performance:
MAE: 185100.6918
RMSE: 240185.2422
MAPE: 5.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 111
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0019, rank=1
   2. Feature_65_t2: importance=0.0015, rank=2
   3. Feature_63_t0: importance=0.0012, rank=3
   4. Feature_64_t1: importance=0.0012, rank=4
   5. Feature_65_t1: importance=0.0012, rank=5

🔧 Applying universal feature engineering for OTTR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OTTR...

==================================================
Training Enhanced OTTR (SVM)
==================================================
Training SVM model...

Enhanced OTTR Performance:
MAE: 219998.4352
RMSE: 289152.9664
MAPE: 6.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 77
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0033, rank=1
   2. Feature_22_t0: importance=0.0027, rank=2
   3. Feature_24_t0: importance=0.0026, rank=3
   4. Feature_17_t0: importance=0.0023, rank=4
   5. Feature_20_t0: importance=0.0022, rank=5

📊 OTTR Results:
  Baseline MAPE: 5.28%
  Enhanced MAPE: 6.57%
  MAPE Improvement: -1.28% (-24.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 310/464: OUT
============================================================
📊 Loading data for OUT...
📊 Loading data for OUT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OUT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OUT...

==================================================
Training Baseline OUT (SVM)
==================================================
Training SVM model...

Baseline OUT Performance:
MAE: 1089656.3107
RMSE: 1443738.0500
MAPE: 11.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 285
   • Highly important features (top 5%): 155

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0007, rank=1
   2. Feature_72_t2: importance=0.0006, rank=2
   3. Feature_84_t3: importance=0.0005, rank=3
   4. Feature_65_t1: importance=0.0005, rank=4
   5. Feature_90_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for OUT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OUT...

==================================================
Training Enhanced OUT (SVM)
==================================================
Training SVM model...

Enhanced OUT Performance:
MAE: 1080698.6454
RMSE: 1498937.6454
MAPE: 10.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0013, rank=1
   2. Feature_12_t3: importance=0.0009, rank=2
   3. Feature_1_t3: importance=0.0009, rank=3
   4. Feature_5_t1: importance=0.0009, rank=4
   5. Feature_17_t3: importance=0.0009, rank=5

📊 OUT Results:
  Baseline MAPE: 11.06%
  Enhanced MAPE: 10.51%
  MAPE Improvement: +0.55% (+4.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 311/464: OXM
============================================================
📊 Loading data for OXM...
📊 Loading data for OXM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for OXM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for OXM...

==================================================
Training Baseline OXM (SVM)
==================================================
Training SVM model...

Baseline OXM Performance:
MAE: 148892.6976
RMSE: 193839.9445
MAPE: 6.55%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 233
   • Highly important features (top 5%): 131

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t2: importance=0.0002, rank=1
   2. Feature_65_t1: importance=0.0002, rank=2
   3. Feature_65_t2: importance=0.0002, rank=3
   4. Feature_75_t1: importance=0.0001, rank=4
   5. Feature_78_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for OXM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for OXM...

==================================================
Training Enhanced OXM (SVM)
==================================================
Training SVM model...

Enhanced OXM Performance:
MAE: 141946.8439
RMSE: 186180.7752
MAPE: 6.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 69

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0005, rank=1
   2. Feature_15_t3: importance=0.0004, rank=2
   3. Feature_7_t2: importance=0.0003, rank=3
   4. Feature_15_t1: importance=0.0003, rank=4
   5. Feature_17_t1: importance=0.0003, rank=5

📊 OXM Results:
  Baseline MAPE: 6.55%
  Enhanced MAPE: 6.24%
  MAPE Improvement: +0.31% (+4.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 312/464: PAHC
============================================================
📊 Loading data for PAHC...
📊 Loading data for PAHC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing PAHC: 'PAHC'

============================================================
TESTING TICKER 313/464: PARR
============================================================
📊 Loading data for PARR...
📊 Loading data for PARR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PARR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PARR...

==================================================
Training Baseline PARR (SVM)
==================================================
Training SVM model...

Baseline PARR Performance:
MAE: 425965.6366
RMSE: 569595.3435
MAPE: 12.63%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 238
   • Highly important features (top 5%): 132

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t2: importance=0.0008, rank=1
   2. Feature_73_t2: importance=0.0008, rank=2
   3. Feature_94_t2: importance=0.0005, rank=3
   4. Feature_75_t3: importance=0.0004, rank=4
   5. Feature_65_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for PARR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PARR...

==================================================
Training Enhanced PARR (SVM)
==================================================
Training SVM model...

Enhanced PARR Performance:
MAE: 380994.7282
RMSE: 554380.0227
MAPE: 10.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0011, rank=1
   2. Feature_20_t1: importance=0.0005, rank=2
   3. Feature_17_t3: importance=0.0005, rank=3
   4. Feature_4_t2: importance=0.0005, rank=4
   5. Feature_22_t2: importance=0.0004, rank=5

📊 PARR Results:
  Baseline MAPE: 12.63%
  Enhanced MAPE: 10.83%
  MAPE Improvement: +1.80% (+14.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 314/464: PATK
============================================================
📊 Loading data for PATK...
📊 Loading data for PATK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PATK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PATK...

==================================================
Training Baseline PATK (SVM)
==================================================
Training SVM model...

Baseline PATK Performance:
MAE: 147633.8550
RMSE: 174424.2836
MAPE: 7.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 58
   • Highly important features (top 5%): 42

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t0: importance=0.0009, rank=1
   2. Feature_85_t3: importance=0.0003, rank=2
   3. Feature_93_t0: importance=0.0002, rank=3
   4. Feature_91_t0: importance=0.0002, rank=4
   5. Feature_75_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PATK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PATK...

==================================================
Training Enhanced PATK (SVM)
==================================================
Training SVM model...

Enhanced PATK Performance:
MAE: 149410.4763
RMSE: 188025.7237
MAPE: 7.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 32
   • Highly important features (top 5%): 16

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t0: importance=0.0011, rank=1
   2. Feature_20_t0: importance=0.0005, rank=2
   3. Feature_13_t1: importance=0.0004, rank=3
   4. Feature_22_t1: importance=0.0003, rank=4
   5. Feature_14_t1: importance=0.0002, rank=5

📊 PATK Results:
  Baseline MAPE: 7.61%
  Enhanced MAPE: 7.41%
  MAPE Improvement: +0.20% (+2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 315/464: PBH
============================================================
📊 Loading data for PBH...
📊 Loading data for PBH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PBH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PBH...

==================================================
Training Baseline PBH (SVM)
==================================================
Training SVM model...

Baseline PBH Performance:
MAE: 139654.9580
RMSE: 179887.2990
MAPE: 7.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 106
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_94_t0: importance=0.0002, rank=1
   2. Feature_82_t1: importance=0.0001, rank=2
   3. Feature_79_t2: importance=0.0001, rank=3
   4. Feature_0_t0: importance=0.0001, rank=4
   5. Feature_2_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for PBH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PBH...

==================================================
Training Enhanced PBH (SVM)
==================================================
Training SVM model...

Enhanced PBH Performance:
MAE: 150207.7036
RMSE: 188324.3840
MAPE: 7.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t3: importance=0.0002, rank=1
   2. Feature_11_t2: importance=0.0002, rank=2
   3. Feature_20_t3: importance=0.0002, rank=3
   4. Feature_9_t0: importance=0.0002, rank=4
   5. Feature_7_t3: importance=0.0002, rank=5

📊 PBH Results:
  Baseline MAPE: 7.62%
  Enhanced MAPE: 7.94%
  MAPE Improvement: -0.31% (-4.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 316/464: PBI
============================================================
📊 Loading data for PBI...
📊 Loading data for PBI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PBI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PBI...

==================================================
Training Baseline PBI (SVM)
==================================================
Training SVM model...

Baseline PBI Performance:
MAE: 985694.3350
RMSE: 1222270.4882
MAPE: 8.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 209
   • Highly important features (top 5%): 126

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t2: importance=0.0022, rank=1
   2. Feature_70_t2: importance=0.0017, rank=2
   3. Feature_64_t3: importance=0.0003, rank=3
   4. Feature_78_t1: importance=0.0002, rank=4
   5. Feature_65_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PBI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PBI...

==================================================
Training Enhanced PBI (SVM)
==================================================
Training SVM model...

Enhanced PBI Performance:
MAE: 975236.1922
RMSE: 1292857.4325
MAPE: 8.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 42
   • Highly important features (top 5%): 23

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t1: importance=0.0020, rank=1
   2. Feature_1_t3: importance=0.0014, rank=2
   3. Feature_12_t0: importance=0.0009, rank=3
   4. Feature_6_t2: importance=0.0009, rank=4
   5. Feature_22_t1: importance=0.0006, rank=5

📊 PBI Results:
  Baseline MAPE: 8.65%
  Enhanced MAPE: 8.66%
  MAPE Improvement: -0.01% (-0.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 317/464: PCRX
============================================================
📊 Loading data for PCRX...
📊 Loading data for PCRX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PCRX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'PCRX' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PCRX...

==================================================
Training Baseline PCRX (SVM)
==================================================
Training SVM model...

Baseline PCRX Performance:
MAE: 423912.2054
RMSE: 609282.2624
MAPE: 7.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 36
   • Highly important features (top 5%): 11

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t0: importance=0.0006, rank=1
   2. Feature_66_t3: importance=0.0006, rank=2
   3. Feature_65_t1: importance=0.0003, rank=3
   4. Feature_65_t3: importance=0.0002, rank=4
   5. Feature_2_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PCRX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PCRX...

==================================================
Training Enhanced PCRX (SVM)
==================================================
Training SVM model...

Enhanced PCRX Performance:
MAE: 394784.9000
RMSE: 590088.2381
MAPE: 7.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 61
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0003, rank=1
   2. Feature_5_t0: importance=0.0002, rank=2
   3. Feature_22_t1: importance=0.0002, rank=3
   4. Feature_5_t1: importance=0.0002, rank=4
   5. Feature_5_t3: importance=0.0002, rank=5

📊 PCRX Results:
  Baseline MAPE: 7.83%
  Enhanced MAPE: 7.37%
  MAPE Improvement: +0.47% (+5.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 318/464: PDFS
============================================================
📊 Loading data for PDFS...
📊 Loading data for PDFS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PDFS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PDFS...

==================================================
Training Baseline PDFS (SVM)
==================================================
Training SVM model...

Baseline PDFS Performance:
MAE: 62763.1528
RMSE: 82492.8598
MAPE: 9.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 255
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_79_t1: importance=0.0004, rank=1
   2. Feature_2_t1: importance=0.0003, rank=2
   3. Feature_80_t0: importance=0.0003, rank=3
   4. Feature_78_t0: importance=0.0003, rank=4
   5. Feature_95_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for PDFS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PDFS...

==================================================
Training Enhanced PDFS (SVM)
==================================================
Training SVM model...

Enhanced PDFS Performance:
MAE: 65199.0242
RMSE: 89240.6744
MAPE: 9.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0012, rank=1
   2. Feature_7_t3: importance=0.0005, rank=2
   3. Feature_19_t3: importance=0.0005, rank=3
   4. Feature_24_t2: importance=0.0005, rank=4
   5. Feature_22_t1: importance=0.0004, rank=5

📊 PDFS Results:
  Baseline MAPE: 9.06%
  Enhanced MAPE: 9.13%
  MAPE Improvement: -0.06% (-0.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 319/464: PEB
============================================================
📊 Loading data for PEB...
📊 Loading data for PEB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PEB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PEB...

==================================================
Training Baseline PEB (SVM)
==================================================
Training SVM model...

Baseline PEB Performance:
MAE: 1210391.5881
RMSE: 1444532.9916
MAPE: 7.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 152
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_77_t0: importance=0.0006, rank=1
   2. Feature_90_t1: importance=0.0004, rank=2
   3. Feature_89_t1: importance=0.0003, rank=3
   4. Feature_69_t2: importance=0.0003, rank=4
   5. Feature_1_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for PEB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PEB...

==================================================
Training Enhanced PEB (SVM)
==================================================
Training SVM model...

Enhanced PEB Performance:
MAE: 1080452.1350
RMSE: 1302667.6135
MAPE: 7.05%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t1: importance=0.0009, rank=1
   2. Feature_8_t3: importance=0.0008, rank=2
   3. Feature_13_t0: importance=0.0007, rank=3
   4. Feature_11_t1: importance=0.0006, rank=4
   5. Feature_24_t1: importance=0.0005, rank=5

📊 PEB Results:
  Baseline MAPE: 7.61%
  Enhanced MAPE: 7.05%
  MAPE Improvement: +0.56% (+7.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 320/464: PENN
============================================================
📊 Loading data for PENN...
📊 Loading data for PENN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing PENN: 'PENN'

============================================================
TESTING TICKER 321/464: PFBC
============================================================
📊 Loading data for PFBC...
📊 Loading data for PFBC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing PFBC: 'PFBC'

============================================================
TESTING TICKER 322/464: PFS
============================================================
📊 Loading data for PFS...
📊 Loading data for PFS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PFS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PFS...

==================================================
Training Baseline PFS (SVM)
==================================================
Training SVM model...

Baseline PFS Performance:
MAE: 395365.5745
RMSE: 497378.1179
MAPE: 10.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 175
   • Highly important features (top 5%): 102

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0006, rank=1
   2. Feature_71_t3: importance=0.0005, rank=2
   3. Feature_86_t0: importance=0.0005, rank=3
   4. Feature_74_t3: importance=0.0005, rank=4
   5. Feature_86_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for PFS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PFS...

==================================================
Training Enhanced PFS (SVM)
==================================================
Training SVM model...

Enhanced PFS Performance:
MAE: 321569.0304
RMSE: 431891.7488
MAPE: 8.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t0: importance=0.0008, rank=1
   2. Feature_7_t1: importance=0.0007, rank=2
   3. Feature_5_t0: importance=0.0007, rank=3
   4. Feature_20_t1: importance=0.0006, rank=4
   5. Feature_15_t3: importance=0.0005, rank=5

📊 PFS Results:
  Baseline MAPE: 10.90%
  Enhanced MAPE: 8.70%
  MAPE Improvement: +2.20% (+20.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 323/464: PI
============================================================
📊 Loading data for PI...
📊 Loading data for PI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PI...

==================================================
Training Baseline PI (SVM)
==================================================
Training SVM model...

Baseline PI Performance:
MAE: 238258.7932
RMSE: 341933.0724
MAPE: 7.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 161
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t2: importance=0.0001, rank=1
   2. Feature_71_t0: importance=0.0001, rank=2
   3. Feature_64_t0: importance=0.0001, rank=3
   4. Feature_0_t1: importance=0.0001, rank=4
   5. Feature_71_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for PI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PI...

==================================================
Training Enhanced PI (SVM)
==================================================
Training SVM model...

Enhanced PI Performance:
MAE: 235852.5653
RMSE: 344647.5461
MAPE: 7.07%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 67
   • Highly important features (top 5%): 42

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0004, rank=1
   2. Feature_13_t0: importance=0.0003, rank=2
   3. Feature_20_t3: importance=0.0003, rank=3
   4. Feature_12_t3: importance=0.0002, rank=4
   5. Feature_5_t0: importance=0.0002, rank=5

📊 PI Results:
  Baseline MAPE: 7.21%
  Enhanced MAPE: 7.07%
  MAPE Improvement: +0.13% (+1.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 324/464: PINC
============================================================
📊 Loading data for PINC...
📊 Loading data for PINC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PINC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PINC...

==================================================
Training Baseline PINC (SVM)
==================================================
Training SVM model...

Baseline PINC Performance:
MAE: 918850.1896
RMSE: 1745140.7558
MAPE: 9.71%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 239
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0006, rank=1
   2. Feature_85_t2: importance=0.0004, rank=2
   3. Feature_85_t1: importance=0.0004, rank=3
   4. Feature_91_t0: importance=0.0002, rank=4
   5. Feature_68_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PINC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PINC...

==================================================
Training Enhanced PINC (SVM)
==================================================
Training SVM model...

Enhanced PINC Performance:
MAE: 951493.1529
RMSE: 1842079.9158
MAPE: 10.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t1: importance=0.0007, rank=1
   2. Feature_5_t3: importance=0.0007, rank=2
   3. Feature_1_t3: importance=0.0006, rank=3
   4. Feature_24_t3: importance=0.0006, rank=4
   5. Feature_20_t0: importance=0.0006, rank=5

📊 PINC Results:
  Baseline MAPE: 9.71%
  Enhanced MAPE: 10.21%
  MAPE Improvement: -0.51% (-5.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 325/464: PJT
============================================================
📊 Loading data for PJT...
📊 Loading data for PJT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PJT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PJT...

==================================================
Training Baseline PJT (SVM)
==================================================
Training SVM model...

Baseline PJT Performance:
MAE: 149851.3309
RMSE: 187936.8439
MAPE: 9.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 251
   • Highly important features (top 5%): 138

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t1: importance=0.0009, rank=1
   2. Feature_72_t2: importance=0.0009, rank=2
   3. Feature_79_t0: importance=0.0009, rank=3
   4. Feature_2_t2: importance=0.0008, rank=4
   5. Feature_65_t1: importance=0.0007, rank=5

🔧 Applying universal feature engineering for PJT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PJT...

==================================================
Training Enhanced PJT (SVM)
==================================================
Training SVM model...

Enhanced PJT Performance:
MAE: 132051.5229
RMSE: 165813.9571
MAPE: 8.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t0: importance=0.0032, rank=1
   2. Feature_15_t2: importance=0.0021, rank=2
   3. Feature_20_t2: importance=0.0016, rank=3
   4. Feature_13_t0: importance=0.0015, rank=4
   5. Feature_7_t0: importance=0.0014, rank=5

📊 PJT Results:
  Baseline MAPE: 9.25%
  Enhanced MAPE: 8.43%
  MAPE Improvement: +0.83% (+8.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 326/464: PLAB
============================================================
📊 Loading data for PLAB...
📊 Loading data for PLAB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PLAB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PLAB...

==================================================
Training Baseline PLAB (SVM)
==================================================
Training SVM model...

Baseline PLAB Performance:
MAE: 182064.1947
RMSE: 229111.4474
MAPE: 7.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 211
   • Highly important features (top 5%): 102

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0005, rank=1
   2. Feature_96_t0: importance=0.0004, rank=2
   3. Feature_86_t0: importance=0.0004, rank=3
   4. Feature_78_t3: importance=0.0004, rank=4
   5. Feature_90_t0: importance=0.0004, rank=5

🔧 Applying universal feature engineering for PLAB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PLAB...

==================================================
Training Enhanced PLAB (SVM)
==================================================
Training SVM model...

Enhanced PLAB Performance:
MAE: 217634.5311
RMSE: 278649.5406
MAPE: 8.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0015, rank=1
   2. Feature_17_t1: importance=0.0010, rank=2
   3. Feature_19_t2: importance=0.0009, rank=3
   4. Feature_3_t3: importance=0.0009, rank=4
   5. Feature_17_t0: importance=0.0009, rank=5

📊 PLAB Results:
  Baseline MAPE: 7.56%
  Enhanced MAPE: 8.94%
  MAPE Improvement: -1.38% (-18.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 327/464: PLAY
============================================================
📊 Loading data for PLAY...
📊 Loading data for PLAY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PLAY...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PLAY...

==================================================
Training Baseline PLAY (SVM)
==================================================
Training SVM model...

Baseline PLAY Performance:
MAE: 740637.7515
RMSE: 975522.7626
MAPE: 12.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 313
   • Highly important features (top 5%): 206

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_85_t3: importance=0.0003, rank=1
   2. Feature_63_t3: importance=0.0003, rank=2
   3. Feature_83_t3: importance=0.0002, rank=3
   4. Feature_84_t3: importance=0.0002, rank=4
   5. Feature_63_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PLAY...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PLAY...

==================================================
Training Enhanced PLAY (SVM)
==================================================
Training SVM model...

Enhanced PLAY Performance:
MAE: 664781.7371
RMSE: 894215.3785
MAPE: 10.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t3: importance=0.0008, rank=1
   2. Feature_24_t0: importance=0.0006, rank=2
   3. Feature_1_t3: importance=0.0006, rank=3
   4. Feature_15_t3: importance=0.0003, rank=4
   5. Feature_7_t3: importance=0.0002, rank=5

📊 PLAY Results:
  Baseline MAPE: 12.09%
  Enhanced MAPE: 10.75%
  MAPE Improvement: +1.35% (+11.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 328/464: PLUS
============================================================
📊 Loading data for PLUS...
📊 Loading data for PLUS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing PLUS: 'PLUS'

============================================================
TESTING TICKER 329/464: PLXS
============================================================
📊 Loading data for PLXS...
📊 Loading data for PLXS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PLXS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PLXS...

==================================================
Training Baseline PLXS (SVM)
==================================================
Training SVM model...

Baseline PLXS Performance:
MAE: 59470.8819
RMSE: 76229.2077
MAPE: 12.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 270
   • Highly important features (top 5%): 176

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t3: importance=0.0002, rank=1
   2. Feature_2_t1: importance=0.0002, rank=2
   3. Feature_73_t3: importance=0.0002, rank=3
   4. Feature_80_t1: importance=0.0002, rank=4
   5. Feature_0_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PLXS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PLXS...

==================================================
Training Enhanced PLXS (SVM)
==================================================
Training SVM model...

Enhanced PLXS Performance:
MAE: 62444.6869
RMSE: 77130.8428
MAPE: 12.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0008, rank=1
   2. Feature_23_t1: importance=0.0006, rank=2
   3. Feature_19_t2: importance=0.0005, rank=3
   4. Feature_15_t2: importance=0.0004, rank=4
   5. Feature_17_t3: importance=0.0004, rank=5

📊 PLXS Results:
  Baseline MAPE: 12.11%
  Enhanced MAPE: 12.67%
  MAPE Improvement: -0.56% (-4.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 330/464: PMT
============================================================
📊 Loading data for PMT...
📊 Loading data for PMT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PMT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PMT...

==================================================
Training Baseline PMT (SVM)
==================================================
Training SVM model...

Baseline PMT Performance:
MAE: 264928.1447
RMSE: 425497.1896
MAPE: 7.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 96
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t3: importance=0.0028, rank=1
   2. Feature_81_t3: importance=0.0019, rank=2
   3. Feature_65_t0: importance=0.0017, rank=3
   4. Feature_84_t3: importance=0.0009, rank=4
   5. Feature_82_t2: importance=0.0008, rank=5

🔧 Applying universal feature engineering for PMT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PMT...

==================================================
Training Enhanced PMT (SVM)
==================================================
Training SVM model...

Enhanced PMT Performance:
MAE: 255667.6147
RMSE: 402000.2099
MAPE: 7.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 70

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0022, rank=1
   2. Feature_8_t3: importance=0.0015, rank=2
   3. Feature_13_t3: importance=0.0014, rank=3
   4. Feature_15_t3: importance=0.0014, rank=4
   5. Feature_5_t0: importance=0.0014, rank=5

📊 PMT Results:
  Baseline MAPE: 7.24%
  Enhanced MAPE: 7.31%
  MAPE Improvement: -0.07% (-0.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 331/464: POWL
============================================================
📊 Loading data for POWL...
📊 Loading data for POWL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing POWL: 'POWL'

============================================================
TESTING TICKER 332/464: PRA
============================================================
📊 Loading data for PRA...
📊 Loading data for PRA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PRA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PRA...

==================================================
Training Baseline PRA (SVM)
==================================================
Training SVM model...

Baseline PRA Performance:
MAE: 120304.5113
RMSE: 199919.6029
MAPE: 12.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 231
   • Highly important features (top 5%): 101

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t2: importance=0.0007, rank=1
   2. Feature_2_t3: importance=0.0006, rank=2
   3. Feature_85_t1: importance=0.0005, rank=3
   4. Feature_92_t0: importance=0.0005, rank=4
   5. Feature_69_t0: importance=0.0005, rank=5

🔧 Applying universal feature engineering for PRA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PRA...

==================================================
Training Enhanced PRA (SVM)
==================================================
Training SVM model...

Enhanced PRA Performance:
MAE: 121709.6471
RMSE: 204114.0953
MAPE: 12.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 99
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0012, rank=1
   2. Feature_13_t2: importance=0.0010, rank=2
   3. Feature_23_t2: importance=0.0008, rank=3
   4. Feature_14_t0: importance=0.0007, rank=4
   5. Feature_23_t1: importance=0.0007, rank=5

📊 PRA Results:
  Baseline MAPE: 12.68%
  Enhanced MAPE: 12.46%
  MAPE Improvement: +0.23% (+1.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 333/464: PRAA
============================================================
📊 Loading data for PRAA...
📊 Loading data for PRAA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PRAA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PRAA...

==================================================
Training Baseline PRAA (SVM)
==================================================
Training SVM model...

Baseline PRAA Performance:
MAE: 96807.7174
RMSE: 132088.1152
MAPE: 12.39%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 137
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_86_t3: importance=0.0002, rank=1
   2. Feature_76_t2: importance=0.0001, rank=2
   3. Feature_65_t3: importance=0.0001, rank=3
   4. Feature_65_t1: importance=0.0000, rank=4
   5. Feature_86_t0: importance=0.0000, rank=5

🔧 Applying universal feature engineering for PRAA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PRAA...

==================================================
Training Enhanced PRAA (SVM)
==================================================
Training SVM model...

Enhanced PRAA Performance:
MAE: 99830.3930
RMSE: 135627.1853
MAPE: 13.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 45
   • Highly important features (top 5%): 35

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0001, rank=1
   2. Feature_5_t3: importance=0.0001, rank=2
   3. Feature_5_t1: importance=0.0001, rank=3
   4. Feature_15_t2: importance=0.0001, rank=4
   5. Feature_20_t3: importance=0.0001, rank=5

📊 PRAA Results:
  Baseline MAPE: 12.39%
  Enhanced MAPE: 13.23%
  MAPE Improvement: -0.83% (-6.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 334/464: PRGS
============================================================
📊 Loading data for PRGS...
📊 Loading data for PRGS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PRGS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PRGS...

==================================================
Training Baseline PRGS (SVM)
==================================================
Training SVM model...

Baseline PRGS Performance:
MAE: 252897.7922
RMSE: 330840.1687
MAPE: 5.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 191
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t3: importance=0.0015, rank=1
   2. Feature_65_t2: importance=0.0010, rank=2
   3. Feature_1_t0: importance=0.0007, rank=3
   4. Feature_68_t3: importance=0.0007, rank=4
   5. Feature_88_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for PRGS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PRGS...

==================================================
Training Enhanced PRGS (SVM)
==================================================
Training SVM model...

Enhanced PRGS Performance:
MAE: 285921.2629
RMSE: 346152.3495
MAPE: 6.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t0: importance=0.0017, rank=1
   2. Feature_15_t3: importance=0.0014, rank=2
   3. Feature_4_t3: importance=0.0013, rank=3
   4. Feature_1_t0: importance=0.0013, rank=4
   5. Feature_5_t0: importance=0.0013, rank=5

📊 PRGS Results:
  Baseline MAPE: 5.37%
  Enhanced MAPE: 6.17%
  MAPE Improvement: -0.80% (-14.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 335/464: PRK
============================================================
📊 Loading data for PRK...
📊 Loading data for PRK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PRK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PRK...

==================================================
Training Baseline PRK (SVM)
==================================================
Training SVM model...

Baseline PRK Performance:
MAE: 43145.2764
RMSE: 50635.2374
MAPE: 7.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 275
   • Highly important features (top 5%): 192

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0022, rank=1
   2. Feature_67_t3: importance=0.0016, rank=2
   3. Feature_71_t3: importance=0.0012, rank=3
   4. Feature_69_t3: importance=0.0005, rank=4
   5. Feature_73_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for PRK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PRK...

==================================================
Training Enhanced PRK (SVM)
==================================================
Training SVM model...

Enhanced PRK Performance:
MAE: 59537.0552
RMSE: 68278.2893
MAPE: 10.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 51
   • Highly important features (top 5%): 32

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0031, rank=1
   2. Feature_22_t1: importance=0.0019, rank=2
   3. Feature_23_t1: importance=0.0018, rank=3
   4. Feature_1_t3: importance=0.0013, rank=4
   5. Feature_19_t3: importance=0.0012, rank=5

📊 PRK Results:
  Baseline MAPE: 7.95%
  Enhanced MAPE: 10.88%
  MAPE Improvement: -2.93% (-36.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 336/464: PRLB
============================================================
📊 Loading data for PRLB...
📊 Loading data for PRLB from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PRLB...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PRLB...

==================================================
Training Baseline PRLB (SVM)
==================================================
Training SVM model...

Baseline PRLB Performance:
MAE: 79808.0715
RMSE: 108445.7022
MAPE: 11.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 306
   • Highly important features (top 5%): 172

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_80_t3: importance=0.0003, rank=1
   2. Feature_78_t3: importance=0.0002, rank=2
   3. Feature_65_t0: importance=0.0002, rank=3
   4. Feature_70_t1: importance=0.0002, rank=4
   5. Feature_70_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for PRLB...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PRLB...

==================================================
Training Enhanced PRLB (SVM)
==================================================
Training SVM model...

Enhanced PRLB Performance:
MAE: 76363.3411
RMSE: 102323.9465
MAPE: 10.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0004, rank=1
   2. Feature_12_t2: importance=0.0004, rank=2
   3. Feature_5_t0: importance=0.0004, rank=3
   4. Feature_7_t3: importance=0.0003, rank=4
   5. Feature_16_t0: importance=0.0003, rank=5

📊 PRLB Results:
  Baseline MAPE: 11.22%
  Enhanced MAPE: 10.85%
  MAPE Improvement: +0.37% (+3.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 337/464: PSMT
============================================================
📊 Loading data for PSMT...
📊 Loading data for PSMT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PSMT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PSMT...

==================================================
Training Baseline PSMT (SVM)
==================================================
Training SVM model...

Baseline PSMT Performance:
MAE: 103150.3982
RMSE: 128077.2201
MAPE: 10.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 168
   • Highly important features (top 5%): 94

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t2: importance=0.0011, rank=1
   2. Feature_84_t2: importance=0.0009, rank=2
   3. Feature_63_t3: importance=0.0009, rank=3
   4. Feature_76_t3: importance=0.0006, rank=4
   5. Feature_91_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for PSMT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PSMT...

==================================================
Training Enhanced PSMT (SVM)
==================================================
Training SVM model...

Enhanced PSMT Performance:
MAE: 88971.4982
RMSE: 123346.3405
MAPE: 8.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 36

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t0: importance=0.0017, rank=1
   2. Feature_7_t0: importance=0.0011, rank=2
   3. Feature_5_t1: importance=0.0009, rank=3
   4. Feature_17_t1: importance=0.0007, rank=4
   5. Feature_22_t2: importance=0.0007, rank=5

📊 PSMT Results:
  Baseline MAPE: 10.17%
  Enhanced MAPE: 8.99%
  MAPE Improvement: +1.18% (+11.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 338/464: PTEN
============================================================
📊 Loading data for PTEN...
📊 Loading data for PTEN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PTEN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PTEN...

==================================================
Training Baseline PTEN (SVM)
==================================================
Training SVM model...

Baseline PTEN Performance:
MAE: 3120330.8877
RMSE: 3928747.5482
MAPE: 12.12%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 235
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t1: importance=0.0003, rank=1
   2. Feature_77_t3: importance=0.0003, rank=2
   3. Feature_78_t3: importance=0.0003, rank=3
   4. Feature_96_t2: importance=0.0003, rank=4
   5. Feature_65_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for PTEN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PTEN...

==================================================
Training Enhanced PTEN (SVM)
==================================================
Training SVM model...

Enhanced PTEN Performance:
MAE: 2728976.7261
RMSE: 3388339.6983
MAPE: 10.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_21_t0: importance=0.0005, rank=1
   2. Feature_19_t3: importance=0.0005, rank=2
   3. Feature_6_t1: importance=0.0004, rank=3
   4. Feature_15_t3: importance=0.0003, rank=4
   5. Feature_17_t1: importance=0.0003, rank=5

📊 PTEN Results:
  Baseline MAPE: 12.12%
  Enhanced MAPE: 10.54%
  MAPE Improvement: +1.58% (+13.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 339/464: PTGX
============================================================
📊 Loading data for PTGX...
📊 Loading data for PTGX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing PTGX: 'PTGX'

============================================================
TESTING TICKER 340/464: PZZA
============================================================
📊 Loading data for PZZA...
📊 Loading data for PZZA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for PZZA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for PZZA...

==================================================
Training Baseline PZZA (SVM)
==================================================
Training SVM model...

Baseline PZZA Performance:
MAE: 619098.3380
RMSE: 891783.7650
MAPE: 16.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 112
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t0: importance=0.0007, rank=1
   2. Feature_75_t3: importance=0.0007, rank=2
   3. Feature_63_t0: importance=0.0006, rank=3
   4. Feature_63_t1: importance=0.0006, rank=4
   5. Feature_63_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for PZZA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for PZZA...

==================================================
Training Enhanced PZZA (SVM)
==================================================
Training SVM model...

Enhanced PZZA Performance:
MAE: 537790.2192
RMSE: 755833.1625
MAPE: 14.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0011, rank=1
   2. Feature_4_t1: importance=0.0009, rank=2
   3. Feature_4_t2: importance=0.0008, rank=3
   4. Feature_24_t3: importance=0.0008, rank=4
   5. Feature_19_t3: importance=0.0008, rank=5

📊 PZZA Results:
  Baseline MAPE: 16.65%
  Enhanced MAPE: 14.14%
  MAPE Improvement: +2.51% (+15.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 341/464: QDEL
============================================================
📊 Loading data for QDEL...
📊 Loading data for QDEL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing QDEL: 'QDEL'

============================================================
TESTING TICKER 342/464: QNST
============================================================
📊 Loading data for QNST...
📊 Loading data for QNST from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for QNST...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for QNST...

==================================================
Training Baseline QNST (SVM)
==================================================
Training SVM model...

Baseline QNST Performance:
MAE: 240772.2277
RMSE: 381971.1578
MAPE: 13.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 230
   • Highly important features (top 5%): 138

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0018, rank=1
   2. Feature_2_t2: importance=0.0007, rank=2
   3. Feature_63_t3: importance=0.0007, rank=3
   4. Feature_93_t2: importance=0.0006, rank=4
   5. Feature_94_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for QNST...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for QNST...

==================================================
Training Enhanced QNST (SVM)
==================================================
Training SVM model...

Enhanced QNST Performance:
MAE: 229932.1560
RMSE: 389199.4179
MAPE: 12.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t2: importance=0.0015, rank=1
   2. Feature_4_t2: importance=0.0011, rank=2
   3. Feature_11_t2: importance=0.0010, rank=3
   4. Feature_17_t3: importance=0.0010, rank=4
   5. Feature_3_t3: importance=0.0008, rank=5

📊 QNST Results:
  Baseline MAPE: 13.60%
  Enhanced MAPE: 12.84%
  MAPE Improvement: +0.76% (+5.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 343/464: QRVO
============================================================
📊 Loading data for QRVO...
📊 Loading data for QRVO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for QRVO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for QRVO...

==================================================
Training Baseline QRVO (SVM)
==================================================
Training SVM model...

Baseline QRVO Performance:
MAE: 566988.2830
RMSE: 950482.0443
MAPE: 11.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 191
   • Highly important features (top 5%): 133

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0012, rank=1
   2. Feature_65_t3: importance=0.0004, rank=2
   3. Feature_82_t2: importance=0.0003, rank=3
   4. Feature_67_t3: importance=0.0003, rank=4
   5. Feature_80_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for QRVO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for QRVO...

==================================================
Training Enhanced QRVO (SVM)
==================================================
Training SVM model...

Enhanced QRVO Performance:
MAE: 579057.1789
RMSE: 955676.0740
MAPE: 12.33%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0008, rank=1
   2. Feature_5_t2: importance=0.0008, rank=2
   3. Feature_11_t2: importance=0.0005, rank=3
   4. Feature_10_t0: importance=0.0005, rank=4
   5. Feature_17_t0: importance=0.0004, rank=5

📊 QRVO Results:
  Baseline MAPE: 11.61%
  Enhanced MAPE: 12.33%
  MAPE Improvement: -0.72% (-6.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 344/464: QTWO
============================================================
📊 Loading data for QTWO...
📊 Loading data for QTWO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing QTWO: 'QTWO'

============================================================
TESTING TICKER 345/464: RDN
============================================================
📊 Loading data for RDN...
📊 Loading data for RDN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RDN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RDN...

==================================================
Training Baseline RDN (SVM)
==================================================
Training SVM model...

Baseline RDN Performance:
MAE: 766852.5851
RMSE: 1126708.1908
MAPE: 9.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 239
   • Highly important features (top 5%): 147

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0012, rank=1
   2. Feature_69_t1: importance=0.0007, rank=2
   3. Feature_68_t3: importance=0.0006, rank=3
   4. Feature_67_t1: importance=0.0006, rank=4
   5. Feature_0_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for RDN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RDN...

==================================================
Training Enhanced RDN (SVM)
==================================================
Training SVM model...

Enhanced RDN Performance:
MAE: 871004.9639
RMSE: 1243217.4938
MAPE: 10.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0017, rank=1
   2. Feature_7_t0: importance=0.0016, rank=2
   3. Feature_13_t2: importance=0.0015, rank=3
   4. Feature_15_t1: importance=0.0014, rank=4
   5. Feature_1_t3: importance=0.0012, rank=5

📊 RDN Results:
  Baseline MAPE: 9.64%
  Enhanced MAPE: 10.54%
  MAPE Improvement: -0.90% (-9.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 346/464: RDNT
============================================================
📊 Loading data for RDNT...
📊 Loading data for RDNT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RDNT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RDNT...

==================================================
Training Baseline RDNT (SVM)
==================================================
Training SVM model...

Baseline RDNT Performance:
MAE: 433851.3647
RMSE: 544181.8099
MAPE: 9.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 151
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0015, rank=1
   2. Feature_69_t1: importance=0.0012, rank=2
   3. Feature_78_t3: importance=0.0007, rank=3
   4. Feature_63_t2: importance=0.0006, rank=4
   5. Feature_77_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for RDNT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RDNT...

==================================================
Training Enhanced RDNT (SVM)
==================================================
Training SVM model...

Enhanced RDNT Performance:
MAE: 421628.7654
RMSE: 537776.0173
MAPE: 9.63%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 64
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t0: importance=0.0017, rank=1
   2. Feature_19_t3: importance=0.0015, rank=2
   3. Feature_20_t1: importance=0.0013, rank=3
   4. Feature_2_t3: importance=0.0009, rank=4
   5. Feature_16_t0: importance=0.0009, rank=5

📊 RDNT Results:
  Baseline MAPE: 9.99%
  Enhanced MAPE: 9.63%
  MAPE Improvement: +0.37% (+3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 347/464: RES
============================================================
📊 Loading data for RES...
📊 Loading data for RES from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RES...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RES...

==================================================
Training Baseline RES (SVM)
==================================================
Training SVM model...

Baseline RES Performance:
MAE: 1610991.1181
RMSE: 2018218.0064
MAPE: 9.95%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 336
   • Highly important features (top 5%): 230

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t2: importance=0.0003, rank=1
   2. Feature_71_t3: importance=0.0003, rank=2
   3. Feature_83_t2: importance=0.0002, rank=3
   4. Feature_75_t3: importance=0.0002, rank=4
   5. Feature_76_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for RES...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RES...

==================================================
Training Enhanced RES (SVM)
==================================================
Training SVM model...

Enhanced RES Performance:
MAE: 1369164.0172
RMSE: 1688703.8129
MAPE: 8.46%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0011, rank=1
   2. Feature_24_t1: importance=0.0005, rank=2
   3. Feature_12_t2: importance=0.0005, rank=3
   4. Feature_16_t0: importance=0.0004, rank=4
   5. Feature_7_t3: importance=0.0004, rank=5

📊 RES Results:
  Baseline MAPE: 9.95%
  Enhanced MAPE: 8.46%
  MAPE Improvement: +1.49% (+15.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 348/464: REX
============================================================
📊 Loading data for REX...
📊 Loading data for REX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing REX: 'REX'

============================================================
TESTING TICKER 349/464: RGR
============================================================
📊 Loading data for RGR...
📊 Loading data for RGR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RGR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RGR...

==================================================
Training Baseline RGR (SVM)
==================================================
Training SVM model...

Baseline RGR Performance:
MAE: 65092.2764
RMSE: 80495.7176
MAPE: 11.12%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 88
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t0: importance=0.0011, rank=1
   2. Feature_65_t1: importance=0.0004, rank=2
   3. Feature_88_t1: importance=0.0004, rank=3
   4. Feature_65_t3: importance=0.0003, rank=4
   5. Feature_71_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for RGR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RGR...

==================================================
Training Enhanced RGR (SVM)
==================================================
Training SVM model...

Enhanced RGR Performance:
MAE: 48157.6382
RMSE: 66439.4158
MAPE: 8.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t0: importance=0.0011, rank=1
   2. Feature_11_t3: importance=0.0007, rank=2
   3. Feature_15_t2: importance=0.0006, rank=3
   4. Feature_1_t3: importance=0.0006, rank=4
   5. Feature_20_t1: importance=0.0006, rank=5

📊 RGR Results:
  Baseline MAPE: 11.12%
  Enhanced MAPE: 8.42%
  MAPE Improvement: +2.70% (+24.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 350/464: RHI
============================================================
📊 Loading data for RHI...
📊 Loading data for RHI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RHI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RHI...

==================================================
Training Baseline RHI (SVM)
==================================================
Training SVM model...

Baseline RHI Performance:
MAE: 600425.9357
RMSE: 759838.1558
MAPE: 8.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 160
   • Highly important features (top 5%): 102

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0002, rank=1
   2. Feature_69_t3: importance=0.0001, rank=2
   3. Feature_95_t1: importance=0.0001, rank=3
   4. Feature_90_t3: importance=0.0001, rank=4
   5. Feature_86_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for RHI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RHI...

==================================================
Training Enhanced RHI (SVM)
==================================================
Training SVM model...

Enhanced RHI Performance:
MAE: 569593.0989
RMSE: 749818.3146
MAPE: 7.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t0: importance=0.0002, rank=1
   2. Feature_20_t3: importance=0.0002, rank=2
   3. Feature_22_t2: importance=0.0002, rank=3
   4. Feature_12_t2: importance=0.0002, rank=4
   5. Feature_15_t3: importance=0.0002, rank=5

📊 RHI Results:
  Baseline MAPE: 8.28%
  Enhanced MAPE: 7.74%
  MAPE Improvement: +0.53% (+6.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 351/464: RHP
============================================================
📊 Loading data for RHP...
📊 Loading data for RHP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RHP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RHP...

==================================================
Training Baseline RHP (SVM)
==================================================
Training SVM model...

Baseline RHP Performance:
MAE: 344888.6875
RMSE: 525943.5184
MAPE: 12.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 227
   • Highly important features (top 5%): 123

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t3: importance=0.0007, rank=1
   2. Feature_70_t2: importance=0.0005, rank=2
   3. Feature_64_t1: importance=0.0005, rank=3
   4. Feature_2_t3: importance=0.0005, rank=4
   5. Feature_0_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for RHP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RHP...

==================================================
Training Enhanced RHP (SVM)
==================================================
Training SVM model...

Enhanced RHP Performance:
MAE: 376116.0418
RMSE: 565494.6627
MAPE: 13.37%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 36

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0016, rank=1
   2. Feature_7_t0: importance=0.0015, rank=2
   3. Feature_13_t3: importance=0.0014, rank=3
   4. Feature_19_t1: importance=0.0011, rank=4
   5. Feature_14_t2: importance=0.0007, rank=5

📊 RHP Results:
  Baseline MAPE: 12.42%
  Enhanced MAPE: 13.37%
  MAPE Improvement: -0.95% (-7.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 352/464: RNST
============================================================
📊 Loading data for RNST...
📊 Loading data for RNST from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RNST...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RNST...

==================================================
Training Baseline RNST (SVM)
==================================================
Training SVM model...

Baseline RNST Performance:
MAE: 296972.0776
RMSE: 529504.3999
MAPE: 10.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 231
   • Highly important features (top 5%): 146

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t1: importance=0.0008, rank=1
   2. Feature_79_t2: importance=0.0007, rank=2
   3. Feature_76_t3: importance=0.0005, rank=3
   4. Feature_80_t2: importance=0.0004, rank=4
   5. Feature_82_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for RNST...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RNST...

==================================================
Training Enhanced RNST (SVM)
==================================================
Training SVM model...

Enhanced RNST Performance:
MAE: 317532.5675
RMSE: 553902.9402
MAPE: 11.04%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 52
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0033, rank=1
   2. Feature_17_t2: importance=0.0017, rank=2
   3. Feature_19_t2: importance=0.0013, rank=3
   4. Feature_17_t3: importance=0.0012, rank=4
   5. Feature_13_t1: importance=0.0012, rank=5

📊 RNST Results:
  Baseline MAPE: 10.75%
  Enhanced MAPE: 11.04%
  MAPE Improvement: -0.29% (-2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 353/464: ROCK
============================================================
📊 Loading data for ROCK...
📊 Loading data for ROCK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ROCK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ROCK...

==================================================
Training Baseline ROCK (SVM)
==================================================
Training SVM model...

Baseline ROCK Performance:
MAE: 62378.3781
RMSE: 77111.3258
MAPE: 14.97%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 202
   • Highly important features (top 5%): 110

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t3: importance=0.0005, rank=1
   2. Feature_63_t2: importance=0.0005, rank=2
   3. Feature_96_t0: importance=0.0004, rank=3
   4. Feature_67_t3: importance=0.0004, rank=4
   5. Feature_71_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for ROCK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ROCK...

==================================================
Training Enhanced ROCK (SVM)
==================================================
Training SVM model...

Enhanced ROCK Performance:
MAE: 71131.3121
RMSE: 87719.6625
MAPE: 17.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t1: importance=0.0013, rank=1
   2. Feature_14_t2: importance=0.0012, rank=2
   3. Feature_22_t0: importance=0.0011, rank=3
   4. Feature_1_t1: importance=0.0010, rank=4
   5. Feature_19_t3: importance=0.0009, rank=5

📊 ROCK Results:
  Baseline MAPE: 14.97%
  Enhanced MAPE: 17.96%
  MAPE Improvement: -2.98% (-19.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 354/464: ROG
============================================================
📊 Loading data for ROG...
📊 Loading data for ROG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for ROG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for ROG...

==================================================
Training Baseline ROG (SVM)
==================================================
Training SVM model...

Baseline ROG Performance:
MAE: 58886.6141
RMSE: 77059.1111
MAPE: 11.16%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 130
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t0: importance=0.0011, rank=1
   2. Feature_95_t0: importance=0.0010, rank=2
   3. Feature_96_t0: importance=0.0010, rank=3
   4. Feature_65_t3: importance=0.0010, rank=4
   5. Feature_96_t3: importance=0.0010, rank=5

🔧 Applying universal feature engineering for ROG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for ROG...

==================================================
Training Enhanced ROG (SVM)
==================================================
Training SVM model...

Enhanced ROG Performance:
MAE: 49382.5222
RMSE: 63079.0115
MAPE: 9.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0019, rank=1
   2. Feature_10_t2: importance=0.0016, rank=2
   3. Feature_13_t0: importance=0.0015, rank=3
   4. Feature_11_t1: importance=0.0014, rank=4
   5. Feature_17_t3: importance=0.0013, rank=5

📊 ROG Results:
  Baseline MAPE: 11.16%
  Enhanced MAPE: 9.47%
  MAPE Improvement: +1.69% (+15.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 355/464: RUN
============================================================
📊 Loading data for RUN...
📊 Loading data for RUN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RUN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RUN...

==================================================
Training Baseline RUN (SVM)
==================================================
Training SVM model...

Baseline RUN Performance:
MAE: 2433085.8086
RMSE: 3106364.7899
MAPE: 4.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 178
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_79_t1: importance=0.0001, rank=1
   2. Feature_68_t3: importance=0.0001, rank=2
   3. Feature_63_t3: importance=0.0001, rank=3
   4. Feature_73_t0: importance=0.0001, rank=4
   5. Feature_63_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for RUN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RUN...

==================================================
Training Enhanced RUN (SVM)
==================================================
Training SVM model...

Enhanced RUN Performance:
MAE: 2379265.5771
RMSE: 3064446.3977
MAPE: 4.67%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0002, rank=1
   2. Feature_16_t0: importance=0.0001, rank=2
   3. Feature_4_t3: importance=0.0001, rank=3
   4. Feature_7_t0: importance=0.0001, rank=4
   5. Feature_4_t0: importance=0.0001, rank=5

📊 RUN Results:
  Baseline MAPE: 4.78%
  Enhanced MAPE: 4.67%
  MAPE Improvement: +0.11% (+2.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 356/464: RUSHA
============================================================
📊 Loading data for RUSHA...
📊 Loading data for RUSHA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RUSHA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RUSHA...

==================================================
Training Baseline RUSHA (SVM)
==================================================
Training SVM model...

Baseline RUSHA Performance:
MAE: 256262.6889
RMSE: 336241.2601
MAPE: 7.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 248
   • Highly important features (top 5%): 120

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0010, rank=1
   2. Feature_74_t2: importance=0.0008, rank=2
   3. Feature_63_t1: importance=0.0006, rank=3
   4. Feature_86_t0: importance=0.0004, rank=4
   5. Feature_73_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for RUSHA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RUSHA...

==================================================
Training Enhanced RUSHA (SVM)
==================================================
Training SVM model...

Enhanced RUSHA Performance:
MAE: 213903.5269
RMSE: 283955.8509
MAPE: 6.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 55

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0017, rank=1
   2. Feature_4_t3: importance=0.0012, rank=2
   3. Feature_19_t3: importance=0.0011, rank=3
   4. Feature_16_t1: importance=0.0010, rank=4
   5. Feature_16_t3: importance=0.0010, rank=5

📊 RUSHA Results:
  Baseline MAPE: 7.80%
  Enhanced MAPE: 6.51%
  MAPE Improvement: +1.29% (+16.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 357/464: RWT
============================================================
📊 Loading data for RWT...
📊 Loading data for RWT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for RWT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for RWT...

==================================================
Training Baseline RWT (SVM)
==================================================
Training SVM model...

Baseline RWT Performance:
MAE: 488871.1592
RMSE: 673076.9994
MAPE: 10.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 97
   • Highly important features (top 5%): 29

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t0: importance=0.0006, rank=1
   2. Feature_68_t3: importance=0.0006, rank=2
   3. Feature_65_t3: importance=0.0004, rank=3
   4. Feature_67_t3: importance=0.0004, rank=4
   5. Feature_63_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for RWT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for RWT...

==================================================
Training Enhanced RWT (SVM)
==================================================
Training SVM model...

Enhanced RWT Performance:
MAE: 506607.7142
RMSE: 658634.0102
MAPE: 10.49%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 84
   • Highly important features (top 5%): 58

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t3: importance=0.0014, rank=1
   2. Feature_19_t3: importance=0.0013, rank=2
   3. Feature_12_t0: importance=0.0008, rank=3
   4. Feature_1_t0: importance=0.0007, rank=4
   5. Feature_22_t2: importance=0.0007, rank=5

📊 RWT Results:
  Baseline MAPE: 10.21%
  Enhanced MAPE: 10.49%
  MAPE Improvement: -0.28% (-2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 358/464: SAFE
============================================================
📊 Loading data for SAFE...
📊 Loading data for SAFE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing SAFE: 'SAFE'

============================================================
TESTING TICKER 359/464: SABR
============================================================
📊 Loading data for SABR...
📊 Loading data for SABR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SABR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SABR...

==================================================
Training Baseline SABR (SVM)
==================================================
Training SVM model...

Baseline SABR Performance:
MAE: 1856113.7545
RMSE: 2169075.8764
MAPE: 7.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 192
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0007, rank=1
   2. Feature_63_t0: importance=0.0004, rank=2
   3. Feature_70_t1: importance=0.0004, rank=3
   4. Feature_70_t2: importance=0.0004, rank=4
   5. Feature_84_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for SABR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SABR...

==================================================
Training Enhanced SABR (SVM)
==================================================
Training SVM model...

Enhanced SABR Performance:
MAE: 1694981.5887
RMSE: 2025028.2079
MAPE: 6.90%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t3: importance=0.0020, rank=1
   2. Feature_10_t3: importance=0.0016, rank=2
   3. Feature_11_t3: importance=0.0011, rank=3
   4. Feature_24_t3: importance=0.0009, rank=4
   5. Feature_19_t3: importance=0.0007, rank=5

📊 SABR Results:
  Baseline MAPE: 7.58%
  Enhanced MAPE: 6.90%
  MAPE Improvement: +0.69% (+9.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 360/464: SAFT
============================================================
📊 Loading data for SAFT...
📊 Loading data for SAFT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SAFT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SAFT...

==================================================
Training Baseline SAFT (SVM)
==================================================
Training SVM model...

Baseline SAFT Performance:
MAE: 11471.3726
RMSE: 15671.0077
MAPE: 9.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 263
   • Highly important features (top 5%): 125

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0009, rank=1
   2. Feature_70_t0: importance=0.0007, rank=2
   3. Feature_78_t2: importance=0.0006, rank=3
   4. Feature_65_t1: importance=0.0005, rank=4
   5. Feature_65_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for SAFT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SAFT...

==================================================
Training Enhanced SAFT (SVM)
==================================================
Training SVM model...

Enhanced SAFT Performance:
MAE: 14188.6709
RMSE: 19394.4355
MAPE: 11.61%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0013, rank=1
   2. Feature_15_t2: importance=0.0011, rank=2
   3. Feature_13_t0: importance=0.0009, rank=3
   4. Feature_7_t0: importance=0.0009, rank=4
   5. Feature_13_t2: importance=0.0009, rank=5

📊 SAFT Results:
  Baseline MAPE: 9.74%
  Enhanced MAPE: 11.61%
  MAPE Improvement: -1.87% (-19.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 361/464: SAH
============================================================
📊 Loading data for SAH...
📊 Loading data for SAH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SAH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SAH...

==================================================
Training Baseline SAH (SVM)
==================================================
Training SVM model...

Baseline SAH Performance:
MAE: 81345.2319
RMSE: 100055.9006
MAPE: 5.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 193
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_68_t3: importance=0.0000, rank=1
   2. Feature_93_t1: importance=0.0000, rank=2
   3. Feature_63_t1: importance=0.0000, rank=3
   4. Feature_68_t2: importance=0.0000, rank=4
   5. Feature_84_t3: importance=0.0000, rank=5

🔧 Applying universal feature engineering for SAH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SAH...

==================================================
Training Enhanced SAH (SVM)
==================================================
Training SVM model...

Enhanced SAH Performance:
MAE: 86964.9986
RMSE: 104963.7001
MAPE: 5.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t0: importance=0.0001, rank=1
   2. Feature_11_t1: importance=0.0001, rank=2
   3. Feature_24_t0: importance=0.0001, rank=3
   4. Feature_8_t0: importance=0.0000, rank=4
   5. Feature_22_t3: importance=0.0000, rank=5

📊 SAH Results:
  Baseline MAPE: 5.00%
  Enhanced MAPE: 5.42%
  MAPE Improvement: -0.42% (-8.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 362/464: SANM
============================================================
📊 Loading data for SANM...
📊 Loading data for SANM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SANM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SANM...

==================================================
Training Baseline SANM (SVM)
==================================================
Training SVM model...

Baseline SANM Performance:
MAE: 161803.9976
RMSE: 233589.4472
MAPE: 10.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 299
   • Highly important features (top 5%): 156

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t3: importance=0.0004, rank=1
   2. Feature_73_t1: importance=0.0004, rank=2
   3. Feature_94_t0: importance=0.0004, rank=3
   4. Feature_2_t2: importance=0.0003, rank=4
   5. Feature_75_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for SANM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SANM...

==================================================
Training Enhanced SANM (SVM)
==================================================
Training SVM model...

Enhanced SANM Performance:
MAE: 142843.8755
RMSE: 198816.6551
MAPE: 9.22%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0007, rank=1
   2. Feature_1_t2: importance=0.0007, rank=2
   3. Feature_16_t0: importance=0.0006, rank=3
   4. Feature_1_t3: importance=0.0005, rank=4
   5. Feature_20_t3: importance=0.0005, rank=5

📊 SANM Results:
  Baseline MAPE: 10.30%
  Enhanced MAPE: 9.22%
  MAPE Improvement: +1.08% (+10.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 363/464: SBCF
============================================================
📊 Loading data for SBCF...
📊 Loading data for SBCF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SBCF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SBCF...

==================================================
Training Baseline SBCF (SVM)
==================================================
Training SVM model...

Baseline SBCF Performance:
MAE: 174319.9304
RMSE: 237983.8086
MAPE: 9.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 56
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0021, rank=1
   2. Feature_0_t2: importance=0.0013, rank=2
   3. Feature_2_t1: importance=0.0007, rank=3
   4. Feature_2_t2: importance=0.0005, rank=4
   5. Feature_64_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for SBCF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SBCF...

==================================================
Training Enhanced SBCF (SVM)
==================================================
Training SVM model...

Enhanced SBCF Performance:
MAE: 170685.4075
RMSE: 218832.3901
MAPE: 9.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 54

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t3: importance=0.0028, rank=1
   2. Feature_2_t2: importance=0.0017, rank=2
   3. Feature_15_t2: importance=0.0011, rank=3
   4. Feature_23_t0: importance=0.0011, rank=4
   5. Feature_3_t3: importance=0.0011, rank=5

📊 SBCF Results:
  Baseline MAPE: 9.64%
  Enhanced MAPE: 9.65%
  MAPE Improvement: -0.02% (-0.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 364/464: SBH
============================================================
📊 Loading data for SBH...
📊 Loading data for SBH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SBH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SBH...

==================================================
Training Baseline SBH (SVM)
==================================================
Training SVM model...

Baseline SBH Performance:
MAE: 1116113.8572
RMSE: 1605942.5479
MAPE: 8.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 137
   • Highly important features (top 5%): 104

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t1: importance=0.0007, rank=1
   2. Feature_63_t1: importance=0.0003, rank=2
   3. Feature_76_t3: importance=0.0002, rank=3
   4. Feature_65_t2: importance=0.0001, rank=4
   5. Feature_83_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SBH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SBH...

==================================================
Training Enhanced SBH (SVM)
==================================================
Training SVM model...

Enhanced SBH Performance:
MAE: 1400921.9606
RMSE: 1796443.3962
MAPE: 10.82%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 86
   • Highly important features (top 5%): 64

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0003, rank=1
   2. Feature_4_t1: importance=0.0003, rank=2
   3. Feature_16_t1: importance=0.0002, rank=3
   4. Feature_12_t0: importance=0.0002, rank=4
   5. Feature_15_t2: importance=0.0002, rank=5

📊 SBH Results:
  Baseline MAPE: 8.86%
  Enhanced MAPE: 10.82%
  MAPE Improvement: -1.95% (-22.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 365/464: SBSI
============================================================
📊 Loading data for SBSI...
📊 Loading data for SBSI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SBSI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SBSI...

==================================================
Training Baseline SBSI (SVM)
==================================================
Training SVM model...

Baseline SBSI Performance:
MAE: 67170.0084
RMSE: 136305.6920
MAPE: 6.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 177
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_66_t2: importance=0.0001, rank=1
   2. Feature_66_t3: importance=0.0001, rank=2
   3. Feature_71_t3: importance=0.0001, rank=3
   4. Feature_65_t0: importance=0.0001, rank=4
   5. Feature_68_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SBSI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SBSI...

==================================================
Training Enhanced SBSI (SVM)
==================================================
Training SVM model...

Enhanced SBSI Performance:
MAE: 73868.1129
RMSE: 139169.5755
MAPE: 7.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t0: importance=0.0004, rank=1
   2. Feature_11_t0: importance=0.0002, rank=2
   3. Feature_24_t1: importance=0.0002, rank=3
   4. Feature_15_t2: importance=0.0002, rank=4
   5. Feature_3_t1: importance=0.0002, rank=5

📊 SBSI Results:
  Baseline MAPE: 6.62%
  Enhanced MAPE: 7.51%
  MAPE Improvement: -0.88% (-13.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 366/464: SCHL
============================================================
📊 Loading data for SCHL...
📊 Loading data for SCHL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SCHL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SCHL...

==================================================
Training Baseline SCHL (SVM)
==================================================
Training SVM model...

Baseline SCHL Performance:
MAE: 117330.0616
RMSE: 164543.2289
MAPE: 12.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 205
   • Highly important features (top 5%): 92

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0011, rank=1
   2. Feature_70_t0: importance=0.0011, rank=2
   3. Feature_84_t1: importance=0.0009, rank=3
   4. Feature_70_t1: importance=0.0009, rank=4
   5. Feature_2_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for SCHL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SCHL...

==================================================
Training Enhanced SCHL (SVM)
==================================================
Training SVM model...

Enhanced SCHL Performance:
MAE: 126141.8169
RMSE: 177692.9897
MAPE: 12.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 47

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0030, rank=1
   2. Feature_16_t0: importance=0.0025, rank=2
   3. Feature_20_t0: importance=0.0022, rank=3
   4. Feature_24_t1: importance=0.0013, rank=4
   5. Feature_24_t3: importance=0.0013, rank=5

📊 SCHL Results:
  Baseline MAPE: 12.17%
  Enhanced MAPE: 12.85%
  MAPE Improvement: -0.69% (-5.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 367/464: SCL
============================================================
📊 Loading data for SCL...
📊 Loading data for SCL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SCL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SCL...

==================================================
Training Baseline SCL (SVM)
==================================================
Training SVM model...

Baseline SCL Performance:
MAE: 30718.4327
RMSE: 43471.1926
MAPE: 10.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 242
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0008, rank=1
   2. Feature_65_t0: importance=0.0006, rank=2
   3. Feature_77_t2: importance=0.0004, rank=3
   4. Feature_92_t2: importance=0.0004, rank=4
   5. Feature_2_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for SCL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SCL...

==================================================
Training Enhanced SCL (SVM)
==================================================
Training SVM model...

Enhanced SCL Performance:
MAE: 30683.2446
RMSE: 40563.1519
MAPE: 9.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t3: importance=0.0009, rank=1
   2. Feature_7_t2: importance=0.0009, rank=2
   3. Feature_14_t1: importance=0.0007, rank=3
   4. Feature_24_t1: importance=0.0007, rank=4
   5. Feature_13_t1: importance=0.0006, rank=5

📊 SCL Results:
  Baseline MAPE: 10.11%
  Enhanced MAPE: 9.65%
  MAPE Improvement: +0.46% (+4.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 368/464: SCSC
============================================================
📊 Loading data for SCSC...
📊 Loading data for SCSC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SCSC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SCSC...

==================================================
Training Baseline SCSC (SVM)
==================================================
Training SVM model...

Baseline SCSC Performance:
MAE: 166784.6698
RMSE: 242181.3330
MAPE: 11.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 142
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t0: importance=0.0013, rank=1
   2. Feature_82_t3: importance=0.0008, rank=2
   3. Feature_0_t3: importance=0.0007, rank=3
   4. Feature_81_t2: importance=0.0006, rank=4
   5. Feature_96_t0: importance=0.0006, rank=5

🔧 Applying universal feature engineering for SCSC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SCSC...

==================================================
Training Enhanced SCSC (SVM)
==================================================
Training SVM model...

Enhanced SCSC Performance:
MAE: 195560.7222
RMSE: 267979.7491
MAPE: 13.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0012, rank=1
   2. Feature_17_t1: importance=0.0011, rank=2
   3. Feature_3_t0: importance=0.0011, rank=3
   4. Feature_20_t2: importance=0.0009, rank=4
   5. Feature_1_t0: importance=0.0009, rank=5

📊 SCSC Results:
  Baseline MAPE: 11.52%
  Enhanced MAPE: 13.89%
  MAPE Improvement: -2.36% (-20.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 369/464: SCVL
============================================================
📊 Loading data for SCVL...
📊 Loading data for SCVL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SCVL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SCVL...

==================================================
Training Baseline SCVL (SVM)
==================================================
Training SVM model...

Baseline SCVL Performance:
MAE: 184399.6350
RMSE: 241794.2977
MAPE: 6.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 264
   • Highly important features (top 5%): 199

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t3: importance=0.0002, rank=1
   2. Feature_80_t2: importance=0.0002, rank=2
   3. Feature_79_t2: importance=0.0002, rank=3
   4. Feature_64_t3: importance=0.0001, rank=4
   5. Feature_67_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SCVL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SCVL...

==================================================
Training Enhanced SCVL (SVM)
==================================================
Training SVM model...

Enhanced SCVL Performance:
MAE: 143225.0184
RMSE: 213002.7369
MAPE: 4.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 59
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0004, rank=1
   2. Feature_16_t1: importance=0.0004, rank=2
   3. Feature_22_t0: importance=0.0003, rank=3
   4. Feature_3_t3: importance=0.0003, rank=4
   5. Feature_11_t1: importance=0.0002, rank=5

📊 SCVL Results:
  Baseline MAPE: 6.41%
  Enhanced MAPE: 4.93%
  MAPE Improvement: +1.48% (+23.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 370/464: SEDG
============================================================
📊 Loading data for SEDG...
📊 Loading data for SEDG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SEDG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SEDG...

==================================================
Training Baseline SEDG (SVM)
==================================================
Training SVM model...

Baseline SEDG Performance:
MAE: 1172683.4451
RMSE: 1513787.2622
MAPE: 7.54%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 216
   • Highly important features (top 5%): 135

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0003, rank=1
   2. Feature_76_t3: importance=0.0002, rank=2
   3. Feature_80_t3: importance=0.0002, rank=3
   4. Feature_76_t2: importance=0.0002, rank=4
   5. Feature_63_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for SEDG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SEDG...

==================================================
Training Enhanced SEDG (SVM)
==================================================
Training SVM model...

Enhanced SEDG Performance:
MAE: 1016809.7647
RMSE: 1357478.7016
MAPE: 6.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0006, rank=1
   2. Feature_17_t3: importance=0.0004, rank=2
   3. Feature_22_t2: importance=0.0004, rank=3
   4. Feature_15_t2: importance=0.0003, rank=4
   5. Feature_9_t2: importance=0.0003, rank=5

📊 SEDG Results:
  Baseline MAPE: 7.54%
  Enhanced MAPE: 6.84%
  MAPE Improvement: +0.70% (+9.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 371/464: SEE
============================================================
📊 Loading data for SEE...
📊 Loading data for SEE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SEE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SEE...

==================================================
Training Baseline SEE (SVM)
==================================================
Training SVM model...

Baseline SEE Performance:
MAE: 551081.7644
RMSE: 731934.9434
MAPE: 9.63%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 245
   • Highly important features (top 5%): 128

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t0: importance=0.0003, rank=1
   2. Feature_71_t3: importance=0.0003, rank=2
   3. Feature_78_t2: importance=0.0003, rank=3
   4. Feature_74_t0: importance=0.0003, rank=4
   5. Feature_67_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for SEE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SEE...

==================================================
Training Enhanced SEE (SVM)
==================================================
Training SVM model...

Enhanced SEE Performance:
MAE: 572037.0188
RMSE: 787727.0575
MAPE: 9.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 66
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0013, rank=1
   2. Feature_13_t1: importance=0.0010, rank=2
   3. Feature_7_t3: importance=0.0007, rank=3
   4. Feature_23_t3: importance=0.0006, rank=4
   5. Feature_9_t3: importance=0.0005, rank=5

📊 SEE Results:
  Baseline MAPE: 9.63%
  Enhanced MAPE: 9.94%
  MAPE Improvement: -0.31% (-3.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 372/464: SEM
============================================================
📊 Loading data for SEM...
📊 Loading data for SEM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SEM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SEM...

==================================================
Training Baseline SEM (SVM)
==================================================
Training SVM model...

Baseline SEM Performance:
MAE: 257811.5746
RMSE: 350258.2505
MAPE: 8.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 295
   • Highly important features (top 5%): 175

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_78_t3: importance=0.0003, rank=1
   2. Feature_65_t3: importance=0.0003, rank=2
   3. Feature_65_t0: importance=0.0002, rank=3
   4. Feature_79_t3: importance=0.0002, rank=4
   5. Feature_70_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for SEM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SEM...

==================================================
Training Enhanced SEM (SVM)
==================================================
Training SVM model...

Enhanced SEM Performance:
MAE: 272898.2634
RMSE: 368018.7974
MAPE: 9.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t1: importance=0.0009, rank=1
   2. Feature_20_t0: importance=0.0008, rank=2
   3. Feature_14_t3: importance=0.0008, rank=3
   4. Feature_15_t3: importance=0.0007, rank=4
   5. Feature_12_t0: importance=0.0006, rank=5

📊 SEM Results:
  Baseline MAPE: 8.60%
  Enhanced MAPE: 9.56%
  MAPE Improvement: -0.97% (-11.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 373/464: SFBS
============================================================
📊 Loading data for SFBS...
📊 Loading data for SFBS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SFBS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SFBS...

==================================================
Training Baseline SFBS (SVM)
==================================================
Training SVM model...

Baseline SFBS Performance:
MAE: 192743.8723
RMSE: 227251.7855
MAPE: 5.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 229
   • Highly important features (top 5%): 116

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_87_t3: importance=0.0001, rank=1
   2. Feature_80_t1: importance=0.0001, rank=2
   3. Feature_76_t1: importance=0.0000, rank=3
   4. Feature_63_t0: importance=0.0000, rank=4
   5. Feature_89_t0: importance=0.0000, rank=5

🔧 Applying universal feature engineering for SFBS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SFBS...

==================================================
Training Enhanced SFBS (SVM)
==================================================
Training SVM model...

Enhanced SFBS Performance:
MAE: 99720.0134
RMSE: 129388.7738
MAPE: 2.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_12_t3: importance=0.0002, rank=1
   2. Feature_4_t2: importance=0.0001, rank=2
   3. Feature_4_t3: importance=0.0001, rank=3
   4. Feature_14_t2: importance=0.0001, rank=4
   5. Feature_20_t0: importance=0.0001, rank=5

📊 SFBS Results:
  Baseline MAPE: 5.14%
  Enhanced MAPE: 2.69%
  MAPE Improvement: +2.45% (+47.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 374/464: SFNC
============================================================
📊 Loading data for SFNC...
📊 Loading data for SFNC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SFNC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SFNC...

==================================================
Training Baseline SFNC (SVM)
==================================================
Training SVM model...

Baseline SFNC Performance:
MAE: 207896.6342
RMSE: 302989.0363
MAPE: 7.78%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 169
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t2: importance=0.0005, rank=1
   2. Feature_78_t1: importance=0.0004, rank=2
   3. Feature_0_t3: importance=0.0003, rank=3
   4. Feature_69_t0: importance=0.0003, rank=4
   5. Feature_71_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for SFNC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SFNC...

==================================================
Training Enhanced SFNC (SVM)
==================================================
Training SVM model...

Enhanced SFNC Performance:
MAE: 209528.5415
RMSE: 309289.0529
MAPE: 7.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0010, rank=1
   2. Feature_13_t3: importance=0.0009, rank=2
   3. Feature_7_t1: importance=0.0009, rank=3
   4. Feature_15_t3: importance=0.0007, rank=4
   5. Feature_20_t3: importance=0.0006, rank=5

📊 SFNC Results:
  Baseline MAPE: 7.78%
  Enhanced MAPE: 7.89%
  MAPE Improvement: -0.12% (-1.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 375/464: SHAK
============================================================
📊 Loading data for SHAK...
📊 Loading data for SHAK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SHAK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SHAK...

==================================================
Training Baseline SHAK (SVM)
==================================================
Training SVM model...

Baseline SHAK Performance:
MAE: 206881.1032
RMSE: 264363.2490
MAPE: 5.09%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 129
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0002, rank=1
   2. Feature_96_t3: importance=0.0001, rank=2
   3. Feature_67_t2: importance=0.0001, rank=3
   4. Feature_63_t0: importance=0.0001, rank=4
   5. Feature_95_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SHAK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SHAK...

==================================================
Training Enhanced SHAK (SVM)
==================================================
Training SVM model...

Enhanced SHAK Performance:
MAE: 211422.6930
RMSE: 271560.9439
MAPE: 5.14%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t1: importance=0.0003, rank=1
   2. Feature_1_t3: importance=0.0002, rank=2
   3. Feature_19_t0: importance=0.0002, rank=3
   4. Feature_19_t3: importance=0.0002, rank=4
   5. Feature_20_t0: importance=0.0002, rank=5

📊 SHAK Results:
  Baseline MAPE: 5.09%
  Enhanced MAPE: 5.14%
  MAPE Improvement: -0.05% (-1.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 376/464: SHEN
============================================================
📊 Loading data for SHEN...
📊 Loading data for SHEN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SHEN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SHEN...

==================================================
Training Baseline SHEN (SVM)
==================================================
Training SVM model...

Baseline SHEN Performance:
MAE: 110532.4648
RMSE: 131783.0500
MAPE: 8.26%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 103
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_84_t3: importance=0.0017, rank=1
   2. Feature_82_t1: importance=0.0016, rank=2
   3. Feature_68_t3: importance=0.0015, rank=3
   4. Feature_96_t3: importance=0.0009, rank=4
   5. Feature_69_t0: importance=0.0007, rank=5

🔧 Applying universal feature engineering for SHEN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SHEN...

==================================================
Training Enhanced SHEN (SVM)
==================================================
Training SVM model...

Enhanced SHEN Performance:
MAE: 106777.3234
RMSE: 127417.9642
MAPE: 7.97%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 57
   • Highly important features (top 5%): 34

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0035, rank=1
   2. Feature_13_t1: importance=0.0028, rank=2
   3. Feature_14_t2: importance=0.0017, rank=3
   4. Feature_20_t2: importance=0.0010, rank=4
   5. Feature_19_t0: importance=0.0009, rank=5

📊 SHEN Results:
  Baseline MAPE: 8.26%
  Enhanced MAPE: 7.97%
  MAPE Improvement: +0.29% (+3.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 377/464: SHO
============================================================
📊 Loading data for SHO...
📊 Loading data for SHO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SHO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SHO...

==================================================
Training Baseline SHO (SVM)
==================================================
Training SVM model...

Baseline SHO Performance:
MAE: 1351492.6029
RMSE: 1747244.6497
MAPE: 10.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 284
   • Highly important features (top 5%): 127

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t2: importance=0.0003, rank=1
   2. Feature_2_t1: importance=0.0003, rank=2
   3. Feature_68_t2: importance=0.0003, rank=3
   4. Feature_63_t1: importance=0.0002, rank=4
   5. Feature_2_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for SHO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SHO...

==================================================
Training Enhanced SHO (SVM)
==================================================
Training SVM model...

Enhanced SHO Performance:
MAE: 1314510.8737
RMSE: 1828157.8391
MAPE: 10.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0010, rank=1
   2. Feature_19_t1: importance=0.0009, rank=2
   3. Feature_16_t1: importance=0.0008, rank=3
   4. Feature_24_t2: importance=0.0008, rank=4
   5. Feature_19_t3: importance=0.0007, rank=5

📊 SHO Results:
  Baseline MAPE: 10.56%
  Enhanced MAPE: 10.23%
  MAPE Improvement: +0.34% (+3.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 378/464: SHOO
============================================================
📊 Loading data for SHOO...
📊 Loading data for SHOO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SHOO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SHOO...

==================================================
Training Baseline SHOO (SVM)
==================================================
Training SVM model...

Baseline SHOO Performance:
MAE: 425743.8668
RMSE: 564943.6326
MAPE: 11.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 206
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0006, rank=1
   2. Feature_70_t0: importance=0.0005, rank=2
   3. Feature_72_t3: importance=0.0004, rank=3
   4. Feature_67_t0: importance=0.0003, rank=4
   5. Feature_77_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for SHOO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SHOO...

==================================================
Training Enhanced SHOO (SVM)
==================================================
Training SVM model...

Enhanced SHOO Performance:
MAE: 381447.7867
RMSE: 536788.0743
MAPE: 10.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0007, rank=1
   2. Feature_19_t3: importance=0.0006, rank=2
   3. Feature_20_t0: importance=0.0006, rank=3
   4. Feature_13_t2: importance=0.0005, rank=4
   5. Feature_13_t0: importance=0.0004, rank=5

📊 SHOO Results:
  Baseline MAPE: 11.83%
  Enhanced MAPE: 10.70%
  MAPE Improvement: +1.13% (+9.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 379/464: SIG
============================================================
📊 Loading data for SIG...
📊 Loading data for SIG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SIG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SIG...

==================================================
Training Baseline SIG (SVM)
==================================================
Training SVM model...

Baseline SIG Performance:
MAE: 337503.3160
RMSE: 422032.3160
MAPE: 6.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 221
   • Highly important features (top 5%): 121

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0003, rank=1
   2. Feature_64_t3: importance=0.0002, rank=2
   3. Feature_94_t3: importance=0.0002, rank=3
   4. Feature_93_t3: importance=0.0002, rank=4
   5. Feature_68_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SIG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SIG...

==================================================
Training Enhanced SIG (SVM)
==================================================
Training SVM model...

Enhanced SIG Performance:
MAE: 268179.9061
RMSE: 349096.6311
MAPE: 5.52%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t0: importance=0.0003, rank=1
   2. Feature_24_t0: importance=0.0003, rank=2
   3. Feature_7_t3: importance=0.0003, rank=3
   4. Feature_20_t3: importance=0.0002, rank=4
   5. Feature_19_t0: importance=0.0002, rank=5

📊 SIG Results:
  Baseline MAPE: 6.96%
  Enhanced MAPE: 5.52%
  MAPE Improvement: +1.45% (+20.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 380/464: SKT
============================================================
📊 Loading data for SKT...
📊 Loading data for SKT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing SKT: 'SKT'

============================================================
TESTING TICKER 381/464: SKY
============================================================
📊 Loading data for SKY...
📊 Loading data for SKY from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing SKY: 'SKY'

============================================================
TESTING TICKER 382/464: SKYW
============================================================
📊 Loading data for SKYW...
📊 Loading data for SKYW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SKYW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SKYW...

==================================================
Training Baseline SKYW (SVM)
==================================================
Training SVM model...

Baseline SKYW Performance:
MAE: 179153.4295
RMSE: 214474.0331
MAPE: 12.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 245
   • Highly important features (top 5%): 119

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t2: importance=0.0005, rank=1
   2. Feature_86_t3: importance=0.0003, rank=2
   3. Feature_0_t3: importance=0.0003, rank=3
   4. Feature_2_t1: importance=0.0003, rank=4
   5. Feature_70_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for SKYW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SKYW...

==================================================
Training Enhanced SKYW (SVM)
==================================================
Training SVM model...

Enhanced SKYW Performance:
MAE: 144446.2800
RMSE: 179324.5404
MAPE: 9.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 89

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0006, rank=1
   2. Feature_17_t2: importance=0.0005, rank=2
   3. Feature_15_t3: importance=0.0005, rank=3
   4. Feature_21_t0: importance=0.0004, rank=4
   5. Feature_24_t2: importance=0.0004, rank=5

📊 SKYW Results:
  Baseline MAPE: 12.03%
  Enhanced MAPE: 9.66%
  MAPE Improvement: +2.37% (+19.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 383/464: SLG
============================================================
📊 Loading data for SLG...
📊 Loading data for SLG from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SLG...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SLG...

==================================================
Training Baseline SLG (SVM)
==================================================
Training SVM model...

Baseline SLG Performance:
MAE: 437113.1914
RMSE: 560535.7022
MAPE: 5.00%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 262
   • Highly important features (top 5%): 150

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_90_t3: importance=0.0003, rank=1
   2. Feature_95_t3: importance=0.0002, rank=2
   3. Feature_2_t2: importance=0.0001, rank=3
   4. Feature_85_t1: importance=0.0001, rank=4
   5. Feature_64_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SLG...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SLG...

==================================================
Training Enhanced SLG (SVM)
==================================================
Training SVM model...

Enhanced SLG Performance:
MAE: 411671.2550
RMSE: 554669.9624
MAPE: 4.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t2: importance=0.0002, rank=1
   2. Feature_19_t3: importance=0.0002, rank=2
   3. Feature_12_t1: importance=0.0002, rank=3
   4. Feature_20_t0: importance=0.0002, rank=4
   5. Feature_9_t3: importance=0.0002, rank=5

📊 SLG Results:
  Baseline MAPE: 5.00%
  Enhanced MAPE: 4.87%
  MAPE Improvement: +0.14% (+2.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 384/464: SM
============================================================
📊 Loading data for SM...
📊 Loading data for SM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SM...

==================================================
Training Baseline SM (SVM)
==================================================
Training SVM model...

Baseline SM Performance:
MAE: 783586.6342
RMSE: 991888.0015
MAPE: 7.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 177
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_66_t2: importance=0.0004, rank=1
   2. Feature_66_t3: importance=0.0004, rank=2
   3. Feature_2_t0: importance=0.0004, rank=3
   4. Feature_63_t1: importance=0.0003, rank=4
   5. Feature_69_t2: importance=0.0003, rank=5

🔧 Applying universal feature engineering for SM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SM...

==================================================
Training Enhanced SM (SVM)
==================================================
Training SVM model...

Enhanced SM Performance:
MAE: 836880.1730
RMSE: 989421.8569
MAPE: 7.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0019, rank=1
   2. Feature_22_t3: importance=0.0009, rank=2
   3. Feature_22_t2: importance=0.0009, rank=3
   4. Feature_15_t2: importance=0.0006, rank=4
   5. Feature_14_t0: importance=0.0006, rank=5

📊 SM Results:
  Baseline MAPE: 7.57%
  Enhanced MAPE: 7.98%
  MAPE Improvement: -0.41% (-5.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 385/464: SMP
============================================================
📊 Loading data for SMP...
📊 Loading data for SMP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SMP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SMP...

==================================================
Training Baseline SMP (SVM)
==================================================
Training SVM model...

Baseline SMP Performance:
MAE: 119992.5877
RMSE: 159133.4498
MAPE: 21.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 320
   • Highly important features (top 5%): 179

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0007, rank=1
   2. Feature_78_t1: importance=0.0006, rank=2
   3. Feature_87_t2: importance=0.0005, rank=3
   4. Feature_83_t0: importance=0.0005, rank=4
   5. Feature_65_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for SMP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SMP...

==================================================
Training Enhanced SMP (SVM)
==================================================
Training SVM model...

Enhanced SMP Performance:
MAE: 118299.5333
RMSE: 155119.4622
MAPE: 19.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t3: importance=0.0017, rank=1
   2. Feature_12_t0: importance=0.0011, rank=2
   3. Feature_15_t3: importance=0.0010, rank=3
   4. Feature_22_t3: importance=0.0010, rank=4
   5. Feature_22_t0: importance=0.0009, rank=5

📊 SMP Results:
  Baseline MAPE: 21.40%
  Enhanced MAPE: 19.81%
  MAPE Improvement: +1.59% (+7.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 386/464: SMPL
============================================================
📊 Loading data for SMPL...
📊 Loading data for SMPL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing SMPL: 'SMPL'

============================================================
TESTING TICKER 387/464: SMTC
============================================================
📊 Loading data for SMTC...
📊 Loading data for SMTC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SMTC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SMTC...

==================================================
Training Baseline SMTC (SVM)
==================================================
Training SVM model...

Baseline SMTC Performance:
MAE: 1034021.5288
RMSE: 1457755.0101
MAPE: 11.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 116
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0014, rank=1
   2. Feature_65_t0: importance=0.0012, rank=2
   3. Feature_93_t2: importance=0.0009, rank=3
   4. Feature_94_t2: importance=0.0008, rank=4
   5. Feature_63_t3: importance=0.0006, rank=5

🔧 Applying universal feature engineering for SMTC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SMTC...

==================================================
Training Enhanced SMTC (SVM)
==================================================
Training SVM model...

Enhanced SMTC Performance:
MAE: 960322.2884
RMSE: 1475731.7754
MAPE: 11.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t2: importance=0.0021, rank=1
   2. Feature_5_t0: importance=0.0013, rank=2
   3. Feature_10_t2: importance=0.0011, rank=3
   4. Feature_16_t3: importance=0.0009, rank=4
   5. Feature_24_t2: importance=0.0007, rank=5

📊 SMTC Results:
  Baseline MAPE: 11.96%
  Enhanced MAPE: 11.18%
  MAPE Improvement: +0.77% (+6.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 388/464: SNDR
============================================================
📊 Loading data for SNDR...
📊 Loading data for SNDR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing SNDR: 'SNDR'

============================================================
TESTING TICKER 389/464: SPSC
============================================================
📊 Loading data for SPSC...
📊 Loading data for SPSC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SPSC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SPSC...

==================================================
Training Baseline SPSC (SVM)
==================================================
Training SVM model...

Baseline SPSC Performance:
MAE: 83649.7939
RMSE: 110374.0926
MAPE: 9.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 208
   • Highly important features (top 5%): 98

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0013, rank=1
   2. Feature_0_t3: importance=0.0005, rank=2
   3. Feature_78_t2: importance=0.0005, rank=3
   4. Feature_0_t1: importance=0.0004, rank=4
   5. Feature_86_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for SPSC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SPSC...

==================================================
Training Enhanced SPSC (SVM)
==================================================
Training SVM model...

Enhanced SPSC Performance:
MAE: 101083.4280
RMSE: 128000.5850
MAPE: 11.82%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0015, rank=1
   2. Feature_16_t1: importance=0.0013, rank=2
   3. Feature_11_t3: importance=0.0012, rank=3
   4. Feature_23_t3: importance=0.0010, rank=4
   5. Feature_24_t3: importance=0.0010, rank=5

📊 SPSC Results:
  Baseline MAPE: 9.74%
  Enhanced MAPE: 11.82%
  MAPE Improvement: -2.08% (-21.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 390/464: SPXC
============================================================
📊 Loading data for SPXC...
📊 Loading data for SPXC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SPXC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SPXC...

==================================================
Training Baseline SPXC (SVM)
==================================================
Training SVM model...

Baseline SPXC Performance:
MAE: 63722.1471
RMSE: 80737.4456
MAPE: 9.73%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 180
   • Highly important features (top 5%): 91

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0006, rank=1
   2. Feature_65_t0: importance=0.0005, rank=2
   3. Feature_71_t1: importance=0.0005, rank=3
   4. Feature_94_t3: importance=0.0004, rank=4
   5. Feature_96_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for SPXC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SPXC...

==================================================
Training Enhanced SPXC (SVM)
==================================================
Training SVM model...

Enhanced SPXC Performance:
MAE: 69203.0035
RMSE: 88439.7256
MAPE: 10.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 88

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0007, rank=1
   2. Feature_7_t1: importance=0.0006, rank=2
   3. Feature_17_t3: importance=0.0006, rank=3
   4. Feature_23_t3: importance=0.0005, rank=4
   5. Feature_0_t3: importance=0.0005, rank=5

📊 SPXC Results:
  Baseline MAPE: 9.73%
  Enhanced MAPE: 10.27%
  MAPE Improvement: -0.54% (-5.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 391/464: SRPT
============================================================
📊 Loading data for SRPT...
📊 Loading data for SRPT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SRPT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Error: Ticker 'SRPT' not found in short volume data.
Retrieved short volume data for 0 days
Creating short volume features with 15 days lookback...
No short volume data available, creating zero features
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SRPT...

==================================================
Training Baseline SRPT (SVM)
==================================================
Training SVM model...

Baseline SRPT Performance:
MAE: 671815.5123
RMSE: 1138522.0027
MAPE: 8.94%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 67
   • Highly important features (top 5%): 46

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_66_t1: importance=0.0008, rank=1
   2. Feature_63_t3: importance=0.0006, rank=2
   3. Feature_65_t3: importance=0.0004, rank=3
   4. Feature_63_t0: importance=0.0001, rank=4
   5. Feature_65_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SRPT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SRPT...

==================================================
Training Enhanced SRPT (SVM)
==================================================
Training SVM model...

Enhanced SRPT Performance:
MAE: 638746.9841
RMSE: 1131177.4868
MAPE: 8.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 70
   • Highly important features (top 5%): 52

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0002, rank=1
   2. Feature_24_t1: importance=0.0002, rank=2
   3. Feature_6_t1: importance=0.0002, rank=3
   4. Feature_16_t3: importance=0.0002, rank=4
   5. Feature_6_t3: importance=0.0002, rank=5

📊 SRPT Results:
  Baseline MAPE: 8.94%
  Enhanced MAPE: 8.38%
  MAPE Improvement: +0.56% (+6.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 392/464: SSTK
============================================================
📊 Loading data for SSTK...
📊 Loading data for SSTK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SSTK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SSTK...

==================================================
Training Baseline SSTK (SVM)
==================================================
Training SVM model...

Baseline SSTK Performance:
MAE: 235984.3807
RMSE: 298900.4420
MAPE: 7.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 168
   • Highly important features (top 5%): 62

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_64_t1: importance=0.0002, rank=1
   2. Feature_2_t2: importance=0.0002, rank=2
   3. Feature_74_t2: importance=0.0001, rank=3
   4. Feature_65_t3: importance=0.0001, rank=4
   5. Feature_78_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SSTK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SSTK...

==================================================
Training Enhanced SSTK (SVM)
==================================================
Training SVM model...

Enhanced SSTK Performance:
MAE: 208234.7654
RMSE: 252816.9068
MAPE: 5.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 78
   • Highly important features (top 5%): 63

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0006, rank=1
   2. Feature_7_t3: importance=0.0004, rank=2
   3. Feature_20_t2: importance=0.0003, rank=3
   4. Feature_5_t3: importance=0.0002, rank=4
   5. Feature_7_t1: importance=0.0002, rank=5

📊 SSTK Results:
  Baseline MAPE: 7.08%
  Enhanced MAPE: 5.89%
  MAPE Improvement: +1.19% (+16.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 393/464: STAA
============================================================
📊 Loading data for STAA...
📊 Loading data for STAA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for STAA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for STAA...

==================================================
Training Baseline STAA (SVM)
==================================================
Training SVM model...

Baseline STAA Performance:
MAE: 399591.9750
RMSE: 527489.7032
MAPE: 8.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 195
   • Highly important features (top 5%): 101

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0004, rank=1
   2. Feature_75_t3: importance=0.0003, rank=2
   3. Feature_94_t2: importance=0.0003, rank=3
   4. Feature_1_t2: importance=0.0002, rank=4
   5. Feature_67_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for STAA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for STAA...

==================================================
Training Enhanced STAA (SVM)
==================================================
Training SVM model...

Enhanced STAA Performance:
MAE: 342579.5210
RMSE: 447736.2878
MAPE: 7.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0008, rank=1
   2. Feature_15_t1: importance=0.0005, rank=2
   3. Feature_5_t3: importance=0.0004, rank=3
   4. Feature_15_t3: importance=0.0004, rank=4
   5. Feature_1_t3: importance=0.0004, rank=5

📊 STAA Results:
  Baseline MAPE: 8.64%
  Enhanced MAPE: 7.74%
  MAPE Improvement: +0.90% (+10.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 394/464: STBA
============================================================
📊 Loading data for STBA...
📊 Loading data for STBA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for STBA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for STBA...

==================================================
Training Baseline STBA (SVM)
==================================================
Training SVM model...

Baseline STBA Performance:
MAE: 53363.5343
RMSE: 66789.8168
MAPE: 6.17%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 140
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0002, rank=1
   2. Feature_96_t1: importance=0.0002, rank=2
   3. Feature_92_t3: importance=0.0002, rank=3
   4. Feature_80_t0: importance=0.0001, rank=4
   5. Feature_92_t1: importance=0.0001, rank=5

🔧 Applying universal feature engineering for STBA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for STBA...

==================================================
Training Enhanced STBA (SVM)
==================================================
Training SVM model...

Enhanced STBA Performance:
MAE: 46056.2286
RMSE: 62510.8490
MAPE: 5.55%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0004, rank=1
   2. Feature_23_t1: importance=0.0004, rank=2
   3. Feature_22_t2: importance=0.0003, rank=3
   4. Feature_13_t1: importance=0.0003, rank=4
   5. Feature_14_t0: importance=0.0003, rank=5

📊 STBA Results:
  Baseline MAPE: 6.17%
  Enhanced MAPE: 5.55%
  MAPE Improvement: +0.62% (+10.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 395/464: STC
============================================================
📊 Loading data for STC...
📊 Loading data for STC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for STC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for STC...

==================================================
Training Baseline STC (SVM)
==================================================
Training SVM model...

Baseline STC Performance:
MAE: 120968.3779
RMSE: 205855.0849
MAPE: 18.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 156
   • Highly important features (top 5%): 88

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_96_t0: importance=0.0020, rank=1
   2. Feature_95_t0: importance=0.0013, rank=2
   3. Feature_85_t2: importance=0.0012, rank=3
   4. Feature_2_t2: importance=0.0010, rank=4
   5. Feature_95_t3: importance=0.0009, rank=5

🔧 Applying universal feature engineering for STC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for STC...

==================================================
Training Enhanced STC (SVM)
==================================================
Training SVM model...

Enhanced STC Performance:
MAE: 112193.2868
RMSE: 187421.7477
MAPE: 17.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 83
   • Highly important features (top 5%): 51

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_14_t2: importance=0.0044, rank=1
   2. Feature_17_t0: importance=0.0030, rank=2
   3. Feature_13_t3: importance=0.0024, rank=3
   4. Feature_15_t1: importance=0.0024, rank=4
   5. Feature_22_t2: importance=0.0019, rank=5

📊 STC Results:
  Baseline MAPE: 18.42%
  Enhanced MAPE: 17.28%
  MAPE Improvement: +1.13% (+6.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 396/464: STRA
============================================================
📊 Loading data for STRA...
📊 Loading data for STRA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for STRA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for STRA...

==================================================
Training Baseline STRA (SVM)
==================================================
Training SVM model...

Baseline STRA Performance:
MAE: 47018.0453
RMSE: 62429.7982
MAPE: 10.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 220
   • Highly important features (top 5%): 105

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t2: importance=0.0006, rank=1
   2. Feature_78_t2: importance=0.0004, rank=2
   3. Feature_72_t2: importance=0.0003, rank=3
   4. Feature_71_t0: importance=0.0003, rank=4
   5. Feature_72_t1: importance=0.0003, rank=5

🔧 Applying universal feature engineering for STRA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for STRA...

==================================================
Training Enhanced STRA (SVM)
==================================================
Training SVM model...

Enhanced STRA Performance:
MAE: 56255.2634
RMSE: 73487.1077
MAPE: 13.44%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 39
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t1: importance=0.0043, rank=1
   2. Feature_20_t1: importance=0.0015, rank=2
   3. Feature_13_t3: importance=0.0013, rank=3
   4. Feature_6_t1: importance=0.0007, rank=4
   5. Feature_4_t1: importance=0.0006, rank=5

📊 STRA Results:
  Baseline MAPE: 10.96%
  Enhanced MAPE: 13.44%
  MAPE Improvement: -2.48% (-22.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 397/464: STRL
============================================================
📊 Loading data for STRL...
📊 Loading data for STRL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for STRL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for STRL...

==================================================
Training Baseline STRL (SVM)
==================================================
Training SVM model...

Baseline STRL Performance:
MAE: 163640.2970
RMSE: 261275.8337
MAPE: 9.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 192
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_75_t3: importance=0.0008, rank=1
   2. Feature_68_t0: importance=0.0007, rank=2
   3. Feature_64_t0: importance=0.0005, rank=3
   4. Feature_76_t1: importance=0.0004, rank=4
   5. Feature_79_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for STRL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for STRL...

==================================================
Training Enhanced STRL (SVM)
==================================================
Training SVM model...

Enhanced STRL Performance:
MAE: 154276.1123
RMSE: 252516.4863
MAPE: 8.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t0: importance=0.0009, rank=1
   2. Feature_17_t1: importance=0.0008, rank=2
   3. Feature_19_t3: importance=0.0007, rank=3
   4. Feature_17_t0: importance=0.0007, rank=4
   5. Feature_15_t3: importance=0.0006, rank=5

📊 STRL Results:
  Baseline MAPE: 9.70%
  Enhanced MAPE: 8.91%
  MAPE Improvement: +0.80% (+8.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 398/464: SUPN
============================================================
📊 Loading data for SUPN...
📊 Loading data for SUPN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SUPN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SUPN...

==================================================
Training Baseline SUPN (SVM)
==================================================
Training SVM model...

Baseline SUPN Performance:
MAE: 310351.9922
RMSE: 391859.2410
MAPE: 6.01%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 128
   • Highly important features (top 5%): 33

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t1: importance=0.0002, rank=1
   2. Feature_2_t1: importance=0.0001, rank=2
   3. Feature_0_t0: importance=0.0001, rank=3
   4. Feature_95_t1: importance=0.0001, rank=4
   5. Feature_91_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for SUPN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SUPN...

==================================================
Training Enhanced SUPN (SVM)
==================================================
Training SVM model...

Enhanced SUPN Performance:
MAE: 282614.6030
RMSE: 355233.6428
MAPE: 5.47%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 51

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t1: importance=0.0002, rank=1
   2. Feature_4_t1: importance=0.0002, rank=2
   3. Feature_24_t1: importance=0.0001, rank=3
   4. Feature_9_t1: importance=0.0001, rank=4
   5. Feature_2_t1: importance=0.0001, rank=5

📊 SUPN Results:
  Baseline MAPE: 6.01%
  Enhanced MAPE: 5.47%
  MAPE Improvement: +0.54% (+9.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 399/464: SXC
============================================================
📊 Loading data for SXC...
📊 Loading data for SXC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SXC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SXC...

==================================================
Training Baseline SXC (SVM)
==================================================
Training SVM model...

Baseline SXC Performance:
MAE: 537534.3858
RMSE: 777529.0739
MAPE: 15.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 254
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t1: importance=0.0015, rank=1
   2. Feature_2_t3: importance=0.0009, rank=2
   3. Feature_2_t2: importance=0.0009, rank=3
   4. Feature_87_t0: importance=0.0009, rank=4
   5. Feature_90_t0: importance=0.0007, rank=5

🔧 Applying universal feature engineering for SXC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SXC...

==================================================
Training Enhanced SXC (SVM)
==================================================
Training SVM model...

Enhanced SXC Performance:
MAE: 541138.0788
RMSE: 735148.1194
MAPE: 14.87%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 97
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0025, rank=1
   2. Feature_7_t2: importance=0.0022, rank=2
   3. Feature_1_t1: importance=0.0021, rank=3
   4. Feature_20_t3: importance=0.0020, rank=4
   5. Feature_9_t3: importance=0.0019, rank=5

📊 SXC Results:
  Baseline MAPE: 15.80%
  Enhanced MAPE: 14.87%
  MAPE Improvement: +0.93% (+5.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 400/464: SXI
============================================================
📊 Loading data for SXI...
📊 Loading data for SXI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SXI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SXI...

==================================================
Training Baseline SXI (SVM)
==================================================
Training SVM model...

Baseline SXI Performance:
MAE: 21691.0582
RMSE: 27764.2618
MAPE: 10.23%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 268
   • Highly important features (top 5%): 172

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0020, rank=1
   2. Feature_73_t3: importance=0.0014, rank=2
   3. Feature_94_t2: importance=0.0014, rank=3
   4. Feature_63_t3: importance=0.0013, rank=4
   5. Feature_80_t3: importance=0.0011, rank=5

🔧 Applying universal feature engineering for SXI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SXI...

==================================================
Training Enhanced SXI (SVM)
==================================================
Training SVM model...

Enhanced SXI Performance:
MAE: 31261.2835
RMSE: 36312.6862
MAPE: 14.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 91

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t1: importance=0.0014, rank=1
   2. Feature_19_t3: importance=0.0012, rank=2
   3. Feature_21_t2: importance=0.0011, rank=3
   4. Feature_14_t3: importance=0.0011, rank=4
   5. Feature_12_t2: importance=0.0011, rank=5

📊 SXI Results:
  Baseline MAPE: 10.23%
  Enhanced MAPE: 14.25%
  MAPE Improvement: -4.02% (-39.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 401/464: SXT
============================================================
📊 Loading data for SXT...
📊 Loading data for SXT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for SXT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for SXT...

==================================================
Training Baseline SXT (SVM)
==================================================
Training SVM model...

Baseline SXT Performance:
MAE: 84243.3650
RMSE: 127045.1486
MAPE: 10.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 314
   • Highly important features (top 5%): 173

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0014, rank=1
   2. Feature_81_t2: importance=0.0005, rank=2
   3. Feature_63_t2: importance=0.0003, rank=3
   4. Feature_1_t2: importance=0.0003, rank=4
   5. Feature_63_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for SXT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for SXT...

==================================================
Training Enhanced SXT (SVM)
==================================================
Training SVM model...

Enhanced SXT Performance:
MAE: 87320.0197
RMSE: 132425.0652
MAPE: 10.93%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0010, rank=1
   2. Feature_4_t1: importance=0.0008, rank=2
   3. Feature_7_t0: importance=0.0007, rank=3
   4. Feature_22_t3: importance=0.0007, rank=4
   5. Feature_1_t3: importance=0.0007, rank=5

📊 SXT Results:
  Baseline MAPE: 10.68%
  Enhanced MAPE: 10.93%
  MAPE Improvement: -0.25% (-2.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 402/464: TBBK
============================================================
📊 Loading data for TBBK...
📊 Loading data for TBBK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TBBK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TBBK...

==================================================
Training Baseline TBBK (SVM)
==================================================
Training SVM model...

Baseline TBBK Performance:
MAE: 313424.0936
RMSE: 379319.7253
MAPE: 5.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 195
   • Highly important features (top 5%): 120

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t2: importance=0.0008, rank=1
   2. Feature_74_t3: importance=0.0007, rank=2
   3. Feature_65_t3: importance=0.0007, rank=3
   4. Feature_76_t3: importance=0.0006, rank=4
   5. Feature_88_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for TBBK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TBBK...

==================================================
Training Enhanced TBBK (SVM)
==================================================
Training SVM model...

Enhanced TBBK Performance:
MAE: 283666.6849
RMSE: 373013.2208
MAPE: 4.99%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 45

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0021, rank=1
   2. Feature_5_t2: importance=0.0020, rank=2
   3. Feature_5_t0: importance=0.0017, rank=3
   4. Feature_12_t0: importance=0.0014, rank=4
   5. Feature_19_t1: importance=0.0010, rank=5

📊 TBBK Results:
  Baseline MAPE: 5.25%
  Enhanced MAPE: 4.99%
  MAPE Improvement: +0.26% (+4.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 403/464: TDC
============================================================
📊 Loading data for TDC...
📊 Loading data for TDC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TDC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TDC...

==================================================
Training Baseline TDC (SVM)
==================================================
Training SVM model...

Baseline TDC Performance:
MAE: 352950.0881
RMSE: 461073.0540
MAPE: 9.13%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 213
   • Highly important features (top 5%): 108

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0008, rank=1
   2. Feature_69_t3: importance=0.0002, rank=2
   3. Feature_75_t0: importance=0.0002, rank=3
   4. Feature_94_t3: importance=0.0002, rank=4
   5. Feature_81_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for TDC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TDC...

==================================================
Training Enhanced TDC (SVM)
==================================================
Training SVM model...

Enhanced TDC Performance:
MAE: 338300.2109
RMSE: 439344.4630
MAPE: 8.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 61
   • Highly important features (top 5%): 41

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t1: importance=0.0005, rank=1
   2. Feature_5_t2: importance=0.0004, rank=2
   3. Feature_17_t1: importance=0.0003, rank=3
   4. Feature_6_t0: importance=0.0002, rank=4
   5. Feature_15_t3: importance=0.0002, rank=5

📊 TDC Results:
  Baseline MAPE: 9.13%
  Enhanced MAPE: 8.77%
  MAPE Improvement: +0.36% (+3.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 404/464: TDS
============================================================
📊 Loading data for TDS...
📊 Loading data for TDS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TDS: 'TDS'

============================================================
TESTING TICKER 405/464: TDW
============================================================
📊 Loading data for TDW...
📊 Loading data for TDW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TDW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TDW...

==================================================
Training Baseline TDW (SVM)
==================================================
Training SVM model...

Baseline TDW Performance:
MAE: 401722.6307
RMSE: 495442.0127
MAPE: 7.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 78
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t0: importance=0.0007, rank=1
   2. Feature_72_t3: importance=0.0006, rank=2
   3. Feature_68_t0: importance=0.0006, rank=3
   4. Feature_91_t1: importance=0.0006, rank=4
   5. Feature_90_t1: importance=0.0006, rank=5

🔧 Applying universal feature engineering for TDW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TDW...

==================================================
Training Enhanced TDW (SVM)
==================================================
Training SVM model...

Enhanced TDW Performance:
MAE: 366152.3274
RMSE: 476265.2385
MAPE: 6.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 53
   • Highly important features (top 5%): 27

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0035, rank=1
   2. Feature_20_t3: importance=0.0015, rank=2
   3. Feature_23_t0: importance=0.0010, rank=3
   4. Feature_17_t0: importance=0.0009, rank=4
   5. Feature_12_t1: importance=0.0009, rank=5

📊 TDW Results:
  Baseline MAPE: 7.40%
  Enhanced MAPE: 6.70%
  MAPE Improvement: +0.70% (+9.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 406/464: TFX
============================================================
📊 Loading data for TFX...
📊 Loading data for TFX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TFX...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TFX...

==================================================
Training Baseline TFX (SVM)
==================================================
Training SVM model...

Baseline TFX Performance:
MAE: 198649.0016
RMSE: 332601.8244
MAPE: 20.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 325
   • Highly important features (top 5%): 179

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0005, rank=1
   2. Feature_78_t3: importance=0.0004, rank=2
   3. Feature_64_t1: importance=0.0004, rank=3
   4. Feature_96_t3: importance=0.0004, rank=4
   5. Feature_82_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for TFX...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TFX...

==================================================
Training Enhanced TFX (SVM)
==================================================
Training SVM model...

Enhanced TFX Performance:
MAE: 195832.6883
RMSE: 330327.1031
MAPE: 20.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 85

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t3: importance=0.0016, rank=1
   2. Feature_24_t0: importance=0.0006, rank=2
   3. Feature_4_t3: importance=0.0005, rank=3
   4. Feature_7_t3: importance=0.0005, rank=4
   5. Feature_19_t1: importance=0.0005, rank=5

📊 TFX Results:
  Baseline MAPE: 20.91%
  Enhanced MAPE: 20.77%
  MAPE Improvement: +0.13% (+0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 407/464: TGNA
============================================================
📊 Loading data for TGNA...
📊 Loading data for TGNA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TGNA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TGNA...

==================================================
Training Baseline TGNA (SVM)
==================================================
Training SVM model...

Baseline TGNA Performance:
MAE: 880329.2902
RMSE: 1149203.5960
MAPE: 11.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 241
   • Highly important features (top 5%): 134

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t3: importance=0.0014, rank=1
   2. Feature_65_t3: importance=0.0014, rank=2
   3. Feature_0_t2: importance=0.0010, rank=3
   4. Feature_93_t1: importance=0.0009, rank=4
   5. Feature_75_t3: importance=0.0008, rank=5

🔧 Applying universal feature engineering for TGNA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TGNA...

==================================================
Training Enhanced TGNA (SVM)
==================================================
Training SVM model...

Enhanced TGNA Performance:
MAE: 857671.4588
RMSE: 1241346.2808
MAPE: 10.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_6_t3: importance=0.0028, rank=1
   2. Feature_17_t1: importance=0.0024, rank=2
   3. Feature_21_t0: importance=0.0020, rank=3
   4. Feature_22_t0: importance=0.0020, rank=4
   5. Feature_2_t1: importance=0.0020, rank=5

📊 TGNA Results:
  Baseline MAPE: 11.06%
  Enhanced MAPE: 10.66%
  MAPE Improvement: +0.40% (+3.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 408/464: TGTX
============================================================
📊 Loading data for TGTX...
📊 Loading data for TGTX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TGTX: 'TGTX'

============================================================
TESTING TICKER 409/464: THRM
============================================================
📊 Loading data for THRM...
📊 Loading data for THRM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for THRM...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for THRM...

==================================================
Training Baseline THRM (SVM)
==================================================
Training SVM model...

Baseline THRM Performance:
MAE: 100622.6494
RMSE: 135658.6105
MAPE: 10.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 153
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t2: importance=0.0007, rank=1
   2. Feature_92_t1: importance=0.0004, rank=2
   3. Feature_65_t0: importance=0.0003, rank=3
   4. Feature_76_t1: importance=0.0003, rank=4
   5. Feature_76_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for THRM...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for THRM...

==================================================
Training Enhanced THRM (SVM)
==================================================
Training SVM model...

Enhanced THRM Performance:
MAE: 95356.4300
RMSE: 126044.3360
MAPE: 10.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 65
   • Highly important features (top 5%): 39

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_23_t1: importance=0.0013, rank=1
   2. Feature_15_t3: importance=0.0011, rank=2
   3. Feature_5_t2: importance=0.0009, rank=3
   4. Feature_15_t2: importance=0.0007, rank=4
   5. Feature_19_t1: importance=0.0006, rank=5

📊 THRM Results:
  Baseline MAPE: 10.51%
  Enhanced MAPE: 10.38%
  MAPE Improvement: +0.14% (+1.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 410/464: THS
============================================================
📊 Loading data for THS...
📊 Loading data for THS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for THS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for THS...

==================================================
Training Baseline THS (SVM)
==================================================
Training SVM model...

Baseline THS Performance:
MAE: 208396.1000
RMSE: 306211.0807
MAPE: 9.65%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 157
   • Highly important features (top 5%): 79

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t0: importance=0.0003, rank=1
   2. Feature_67_t1: importance=0.0002, rank=2
   3. Feature_85_t3: importance=0.0002, rank=3
   4. Feature_71_t1: importance=0.0002, rank=4
   5. Feature_89_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for THS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for THS...

==================================================
Training Enhanced THS (SVM)
==================================================
Training SVM model...

Enhanced THS Performance:
MAE: 184958.5943
RMSE: 289210.4866
MAPE: 8.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 40

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t0: importance=0.0005, rank=1
   2. Feature_20_t1: importance=0.0003, rank=2
   3. Feature_19_t1: importance=0.0003, rank=3
   4. Feature_7_t1: importance=0.0003, rank=4
   5. Feature_13_t1: importance=0.0002, rank=5

📊 THS Results:
  Baseline MAPE: 9.65%
  Enhanced MAPE: 8.42%
  MAPE Improvement: +1.23% (+12.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 411/464: TILE
============================================================
📊 Loading data for TILE...
📊 Loading data for TILE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TILE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TILE...

==================================================
Training Baseline TILE (SVM)
==================================================
Training SVM model...

Baseline TILE Performance:
MAE: 299405.3101
RMSE: 452594.5467
MAPE: 17.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 319
   • Highly important features (top 5%): 127

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t1: importance=0.0006, rank=1
   2. Feature_81_t0: importance=0.0005, rank=2
   3. Feature_73_t3: importance=0.0005, rank=3
   4. Feature_77_t2: importance=0.0005, rank=4
   5. Feature_70_t2: importance=0.0005, rank=5

🔧 Applying universal feature engineering for TILE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TILE...

==================================================
Training Enhanced TILE (SVM)
==================================================
Training SVM model...

Enhanced TILE Performance:
MAE: 284413.7749
RMSE: 417007.6673
MAPE: 16.12%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t1: importance=0.0011, rank=1
   2. Feature_1_t0: importance=0.0010, rank=2
   3. Feature_11_t2: importance=0.0010, rank=3
   4. Feature_19_t2: importance=0.0008, rank=4
   5. Feature_2_t0: importance=0.0008, rank=5

📊 TILE Results:
  Baseline MAPE: 17.19%
  Enhanced MAPE: 16.12%
  MAPE Improvement: +1.07% (+6.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 412/464: TMP
============================================================
📊 Loading data for TMP...
📊 Loading data for TMP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TMP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TMP...

==================================================
Training Baseline TMP (SVM)
==================================================
Training SVM model...

Baseline TMP Performance:
MAE: 18171.9398
RMSE: 25998.7156
MAPE: 11.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 236
   • Highly important features (top 5%): 113

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0001, rank=1
   2. Feature_65_t3: importance=0.0001, rank=2
   3. Feature_93_t1: importance=0.0001, rank=3
   4. Feature_67_t3: importance=0.0001, rank=4
   5. Feature_68_t3: importance=0.0000, rank=5

🔧 Applying universal feature engineering for TMP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TMP...

==================================================
Training Enhanced TMP (SVM)
==================================================
Training SVM model...

Enhanced TMP Performance:
MAE: 16771.9760
RMSE: 24743.0296
MAPE: 10.86%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t3: importance=0.0001, rank=1
   2. Feature_7_t3: importance=0.0001, rank=2
   3. Feature_22_t1: importance=0.0001, rank=3
   4. Feature_8_t0: importance=0.0001, rank=4
   5. Feature_17_t0: importance=0.0000, rank=5

📊 TMP Results:
  Baseline MAPE: 11.30%
  Enhanced MAPE: 10.86%
  MAPE Improvement: +0.44% (+3.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 413/464: TNC
============================================================
📊 Loading data for TNC...
📊 Loading data for TNC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TNC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TNC...

==================================================
Training Baseline TNC (SVM)
==================================================
Training SVM model...

Baseline TNC Performance:
MAE: 45614.9268
RMSE: 54698.1568
MAPE: 9.71%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 157
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t0: importance=0.0005, rank=1
   2. Feature_77_t0: importance=0.0002, rank=2
   3. Feature_79_t0: importance=0.0002, rank=3
   4. Feature_76_t0: importance=0.0002, rank=4
   5. Feature_86_t0: importance=0.0002, rank=5

🔧 Applying universal feature engineering for TNC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TNC...

==================================================
Training Enhanced TNC (SVM)
==================================================
Training SVM model...

Enhanced TNC Performance:
MAE: 43056.7415
RMSE: 52088.3725
MAPE: 9.20%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 92
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0006, rank=1
   2. Feature_20_t0: importance=0.0005, rank=2
   3. Feature_19_t2: importance=0.0005, rank=3
   4. Feature_4_t0: importance=0.0005, rank=4
   5. Feature_3_t0: importance=0.0005, rank=5

📊 TNC Results:
  Baseline MAPE: 9.71%
  Enhanced MAPE: 9.20%
  MAPE Improvement: +0.50% (+5.2%)
  Features: 97 -> 25

============================================================
TESTING TICKER 414/464: TNDM
============================================================
📊 Loading data for TNDM...
📊 Loading data for TNDM from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TNDM: 'TNDM'

============================================================
TESTING TICKER 415/464: TPH
============================================================
📊 Loading data for TPH...
📊 Loading data for TPH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TPH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TPH...

==================================================
Training Baseline TPH (SVM)
==================================================
Training SVM model...

Baseline TPH Performance:
MAE: 361869.4167
RMSE: 586052.8506
MAPE: 13.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 245
   • Highly important features (top 5%): 158

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_71_t3: importance=0.0002, rank=1
   2. Feature_94_t2: importance=0.0002, rank=2
   3. Feature_65_t1: importance=0.0002, rank=3
   4. Feature_93_t2: importance=0.0001, rank=4
   5. Feature_78_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for TPH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TPH...

==================================================
Training Enhanced TPH (SVM)
==================================================
Training SVM model...

Enhanced TPH Performance:
MAE: 389208.8543
RMSE: 583337.1765
MAPE: 14.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 55
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t1: importance=0.0011, rank=1
   2. Feature_20_t2: importance=0.0005, rank=2
   3. Feature_12_t1: importance=0.0004, rank=3
   4. Feature_5_t0: importance=0.0004, rank=4
   5. Feature_5_t2: importance=0.0003, rank=5

📊 TPH Results:
  Baseline MAPE: 13.69%
  Enhanced MAPE: 14.10%
  MAPE Improvement: -0.41% (-3.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 416/464: TR
============================================================
📊 Loading data for TR...
📊 Loading data for TR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TR: 'TR'

============================================================
TESTING TICKER 417/464: TRIP
============================================================
📊 Loading data for TRIP...
📊 Loading data for TRIP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TRIP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TRIP...

==================================================
Training Baseline TRIP (SVM)
==================================================
Training SVM model...

Baseline TRIP Performance:
MAE: 1099244.5358
RMSE: 1868842.2794
MAPE: 11.24%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 80
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_81_t1: importance=0.0010, rank=1
   2. Feature_79_t0: importance=0.0007, rank=2
   3. Feature_91_t2: importance=0.0007, rank=3
   4. Feature_0_t3: importance=0.0006, rank=4
   5. Feature_82_t1: importance=0.0005, rank=5

🔧 Applying universal feature engineering for TRIP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TRIP...

==================================================
Training Enhanced TRIP (SVM)
==================================================
Training SVM model...

Enhanced TRIP Performance:
MAE: 1032668.1745
RMSE: 1697312.2520
MAPE: 10.34%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0007, rank=1
   2. Feature_7_t0: importance=0.0006, rank=2
   3. Feature_16_t0: importance=0.0006, rank=3
   4. Feature_11_t3: importance=0.0005, rank=4
   5. Feature_0_t3: importance=0.0005, rank=5

📊 TRIP Results:
  Baseline MAPE: 11.24%
  Enhanced MAPE: 10.34%
  MAPE Improvement: +0.90% (+8.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 418/464: TRMK
============================================================
📊 Loading data for TRMK...
📊 Loading data for TRMK from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TRMK...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TRMK...

==================================================
Training Baseline TRMK (SVM)
==================================================
Training SVM model...

Baseline TRMK Performance:
MAE: 122761.6343
RMSE: 153020.8154
MAPE: 7.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 231
   • Highly important features (top 5%): 122

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0005, rank=1
   2. Feature_87_t2: importance=0.0004, rank=2
   3. Feature_83_t2: importance=0.0003, rank=3
   4. Feature_68_t3: importance=0.0002, rank=4
   5. Feature_95_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for TRMK...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TRMK...

==================================================
Training Enhanced TRMK (SVM)
==================================================
Training SVM model...

Enhanced TRMK Performance:
MAE: 135938.6894
RMSE: 174786.4413
MAPE: 8.55%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 79
   • Highly important features (top 5%): 54

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_10_t0: importance=0.0005, rank=1
   2. Feature_15_t2: importance=0.0005, rank=2
   3. Feature_9_t1: importance=0.0004, rank=3
   4. Feature_17_t1: importance=0.0004, rank=4
   5. Feature_12_t2: importance=0.0004, rank=5

📊 TRMK Results:
  Baseline MAPE: 7.81%
  Enhanced MAPE: 8.55%
  MAPE Improvement: -0.74% (-9.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 419/464: TRN
============================================================
📊 Loading data for TRN...
📊 Loading data for TRN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TRN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TRN...

==================================================
Training Baseline TRN (SVM)
==================================================
Training SVM model...

Baseline TRN Performance:
MAE: 192780.5683
RMSE: 275954.9701
MAPE: 9.43%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 288
   • Highly important features (top 5%): 209

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_94_t3: importance=0.0007, rank=1
   2. Feature_77_t2: importance=0.0006, rank=2
   3. Feature_78_t2: importance=0.0005, rank=3
   4. Feature_93_t3: importance=0.0004, rank=4
   5. Feature_74_t2: importance=0.0004, rank=5

🔧 Applying universal feature engineering for TRN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TRN...

==================================================
Training Enhanced TRN (SVM)
==================================================
Training SVM model...

Enhanced TRN Performance:
MAE: 201326.1770
RMSE: 263735.5710
MAPE: 10.06%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_11_t3: importance=0.0037, rank=1
   2. Feature_10_t3: importance=0.0020, rank=2
   3. Feature_22_t3: importance=0.0016, rank=3
   4. Feature_19_t2: importance=0.0015, rank=4
   5. Feature_14_t3: importance=0.0011, rank=5

📊 TRN Results:
  Baseline MAPE: 9.43%
  Enhanced MAPE: 10.06%
  MAPE Improvement: -0.63% (-6.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 420/464: TRNO
============================================================
📊 Loading data for TRNO...
📊 Loading data for TRNO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TRNO: 'TRNO'

============================================================
TESTING TICKER 421/464: TRST
============================================================
📊 Loading data for TRST...
📊 Loading data for TRST from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TRST: 'TRST'

============================================================
TESTING TICKER 422/464: TRUP
============================================================
📊 Loading data for TRUP...
📊 Loading data for TRUP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing TRUP: 'TRUP'

============================================================
TESTING TICKER 423/464: TTMI
============================================================
📊 Loading data for TTMI...
📊 Loading data for TTMI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TTMI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TTMI...

==================================================
Training Baseline TTMI (SVM)
==================================================
Training SVM model...

Baseline TTMI Performance:
MAE: 271021.2536
RMSE: 355235.8840
MAPE: 14.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 65
   • Highly important features (top 5%): 26

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0010, rank=1
   2. Feature_84_t0: importance=0.0004, rank=2
   3. Feature_83_t0: importance=0.0003, rank=3
   4. Feature_84_t3: importance=0.0002, rank=4
   5. Feature_75_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for TTMI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TTMI...

==================================================
Training Enhanced TTMI (SVM)
==================================================
Training SVM model...

Enhanced TTMI Performance:
MAE: 291261.5721
RMSE: 381933.6895
MAPE: 14.80%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 82
   • Highly important features (top 5%): 53

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t2: importance=0.0008, rank=1
   2. Feature_22_t2: importance=0.0005, rank=2
   3. Feature_15_t3: importance=0.0005, rank=3
   4. Feature_11_t1: importance=0.0005, rank=4
   5. Feature_19_t3: importance=0.0005, rank=5

📊 TTMI Results:
  Baseline MAPE: 14.03%
  Enhanced MAPE: 14.80%
  MAPE Improvement: -0.77% (-5.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 424/464: TWI
============================================================
📊 Loading data for TWI...
📊 Loading data for TWI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TWI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TWI...

==================================================
Training Baseline TWI (SVM)
==================================================
Training SVM model...

Baseline TWI Performance:
MAE: 344084.1546
RMSE: 447360.9805
MAPE: 9.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 182
   • Highly important features (top 5%): 87

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t2: importance=0.0010, rank=1
   2. Feature_75_t2: importance=0.0006, rank=2
   3. Feature_0_t3: importance=0.0005, rank=3
   4. Feature_74_t2: importance=0.0005, rank=4
   5. Feature_69_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for TWI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TWI...

==================================================
Training Enhanced TWI (SVM)
==================================================
Training SVM model...

Enhanced TWI Performance:
MAE: 285513.1057
RMSE: 339910.7984
MAPE: 8.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 67

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0015, rank=1
   2. Feature_1_t2: importance=0.0013, rank=2
   3. Feature_19_t2: importance=0.0010, rank=3
   4. Feature_20_t2: importance=0.0010, rank=4
   5. Feature_13_t3: importance=0.0009, rank=5

📊 TWI Results:
  Baseline MAPE: 9.77%
  Enhanced MAPE: 8.83%
  MAPE Improvement: +0.94% (+9.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 425/464: TWO
============================================================
📊 Loading data for TWO...
📊 Loading data for TWO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for TWO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for TWO...

==================================================
Training Baseline TWO (SVM)
==================================================
Training SVM model...

Baseline TWO Performance:
MAE: 468058.6938
RMSE: 626515.4170
MAPE: 12.41%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 259
   • Highly important features (top 5%): 141

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t2: importance=0.0014, rank=1
   2. Feature_71_t3: importance=0.0010, rank=2
   3. Feature_65_t1: importance=0.0009, rank=3
   4. Feature_81_t1: importance=0.0008, rank=4
   5. Feature_75_t1: importance=0.0007, rank=5

🔧 Applying universal feature engineering for TWO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for TWO...

==================================================
Training Enhanced TWO (SVM)
==================================================
Training SVM model...

Enhanced TWO Performance:
MAE: 460519.6448
RMSE: 577241.3193
MAPE: 12.89%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_8_t2: importance=0.0032, rank=1
   2. Feature_8_t3: importance=0.0024, rank=2
   3. Feature_22_t2: importance=0.0020, rank=3
   4. Feature_22_t3: importance=0.0018, rank=4
   5. Feature_8_t1: importance=0.0018, rank=5

📊 TWO Results:
  Baseline MAPE: 12.41%
  Enhanced MAPE: 12.89%
  MAPE Improvement: -0.48% (-3.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 426/464: UCTT
============================================================
📊 Loading data for UCTT...
📊 Loading data for UCTT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UCTT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UCTT...

==================================================
Training Baseline UCTT (SVM)
==================================================
Training SVM model...

Baseline UCTT Performance:
MAE: 88957.2230
RMSE: 104588.2068
MAPE: 9.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 118
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t1: importance=0.0004, rank=1
   2. Feature_73_t0: importance=0.0003, rank=2
   3. Feature_95_t3: importance=0.0002, rank=3
   4. Feature_75_t3: importance=0.0002, rank=4
   5. Feature_74_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for UCTT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UCTT...

==================================================
Training Enhanced UCTT (SVM)
==================================================
Training SVM model...

Enhanced UCTT Performance:
MAE: 93977.9678
RMSE: 119310.3937
MAPE: 9.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 72
   • Highly important features (top 5%): 38

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_22_t0: importance=0.0006, rank=1
   2. Feature_20_t1: importance=0.0006, rank=2
   3. Feature_20_t3: importance=0.0006, rank=3
   4. Feature_13_t1: importance=0.0004, rank=4
   5. Feature_15_t2: importance=0.0003, rank=5

📊 UCTT Results:
  Baseline MAPE: 9.38%
  Enhanced MAPE: 9.91%
  MAPE Improvement: -0.53% (-5.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 427/464: UE
============================================================
📊 Loading data for UE...
📊 Loading data for UE from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UE...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UE...

==================================================
Training Baseline UE (SVM)
==================================================
Training SVM model...

Baseline UE Performance:
MAE: 398008.7505
RMSE: 534317.6040
MAPE: 12.18%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 306
   • Highly important features (top 5%): 135

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_79_t2: importance=0.0003, rank=1
   2. Feature_0_t1: importance=0.0003, rank=2
   3. Feature_2_t2: importance=0.0002, rank=3
   4. Feature_91_t2: importance=0.0002, rank=4
   5. Feature_0_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for UE...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UE...

==================================================
Training Enhanced UE (SVM)
==================================================
Training SVM model...

Enhanced UE Performance:
MAE: 437112.6688
RMSE: 556861.8703
MAPE: 13.38%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 80

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_9_t2: importance=0.0006, rank=1
   2. Feature_20_t3: importance=0.0005, rank=2
   3. Feature_20_t2: importance=0.0005, rank=3
   4. Feature_10_t1: importance=0.0005, rank=4
   5. Feature_7_t3: importance=0.0004, rank=5

📊 UE Results:
  Baseline MAPE: 12.18%
  Enhanced MAPE: 13.38%
  MAPE Improvement: -1.20% (-9.8%)
  Features: 97 -> 25

============================================================
TESTING TICKER 428/464: UFCS
============================================================
📊 Loading data for UFCS...
📊 Loading data for UFCS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UFCS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UFCS...

==================================================
Training Baseline UFCS (SVM)
==================================================
Training SVM model...

Baseline UFCS Performance:
MAE: 44650.5961
RMSE: 61140.7764
MAPE: 14.85%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 293
   • Highly important features (top 5%): 189

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t3: importance=0.0012, rank=1
   2. Feature_65_t2: importance=0.0008, rank=2
   3. Feature_65_t3: importance=0.0008, rank=3
   4. Feature_83_t2: importance=0.0005, rank=4
   5. Feature_77_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for UFCS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UFCS...

==================================================
Training Enhanced UFCS (SVM)
==================================================
Training SVM model...

Enhanced UFCS Performance:
MAE: 46061.2488
RMSE: 61960.7056
MAPE: 15.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t2: importance=0.0013, rank=1
   2. Feature_13_t3: importance=0.0012, rank=2
   3. Feature_5_t2: importance=0.0008, rank=3
   4. Feature_0_t3: importance=0.0008, rank=4
   5. Feature_17_t2: importance=0.0008, rank=5

📊 UFCS Results:
  Baseline MAPE: 14.85%
  Enhanced MAPE: 15.69%
  MAPE Improvement: -0.84% (-5.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 429/464: UFPT
============================================================
📊 Loading data for UFPT...
📊 Loading data for UFPT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing UFPT: 'UFPT'

============================================================
TESTING TICKER 430/464: UHT
============================================================
📊 Loading data for UHT...
📊 Loading data for UHT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UHT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UHT...

==================================================
Training Baseline UHT (SVM)
==================================================
Training SVM model...

Baseline UHT Performance:
MAE: 45317.8931
RMSE: 69960.4770
MAPE: 27.03%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 195
   • Highly important features (top 5%): 102

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0009, rank=1
   2. Feature_94_t1: importance=0.0007, rank=2
   3. Feature_0_t3: importance=0.0007, rank=3
   4. Feature_93_t3: importance=0.0006, rank=4
   5. Feature_71_t2: importance=0.0006, rank=5

🔧 Applying universal feature engineering for UHT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UHT...

==================================================
Training Enhanced UHT (SVM)
==================================================
Training SVM model...

Enhanced UHT Performance:
MAE: 40518.4137
RMSE: 67314.2331
MAPE: 24.40%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 81
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0050, rank=1
   2. Feature_11_t3: importance=0.0016, rank=2
   3. Feature_16_t0: importance=0.0013, rank=3
   4. Feature_5_t3: importance=0.0012, rank=4
   5. Feature_4_t0: importance=0.0012, rank=5

📊 UHT Results:
  Baseline MAPE: 27.03%
  Enhanced MAPE: 24.40%
  MAPE Improvement: +2.62% (+9.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 431/464: UNF
============================================================
📊 Loading data for UNF...
📊 Loading data for UNF from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UNF...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UNF...

==================================================
Training Baseline UNF (SVM)
==================================================
Training SVM model...

Baseline UNF Performance:
MAE: 25147.2406
RMSE: 31746.6607
MAPE: 15.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 292
   • Highly important features (top 5%): 138

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0009, rank=1
   2. Feature_92_t3: importance=0.0007, rank=2
   3. Feature_88_t2: importance=0.0007, rank=3
   4. Feature_71_t0: importance=0.0006, rank=4
   5. Feature_65_t0: importance=0.0005, rank=5

🔧 Applying universal feature engineering for UNF...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UNF...

==================================================
Training Enhanced UNF (SVM)
==================================================
Training SVM model...

Enhanced UNF Performance:
MAE: 25976.7978
RMSE: 31038.2807
MAPE: 15.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 73

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0023, rank=1
   2. Feature_7_t0: importance=0.0014, rank=2
   3. Feature_4_t3: importance=0.0012, rank=3
   4. Feature_11_t3: importance=0.0010, rank=4
   5. Feature_17_t3: importance=0.0010, rank=5

📊 UNF Results:
  Baseline MAPE: 15.10%
  Enhanced MAPE: 15.69%
  MAPE Improvement: -0.58% (-3.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 432/464: UNFI
============================================================
📊 Loading data for UNFI...
📊 Loading data for UNFI from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UNFI...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UNFI...

==================================================
Training Baseline UNFI (SVM)
==================================================
Training SVM model...

Baseline UNFI Performance:
MAE: 257333.5577
RMSE: 329559.2710
MAPE: 6.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 214
   • Highly important features (top 5%): 138

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t2: importance=0.0003, rank=1
   2. Feature_1_t3: importance=0.0003, rank=2
   3. Feature_64_t3: importance=0.0003, rank=3
   4. Feature_69_t3: importance=0.0002, rank=4
   5. Feature_91_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for UNFI...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UNFI...

==================================================
Training Enhanced UNFI (SVM)
==================================================
Training SVM model...

Enhanced UNFI Performance:
MAE: 254187.5297
RMSE: 328015.9353
MAPE: 6.75%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0009, rank=1
   2. Feature_7_t2: importance=0.0009, rank=2
   3. Feature_19_t3: importance=0.0006, rank=3
   4. Feature_22_t2: importance=0.0005, rank=4
   5. Feature_17_t3: importance=0.0004, rank=5

📊 UNFI Results:
  Baseline MAPE: 6.88%
  Enhanced MAPE: 6.75%
  MAPE Improvement: +0.14% (+2.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 433/464: UNIT
============================================================
📊 Loading data for UNIT...
📊 Loading data for UNIT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing UNIT: 'UNIT'

============================================================
TESTING TICKER 434/464: URBN
============================================================
📊 Loading data for URBN...
📊 Loading data for URBN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for URBN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for URBN...

==================================================
Training Baseline URBN (SVM)
==================================================
Training SVM model...

Baseline URBN Performance:
MAE: 741180.7655
RMSE: 914771.6506
MAPE: 13.19%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 313
   • Highly important features (top 5%): 182

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_0_t2: importance=0.0004, rank=1
   2. Feature_0_t3: importance=0.0003, rank=2
   3. Feature_84_t2: importance=0.0002, rank=3
   4. Feature_67_t3: importance=0.0002, rank=4
   5. Feature_0_t1: importance=0.0002, rank=5

🔧 Applying universal feature engineering for URBN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for URBN...

==================================================
Training Enhanced URBN (SVM)
==================================================
Training SVM model...

Enhanced URBN Performance:
MAE: 734392.9947
RMSE: 965887.2948
MAPE: 12.35%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 96
   • Highly important features (top 5%): 90

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_18_t2: importance=0.0007, rank=1
   2. Feature_23_t3: importance=0.0006, rank=2
   3. Feature_17_t1: importance=0.0006, rank=3
   4. Feature_19_t0: importance=0.0006, rank=4
   5. Feature_5_t0: importance=0.0005, rank=5

📊 URBN Results:
  Baseline MAPE: 13.19%
  Enhanced MAPE: 12.35%
  MAPE Improvement: +0.84% (+6.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 435/464: USNA
============================================================
📊 Loading data for USNA...
📊 Loading data for USNA from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for USNA...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for USNA...

==================================================
Training Baseline USNA (SVM)
==================================================
Training SVM model...

Baseline USNA Performance:
MAE: 48426.0414
RMSE: 66251.4668
MAPE: 9.72%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 184
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0006, rank=1
   2. Feature_90_t1: importance=0.0006, rank=2
   3. Feature_89_t1: importance=0.0004, rank=3
   4. Feature_84_t2: importance=0.0004, rank=4
   5. Feature_84_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for USNA...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for USNA...

==================================================
Training Enhanced USNA (SVM)
==================================================
Training SVM model...

Enhanced USNA Performance:
MAE: 41938.6344
RMSE: 62410.2225
MAPE: 8.88%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 90
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0013, rank=1
   2. Feature_1_t3: importance=0.0008, rank=2
   3. Feature_14_t3: importance=0.0007, rank=3
   4. Feature_2_t0: importance=0.0006, rank=4
   5. Feature_16_t2: importance=0.0005, rank=5

📊 USNA Results:
  Baseline MAPE: 9.72%
  Enhanced MAPE: 8.88%
  MAPE Improvement: +0.84% (+8.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 436/464: USPH
============================================================
📊 Loading data for USPH...
📊 Loading data for USPH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for USPH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for USPH...

==================================================
Training Baseline USPH (SVM)
==================================================
Training SVM model...

Baseline USPH Performance:
MAE: 43929.8124
RMSE: 54768.8675
MAPE: 7.68%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 152
   • Highly important features (top 5%): 76

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0002, rank=1
   2. Feature_2_t3: importance=0.0001, rank=2
   3. Feature_2_t2: importance=0.0001, rank=3
   4. Feature_89_t1: importance=0.0001, rank=4
   5. Feature_77_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for USPH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for USPH...

==================================================
Training Enhanced USPH (SVM)
==================================================
Training SVM model...

Enhanced USPH Performance:
MAE: 40778.7712
RMSE: 50121.2452
MAPE: 7.26%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 56

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0005, rank=1
   2. Feature_16_t3: importance=0.0004, rank=2
   3. Feature_11_t3: importance=0.0002, rank=3
   4. Feature_10_t3: importance=0.0001, rank=4
   5. Feature_23_t3: importance=0.0001, rank=5

📊 USPH Results:
  Baseline MAPE: 7.68%
  Enhanced MAPE: 7.26%
  MAPE Improvement: +0.43% (+5.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 437/464: UTL
============================================================
📊 Loading data for UTL...
📊 Loading data for UTL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UTL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UTL...

==================================================
Training Baseline UTL (SVM)
==================================================
Training SVM model...

Baseline UTL Performance:
MAE: 25442.0507
RMSE: 34227.5092
MAPE: 15.10%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 341
   • Highly important features (top 5%): 177

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t3: importance=0.0011, rank=1
   2. Feature_70_t3: importance=0.0007, rank=2
   3. Feature_63_t0: importance=0.0007, rank=3
   4. Feature_69_t3: importance=0.0007, rank=4
   5. Feature_86_t3: importance=0.0006, rank=5

🔧 Applying universal feature engineering for UTL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UTL...

==================================================
Training Enhanced UTL (SVM)
==================================================
Training SVM model...

Enhanced UTL Performance:
MAE: 26316.9985
RMSE: 36763.1463
MAPE: 14.50%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 98
   • Highly important features (top 5%): 84

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t2: importance=0.0024, rank=1
   2. Feature_17_t0: importance=0.0013, rank=2
   3. Feature_1_t3: importance=0.0013, rank=3
   4. Feature_20_t3: importance=0.0010, rank=4
   5. Feature_20_t2: importance=0.0010, rank=5

📊 UTL Results:
  Baseline MAPE: 15.10%
  Enhanced MAPE: 14.50%
  MAPE Improvement: +0.60% (+4.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 438/464: UVV
============================================================
📊 Loading data for UVV...
📊 Loading data for UVV from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for UVV...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for UVV...

==================================================
Training Baseline UVV (SVM)
==================================================
Training SVM model...

Baseline UVV Performance:
MAE: 79427.5482
RMSE: 146265.7017
MAPE: 19.66%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 130
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0008, rank=1
   2. Feature_89_t2: importance=0.0004, rank=2
   3. Feature_84_t1: importance=0.0003, rank=3
   4. Feature_2_t1: importance=0.0002, rank=4
   5. Feature_70_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for UVV...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for UVV...

==================================================
Training Enhanced UVV (SVM)
==================================================
Training SVM model...

Enhanced UVV Performance:
MAE: 80044.5673
RMSE: 143951.7082
MAPE: 19.74%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 94
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t0: importance=0.0009, rank=1
   2. Feature_16_t0: importance=0.0008, rank=2
   3. Feature_24_t1: importance=0.0007, rank=3
   4. Feature_17_t0: importance=0.0006, rank=4
   5. Feature_11_t1: importance=0.0005, rank=5

📊 UVV Results:
  Baseline MAPE: 19.66%
  Enhanced MAPE: 19.74%
  MAPE Improvement: -0.09% (-0.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 439/464: VBTX
============================================================
📊 Loading data for VBTX...
📊 Loading data for VBTX from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing VBTX: 'VBTX'

============================================================
TESTING TICKER 440/464: VCEL
============================================================
📊 Loading data for VCEL...
📊 Loading data for VCEL from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VCEL...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VCEL...

==================================================
Training Baseline VCEL (SVM)
==================================================
Training SVM model...

Baseline VCEL Performance:
MAE: 366306.4231
RMSE: 570262.1719
MAPE: 10.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 142
   • Highly important features (top 5%): 82

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_92_t1: importance=0.0009, rank=1
   2. Feature_94_t3: importance=0.0009, rank=2
   3. Feature_67_t3: importance=0.0007, rank=3
   4. Feature_92_t3: importance=0.0005, rank=4
   5. Feature_80_t1: importance=0.0004, rank=5

🔧 Applying universal feature engineering for VCEL...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VCEL...

==================================================
Training Enhanced VCEL (SVM)
==================================================
Training SVM model...

Enhanced VCEL Performance:
MAE: 306066.3444
RMSE: 453936.2619
MAPE: 8.55%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_6_t2: importance=0.0012, rank=1
   2. Feature_1_t3: importance=0.0010, rank=2
   3. Feature_8_t2: importance=0.0010, rank=3
   4. Feature_5_t3: importance=0.0008, rank=4
   5. Feature_11_t3: importance=0.0008, rank=5

📊 VCEL Results:
  Baseline MAPE: 10.42%
  Enhanced MAPE: 8.55%
  MAPE Improvement: +1.87% (+18.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 441/464: VCYT
============================================================
📊 Loading data for VCYT...
📊 Loading data for VCYT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing VCYT: 'VCYT'

============================================================
TESTING TICKER 442/464: VECO
============================================================
📊 Loading data for VECO...
📊 Loading data for VECO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VECO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VECO...

==================================================
Training Baseline VECO (SVM)
==================================================
Training SVM model...

Baseline VECO Performance:
MAE: 339967.9838
RMSE: 448871.9506
MAPE: 6.28%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 76
   • Highly important features (top 5%): 28

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_2_t1: importance=0.0005, rank=1
   2. Feature_76_t0: importance=0.0003, rank=2
   3. Feature_65_t1: importance=0.0003, rank=3
   4. Feature_84_t0: importance=0.0002, rank=4
   5. Feature_65_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for VECO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VECO...

==================================================
Training Enhanced VECO (SVM)
==================================================
Training SVM model...

Enhanced VECO Performance:
MAE: 347699.4399
RMSE: 458360.1307
MAPE: 6.55%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 75

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_24_t2: importance=0.0003, rank=1
   2. Feature_11_t1: importance=0.0003, rank=2
   3. Feature_24_t1: importance=0.0003, rank=3
   4. Feature_11_t2: importance=0.0003, rank=4
   5. Feature_19_t0: importance=0.0002, rank=5

📊 VECO Results:
  Baseline MAPE: 6.28%
  Enhanced MAPE: 6.55%
  MAPE Improvement: -0.27% (-4.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 443/464: VIAV
============================================================
📊 Loading data for VIAV...
📊 Loading data for VIAV from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VIAV...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VIAV...

==================================================
Training Baseline VIAV (SVM)
==================================================
Training SVM model...

Baseline VIAV Performance:
MAE: 456121.5031
RMSE: 583851.5733
MAPE: 8.77%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 198
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_66_t1: importance=0.0003, rank=1
   2. Feature_66_t2: importance=0.0002, rank=2
   3. Feature_81_t2: importance=0.0002, rank=3
   4. Feature_66_t3: importance=0.0002, rank=4
   5. Feature_71_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for VIAV...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VIAV...

==================================================
Training Enhanced VIAV (SVM)
==================================================
Training SVM model...

Enhanced VIAV Performance:
MAE: 468785.1921
RMSE: 595184.8297
MAPE: 8.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 62
   • Highly important features (top 5%): 29

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t0: importance=0.0006, rank=1
   2. Feature_2_t2: importance=0.0004, rank=2
   3. Feature_22_t0: importance=0.0004, rank=3
   4. Feature_12_t0: importance=0.0003, rank=4
   5. Feature_6_t1: importance=0.0003, rank=5

📊 VIAV Results:
  Baseline MAPE: 8.77%
  Enhanced MAPE: 8.96%
  MAPE Improvement: -0.18% (-2.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 444/464: VICR
============================================================
📊 Loading data for VICR...
📊 Loading data for VICR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VICR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VICR...

==================================================
Training Baseline VICR (SVM)
==================================================
Training SVM model...

Baseline VICR Performance:
MAE: 102986.1399
RMSE: 126441.2794
MAPE: 6.21%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 171
   • Highly important features (top 5%): 38

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_67_t3: importance=0.0009, rank=1
   2. Feature_68_t3: importance=0.0006, rank=2
   3. Feature_63_t2: importance=0.0003, rank=3
   4. Feature_70_t3: importance=0.0003, rank=4
   5. Feature_0_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for VICR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VICR...

==================================================
Training Enhanced VICR (SVM)
==================================================
Training SVM model...

Enhanced VICR Performance:
MAE: 69314.9018
RMSE: 97716.5304
MAPE: 4.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 77

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0007, rank=1
   2. Feature_20_t3: importance=0.0005, rank=2
   3. Feature_17_t3: importance=0.0004, rank=3
   4. Feature_7_t3: importance=0.0004, rank=4
   5. Feature_4_t2: importance=0.0004, rank=5

📊 VICR Results:
  Baseline MAPE: 6.21%
  Enhanced MAPE: 4.29%
  MAPE Improvement: +1.92% (+30.9%)
  Features: 97 -> 25

============================================================
TESTING TICKER 445/464: VIRT
============================================================
📊 Loading data for VIRT...
📊 Loading data for VIRT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VIRT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VIRT...

==================================================
Training Baseline VIRT (SVM)
==================================================
Training SVM model...

Baseline VIRT Performance:
MAE: 310034.5658
RMSE: 484251.5164
MAPE: 12.25%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 366
   • Highly important features (top 5%): 323

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_89_t3: importance=0.0004, rank=1
   2. Feature_63_t2: importance=0.0003, rank=2
   3. Feature_86_t3: importance=0.0003, rank=3
   4. Feature_96_t2: importance=0.0003, rank=4
   5. Feature_68_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for VIRT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VIRT...

==================================================
Training Enhanced VIRT (SVM)
==================================================
Training SVM model...

Enhanced VIRT Performance:
MAE: 312309.6115
RMSE: 506030.9999
MAPE: 12.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 42

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_17_t0: importance=0.0017, rank=1
   2. Feature_19_t3: importance=0.0017, rank=2
   3. Feature_13_t0: importance=0.0015, rank=3
   4. Feature_9_t3: importance=0.0011, rank=4
   5. Feature_19_t2: importance=0.0011, rank=5

📊 VIRT Results:
  Baseline MAPE: 12.25%
  Enhanced MAPE: 12.08%
  MAPE Improvement: +0.17% (+1.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 446/464: VRTS
============================================================
📊 Loading data for VRTS...
📊 Loading data for VRTS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing VRTS: 'VRTS'

============================================================
TESTING TICKER 447/464: VSAT
============================================================
📊 Loading data for VSAT...
📊 Loading data for VSAT from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VSAT...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VSAT...

==================================================
Training Baseline VSAT (SVM)
==================================================
Training SVM model...

Baseline VSAT Performance:
MAE: 1231150.9953
RMSE: 1594505.6688
MAPE: 7.11%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 140
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t3: importance=0.0002, rank=1
   2. Feature_71_t3: importance=0.0001, rank=2
   3. Feature_93_t1: importance=0.0001, rank=3
   4. Feature_72_t3: importance=0.0001, rank=4
   5. Feature_88_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for VSAT...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VSAT...

==================================================
Training Enhanced VSAT (SVM)
==================================================
Training SVM model...

Enhanced VSAT Performance:
MAE: 1234888.6277
RMSE: 1548005.9971
MAPE: 7.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 64
   • Highly important features (top 5%): 37

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t2: importance=0.0002, rank=1
   2. Feature_15_t3: importance=0.0002, rank=2
   3. Feature_7_t1: importance=0.0002, rank=3
   4. Feature_13_t0: importance=0.0002, rank=4
   5. Feature_3_t0: importance=0.0001, rank=5

📊 VSAT Results:
  Baseline MAPE: 7.11%
  Enhanced MAPE: 7.15%
  MAPE Improvement: -0.04% (-0.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 448/464: VSH
============================================================
📊 Loading data for VSH...
📊 Loading data for VSH from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for VSH...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for VSH...

==================================================
Training Baseline VSH (SVM)
==================================================
Training SVM model...

Baseline VSH Performance:
MAE: 773796.7836
RMSE: 1129449.6734
MAPE: 6.58%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 231
   • Highly important features (top 5%): 171

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_82_t3: importance=0.0001, rank=1
   2. Feature_80_t3: importance=0.0001, rank=2
   3. Feature_81_t3: importance=0.0001, rank=3
   4. Feature_78_t3: importance=0.0001, rank=4
   5. Feature_1_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for VSH...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for VSH...

==================================================
Training Enhanced VSH (SVM)
==================================================
Training SVM model...

Enhanced VSH Performance:
MAE: 765277.1883
RMSE: 1147309.4449
MAPE: 6.48%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 48

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0002, rank=1
   2. Feature_7_t2: importance=0.0002, rank=2
   3. Feature_23_t1: importance=0.0001, rank=3
   4. Feature_13_t0: importance=0.0001, rank=4
   5. Feature_19_t1: importance=0.0001, rank=5

📊 VSH Results:
  Baseline MAPE: 6.58%
  Enhanced MAPE: 6.48%
  MAPE Improvement: +0.10% (+1.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 449/464: WABC
============================================================
📊 Loading data for WABC...
📊 Loading data for WABC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WABC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WABC...

==================================================
Training Baseline WABC (SVM)
==================================================
Training SVM model...

Baseline WABC Performance:
MAE: 34771.5893
RMSE: 43647.0745
MAPE: 11.98%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 288
   • Highly important features (top 5%): 118

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t0: importance=0.0001, rank=1
   2. Feature_93_t1: importance=0.0001, rank=2
   3. Feature_70_t0: importance=0.0001, rank=3
   4. Feature_87_t0: importance=0.0001, rank=4
   5. Feature_75_t0: importance=0.0001, rank=5

🔧 Applying universal feature engineering for WABC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WABC...

==================================================
Training Enhanced WABC (SVM)
==================================================
Training SVM model...

Enhanced WABC Performance:
MAE: 35108.7353
RMSE: 44848.3880
MAPE: 11.83%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 76
   • Highly important features (top 5%): 61

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t2: importance=0.0002, rank=1
   2. Feature_1_t1: importance=0.0002, rank=2
   3. Feature_15_t2: importance=0.0002, rank=3
   4. Feature_4_t0: importance=0.0002, rank=4
   5. Feature_22_t1: importance=0.0002, rank=5

📊 WABC Results:
  Baseline MAPE: 11.98%
  Enhanced MAPE: 11.83%
  MAPE Improvement: +0.16% (+1.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 450/464: WAFD
============================================================
📊 Loading data for WAFD...
📊 Loading data for WAFD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WAFD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WAFD...

==================================================
Training Baseline WAFD (SVM)
==================================================
Training SVM model...

Baseline WAFD Performance:
MAE: 227279.7874
RMSE: 296498.5272
MAPE: 12.59%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 222
   • Highly important features (top 5%): 119

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t1: importance=0.0006, rank=1
   2. Feature_72_t0: importance=0.0006, rank=2
   3. Feature_0_t3: importance=0.0004, rank=3
   4. Feature_86_t1: importance=0.0004, rank=4
   5. Feature_2_t3: importance=0.0004, rank=5

🔧 Applying universal feature engineering for WAFD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WAFD...

==================================================
Training Enhanced WAFD (SVM)
==================================================
Training SVM model...

Enhanced WAFD Performance:
MAE: 241977.0882
RMSE: 336041.0648
MAPE: 13.60%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 74

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_3_t3: importance=0.0012, rank=1
   2. Feature_22_t0: importance=0.0010, rank=2
   3. Feature_24_t2: importance=0.0009, rank=3
   4. Feature_15_t3: importance=0.0008, rank=4
   5. Feature_19_t0: importance=0.0008, rank=5

📊 WAFD Results:
  Baseline MAPE: 12.59%
  Enhanced MAPE: 13.60%
  MAPE Improvement: -1.01% (-8.0%)
  Features: 97 -> 25

============================================================
TESTING TICKER 451/464: WD
============================================================
📊 Loading data for WD...
📊 Loading data for WD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WD...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WD...

==================================================
Training Baseline WD (SVM)
==================================================
Training SVM model...

Baseline WD Performance:
MAE: 96176.7289
RMSE: 165699.6297
MAPE: 8.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 328
   • Highly important features (top 5%): 171

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_65_t2: importance=0.0004, rank=1
   2. Feature_78_t3: importance=0.0004, rank=2
   3. Feature_94_t2: importance=0.0004, rank=3
   4. Feature_94_t1: importance=0.0003, rank=4
   5. Feature_83_t0: importance=0.0003, rank=5

🔧 Applying universal feature engineering for WD...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WD...

==================================================
Training Enhanced WD (SVM)
==================================================
Training SVM model...

Enhanced WD Performance:
MAE: 105320.9195
RMSE: 157707.2050
MAPE: 9.42%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 59

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t0: importance=0.0011, rank=1
   2. Feature_5_t3: importance=0.0009, rank=2
   3. Feature_15_t2: importance=0.0007, rank=3
   4. Feature_14_t3: importance=0.0006, rank=4
   5. Feature_4_t1: importance=0.0006, rank=5

📊 WD Results:
  Baseline MAPE: 8.30%
  Enhanced MAPE: 9.42%
  MAPE Improvement: -1.13% (-13.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 452/464: WDFC
============================================================
📊 Loading data for WDFC...
📊 Loading data for WDFC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WDFC...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WDFC...

==================================================
Training Baseline WDFC (SVM)
==================================================
Training SVM model...

Baseline WDFC Performance:
MAE: 39830.6402
RMSE: 55684.0997
MAPE: 3.50%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 222
   • Highly important features (top 5%): 136

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_72_t1: importance=0.0001, rank=1
   2. Feature_68_t3: importance=0.0000, rank=2
   3. Feature_71_t1: importance=0.0000, rank=3
   4. Feature_63_t2: importance=0.0000, rank=4
   5. Feature_64_t1: importance=0.0000, rank=5

🔧 Applying universal feature engineering for WDFC...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WDFC...

==================================================
Training Enhanced WDFC (SVM)
==================================================
Training SVM model...

Enhanced WDFC Performance:
MAE: 40725.2592
RMSE: 58016.2823
MAPE: 3.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 60
   • Highly important features (top 5%): 31

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_5_t3: importance=0.0001, rank=1
   2. Feature_22_t0: importance=0.0001, rank=2
   3. Feature_20_t1: importance=0.0001, rank=3
   4. Feature_16_t2: importance=0.0001, rank=4
   5. Feature_24_t3: importance=0.0000, rank=5

📊 WDFC Results:
  Baseline MAPE: 3.50%
  Enhanced MAPE: 3.57%
  MAPE Improvement: -0.07% (-2.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 453/464: WEN
============================================================
📊 Loading data for WEN...
📊 Loading data for WEN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WEN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WEN...

==================================================
Training Baseline WEN (SVM)
==================================================
Training SVM model...

Baseline WEN Performance:
MAE: 1648656.9810
RMSE: 2197511.0225
MAPE: 12.57%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 239
   • Highly important features (top 5%): 128

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_95_t1: importance=0.0004, rank=1
   2. Feature_68_t2: importance=0.0004, rank=2
   3. Feature_70_t2: importance=0.0004, rank=3
   4. Feature_0_t3: importance=0.0004, rank=4
   5. Feature_77_t3: importance=0.0003, rank=5

🔧 Applying universal feature engineering for WEN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WEN...

==================================================
Training Enhanced WEN (SVM)
==================================================
Training SVM model...

Enhanced WEN Performance:
MAE: 1707213.2118
RMSE: 2132004.2834
MAPE: 13.84%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 50

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0019, rank=1
   2. Feature_19_t3: importance=0.0013, rank=2
   3. Feature_15_t3: importance=0.0013, rank=3
   4. Feature_23_t2: importance=0.0011, rank=4
   5. Feature_12_t0: importance=0.0010, rank=5

📊 WEN Results:
  Baseline MAPE: 12.57%
  Enhanced MAPE: 13.84%
  MAPE Improvement: -1.27% (-10.1%)
  Features: 97 -> 25

============================================================
TESTING TICKER 454/464: WERN
============================================================
📊 Loading data for WERN...
📊 Loading data for WERN from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WERN...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WERN...

==================================================
Training Baseline WERN (SVM)
==================================================
Training SVM model...

Baseline WERN Performance:
MAE: 358221.3066
RMSE: 444247.2142
MAPE: 10.29%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 123
   • Highly important features (top 5%): 60

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t0: importance=0.0004, rank=1
   2. Feature_63_t3: importance=0.0004, rank=2
   3. Feature_64_t3: importance=0.0003, rank=3
   4. Feature_90_t1: importance=0.0002, rank=4
   5. Feature_77_t3: importance=0.0002, rank=5

🔧 Applying universal feature engineering for WERN...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WERN...

==================================================
Training Enhanced WERN (SVM)
==================================================
Training SVM model...

Enhanced WERN Performance:
MAE: 378942.9541
RMSE: 454800.2088
MAPE: 11.08%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 91
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t3: importance=0.0006, rank=1
   2. Feature_15_t2: importance=0.0005, rank=2
   3. Feature_20_t1: importance=0.0004, rank=3
   4. Feature_7_t3: importance=0.0004, rank=4
   5. Feature_1_t0: importance=0.0004, rank=5

📊 WERN Results:
  Baseline MAPE: 10.29%
  Enhanced MAPE: 11.08%
  MAPE Improvement: -0.78% (-7.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 455/464: WGO
============================================================
📊 Loading data for WGO...
📊 Loading data for WGO from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WGO...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WGO...

==================================================
Training Baseline WGO (SVM)
==================================================
Training SVM model...

Baseline WGO Performance:
MAE: 258968.2417
RMSE: 322589.3825
MAPE: 5.70%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 211
   • Highly important features (top 5%): 83

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_69_t3: importance=0.0003, rank=1
   2. Feature_94_t0: importance=0.0002, rank=2
   3. Feature_70_t3: importance=0.0002, rank=3
   4. Feature_93_t0: importance=0.0001, rank=4
   5. Feature_74_t2: importance=0.0001, rank=5

🔧 Applying universal feature engineering for WGO...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WGO...

==================================================
Training Enhanced WGO (SVM)
==================================================
Training SVM model...

Enhanced WGO Performance:
MAE: 194579.5129
RMSE: 241381.9790
MAPE: 4.30%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 89
   • Highly important features (top 5%): 66

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_19_t3: importance=0.0004, rank=1
   2. Feature_24_t0: importance=0.0003, rank=2
   3. Feature_1_t0: importance=0.0003, rank=3
   4. Feature_15_t2: importance=0.0003, rank=4
   5. Feature_23_t0: importance=0.0002, rank=5

📊 WGO Results:
  Baseline MAPE: 5.70%
  Enhanced MAPE: 4.30%
  MAPE Improvement: +1.40% (+24.6%)
  Features: 97 -> 25

============================================================
TESTING TICKER 456/464: WOR
============================================================
📊 Loading data for WOR...
📊 Loading data for WOR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WOR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WOR...

==================================================
Training Baseline WOR (SVM)
==================================================
Training SVM model...

Baseline WOR Performance:
MAE: 175241.5633
RMSE: 244375.3284
MAPE: 14.56%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 157
   • Highly important features (top 5%): 86

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_95_t0: importance=0.0015, rank=1
   2. Feature_96_t0: importance=0.0010, rank=2
   3. Feature_67_t3: importance=0.0009, rank=3
   4. Feature_76_t3: importance=0.0007, rank=4
   5. Feature_63_t3: importance=0.0006, rank=5

🔧 Applying universal feature engineering for WOR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WOR...

==================================================
Training Enhanced WOR (SVM)
==================================================
Training SVM model...

Enhanced WOR Performance:
MAE: 158728.9065
RMSE: 216712.9211
MAPE: 12.91%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 95
   • Highly important features (top 5%): 78

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_13_t1: importance=0.0016, rank=1
   2. Feature_1_t3: importance=0.0014, rank=2
   3. Feature_4_t3: importance=0.0012, rank=3
   4. Feature_11_t3: importance=0.0011, rank=4
   5. Feature_13_t0: importance=0.0011, rank=5

📊 WOR Results:
  Baseline MAPE: 14.56%
  Enhanced MAPE: 12.91%
  MAPE Improvement: +1.65% (+11.3%)
  Features: 97 -> 25

============================================================
TESTING TICKER 457/464: WRLD
============================================================
📊 Loading data for WRLD...
📊 Loading data for WRLD from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing WRLD: 'WRLD'

============================================================
TESTING TICKER 458/464: WSC
============================================================
📊 Loading data for WSC...
📊 Loading data for WSC from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
❌ Error testing WSC: 'WSC'

============================================================
TESTING TICKER 459/464: WSFS
============================================================
📊 Loading data for WSFS...
📊 Loading data for WSFS from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WSFS...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WSFS...

==================================================
Training Baseline WSFS (SVM)
==================================================
Training SVM model...

Baseline WSFS Performance:
MAE: 131914.5087
RMSE: 169770.9686
MAPE: 9.69%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 284
   • Highly important features (top 5%): 102

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0010, rank=1
   2. Feature_63_t0: importance=0.0009, rank=2
   3. Feature_67_t3: importance=0.0007, rank=3
   4. Feature_70_t2: importance=0.0006, rank=4
   5. Feature_63_t3: importance=0.0006, rank=5

🔧 Applying universal feature engineering for WSFS...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WSFS...

==================================================
Training Enhanced WSFS (SVM)
==================================================
Training SVM model...

Enhanced WSFS Performance:
MAE: 136646.6322
RMSE: 172109.0182
MAPE: 10.31%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 85
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_16_t0: importance=0.0018, rank=1
   2. Feature_4_t0: importance=0.0018, rank=2
   3. Feature_24_t2: importance=0.0016, rank=3
   4. Feature_11_t2: importance=0.0013, rank=4
   5. Feature_11_t1: importance=0.0012, rank=5

📊 WSFS Results:
  Baseline MAPE: 9.69%
  Enhanced MAPE: 10.31%
  MAPE Improvement: -0.62% (-6.4%)
  Features: 97 -> 25

============================================================
TESTING TICKER 460/464: WSR
============================================================
📊 Loading data for WSR...
📊 Loading data for WSR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WSR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WSR...

==================================================
Training Baseline WSR (SVM)
==================================================
Training SVM model...

Baseline WSR Performance:
MAE: 91765.7348
RMSE: 117957.5500
MAPE: 14.07%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 172
   • Highly important features (top 5%): 96

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_83_t0: importance=0.0014, rank=1
   2. Feature_0_t3: importance=0.0013, rank=2
   3. Feature_2_t3: importance=0.0013, rank=3
   4. Feature_76_t1: importance=0.0010, rank=4
   5. Feature_75_t1: importance=0.0009, rank=5

🔧 Applying universal feature engineering for WSR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WSR...

==================================================
Training Enhanced WSR (SVM)
==================================================
Training SVM model...

Enhanced WSR Performance:
MAE: 101892.6554
RMSE: 133716.4084
MAPE: 16.81%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 88
   • Highly important features (top 5%): 68

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_15_t3: importance=0.0031, rank=1
   2. Feature_19_t0: importance=0.0025, rank=2
   3. Feature_17_t2: importance=0.0021, rank=3
   4. Feature_13_t2: importance=0.0014, rank=4
   5. Feature_7_t2: importance=0.0014, rank=5

📊 WSR Results:
  Baseline MAPE: 14.07%
  Enhanced MAPE: 16.81%
  MAPE Improvement: -2.74% (-19.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 461/464: WWW
============================================================
📊 Loading data for WWW...
📊 Loading data for WWW from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for WWW...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for WWW...

==================================================
Training Baseline WWW (SVM)
==================================================
Training SVM model...

Baseline WWW Performance:
MAE: 565346.9851
RMSE: 856391.0081
MAPE: 10.27%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 279
   • Highly important features (top 5%): 157

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0004, rank=1
   2. Feature_67_t3: importance=0.0004, rank=2
   3. Feature_68_t3: importance=0.0003, rank=3
   4. Feature_89_t1: importance=0.0003, rank=4
   5. Feature_83_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for WWW...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for WWW...

==================================================
Training Enhanced WWW (SVM)
==================================================
Training SVM model...

Enhanced WWW Performance:
MAE: 606194.2627
RMSE: 858091.6612
MAPE: 10.96%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 87
   • Highly important features (top 5%): 72

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_20_t3: importance=0.0007, rank=1
   2. Feature_7_t1: importance=0.0004, rank=2
   3. Feature_13_t3: importance=0.0004, rank=3
   4. Feature_14_t3: importance=0.0003, rank=4
   5. Feature_9_t3: importance=0.0003, rank=5

📊 WWW Results:
  Baseline MAPE: 10.27%
  Enhanced MAPE: 10.96%
  MAPE Improvement: -0.69% (-6.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 462/464: XHR
============================================================
📊 Loading data for XHR...
📊 Loading data for XHR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for XHR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for XHR...

==================================================
Training Baseline XHR (SVM)
==================================================
Training SVM model...

Baseline XHR Performance:
MAE: 375703.9961
RMSE: 499168.4793
MAPE: 10.15%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 273
   • Highly important features (top 5%): 198

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_70_t3: importance=0.0015, rank=1
   2. Feature_69_t3: importance=0.0011, rank=2
   3. Feature_1_t3: importance=0.0011, rank=3
   4. Feature_67_t3: importance=0.0006, rank=4
   5. Feature_68_t3: importance=0.0005, rank=5

🔧 Applying universal feature engineering for XHR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for XHR...

==================================================
Training Enhanced XHR (SVM)
==================================================
Training SVM model...

Enhanced XHR Performance:
MAE: 391528.0028
RMSE: 495716.6122
MAPE: 10.51%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 80
   • Highly important features (top 5%): 65

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_1_t3: importance=0.0049, rank=1
   2. Feature_11_t3: importance=0.0012, rank=2
   3. Feature_17_t2: importance=0.0011, rank=3
   4. Feature_2_t3: importance=0.0010, rank=4
   5. Feature_24_t3: importance=0.0009, rank=5

📊 XHR Results:
  Baseline MAPE: 10.15%
  Enhanced MAPE: 10.51%
  MAPE Improvement: -0.36% (-3.5%)
  Features: 97 -> 25

============================================================
TESTING TICKER 463/464: XNCR
============================================================
📊 Loading data for XNCR...
📊 Loading data for XNCR from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for XNCR...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for XNCR...

==================================================
Training Baseline XNCR (SVM)
==================================================
Training SVM model...

Baseline XNCR Performance:
MAE: 424852.1688
RMSE: 536074.9827
MAPE: 7.64%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 159
   • Highly important features (top 5%): 98

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_63_t3: importance=0.0002, rank=1
   2. Feature_72_t3: importance=0.0001, rank=2
   3. Feature_67_t3: importance=0.0001, rank=3
   4. Feature_80_t3: importance=0.0001, rank=4
   5. Feature_68_t3: importance=0.0001, rank=5

🔧 Applying universal feature engineering for XNCR...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for XNCR...

==================================================
Training Enhanced XNCR (SVM)
==================================================
Training SVM model...

Enhanced XNCR Performance:
MAE: 418641.0831
RMSE: 514619.7787
MAPE: 7.50%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 73
   • Highly important features (top 5%): 57

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_4_t3: importance=0.0003, rank=1
   2. Feature_16_t3: importance=0.0002, rank=2
   3. Feature_7_t3: importance=0.0002, rank=3
   4. Feature_13_t3: importance=0.0002, rank=4
   5. Feature_24_t1: importance=0.0001, rank=5

📊 XNCR Results:
  Baseline MAPE: 7.64%
  Enhanced MAPE: 7.50%
  MAPE Improvement: +0.13% (+1.7%)
  Features: 97 -> 25

============================================================
TESTING TICKER 464/464: YELP
============================================================
📊 Loading data for YELP...
📊 Loading data for YELP from parquet file...
Loading parquet file: ../data/price_data_multiindex_20250904_113138.parquet
Parquet file loaded. Shape: (6499, 46544)
Date range: 1999-11-01 00:00:00 to 2025-09-03 00:00:00
SI dates range: 2017-12-29 00:00:00 to 2025-07-15 00:00:00
Number of SI observations: 182
Extracting OHLC data for YELP...
Retrieved price data for 1918 trading days
Price data date range: 2017-11-29 00:00:00 to 2025-07-18 00:00:00
Creating price features with 15 days lookback...
Price features shape: (182, 60)
Retrieved short volume data for 1916 days
Short volume data date range: 2017-12-01 00:00:00 to 2025-07-18 00:00:00
Creating short volume features with 15 days lookback...
Short volume features shape: (182, 30)
Combined features shape without short volume: (182, 97)
Training data shape: (106, 4, 97)
Validation data shape: (36, 4, 97)
Test data shape: (36, 4, 97)
✅ Data loaded: Train+Val=(142, 4, 97), Test=(36, 4, 97)

🎯 Training baseline model for YELP...

==================================================
Training Baseline YELP (SVM)
==================================================
Training SVM model...

Baseline YELP Performance:
MAE: 327976.2901
RMSE: 395743.4975
MAPE: 8.62%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 388
   • Important features (top 10%): 234
   • Highly important features (top 5%): 136

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_88_t2: importance=0.0003, rank=1
   2. Feature_87_t2: importance=0.0003, rank=2
   3. Feature_75_t2: importance=0.0002, rank=3
   4. Feature_65_t0: importance=0.0002, rank=4
   5. Feature_77_t2: importance=0.0002, rank=5

🔧 Applying universal feature engineering for YELP...
✅ Claude API client initialized successfully!
✅ Feature selection applied successfully on attempt 1
✅ Feature selection applied successfully on attempt 1
Feature engineering: (142, 4, 97) -> (142, 4, 25)

🚀 Training enhanced model for YELP...

==================================================
Training Enhanced YELP (SVM)
==================================================
Training SVM model...

Enhanced YELP Performance:
MAE: 259346.6913
RMSE: 330428.9199
MAPE: 6.97%

📊 Calculating SVM feature importance...
📈 SVM Feature Importance Analysis:
   • Total features: 100
   • Important features (top 10%): 93
   • Highly important features (top 5%): 71

🔍 TOP 5 MOST IMPORTANT FEATURES:
   1. Feature_7_t2: importance=0.0005, rank=1
   2. Feature_1_t2: importance=0.0005, rank=2
   3. Feature_4_t0: importance=0.0004, rank=3
   4. Feature_20_t1: importance=0.0004, rank=4
   5. Feature_16_t1: importance=0.0004, rank=5

📊 YELP Results:
  Baseline MAPE: 8.62%
  Enhanced MAPE: 6.97%
  MAPE Improvement: +1.65% (+19.2%)
  Features: 97 -> 25

================================================================================
UNIVERSAL FEATURE ENGINEERING PERFORMANCE REPORT
================================================================================

📊 SUMMARY STATISTICS:
  Total tickers tested: 464
  Successful tests: 391
  Failed tests: 73
  Failed tickers: AAP, ACAD, ADMA, ADNT, AIN, APLE, AXL, BANF, BFS, BLFS, BOX, BTU, CABO, CALM, CARG, CARS, CASH, CLB, CPRX, DVAX, DXC, EFC, EXPI, EYE, FBK, FDP, FUN, GOGO, HCC, HCI, IAC, IIPR, INSW, JBGS, JJSF, KAR, KREF, KRYS, LPG, MC, MKTX, MRTN, MXL, NPK, NWL, PAHC, PENN, PFBC, PLUS, POWL, PTGX, QDEL, QTWO, REX, SAFE, SKT, SKY, SMPL, SNDR, TDS, TGTX, TNDM, TR, TRNO, TRST, TRUP, UFPT, UNIT, VBTX, VCYT, VRTS, WRLD, WSC

🎯 MAPE IMPROVEMENT STATISTICS:
  Average MAPE improvement: 0.18%
  Median MAPE improvement: 0.13%
  Std deviation: 1.28%
  Min improvement: -4.63%
  Max improvement: 5.75%

📈 RELATIVE IMPROVEMENT STATISTICS:
  Average relative improvement: 1.4%
  Median relative improvement: 1.3%
  Std deviation: 12.9%

🏆 IMPROVEMENT DISTRIBUTION:
  Tickers with positive improvement: 211/391 (54.0%)
  Tickers with >0.5% improvement: 134/391 (34.3%)

📋 DETAILED RESULTS:
----------------------------------------------------------------------------------------------------
Ticker   Baseline MAPE Enhanced MAPE Improvement  Rel. Imp.  Features    
----------------------------------------------------------------------------------------------------
AAT      13.28        12.02         1.26         9.5        97->25
ABCB     12.17        11.94         0.23         1.9        97->25
ABG      4.76         4.88          -0.12        -2.5       97->25
ABM      14.65        15.09         -0.44        -3.0       97->25
ABR      7.40         5.32          2.08         28.1       97->25
ACHC     8.47         8.30          0.17         2.0        97->25
ACIW     5.82         6.27          -0.45        -7.7       97->25
ACLS     8.81         7.97          0.85         9.6        97->25
ADUS     10.70        13.51         -2.81        -26.3      97->25
AEIS     6.09         5.02          1.07         17.6       97->25
AEO      11.29        11.10         0.20         1.7        97->25
AGO      11.95        10.64         1.31         11.0       97->25
AGYS     11.66        11.80         -0.14        -1.2       97->25
AHH      16.91        14.27         2.64         15.6       97->25
AIR      13.60        10.30         3.30         24.3       97->25
AKR      20.18        20.70         -0.52        -2.6       97->25
AL       12.15        12.91         -0.76        -6.3       97->25
ALEX     13.93        15.73         -1.80        -12.9      97->25
ALG      8.39         9.08          -0.69        -8.2       97->25
ALGT     11.72        12.25         -0.53        -4.5       97->25
ALKS     7.79         8.18          -0.38        -4.9       97->25
ALRM     6.94         6.80          0.14         2.0        97->25
AMN      10.74        9.19          1.54         14.4       97->25
AMPH     6.89         6.97          -0.08        -1.2       97->25
AMSF     16.89        16.65         0.25         1.5        97->25
AMWD     11.41        12.67         -1.27        -11.1      97->25
ANDE     13.70        13.58         0.12         0.9        97->25
ANGI     27.47        27.11         0.36         1.3        97->25
ANIP     12.83        14.65         -1.82        -14.2      97->25
AOSL     9.50         10.05         -0.55        -5.8       97->25
APAM     8.60         7.84          0.76         8.9        97->25
APOG     9.35         11.32         -1.97        -21.1      97->25
ARCB     8.23         8.44          -0.21        -2.6       97->25
ARI      8.68         9.29          -0.62        -7.1       97->25
AROC     9.53         9.16          0.37         3.9        97->25
ARR      17.72        16.02         1.70         9.6        97->25
ARWR     6.36         5.78          0.59         9.2        97->25
ASIX     11.77        9.30          2.47         21.0       97->25
ASTE     12.31        11.25         1.06         8.6        97->25
ATEN     16.60        16.89         -0.29        -1.8       97->25
ATGE     15.44        14.24         1.20         7.8        97->25
AVA      6.98         8.67          -1.68        -24.1      97->25
AWI      19.19        16.30         2.89         15.1       97->25
AWR      11.59        11.98         -0.40        -3.4       97->25
AZZ      13.16        12.75         0.41         3.1        97->25
BANC     8.71         8.95          -0.24        -2.7       97->25
BANR     7.72         8.45          -0.73        -9.4       97->25
BCC      11.88        12.68         -0.80        -6.7       97->25
BCPC     9.04         8.83          0.22         2.4        97->25
BDN      5.66         5.13          0.53         9.3        97->25
BHE      11.75        11.56         0.19         1.6        97->25
BJRI     6.57         6.13          0.45         6.8        97->25
BKE      7.87         7.43          0.44         5.6        97->25
BKU      7.77         7.96          -0.19        -2.4       97->25
BL       9.20         9.45          -0.25        -2.7       97->25
BLMN     13.88        10.16         3.72         26.8       97->25
BMI      4.92         4.79          0.13         2.7        97->25
BOH      3.86         5.99          -2.13        -55.1      97->25
BOOT     11.62        9.40          2.22         19.1       97->25
BRC      19.52        22.42         -2.90        -14.8      97->25
BWA      8.86         9.43          -0.57        -6.4       97->25
BXMT     8.70         9.28          -0.58        -6.7       97->25
CAKE     5.27         5.44          -0.16        -3.1       97->25
CAL      8.22         8.72          -0.50        -6.0       97->25
CALX     11.43        9.32          2.11         18.5       97->25
CATY     10.00        9.06          0.94         9.4        97->25
CBRL     11.60        11.54         0.06         0.5        97->25
CBU      5.84         6.05          -0.21        -3.5       97->25
CC       6.23         6.74          -0.50        -8.1       97->25
CCOI     8.71         8.02          0.70         8.0        97->25
CCS      9.94         10.91         -0.96        -9.7       97->25
CE       7.68         7.19          0.49         6.4        97->25
CENT     8.01         8.19          -0.18        -2.2       97->25
CENTA    11.54        11.54         0.00         0.0        97->25
CENX     9.27         8.56          0.71         7.7        97->25
CEVA     9.62         9.69          -0.07        -0.7       97->25
CFFN     5.87         5.88          -0.01        -0.2       97->25
CHCO     3.09         4.36          -1.27        -41.1      97->25
CHEF     6.45         6.21          0.24         3.7        97->25
CNK      5.85         5.27          0.58         9.9        97->25
CNMD     7.57         6.87          0.71         9.3        97->25
CNS      9.33         7.86          1.47         15.8       97->25
CNXN     13.66        14.52         -0.86        -6.3       97->25
COHU     10.99        11.00         -0.00        -0.0       97->25
COLL     3.94         4.79          -0.85        -21.5      97->25
CORT     5.07         5.26          -0.19        -3.7       97->25
CPF      17.72        17.26         0.46         2.6        97->25
CPK      12.39        12.02         0.37         3.0        97->25
CRI      10.85        10.20         0.65         6.0        97->25
CRK      7.30         7.72          -0.41        -5.7       97->25
CRVL     8.13         6.68          1.45         17.9       97->25
CSGS     8.48         8.54          -0.06        -0.7       97->25
CTRE     16.76        15.96         0.80         4.8        97->25
CTS      8.75         10.81         -2.06        -23.5      97->25
CUBI     11.37        7.08          4.29         37.7       97->25
CVBF     10.70        11.69         -0.99        -9.3       97->25
CVCO     12.77        10.98         1.79         14.1       97->25
CVI      9.64         10.08         -0.43        -4.5       97->25
CWT      15.54        16.37         -0.83        -5.4       97->25
CXW      12.56        10.46         2.10         16.7       97->25
CZR      9.14         9.41          -0.26        -2.9       97->25
DAN      7.59         9.42          -1.83        -24.1      97->25
DCOM     6.25         6.48          -0.23        -3.7       97->25
DEA      18.11        18.16         -0.05        -0.3       97->25
DEI      7.61         7.29          0.33         4.3        97->25
DFIN     11.45        9.35          2.10         18.3       97->25
DGII     5.83         5.91          -0.08        -1.4       97->25
DIOD     7.28         7.17          0.11         1.6        97->25
DLX      3.70         3.78          -0.08        -2.2       97->25
DNOW     16.30        18.29         -1.99        -12.2      97->25
DORM     11.44        11.87         -0.43        -3.7       97->25
DRH      7.99         7.05          0.95         11.8       97->25
DXPE     9.72         10.31         -0.59        -6.0       97->25
DY       10.92        12.08         -1.16        -10.6      97->25
EAT      7.16         6.11          1.05         14.7       97->25
ECPG     4.88         4.37          0.51         10.4       97->25
EGBN     10.69        9.03          1.66         15.5       97->25
EIG      15.07        15.40         -0.33        -2.2       97->25
ENPH     7.67         7.96          -0.29        -3.8       97->25
ENR      5.62         7.38          -1.77        -31.4      97->25
ENVA     5.39         6.34          -0.94        -17.5      97->25
EPC      6.07         6.64          -0.57        -9.3       97->25
ESE      14.10        14.02         0.08         0.6        97->25
ETSY     8.28         5.03          3.25         39.3       97->25
EVTC     11.31        8.27          3.04         26.9       97->25
EXTR     7.53         9.70          -2.17        -28.7      97->25
EZPW     6.87         8.03          -1.16        -16.9      97->25
FBNC     8.74         8.20          0.54         6.2        97->25
FBP      19.88        15.77         4.11         20.7       97->25
FCF      10.90        11.23         -0.33        -3.0       97->25
FCPT     10.49        11.17         -0.67        -6.4       97->25
FELE     10.86        10.75         0.11         1.0        97->25
FFBC     9.05         9.29          -0.24        -2.7       97->25
FHB      7.47         8.87          -1.39        -18.7      97->25
FIZZ     5.15         4.57          0.58         11.2       97->25
FMC      6.83         6.99          -0.16        -2.4       97->25
FORM     8.68         8.05          0.63         7.3        97->25
FOXF     9.32         9.30          0.02         0.2        97->25
FRPT     6.92         4.84          2.08         30.0       97->25
FSS      13.81        12.80         1.01         7.3        97->25
FUL      9.55         9.23          0.32         3.3        97->25
FULT     7.94         8.24          -0.29        -3.7       97->25
FWRD     14.02        10.28         3.74         26.7       97->25
GBX      5.25         5.38          -0.13        -2.5       97->25
GDEN     10.40        13.01         -2.62        -25.2      97->25
GEO      13.18        12.72         0.46         3.5        97->25
GES      8.10         6.25          1.85         22.8       97->25
GFF      10.67        13.91         -3.24        -30.4      97->25
GIII     5.98         5.27          0.71         11.8       97->25
GKOS     11.00        11.09         -0.09        -0.8       97->25
GNL      14.48        14.25         0.22         1.5        97->25
GNW      9.83         11.46         -1.63        -16.6      97->25
GOLF     7.94         7.08          0.86         10.9       97->25
GPI      3.80         3.73          0.06         1.7        97->25
GRBK     11.77        10.93         0.85         7.2        97->25
GTY      13.37        10.96         2.41         18.0       97->25
GVA      6.98         5.04          1.94         27.8       97->25
HAFC     14.99        15.09         -0.09        -0.6       97->25
HASI     5.00         4.39          0.62         12.3       97->25
HBI      5.74         5.58          0.15         2.7        97->25
HCSG     7.46         7.92          -0.46        -6.2       97->25
HELE     9.19         7.89          1.30         14.1       97->25
HFWA     10.08        10.62         -0.54        -5.4       97->25
HI       9.71         9.92          -0.20        -2.1       97->25
HIW      14.77        15.60         -0.83        -5.6       97->25
HL       11.80        12.32         -0.52        -4.4       97->25
HLIT     11.30        9.54          1.76         15.6       97->25
HLX      12.58        11.01         1.57         12.5       97->25
HMN      15.10        15.19         -0.09        -0.6       97->25
HNI      11.01        11.18         -0.17        -1.6       97->25
HOPE     12.89        13.28         -0.39        -3.0       97->25
HP       7.13         6.87          0.25         3.6        97->25
HSII     15.90        13.61         2.29         14.4       97->25
HSTM     11.35        14.97         -3.61        -31.8      97->25
HTH      11.51        16.14         -4.63        -40.2      97->25
HTLD     9.59         10.77         -1.18        -12.3      97->25
HUBG     23.65        23.31         0.34         1.4        97->25
HWKN     18.51        18.41         0.10         0.5        97->25
HZO      6.80         6.30          0.50         7.3        97->25
IART     10.76        10.29         0.47         4.4        97->25
IBP      8.20         8.74          -0.55        -6.7       97->25
ICHR     11.01        10.78         0.23         2.1        97->25
ICUI     9.37         9.74          -0.38        -4.0       97->25
IDCC     5.41         5.96          -0.54        -10.1      97->25
IIIN     13.11        13.73         -0.62        -4.8       97->25
INDB     13.04        14.33         -1.29        -9.9       97->25
INN      16.30        14.44         1.86         11.4       97->25
INVA     3.76         3.93          -0.17        -4.5       97->25
IOSP     16.68        16.79         -0.11        -0.6       97->25
IPAR     9.24         9.80          -0.56        -6.1       97->25
ITGR     7.29         7.68          -0.39        -5.3       97->25
ITRI     7.91         8.31          -0.41        -5.2       97->25
JBLU     12.15        8.62          3.53         29.1       97->25
JBSS     14.78        15.32         -0.55        -3.7       97->25
JOE      8.79         9.23          -0.44        -5.0       97->25
KAI      11.15        5.40          5.75         51.5       97->25
KALU     13.46        13.33         0.13         1.0        97->25
KFY      16.08        15.89         0.19         1.2        97->25
KLIC     6.53         7.65          -1.13        -17.3      97->25
KMT      8.75         8.38          0.37         4.2        97->25
KN       11.34        11.21         0.13         1.1        97->25
KOP      14.05        13.03         1.02         7.3        97->25
KSS      6.84         7.08          -0.24        -3.5       97->25
KW       10.88        7.62          3.25         29.9       97->25
KWR      5.01         4.81          0.19         3.9        97->25
LCII     7.46         6.90          0.57         7.6        97->25
LEG      14.24        14.08         0.16         1.1        97->25
LGIH     3.34         3.29          0.05         1.4        97->25
LGND     9.47         9.45          0.03         0.3        97->25
LKFN     3.96         3.21          0.74         18.8       97->25
LMAT     8.22         7.65          0.57         6.9        97->25
LNC      7.15         7.23          -0.08        -1.1       97->25
LNN      9.79         9.66          0.13         1.3        97->25
LQDT     9.86         8.34          1.52         15.4       97->25
LRN      7.93         8.14          -0.21        -2.6       97->25
LTC      6.80         6.59          0.21         3.1        97->25
LXP      18.93        19.89         -0.96        -5.1       97->25
LZB      9.11         8.06          1.06         11.6       97->25
MAC      5.40         5.51          -0.12        -2.1       97->25
MAN      9.66         8.12          1.54         15.9       97->25
MARA     7.59         7.06          0.53         7.0        97->25
MATW     9.41         6.82          2.59         27.5       97->25
MATX     15.66        14.35         1.31         8.4        97->25
MCRI     19.72        18.59         1.13         5.7        97->25
MCY      12.95        12.99         -0.03        -0.3       97->25
MD       13.06        11.66         1.40         10.7       97->25
MDU      10.42        10.36         0.06         0.6        97->25
MGEE     13.65        10.28         3.38         24.7       97->25
MGPI     7.49         7.96          -0.47        -6.3       97->25
MHO      9.80         10.25         -0.45        -4.6       97->25
MMI      11.53        10.61         0.92         7.9        97->25
MMSI     8.22         7.72          0.50         6.1        97->25
MNRO     6.93         6.85          0.08         1.1        97->25
MPW      5.74         3.75          1.99         34.7       97->25
MRCY     4.96         4.81          0.15         2.9        97->25
MSEX     10.02        10.32         -0.30        -3.0       97->25
MTH      13.01        13.52         -0.52        -4.0       97->25
MTRN     8.63         8.79          -0.16        -1.9       97->25
MTX      12.36        10.65         1.71         13.9       97->25
MWA      13.66        12.88         0.78         5.7        97->25
MYGN     10.49        10.15         0.34         3.3        97->25
MYRG     12.37        11.86         0.51         4.1        97->25
NAVI     5.32         5.34          -0.03        -0.5       97->25
NBHC     11.70        10.76         0.94         8.0        97->25
NBTB     10.16        9.84          0.32         3.2        97->25
NEO      11.10        9.18          1.91         17.2       97->25
NEOG     7.67         7.17          0.51         6.6        97->25
NGVT     6.11         6.34          -0.23        -3.8       97->25
NHC      11.40        10.89         0.51         4.5        97->25
NMIH     12.62        12.78         -0.16        -1.3       97->25
NOG      6.33         7.15          -0.82        -13.0      97->25
NPO      11.23        11.57         -0.34        -3.0       97->25
NSIT     9.91         10.82         -0.90        -9.1       97->25
NTCT     11.33        12.63         -1.30        -11.5      97->25
NWBI     7.54         6.83          0.71         9.4        97->25
NWN      17.20        17.31         -0.11        -0.6       97->25
NX       13.14        12.88         0.26         2.0        97->25
NXRT     13.92        17.30         -3.37        -24.2      97->25
OFG      23.64        25.19         -1.55        -6.6       97->25
OI       10.69        9.32          1.37         12.8       97->25
OII      7.00         6.39          0.61         8.8        97->25
OMCL     9.65         9.10          0.55         5.7        97->25
OSIS     8.65         9.00          -0.35        -4.1       97->25
OTTR     5.28         6.57          -1.28        -24.3      97->25
OUT      11.06        10.51         0.55         4.9        97->25
OXM      6.55         6.24          0.31         4.8        97->25
PARR     12.63        10.83         1.80         14.3       97->25
PATK     7.61         7.41          0.20         2.7        97->25
PBH      7.62         7.94          -0.31        -4.1       97->25
PBI      8.65         8.66          -0.01        -0.1       97->25
PCRX     7.83         7.37          0.47         5.9        97->25
PDFS     9.06         9.13          -0.06        -0.7       97->25
PEB      7.61         7.05          0.56         7.4        97->25
PFS      10.90        8.70          2.20         20.2       97->25
PI       7.21         7.07          0.13         1.9        97->25
PINC     9.71         10.21         -0.51        -5.2       97->25
PJT      9.25         8.43          0.83         8.9        97->25
PLAB     7.56         8.94          -1.38        -18.2      97->25
PLAY     12.09        10.75         1.35         11.1       97->25
PLXS     12.11        12.67         -0.56        -4.6       97->25
PMT      7.24         7.31          -0.07        -0.9       97->25
PRA      12.68        12.46         0.23         1.8        97->25
PRAA     12.39        13.23         -0.83        -6.7       97->25
PRGS     5.37         6.17          -0.80        -14.8      97->25
PRK      7.95         10.88         -2.93        -36.8      97->25
PRLB     11.22        10.85         0.37         3.3        97->25
PSMT     10.17        8.99          1.18         11.6       97->25
PTEN     12.12        10.54         1.58         13.0       97->25
PZZA     16.65        14.14         2.51         15.1       97->25
QNST     13.60        12.84         0.76         5.6        97->25
QRVO     11.61        12.33         -0.72        -6.2       97->25
RDN      9.64         10.54         -0.90        -9.4       97->25
RDNT     9.99         9.63          0.37         3.7        97->25
RES      9.95         8.46          1.49         15.0       97->25
RGR      11.12        8.42          2.70         24.3       97->25
RHI      8.28         7.74          0.53         6.4        97->25
RHP      12.42        13.37         -0.95        -7.7       97->25
RNST     10.75        11.04         -0.29        -2.7       97->25
ROCK     14.97        17.96         -2.98        -19.9      97->25
ROG      11.16        9.47          1.69         15.1       97->25
RUN      4.78         4.67          0.11         2.3        97->25
RUSHA    7.80         6.51          1.29         16.5       97->25
RWT      10.21        10.49         -0.28        -2.7       97->25
SABR     7.58         6.90          0.69         9.0        97->25
SAFT     9.74         11.61         -1.87        -19.2      97->25
SAH      5.00         5.42          -0.42        -8.4       97->25
SANM     10.30        9.22          1.08         10.4       97->25
SBCF     9.64         9.65          -0.02        -0.2       97->25
SBH      8.86         10.82         -1.95        -22.0      97->25
SBSI     6.62         7.51          -0.88        -13.3      97->25
SCHL     12.17        12.85         -0.69        -5.6       97->25
SCL      10.11        9.65          0.46         4.6        97->25
SCSC     11.52        13.89         -2.36        -20.5      97->25
SCVL     6.41         4.93          1.48         23.1       97->25
SEDG     7.54         6.84          0.70         9.2        97->25
SEE      9.63         9.94          -0.31        -3.2       97->25
SEM      8.60         9.56          -0.97        -11.2      97->25
SFBS     5.14         2.69          2.45         47.7       97->25
SFNC     7.78         7.89          -0.12        -1.5       97->25
SHAK     5.09         5.14          -0.05        -1.0       97->25
SHEN     8.26         7.97          0.29         3.5        97->25
SHO      10.56        10.23         0.34         3.2        97->25
SHOO     11.83        10.70         1.13         9.5        97->25
SIG      6.96         5.52          1.45         20.8       97->25
SKYW     12.03        9.66          2.37         19.7       97->25
SLG      5.00         4.87          0.14         2.7        97->25
SM       7.57         7.98          -0.41        -5.4       97->25
SMP      21.40        19.81         1.59         7.4        97->25
SMTC     11.96        11.18         0.77         6.5        97->25
SPSC     9.74         11.82         -2.08        -21.4      97->25
SPXC     9.73         10.27         -0.54        -5.6       97->25
SRPT     8.94         8.38          0.56         6.2        97->25
SSTK     7.08         5.89          1.19         16.8       97->25
STAA     8.64         7.74          0.90         10.4       97->25
STBA     6.17         5.55          0.62         10.1       97->25
STC      18.42        17.28         1.13         6.1        97->25
STRA     10.96        13.44         -2.48        -22.6      97->25
STRL     9.70         8.91          0.80         8.2        97->25
SUPN     6.01         5.47          0.54         9.0        97->25
SXC      15.80        14.87         0.93         5.9        97->25
SXI      10.23        14.25         -4.02        -39.3      97->25
SXT      10.68        10.93         -0.25        -2.4       97->25
TBBK     5.25         4.99          0.26         4.9        97->25
TDC      9.13         8.77          0.36         3.9        97->25
TDW      7.40         6.70          0.70         9.4        97->25
TFX      20.91        20.77         0.13         0.6        97->25
TGNA     11.06        10.66         0.40         3.7        97->25
THRM     10.51        10.38         0.14         1.3        97->25
THS      9.65         8.42          1.23         12.7       97->25
TILE     17.19        16.12         1.07         6.2        97->25
TMP      11.30        10.86         0.44         3.9        97->25
TNC      9.71         9.20          0.50         5.2        97->25
TPH      13.69        14.10         -0.41        -3.0       97->25
TRIP     11.24        10.34         0.90         8.0        97->25
TRMK     7.81         8.55          -0.74        -9.4       97->25
TRN      9.43         10.06         -0.63        -6.7       97->25
TTMI     14.03        14.80         -0.77        -5.5       97->25
TWI      9.77         8.83          0.94         9.6        97->25
TWO      12.41        12.89         -0.48        -3.9       97->25
UCTT     9.38         9.91          -0.53        -5.6       97->25
UE       12.18        13.38         -1.20        -9.8       97->25
UFCS     14.85        15.69         -0.84        -5.7       97->25
UHT      27.03        24.40         2.62         9.7        97->25
UNF      15.10        15.69         -0.58        -3.9       97->25
UNFI     6.88         6.75          0.14         2.0        97->25
URBN     13.19        12.35         0.84         6.4        97->25
USNA     9.72         8.88          0.84         8.7        97->25
USPH     7.68         7.26          0.43         5.5        97->25
UTL      15.10        14.50         0.60         4.0        97->25
UVV      19.66        19.74         -0.09        -0.4       97->25
VCEL     10.42        8.55          1.87         18.0       97->25
VECO     6.28         6.55          -0.27        -4.3       97->25
VIAV     8.77         8.96          -0.18        -2.1       97->25
VICR     6.21         4.29          1.92         30.9       97->25
VIRT     12.25        12.08         0.17         1.4        97->25
VSAT     7.11         7.15          -0.04        -0.6       97->25
VSH      6.58         6.48          0.10         1.6        97->25
WABC     11.98        11.83         0.16         1.3        97->25
WAFD     12.59        13.60         -1.01        -8.0       97->25
WD       8.30         9.42          -1.13        -13.6      97->25
WDFC     3.50         3.57          -0.07        -2.1       97->25
WEN      12.57        13.84         -1.27        -10.1      97->25
WERN     10.29        11.08         -0.78        -7.6       97->25
WGO      5.70         4.30          1.40         24.6       97->25
WOR      14.56        12.91         1.65         11.3       97->25
WSFS     9.69         10.31         -0.62        -6.4       97->25
WSR      14.07        16.81         -2.74        -19.5      97->25
WWW      10.27        10.96         -0.69        -6.7       97->25
XHR      10.15        10.51         -0.36        -3.5       97->25
XNCR     7.64         7.50          0.13         1.7        97->25
YELP     8.62         6.97          1.65         19.2       97->25
----------------------------------------------------------------------------------------------------

💾 Detailed report saved to: cache/universal_feature_engineering_validation_report.txt
💾 Validation results saved to: cache/universal_feature_engineering_validation_results.pkl

🎯 VALIDATION SUMMARY:
  Successfully tested: 391/464 tickers
  Average MAPE improvement: 0.18%
  Tickers with positive improvement: 211/391 (54.0%)
  Tickers with >0.5% improvement: 134/391 (34.3%)

🎉 Complete multi-ticker process completed successfully!
Processed 12 tickers for iterative feature engineering
Generated and validated universal feature engineering code on 464 tickers

✅ SVM Multi-ticker results:
  Processed 12 tickers for iterative engineering
  Generated universal feature engineering function
  Validated on 391 tickers

🎉 Examples completed!

To run the full pipeline:
  python code/main.py --config development --single-ticker AAPL
  python code/main.py --config production --tickers AAPL TSLA
  python code/main.py --config quick_test --max-tickers 3
