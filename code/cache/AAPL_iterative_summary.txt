============================================================
ITERATIVE AGENT-BASED FEATURE SELECTION SUMMARY
============================================================
Stock: AAPL
Date: 2025-10-09 00:19:30
Total Iterations: 2

PERFORMANCE TREND:
----------------------------------------
Iteration 0: Baseline - MAPE: 6.85% (Baseline)
Iteration 1: Iteration 1 - MAPE: 8.63% (-1.79%)
Iteration 2: Iteration 2 - MAPE: 6.91% (-0.07%)

Best Model: Baseline - MAPE: 6.85%

============================================================
FEATURE ENGINEERING CODES
============================================================

ITERATION 2:
Performance: MAPE = 6.91%
Improvement: -0.07%
Features: 25
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    features_array = []
    
    for t in range(lookback_window):
        # Initialize lists for raw and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        raw_keep.append(short_interest)  # Short interest
        raw_keep.append(avg_volume)      # Average daily volume
        raw_keep.append(days_to_cover)   # Days to cover
        
        # Extract OHLC data
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values
        raw_keep.append(close_prices[-1])  # Most recent close
        
        # Options data - high importance from previous iterations
        put_call_ratio = data[t, 64]
        synthetic_short_cost = data[t, 65]
        implied_volatility = data[t, 66]
        
        raw_keep.append(put_call_ratio)
        raw_keep.append(synthetic_short_cost)
        raw_keep.append(implied_volatility)
        
        # Shares outstanding
        shares_outstanding = data[t, 67]
        raw_keep.append(shares_outstanding)
        
        # Extract short volume and total volume data
        short_volume = data[t, 68:83]
        total_volume = data[t, 83:98]
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Price momentum and volatility features
        if len(close_prices) > 1:
            # 5-day price momentum
            price_momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8) - 1) if len(close_prices) >= 5 else 0
            eng.append(price_momentum_5d)
            
            # 10-day price momentum
            price_momentum_10d = (close_prices[-1] / max(close_prices[-10], 1e-8) - 1) if len(close_prices) >= 10 else 0
            eng.append(price_momentum_10d)
            
            # Price volatility (standard deviation of returns)
            returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            price_volatility = np.std(returns) if len(returns) > 0 else 0
            eng.append(price_volatility)
            
            # Average true range (ATR) - volatility indicator
            true_ranges = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close_prev = abs(high_prices[i] - close_prices[i-1])
                low_close_prev = abs(low_prices[i] - close_prices[i-1])
                true_range = max(high_low, high_close_prev, low_close_prev)
                true_ranges.append(true_range)
            atr = np.mean(true_ranges) if true_ranges else 0
            eng.append(atr)
        else:
            eng.extend([0, 0, 0, 0])  # Placeholders if not enough data
        
        # 2. Short interest related features
        if len(short_volume) > 0 and len(total_volume) > 0:
            # Short volume ratio (recent 5 days)
            recent_short_vol = np.sum(short_volume[-5:]) if len(short_volume) >= 5 else np.sum(short_volume)
            recent_total_vol = np.sum(total_volume[-5:]) if len(total_volume) >= 5 else np.sum(total_volume)
            short_vol_ratio = recent_short_vol / max(recent_total_vol, 1e-8)
            eng.append(short_vol_ratio)
            
            # Short interest to float ratio
            short_interest_to_float = short_interest / max(shares_outstanding, 1e-8)
            eng.append(short_interest_to_float)
            
            # Short interest momentum (change over time)
            short_interest_momentum = 0
            if t > 0 and data[t-1, 0] > 0:
                short_interest_momentum = (short_interest / max(data[t-1, 0], 1e-8)) - 1
            eng.append(short_interest_momentum)
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 3. Volume-based features
        if len(total_volume) > 1:
            # Volume momentum
            volume_momentum = (total_volume[-1] / max(np.mean(total_volume[:-1]), 1e-8)) - 1
            eng.append(volume_momentum)
            
            # Volume volatility
            volume_volatility = np.std(total_volume) / max(np.mean(total_volume), 1e-8)
            eng.append(volume_volatility)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 4. Options-based features
        # Put-call ratio momentum
        put_call_momentum = 0
        if t > 0:
            prev_put_call = data[t-1, 64]
            put_call_momentum = (put_call_ratio / max(prev_put_call, 1e-8)) - 1 if prev_put_call > 0 else 0
        eng.append(put_call_momentum)
        
        # 5. Technical indicators
        if len(close_prices) >= 14:
            # RSI (Relative Strength Index)
            diff = np.diff(close_prices)
            gains = np.maximum(diff, 0)
            losses = np.maximum(-diff, 0)
            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
            
            # MACD components
            ema12 = np.mean(close_prices[-12:])
            ema26 = np.mean(close_prices[-14:])  # Using all available data as approximation
            macd = ema12 - ema26
            eng.append(macd)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 6. Combined metrics
        # Short interest to volume ratio
        si_to_volume = short_interest / max(avg_volume, 1e-8)
        eng.append(si_to_volume)
        
        # Short interest to volatility ratio
        si_to_volatility = short_interest * price_volatility if 'price_volatility' in locals() else 0
        eng.append(si_to_volatility)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size
        if row.size < MAX_TOTAL:
            # Pad with zeros if needed
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            # Truncate if needed
            row = row[:MAX_TOTAL]
        
        features_array.append(row)
    
    # Convert to numpy array and handle NaNs
    result = np.array(features_array, dtype=np.float32)
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
============================================================
