============================================================
ITERATIVE AGENT-BASED FEATURE SELECTION SUMMARY
============================================================
Stock: AAPL
Date: 2025-10-04 02:03:57
Total Iterations: 3

PERFORMANCE TREND:
----------------------------------------
Iteration 0: Baseline - MAPE: 6.93% (Baseline)
Iteration 1: Iteration 1 - MAPE: 7.49% (-0.56%)
Iteration 2: Iteration 2 - MAPE: 7.53% (-0.60%)
Iteration 3: Iteration 3 - MAPE: 7.73% (-0.81%)

Best Model: Baseline - MAPE: 6.93%

============================================================
FEATURE ENGINEERING CODES
============================================================

ITERATION 1:
Performance: MAPE = 7.49%
Improvement: -0.56%
Features: 20
----------------------------------------
def construct_features(data):
    """
    Constructs features for short interest prediction from equity time series data.
    
    Args:
        data: numpy array of shape (lookback_window, 62)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    # Constants
    RAW_DIM = 62
    MAX_TOTAL = 20
    
    lookback_window = data.shape[0]
    features = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Extract raw data for this timestep
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep essential raw features
        raw_keep = [short_interest, avg_volume]
        
        # Add last day OHLC as they're more relevant for prediction
        raw_keep.extend([open_prices[-1], high_prices[-1], low_prices[-1], close_prices[-1]])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Price momentum features
        # 5-day price change rate
        if len(close_prices) >= 5:
            price_change_5d = (close_prices[-1] - close_prices[-5]) / max(abs(close_prices[-5]), 1e-8)
            eng.append(price_change_5d)
        else:
            eng.append(0.0)
            
        # 10-day price change rate
        if len(close_prices) >= 10:
            price_change_10d = (close_prices[-1] - close_prices[-10]) / max(abs(close_prices[-10]), 1e-8)
            eng.append(price_change_10d)
        else:
            eng.append(0.0)
        
        # 2. Volatility features
        # Daily price range relative to close
        daily_ranges = (high_prices - low_prices) / np.maximum(close_prices, 1e-8)
        avg_daily_range = np.mean(daily_ranges) if len(daily_ranges) > 0 else 0.0
        eng.append(avg_daily_range)
        
        # 3. Volume-price relationship
        # Volume-weighted average price (VWAP)
        if avg_volume > 0:
            vwap = np.mean(close_prices) / max(avg_volume, 1e-8)
            eng.append(vwap)
        else:
            eng.append(0.0)
        
        # 4. Technical indicators
        # RSI (14-day)
        if len(close_prices) >= 2:
            price_diffs = np.diff(close_prices)
            gains = np.maximum(price_diffs, 0)
            losses = np.maximum(-price_diffs, 0)
            avg_gain = np.mean(gains) if len(gains) > 0 else 0.0
            avg_loss = np.mean(losses) if len(losses) > 0 else 0.0
            
            if avg_loss > 1e-8:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100.0 if avg_gain > 0 else 50.0
            eng.append(rsi)
        else:
            eng.append(50.0)  # Default RSI value
        
        # 5. Moving averages
        # 5-day SMA
        sma_5 = np.mean(close_prices[-5:]) if len(close_prices) >= 5 else np.mean(close_prices)
        eng.append(sma_5)
        
        # 10-day SMA
        sma_10 = np.mean(close_prices[-10:]) if len(close_prices) >= 10 else np.mean(close_prices)
        eng.append(sma_10)
        
        # SMA ratio (5-day / 10-day)
        sma_ratio = sma_5 / max(sma_10, 1e-8)
        eng.append(sma_ratio)
        
        # 6. Gap analysis
        # Average overnight gap
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gaps = open_prices[1:] - close_prices[:-1]
            avg_gap = np.mean(overnight_gaps) / max(np.mean(close_prices[:-1]), 1e-8)
            eng.append(avg_gap)
        else:
            eng.append(0.0)
        
        # 7. Trend strength
        # Directional movement over last 5 days
        if len(close_prices) >= 5:
            up_days = np.sum(np.diff(close_prices[-5:]) > 0)
            down_days = np.sum(np.diff(close_prices[-5:]) < 0)
            trend_strength = (up_days - down_days) / 4.0  # Normalize to [-1, 1]
            eng.append(trend_strength)
        else:
            eng.append(0.0)
        
        # 8. Price levels relative to recent history
        # Current price relative to 15-day high-low range
        if len(high_prices) > 0 and len(low_prices) > 0:
            max_price = np.max(high_prices)
            min_price = np.min(low_prices)
            price_range = max_price - min_price
            if price_range > 1e-8:
                price_position = (close_prices[-1] - min_price) / price_range
                eng.append(price_position)
            else:
                eng.append(0.5)  # Default if no range
        else:
            eng.append(0.5)
        
        # 9. Short interest relative to volume
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 10. Short interest momentum
        # We can't calculate this directly without previous timestep data
        # Instead, use a placeholder that will be filled with zeros
        eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent width
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        # Assign to features array
        features[t, :] = row
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
============================================================

ITERATION 2:
Performance: MAPE = 7.53%
Improvement: -0.60%
Features: 20
----------------------------------------
def construct_features(data):
    """
    Constructs features for short interest prediction from equity time series data.
    
    Args:
        data: numpy array of shape (lookback_window, 62)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    # Constants
    RAW_DIM = 62
    MAX_TOTAL = 20
    
    lookback_window = data.shape[0]
    features = []
    
    for t in range(lookback_window):
        # Extract raw data for this timestep
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep essential raw features - based on importance analysis from previous iterations
        # Always keep short interest and volume as they're fundamental
        raw_keep = [short_interest, avg_volume]
        
        # Add last day's close price (most recent price point)
        raw_keep.append(close_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to volume ratio - highly important from previous iterations
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 2. Price volatility - standard deviation of daily returns
        if len(close_prices) >= 2:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0.0
            eng.append(volatility)
        else:
            eng.append(0.0)
        
        # 3. Normalized price position within recent range
        if len(high_prices) > 0 and len(low_prices) > 0:
            max_price = np.max(high_prices)
            min_price = np.min(low_prices)
            price_range = max_price - min_price
            if price_range > 1e-8:
                price_position = (close_prices[-1] - min_price) / price_range
                eng.append(price_position)
            else:
                eng.append(0.5)
        else:
            eng.append(0.5)
        
        # 4. Average True Range (ATR) - volatility indicator
        if len(close_prices) >= 2:
            tr_values = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_prev_close = abs(high_prices[i] - close_prices[i-1])
                low_prev_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_prev_close, low_prev_close)
                tr_values.append(tr)
            atr = np.mean(tr_values) if tr_values else 0.0
            # Normalize by current price
            norm_atr = atr / max(close_prices[-1], 1e-8)
            eng.append(norm_atr)
        else:
            eng.append(0.0)
        
        # 5. RSI (Relative Strength Index) - momentum indicator
        if len(close_prices) >= 2:
            price_diffs = np.diff(close_prices)
            gains = np.maximum(price_diffs, 0)
            losses = np.maximum(-price_diffs, 0)
            avg_gain = np.mean(gains) if len(gains) > 0 else 0.0
            avg_loss = np.mean(losses) if len(losses) > 0 else 0.0
            
            if avg_loss > 1e-8:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100.0 if avg_gain > 0 else 50.0
            # Normalize to [0,1]
            norm_rsi = rsi / 100.0
            eng.append(norm_rsi)
        else:
            eng.append(0.5)
        
        # 6. Price momentum - 5-day rate of change
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] - close_prices[-5]) / max(close_prices[-5], 1e-8)
            eng.append(momentum_5d)
        else:
            eng.append(0.0)
        
        # 7. Volume-weighted price trend
        # Higher values indicate price is rising with higher volume
        if len(close_prices) >= 2 and avg_volume > 0:
            price_changes = np.diff(close_prices)
            # Normalize price changes by the average price
            avg_price = np.mean(close_prices)
            norm_price_changes = price_changes / max(avg_price, 1e-8)
            # Weight by volume
            vw_trend = np.mean(norm_price_changes) * avg_volume
            # Normalize to a reasonable range
            vw_trend = np.tanh(vw_trend)  # Squash to [-1, 1]
            eng.append(vw_trend)
        else:
            eng.append(0.0)
        
        # 8. Gap analysis - average overnight gap
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gaps = open_prices[1:] - close_prices[:-1]
            avg_gap = np.mean(overnight_gaps) / max(np.mean(close_prices[:-1]), 1e-8)
            eng.append(avg_gap)
        else:
            eng.append(0.0)
        
        # 9. Bollinger Band width - volatility measure
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(sma, 1e-8)  # Width relative to price
            eng.append(bb_width)
        else:
            eng.append(0.0)
        
        # 10. Directional movement index (simplified)
        if len(high_prices) >= 2 and len(low_prices) >= 2:
            up_moves = high_prices[1:] - high_prices[:-1]
            down_moves = low_prices[:-1] - low_prices[1:]
            
            # Only positive moves count
            up_moves = np.maximum(up_moves, 0)
            down_moves = np.maximum(down_moves, 0)
            
            # When up > down, +DM = up, else +DM = 0
            # When down > up, -DM = down, else -DM = 0
            plus_dm = np.zeros_like(up_moves)
            minus_dm = np.zeros_like(down_moves)
            
            for i in range(len(up_moves)):
                if up_moves[i] > down_moves[i]:
                    plus_dm[i] = up_moves[i]
                elif down_moves[i] > up_moves[i]:
                    minus_dm[i] = down_moves[i]
            
            # Average +DM and -DM
            avg_plus_dm = np.mean(plus_dm) if len(plus_dm) > 0 else 0.0
            avg_minus_dm = np.mean(minus_dm) if len(minus_dm) > 0 else 0.0
            
            # Calculate directional index
            if avg_plus_dm + avg_minus_dm > 1e-8:
                di = (avg_plus_dm - avg_minus_dm) / (avg_plus_dm + avg_minus_dm)
            else:
                di = 0.0
            eng.append(di)
        else:
            eng.append(0.0)
        
        # 11. Price acceleration - rate of change of momentum
        if len(close_prices) >= 10:
            # Calculate two momentum periods
            momentum_5d_recent = (close_prices[-1] - close_prices[-5]) / max(close_prices[-5], 1e-8)
            momentum_5d_earlier = (close_prices[-6] - close_prices[-10]) / max(close_prices[-10], 1e-8)
            # Acceleration is the difference in momentum
            acceleration = momentum_5d_recent - momentum_5d_earlier
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # 12. Volume trend - rate of change in volume
        # Using average volume as a proxy since we don't have daily volumes
        if t > 0 and data[t-1, 1] > 0:
            volume_trend = (avg_volume - data[t-1, 1]) / max(data[t-1, 1], 1e-8)
            eng.append(volume_trend)
        else:
            eng.append(0.0)
        
        # 13. High-Low range relative to close price
        avg_hl_range = np.mean(high_prices - low_prices) / max(np.mean(close_prices), 1e-8)
        eng.append(avg_hl_range)
        
        # 14. Trend consistency - proportion of days in same direction
        if len(close_prices) >= 5:
            price_changes = np.diff(close_prices[-5:])
            up_days = np.sum(price_changes > 0)
            down_days = np.sum(price_changes < 0)
            flat_days = np.sum(price_changes == 0)
            
            if up_days > down_days:
                trend_consistency = up_days / max(len(price_changes), 1e-8)
            elif down_days > up_days:
                trend_consistency = -down_days / max(len(price_changes), 1e-8)
            else:
                trend_consistency = 0.0
            eng.append(trend_consistency)
        else:
            eng.append(0.0)
        
        # 15. Short interest momentum (if we have previous data)
        if t > 0:
            si_change = (short_interest - data[t-1, 0]) / max(data[t-1, 0], 1e-8)
            eng.append(si_change)
        else:
            eng.append(0.0)
        
        # 16. VWAP (Volume-Weighted Average Price) approximation
        vwap = np.mean(close_prices)  # Simple approximation without actual volume data
        # Relative position of current price to VWAP
        vwap_position = (close_prices[-1] - vwap) / max(vwap, 1e-8)
        eng.append(vwap_position)
        
        # 17. Intraday volatility - average of daily high-low ranges
        intraday_vol = np.mean((high_prices - low_prices) / np.maximum(open_prices, 1e-8))
        eng.append(intraday_vol)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent width
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        # Append to features list
        features.append(row)
    
    # Convert list to numpy array
    features = np.array(features, dtype=np.float32)
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
============================================================

ITERATION 3:
Performance: MAPE = 7.73%
Improvement: -0.81%
Features: 20
----------------------------------------
def construct_features(data):
    """
    Constructs features for short interest prediction from equity time series data.
    
    Args:
        data: numpy array of shape (lookback_window, 62)
        
    Returns:
        numpy array of shape (lookback_window, MAX_TOTAL)
    """
    # Constants
    RAW_DIM = 62
    MAX_TOTAL = 20
    
    lookback_window = data.shape[0]
    features = []
    
    for t in range(lookback_window):
        # Extract raw data for this timestep
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep essential raw features based on importance analysis
        # Always keep short interest as it's our target-related feature
        raw_keep = [short_interest]
        
        # Add volume as it showed high importance in previous iterations
        raw_keep.append(avg_volume)
        
        # Add last day's close price (most recent price point)
        raw_keep.append(close_prices[-1])
        
        # Add last day's high and low to capture recent price range
        raw_keep.append(high_prices[-1])
        raw_keep.append(low_prices[-1])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Initialize engineered features list
        eng = []
        
        # 1. Short interest to volume ratio - consistently high importance
        si_volume_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_volume_ratio)
        
        # 2. Price volatility - standard deviation of returns (normalized by price)
        # More stable than raw volatility and captures relative price movement
        if len(close_prices) >= 2:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            volatility = np.std(daily_returns) if len(daily_returns) > 0 else 0.0
            eng.append(volatility)
        else:
            eng.append(0.0)
        
        # 3. Normalized price position within recent range (price momentum indicator)
        # Shows where current price is within its recent trading range
        if len(high_prices) > 0 and len(low_prices) > 0:
            max_price = np.max(high_prices)
            min_price = np.min(low_prices)
            price_range = max_price - min_price
            if price_range > 1e-8:
                price_position = (close_prices[-1] - min_price) / price_range
                eng.append(price_position)
            else:
                eng.append(0.5)
        else:
            eng.append(0.5)
        
        # 4. RSI (Relative Strength Index) - momentum indicator
        # Captures overbought/oversold conditions that may correlate with short interest
        if len(close_prices) >= 2:
            price_diffs = np.diff(close_prices)
            gains = np.maximum(price_diffs, 0)
            losses = np.maximum(-price_diffs, 0)
            avg_gain = np.mean(gains) if len(gains) > 0 else 0.0
            avg_loss = np.mean(losses) if len(losses) > 0 else 0.0
            
            if avg_loss > 1e-8:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))
            else:
                rsi = 100.0 if avg_gain > 0 else 50.0
            # Normalize to [0,1]
            norm_rsi = rsi / 100.0
            eng.append(norm_rsi)
        else:
            eng.append(0.5)
        
        # 5. Short interest momentum (if we have previous data)
        # Captures trend in short interest which may be predictive
        if t > 0:
            si_change = (short_interest - data[t-1, 0]) / max(data[t-1, 0], 1e-8)
            eng.append(si_change)
        else:
            eng.append(0.0)
        
        # 6. Volume-weighted price trend
        # Captures price movement with volume confirmation
        if len(close_prices) >= 2 and avg_volume > 0:
            price_changes = np.diff(close_prices)
            avg_price = np.mean(close_prices)
            norm_price_changes = price_changes / max(avg_price, 1e-8)
            vw_trend = np.mean(norm_price_changes) * np.log1p(avg_volume)  # Log transform reduces outlier impact
            vw_trend = np.tanh(vw_trend)  # Squash to [-1, 1]
            eng.append(vw_trend)
        else:
            eng.append(0.0)
        
        # 7. Bollinger Band width - volatility measure
        # Captures expanding/contracting volatility which may precede short interest changes
        if len(close_prices) >= 5:
            sma = np.mean(close_prices[-5:])
            std = np.std(close_prices[-5:])
            bb_width = (2 * std) / max(sma, 1e-8)
            eng.append(bb_width)
        else:
            eng.append(0.0)
        
        # 8. Price acceleration - rate of change of momentum
        # Second derivative of price that may indicate trend strength/weakness
        if len(close_prices) >= 10:
            momentum_5d_recent = (close_prices[-1] - close_prices[-5]) / max(close_prices[-5], 1e-8)
            momentum_5d_earlier = (close_prices[-6] - close_prices[-10]) / max(close_prices[-10], 1e-8)
            acceleration = momentum_5d_recent - momentum_5d_earlier
            eng.append(acceleration)
        else:
            eng.append(0.0)
        
        # 9. Intraday volatility - average of daily high-low ranges
        # Captures intraday price action that may correlate with short selling activity
        intraday_vol = np.mean((high_prices - low_prices) / np.maximum(open_prices, 1e-8))
        eng.append(intraday_vol)
        
        # 10. Gap analysis - average overnight gap
        # Captures overnight sentiment shifts that may correlate with short interest
        if len(open_prices) >= 2 and len(close_prices) >= 2:
            overnight_gaps = open_prices[1:] - close_prices[:-1]
            avg_gap = np.mean(overnight_gaps) / max(np.mean(close_prices[:-1]), 1e-8)
            eng.append(avg_gap)
        else:
            eng.append(0.0)
        
        # 11. Trend consistency - proportion of days in same direction
        # Captures strength and consistency of price trend
        if len(close_prices) >= 5:
            price_changes = np.diff(close_prices[-5:])
            up_days = np.sum(price_changes > 0)
            down_days = np.sum(price_changes < 0)
            
            if up_days + down_days > 0:
                trend_consistency = (up_days - down_days) / (up_days + down_days)
            else:
                trend_consistency = 0.0
            eng.append(trend_consistency)
        else:
            eng.append(0.0)
        
        # 12. Short interest to price ratio
        # Captures relationship between short interest and price level
        si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
        eng.append(si_price_ratio)
        
        # 13. Normalized volume - volume relative to its recent average
        # Captures unusual volume that may indicate increased short selling
        if t > 0:
            prev_volumes = [data[max(0, t-i), 1] for i in range(1, min(t+1, 5))]
            if prev_volumes:
                avg_prev_volume = np.mean(prev_volumes)
                norm_volume = avg_volume / max(avg_prev_volume, 1e-8)
                eng.append(norm_volume)
            else:
                eng.append(1.0)
        else:
            eng.append(1.0)
        
        # 14. Price range expansion/contraction
        # Captures changing market conditions that may affect short interest
        if t > 0 and len(high_prices) > 0 and len(low_prices) > 0:
            curr_range = np.max(high_prices) - np.min(low_prices)
            prev_ohlc = data[t-1, 2:].reshape(15, 4)
            prev_high, prev_low = prev_ohlc[:, 1], prev_ohlc[:, 2]
            prev_range = np.max(prev_high) - np.min(prev_low)
            range_change = curr_range / max(prev_range, 1e-8) - 1
            eng.append(range_change)
        else:
            eng.append(0.0)
        
        # 15. Exponential price trend
        # Gives more weight to recent price movements
        if len(close_prices) >= 5:
            weights = np.exp(np.linspace(0, 1, 5))
            weights = weights / np.sum(weights)
            exp_trend = np.sum(weights * close_prices[-5:]) / max(close_prices[-5], 1e-8) - 1
            eng.append(exp_trend)
        else:
            eng.append(0.0)
        
        # Ensure we don't exceed MAX_NEW
        eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to ensure consistent width
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        # Append to features list
        features.append(row)
    
    # Convert list to numpy array
    features = np.array(features, dtype=np.float32)
    
    # Handle NaN, inf values
    features = np.nan_to_num(features, nan=0.0, posinf=0.0, neginf=0.0)
    
    return features
============================================================
