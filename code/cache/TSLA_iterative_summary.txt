============================================================
ITERATIVE AGENT-BASED FEATURE SELECTION SUMMARY
============================================================
Stock: TSLA
Date: 2025-10-03 17:44:05
Total Iterations: 5

PERFORMANCE TREND:
----------------------------------------
Iteration 0: Baseline - MAPE: 8.33% (Baseline)
Iteration 1: Iteration 1 - MAPE: 10.23% (-1.90%)
Iteration 2: Iteration 2 - MAPE: 8.91% (-0.58%)
Iteration 3: Iteration 3 - MAPE: 10.11% (-1.78%)
Iteration 4: Iteration 4 - MAPE: 12.37% (-4.04%)
Iteration 5: Iteration 5 - MAPE: 8.36% (-0.04%)

Best Model: Baseline - MAPE: 8.33%

============================================================
FEATURE ENGINEERING CODES
============================================================

ITERATION 1:
Performance: MAPE = 10.23%
Improvement: -1.90%
Features: 80
----------------------------------------
def construct_features(data):
    RAW_DIM = 62
    MAX_TOTAL = 80
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        raw_keep.extend([short_interest, avg_volume])
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last day)
        raw_keep.extend([open_prices[-1], high_prices[-1], low_prices[-1], close_prices[-1]])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # Price-based features
        
        # 1. Recent price changes (returns)
        if len(close_prices) > 1:
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            # 1-day return
            eng.append(daily_returns[-1])
            # 3-day return
            eng.append(np.sum(daily_returns[-3:]) if len(daily_returns) >= 3 else 0)
            # 5-day return
            eng.append(np.sum(daily_returns[-5:]) if len(daily_returns) >= 5 else 0)
            # 15-day return
            eng.append(np.sum(daily_returns) if len(daily_returns) >= 1 else 0)
        else:
            eng.extend([0, 0, 0, 0])  # Placeholders if not enough data
        
        # 2. Volatility measures
        if len(close_prices) > 1:
            # Daily volatility (std of returns)
            eng.append(np.std(daily_returns) if len(daily_returns) > 1 else 0)
            # Normalized range
            high_low_range = np.mean((high_prices - low_prices) / np.maximum(close_prices, 1e-8))
            eng.append(high_low_range)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 3. Moving averages and crossovers
        if len(close_prices) >= 5:
            sma5 = np.mean(close_prices[-5:])
            eng.append(sma5)
            # Price to SMA5 ratio
            eng.append(close_prices[-1] / max(sma5, 1e-8))
        else:
            eng.extend([0, 0])  # Placeholders
            
        if len(close_prices) >= 10:
            sma10 = np.mean(close_prices[-10:])
            eng.append(sma10)
            # SMA5 to SMA10 ratio (momentum indicator)
            sma5 = np.mean(close_prices[-5:])
            eng.append(sma5 / max(sma10, 1e-8))
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 4. RSI (Relative Strength Index)
        if len(daily_returns) >= 14:
            gains = np.maximum(daily_returns, 0)
            losses = np.maximum(-daily_returns, 0)
            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
        else:
            eng.append(50)  # Default RSI value
        
        # 5. Volume-based features
        # Volume to price ratio
        eng.append(avg_volume / max(close_prices[-1], 1e-8))
        
        # Short interest to volume ratio
        eng.append(short_interest / max(avg_volume, 1e-8))
        
        # 6. Price patterns
        if len(close_prices) >= 3:
            # Candlestick body size (normalized)
            body_sizes = np.abs(close_prices - open_prices) / np.maximum(open_prices, 1e-8)
            eng.append(np.mean(body_sizes[-3:]))
            
            # Upper shadow size (normalized)
            upper_shadows = (high_prices - np.maximum(open_prices, close_prices)) / np.maximum(open_prices, 1e-8)
            eng.append(np.mean(upper_shadows[-3:]))
            
            # Lower shadow size (normalized)
            lower_shadows = (np.minimum(open_prices, close_prices) - low_prices) / np.maximum(open_prices, 1e-8)
            eng.append(np.mean(lower_shadows[-3:]))
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 7. Trend strength indicators
        if len(close_prices) >= 10:
            # ADX-like trend strength (simplified)
            dx_values = []
            for i in range(1, min(10, len(close_prices))):
                plus_dm = max(0, high_prices[i] - high_prices[i-1])
                minus_dm = max(0, low_prices[i-1] - low_prices[i])
                tr = max(high_prices[i] - low_prices[i], 
                         abs(high_prices[i] - close_prices[i-1]),
                         abs(low_prices[i] - close_prices[i-1]))
                plus_di = plus_dm / max(tr, 1e-8)
                minus_di = minus_dm / max(tr, 1e-8)
                dx = 100 * abs(plus_di - minus_di) / max(plus_di + minus_di, 1e-8)
                dx_values.append(dx)
            eng.append(np.mean(dx_values) if dx_values else 0)
        else:
            eng.append(0)  # Placeholder
        
        # 8. Gap analysis
        if len(close_prices) >= 2:
            # Overnight gaps
            gaps = open_prices[1:] - close_prices[:-1]
            normalized_gaps = gaps / np.maximum(close_prices[:-1], 1e-8)
            eng.append(np.mean(normalized_gaps) if len(normalized_gaps) > 0 else 0)
        else:
            eng.append(0)  # Placeholder
        
        # 9. Price acceleration
        if len(daily_returns) >= 3:
            # Second derivative of price (acceleration)
            acceleration = np.diff(daily_returns)
            eng.append(np.mean(acceleration[-2:]) if len(acceleration) >= 2 else 0)
        else:
            eng.append(0)  # Placeholder
        
        # 10. Short interest momentum
        if t > 0:
            prev_short_interest = data[t-1, 0]
            short_interest_change = (short_interest - prev_short_interest) / max(prev_short_interest, 1e-8)
            eng.append(short_interest_change)
        else:
            eng.append(0)  # Placeholder
        
        # Ensure we don't exceed MAX_NEW features
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Stack all rows and handle NaN values
    result_array = np.stack(result)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
============================================================

ITERATION 2:
Performance: MAPE = 8.91%
Improvement: -0.58%
Features: 80
----------------------------------------
def construct_features(data):
    RAW_DIM = 62
    MAX_TOTAL = 80
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (highest importance in baseline)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        raw_keep.extend([short_interest, avg_volume])
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last 3 days)
        # This was shown to be important in feature importance analysis
        if len(close_prices) >= 3:
            raw_keep.extend(open_prices[-3:].tolist())
            raw_keep.extend(high_prices[-3:].tolist())
            raw_keep.extend(low_prices[-3:].tolist())
            raw_keep.extend(close_prices[-3:].tolist())
        else:
            # Pad with zeros if not enough data
            padding_needed = 12 - (len(close_prices) * 4)
            raw_keep.extend(open_prices.tolist())
            raw_keep.extend(high_prices.tolist())
            raw_keep.extend(low_prices.tolist())
            raw_keep.extend(close_prices.tolist())
            raw_keep.extend([0] * padding_needed)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short interest relative metrics (focus on the target variable)
        # Short interest to volume ratio (key relationship)
        si_vol_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_vol_ratio)
        
        # Short interest momentum (change from previous period)
        if t > 0:
            prev_short_interest = data[t-1, 0]
            si_change = (short_interest - prev_short_interest) / max(prev_short_interest, 1e-8)
            eng.append(si_change)
            
            # Short interest acceleration (second derivative)
            if t > 1:
                prev_prev_short_interest = data[t-2, 0]
                prev_si_change = (prev_short_interest - prev_prev_short_interest) / max(prev_prev_short_interest, 1e-8)
                si_acceleration = si_change - prev_si_change
                eng.append(si_acceleration)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 2. Price-based features with focus on recent price action
        if len(close_prices) > 1:
            # Daily returns (more granular than previous implementation)
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Most recent return (1-day)
            eng.append(daily_returns[-1] if len(daily_returns) > 0 else 0)
            
            # 3-day cumulative return
            eng.append(np.sum(daily_returns[-3:]) if len(daily_returns) >= 3 else np.sum(daily_returns))
            
            # 5-day cumulative return
            eng.append(np.sum(daily_returns[-5:]) if len(daily_returns) >= 5 else np.sum(daily_returns))
            
            # Return volatility (standard deviation)
            eng.append(np.std(daily_returns) if len(daily_returns) > 1 else 0)
        else:
            eng.extend([0, 0, 0, 0])  # Placeholders
        
        # 3. Price range and volatility metrics
        if len(close_prices) >= 3:
            # True Range (TR) - captures volatility
            tr_values = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            # Average True Range (ATR) - normalized by price
            atr = np.mean(tr_values) / max(np.mean(close_prices[-3:]), 1e-8)
            eng.append(atr)
            
            # Normalized price range (high-low spread)
            norm_range = np.mean((high_prices[-3:] - low_prices[-3:]) / np.maximum(close_prices[-3:], 1e-8))
            eng.append(norm_range)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 4. Moving averages and trend indicators
        if len(close_prices) >= 5:
            # 5-day SMA
            sma5 = np.mean(close_prices[-5:])
            # Price to SMA ratio (momentum indicator)
            price_to_sma5 = close_prices[-1] / max(sma5, 1e-8)
            eng.append(price_to_sma5)
            
            if len(close_prices) >= 10:
                # 10-day SMA
                sma10 = np.mean(close_prices[-10:])
                # SMA crossover indicator (trend signal)
                sma_crossover = sma5 / max(sma10, 1e-8) - 1
                eng.append(sma_crossover)
                
                # Price trend strength
                price_trend = (close_prices[-1] - close_prices[-10]) / max(close_prices[-10], 1e-8)
                eng.append(price_trend)
            else:
                eng.extend([0, 0])  # Placeholders
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 5. RSI (Relative Strength Index) - improved implementation
        if len(daily_returns) >= 14:
            gains = np.maximum(daily_returns, 0)
            losses = np.maximum(-daily_returns, 0)
            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
            
            # RSI momentum (change in RSI)
            if len(daily_returns) >= 15:
                prev_gains = np.maximum(daily_returns[:-1], 0)
                prev_losses = np.maximum(-daily_returns[:-1], 0)
                prev_avg_gain = np.mean(prev_gains[-14:])
                prev_avg_loss = np.mean(prev_losses[-14:])
                prev_rs = prev_avg_gain / max(prev_avg_loss, 1e-8)
                prev_rsi = 100 - (100 / (1 + prev_rs))
                rsi_momentum = rsi - prev_rsi
                eng.append(rsi_momentum)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([50, 0])  # Default RSI value and placeholder
        
        # 6. Volume analysis
        # Volume trend (normalized)
        if t > 0:
            prev_avg_volume = data[t-1, 1]
            volume_change = (avg_volume - prev_avg_volume) / max(prev_avg_volume, 1e-8)
            eng.append(volume_change)
            
            # Volume to price ratio change
            if len(close_prices) > 0:
                vol_price_ratio = avg_volume / max(close_prices[-1], 1e-8)
                if t > 1 and len(data[t-1, 2:].reshape(15, 4)[:, 3]) > 0:
                    prev_close = data[t-1, 2:].reshape(15, 4)[:, 3][-1]
                    prev_vol_price_ratio = prev_avg_volume / max(prev_close, 1e-8)
                    vol_price_ratio_change = vol_price_ratio / max(prev_vol_price_ratio, 1e-8) - 1
                    eng.append(vol_price_ratio_change)
                else:
                    eng.append(0)  # Placeholder
            else:
                eng.extend([0])  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 7. Candlestick patterns and price formations
        if len(close_prices) >= 3:
            # Body sizes (absolute and relative to range)
            body_sizes = np.abs(close_prices[-3:] - open_prices[-3:])
            ranges = high_prices[-3:] - low_prices[-3:]
            body_to_range = np.mean(body_sizes / np.maximum(ranges, 1e-8))
            eng.append(body_to_range)
            
            # Doji pattern detection (small body relative to range)
            doji_indicator = 1 if body_to_range < 0.3 else 0
            eng.append(doji_indicator)
            
            # Hammer/Shooting Star detection (long lower/upper shadow)
            upper_shadows = high_prices[-1] - max(open_prices[-1], close_prices[-1])
            lower_shadows = min(open_prices[-1], close_prices[-1]) - low_prices[-1]
            total_range = high_prices[-1] - low_prices[-1]
            
            hammer_indicator = 1 if (lower_shadows / max(total_range, 1e-8) > 0.6 and 
                                     body_sizes[-1] / max(total_range, 1e-8) < 0.3) else 0
            eng.append(hammer_indicator)
            
            shooting_star = 1 if (upper_shadows / max(total_range, 1e-8) > 0.6 and 
                                  body_sizes[-1] / max(total_range, 1e-8) < 0.3) else 0
            eng.append(shooting_star)
        else:
            eng.extend([0, 0, 0, 0])  # Placeholders
        
        # 8. Gap analysis (improved)
        if len(close_prices) >= 2:
            # Overnight gaps
            gaps = open_prices[1:] - close_prices[:-1]
            normalized_gaps = gaps / np.maximum(close_prices[:-1], 1e-8)
            
            # Recent gap
            recent_gap = normalized_gaps[-1] if len(normalized_gaps) > 0 else 0
            eng.append(recent_gap)
            
            # Gap volatility
            gap_volatility = np.std(normalized_gaps) if len(normalized_gaps) > 1 else 0
            eng.append(gap_volatility)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 9. Price acceleration and momentum
        if len(daily_returns) >= 3:
            # Second derivative of price (acceleration)
            acceleration = np.diff(daily_returns)
            recent_acceleration = acceleration[-1] if len(acceleration) > 0 else 0
            eng.append(recent_acceleration)
            
            # MACD-like indicator (difference between fast and slow MA)
            if len(close_prices) >= 12:
                ema5 = np.mean(close_prices[-5:])  # Simple approximation of EMA
                ema12 = np.mean(close_prices[-12:])
                macd = (ema5 / max(ema12, 1e-8)) - 1
                eng.append(macd)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 10. Bollinger Bands
        if len(close_prices) >= 10:
            sma20 = np.mean(close_prices[-10:])  # Using 10 instead of 20 due to data constraints
            std20 = np.std(close_prices[-10:])
            
            # %B indicator (position within Bollinger Bands)
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            percent_b = (close_prices[-1] - lower_band) / max((upper_band - lower_band), 1e-8)
            eng.append(percent_b)
            
            # Bollinger Band width (volatility indicator)
            bb_width = (upper_band - lower_band) / max(sma20, 1e-8)
            eng.append(bb_width)
        else:
            eng.extend([0.5, 0])  # Default %B is 0.5 (middle of the band)
        
        # 11. Short interest to price relationship
        if len(close_prices) > 0:
            # Short interest to price ratio
            si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
            eng.append(si_price_ratio)
            
            # Short interest to price volatility ratio
            if len(daily_returns) > 1:
                price_volatility = np.std(daily_returns)
                si_vol_ratio = short_interest / max(price_volatility * 100, 1e-8)  # Scaled for numerical stability
                eng.append(si_vol_ratio)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # Ensure we don't exceed MAX_NEW features
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Stack all rows and handle NaN values
    result_array = np.stack(result)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
============================================================

ITERATION 3:
Performance: MAPE = 10.11%
Improvement: -1.78%
Features: 80
----------------------------------------
def construct_features(data):
    RAW_DIM = 62
    MAX_TOTAL = 80
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (consistently important)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        raw_keep.extend([short_interest, avg_volume])
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last 5 days)
        # Based on feature importance analysis showing recent price data matters most
        if len(close_prices) >= 5:
            raw_keep.extend(close_prices[-5:].tolist())  # Last 5 closes
            raw_keep.append(open_prices[-1])  # Most recent open
            raw_keep.append(high_prices[-1])  # Most recent high
            raw_keep.append(low_prices[-1])   # Most recent low
        else:
            # Pad with zeros if not enough data
            padding_needed = 8 - len(close_prices)
            raw_keep.extend(close_prices.tolist())
            if len(open_prices) > 0:
                raw_keep.append(open_prices[-1])
            else:
                raw_keep.append(0)
            if len(high_prices) > 0:
                raw_keep.append(high_prices[-1])
            else:
                raw_keep.append(0)
            if len(low_prices) > 0:
                raw_keep.append(low_prices[-1])
            else:
                raw_keep.append(0)
            raw_keep.extend([0] * padding_needed)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short interest relative metrics (focus on target variable)
        # Short interest to volume ratio (key relationship that showed high importance)
        si_vol_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_vol_ratio)
        
        # Short interest momentum (change from previous period)
        if t > 0:
            prev_short_interest = data[t-1, 0]
            si_change = (short_interest - prev_short_interest) / max(prev_short_interest, 1e-8)
            eng.append(si_change)
            
            # Short interest acceleration (second derivative)
            if t > 1:
                prev_prev_short_interest = data[t-2, 0]
                prev_si_change = (prev_short_interest - prev_prev_short_interest) / max(prev_prev_short_interest, 1e-8)
                si_acceleration = si_change - prev_si_change
                eng.append(si_acceleration)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 2. Price-based features with focus on recent price action
        if len(close_prices) > 1:
            # Daily returns (more granular than previous implementation)
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Most recent return (1-day)
            eng.append(daily_returns[-1] if len(daily_returns) > 0 else 0)
            
            # 3-day cumulative return
            cum_ret_3d = np.sum(daily_returns[-3:]) if len(daily_returns) >= 3 else np.sum(daily_returns)
            eng.append(cum_ret_3d)
            
            # 7-day cumulative return
            cum_ret_7d = np.sum(daily_returns[-7:]) if len(daily_returns) >= 7 else np.sum(daily_returns)
            eng.append(cum_ret_7d)
            
            # Return volatility (standard deviation) - showed high importance
            ret_vol = np.std(daily_returns) if len(daily_returns) > 1 else 0
            eng.append(ret_vol)
            
            # Skewness of returns (asymmetry measure)
            if len(daily_returns) >= 3:
                mean_ret = np.mean(daily_returns)
                skew_numerator = np.mean((daily_returns - mean_ret) ** 3)
                skew_denominator = max(np.std(daily_returns) ** 3, 1e-8)
                skewness = skew_numerator / skew_denominator
                eng.append(skewness)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0, 0, 0])  # Placeholders
        
        # 3. Price range and volatility metrics
        if len(close_prices) >= 3:
            # True Range (TR) - captures volatility
            tr_values = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            # Average True Range (ATR) - normalized by price
            atr = np.mean(tr_values) / max(np.mean(close_prices[-3:]), 1e-8)
            eng.append(atr)
            
            # ATR to short interest ratio (volatility relative to short interest)
            atr_si_ratio = atr / max(short_interest, 1e-8)
            eng.append(atr_si_ratio)
            
            # Normalized price range (high-low spread)
            norm_range = np.mean((high_prices[-3:] - low_prices[-3:]) / np.maximum(close_prices[-3:], 1e-8))
            eng.append(norm_range)
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 4. Moving averages and trend indicators
        if len(close_prices) >= 5:
            # 5-day SMA
            sma5 = np.mean(close_prices[-5:])
            # Price to SMA ratio (momentum indicator)
            price_to_sma5 = close_prices[-1] / max(sma5, 1e-8)
            eng.append(price_to_sma5)
            
            if len(close_prices) >= 10:
                # 10-day SMA
                sma10 = np.mean(close_prices[-10:])
                # SMA crossover indicator (trend signal)
                sma_crossover = sma5 / max(sma10, 1e-8) - 1
                eng.append(sma_crossover)
                
                # Price trend strength
                price_trend = (close_prices[-1] - close_prices[-10]) / max(close_prices[-10], 1e-8)
                eng.append(price_trend)
                
                # Trend consistency (sign of daily returns)
                if len(daily_returns) >= 5:
                    # Count consecutive positive/negative days
                    pos_days = np.sum(daily_returns[-5:] > 0)
                    neg_days = np.sum(daily_returns[-5:] < 0)
                    trend_consistency = (pos_days - neg_days) / 5  # Ranges from -1 to 1
                    eng.append(trend_consistency)
                else:
                    eng.append(0)  # Placeholder
            else:
                eng.extend([0, 0, 0])  # Placeholders
        else:
            eng.extend([0, 0, 0, 0])  # Placeholders
        
        # 5. RSI (Relative Strength Index) - improved implementation
        if len(daily_returns) >= 14:
            gains = np.maximum(daily_returns, 0)
            losses = np.maximum(-daily_returns, 0)
            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
            
            # RSI extremes (overbought/oversold indicator)
            rsi_extreme = 0
            if rsi > 70:  # Overbought
                rsi_extreme = 1
            elif rsi < 30:  # Oversold
                rsi_extreme = -1
            eng.append(rsi_extreme)
            
            # RSI momentum (change in RSI)
            if len(daily_returns) >= 15:
                prev_gains = np.maximum(daily_returns[:-1], 0)
                prev_losses = np.maximum(-daily_returns[:-1], 0)
                prev_avg_gain = np.mean(prev_gains[-14:])
                prev_avg_loss = np.mean(prev_losses[-14:])
                prev_rs = prev_avg_gain / max(prev_avg_loss, 1e-8)
                prev_rsi = 100 - (100 / (1 + prev_rs))
                rsi_momentum = rsi - prev_rsi
                eng.append(rsi_momentum)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([50, 0, 0])  # Default RSI value and placeholders
        
        # 6. Volume analysis - showed high importance in previous iterations
        # Volume trend (normalized)
        if t > 0:
            prev_avg_volume = data[t-1, 1]
            volume_change = (avg_volume - prev_avg_volume) / max(prev_avg_volume, 1e-8)
            eng.append(volume_change)
            
            # Volume acceleration
            if t > 1:
                prev_prev_avg_volume = data[t-2, 1]
                prev_volume_change = (prev_avg_volume - prev_prev_avg_volume) / max(prev_prev_avg_volume, 1e-8)
                volume_acceleration = volume_change - prev_volume_change
                eng.append(volume_acceleration)
            else:
                eng.append(0)  # Placeholder
            
            # Volume to price ratio change
            if len(close_prices) > 0:
                vol_price_ratio = avg_volume / max(close_prices[-1], 1e-8)
                if t > 1 and len(data[t-1, 2:].reshape(15, 4)[:, 3]) > 0:
                    prev_close = data[t-1, 2:].reshape(15, 4)[:, 3][-1]
                    prev_vol_price_ratio = prev_avg_volume / max(prev_close, 1e-8)
                    vol_price_ratio_change = vol_price_ratio / max(prev_vol_price_ratio, 1e-8) - 1
                    eng.append(vol_price_ratio_change)
                else:
                    eng.append(0)  # Placeholder
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 7. Candlestick patterns and price formations
        if len(close_prices) >= 3:
            # Body sizes (absolute and relative to range)
            body_sizes = np.abs(close_prices[-3:] - open_prices[-3:])
            ranges = high_prices[-3:] - low_prices[-3:]
            body_to_range = np.mean(body_sizes / np.maximum(ranges, 1e-8))
            eng.append(body_to_range)
            
            # Doji pattern detection (small body relative to range)
            doji_indicator = 1 if body_to_range < 0.3 else 0
            eng.append(doji_indicator)
            
            # Hammer/Shooting Star detection (long lower/upper shadow)
            upper_shadows = high_prices[-1] - max(open_prices[-1], close_prices[-1])
            lower_shadows = min(open_prices[-1], close_prices[-1]) - low_prices[-1]
            total_range = high_prices[-1] - low_prices[-1]
            
            hammer_indicator = 1 if (lower_shadows / max(total_range, 1e-8) > 0.6 and 
                                     body_sizes[-1] / max(total_range, 1e-8) < 0.3) else 0
            eng.append(hammer_indicator)
            
            shooting_star = 1 if (upper_shadows / max(total_range, 1e-8) > 0.6 and 
                                  body_sizes[-1] / max(total_range, 1e-8) < 0.3) else 0
            eng.append(shooting_star)
            
            # Engulfing pattern (bullish or bearish)
            if len(close_prices) >= 4 and len(open_prices) >= 4:
                prev_body_size = abs(close_prices[-2] - open_prices[-2])
                curr_body_size = abs(close_prices[-1] - open_prices[-1])
                
                # Bullish engulfing
                bullish_engulfing = 1 if (close_prices[-2] < open_prices[-2] and  # Previous bearish
                                         close_prices[-1] > open_prices[-1] and   # Current bullish
                                         curr_body_size > prev_body_size and      # Current engulfs previous
                                         close_prices[-1] > open_prices[-2] and   # Close above previous open
                                         open_prices[-1] < close_prices[-2]) else 0  # Open below previous close
                
                # Bearish engulfing
                bearish_engulfing = 1 if (close_prices[-2] > open_prices[-2] and  # Previous bullish
                                         close_prices[-1] < open_prices[-1] and   # Current bearish
                                         curr_body_size > prev_body_size and      # Current engulfs previous
                                         close_prices[-1] < open_prices[-2] and   # Close below previous open
                                         open_prices[-1] > close_prices[-2]) else 0  # Open above previous close
                
                eng.append(bullish_engulfing - bearish_engulfing)  # Combined signal: +1 bullish, -1 bearish, 0 neither
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0, 0, 0])  # Placeholders
        
        # 8. Gap analysis (improved)
        if len(close_prices) >= 2 and len(open_prices) >= 2:
            # Overnight gaps
            gaps = open_prices[1:] - close_prices[:-1]
            normalized_gaps = gaps / np.maximum(close_prices[:-1], 1e-8)
            
            # Recent gap
            recent_gap = normalized_gaps[-1] if len(normalized_gaps) > 0 else 0
            eng.append(recent_gap)
            
            # Gap volatility
            gap_volatility = np.std(normalized_gaps) if len(normalized_gaps) > 1 else 0
            eng.append(gap_volatility)
            
            # Gap and go pattern (gap followed by continuation)
            if len(normalized_gaps) > 0 and len(daily_returns) > 0:
                # Positive gap followed by positive return or negative gap followed by negative return
                gap_continuation = 1 if (normalized_gaps[-1] > 0 and daily_returns[-1] > 0) or \
                                       (normalized_gaps[-1] < 0 and daily_returns[-1] < 0) else 0
                eng.append(gap_continuation)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 9. Price acceleration and momentum
        if len(daily_returns) >= 3:
            # Second derivative of price (acceleration)
            acceleration = np.diff(daily_returns)
            recent_acceleration = acceleration[-1] if len(acceleration) > 0 else 0
            eng.append(recent_acceleration)
            
            # MACD-like indicator (difference between fast and slow MA)
            if len(close_prices) >= 12:
                ema5 = np.mean(close_prices[-5:])  # Simple approximation of EMA
                ema12 = np.mean(close_prices[-12:])
                macd = (ema5 / max(ema12, 1e-8)) - 1
                eng.append(macd)
                
                # MACD signal line crossover
                if len(close_prices) >= 13:
                    prev_ema5 = np.mean(close_prices[-6:-1])
                    prev_ema12 = np.mean(close_prices[-13:-1])
                    prev_macd = (prev_ema5 / max(prev_ema12, 1e-8)) - 1
                    
                    # MACD momentum (change in MACD)
                    macd_momentum = macd - prev_macd
                    eng.append(macd_momentum)
                else:
                    eng.append(0)  # Placeholder
            else:
                eng.extend([0, 0])  # Placeholders
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 10. Bollinger Bands
        if len(close_prices) >= 10:
            sma20 = np.mean(close_prices[-10:])  # Using 10 instead of 20 due to data constraints
            std20 = np.std(close_prices[-10:])
            
            # %B indicator (position within Bollinger Bands)
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            percent_b = (close_prices[-1] - lower_band) / max((upper_band - lower_band), 1e-8)
            eng.append(percent_b)
            
            # Bollinger Band width (volatility indicator)
            bb_width = (upper_band - lower_band) / max(sma20, 1e-8)
            eng.append(bb_width)
            
            # Bollinger Band squeeze (narrowing bands)
            if len(close_prices) >= 15:
                prev_std = np.std(close_prices[-15:-5])
                prev_bb_width = (2 * prev_std) / max(np.mean(close_prices[-15:-5]), 1e-8)
                bb_squeeze = bb_width / max(prev_bb_width, 1e-8) - 1
                eng.append(bb_squeeze)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0.5, 0, 0])  # Default %B is 0.5 (middle of the band)
        
        # 11. Short interest to price relationship
        if len(close_prices) > 0:
            # Short interest to price ratio
            si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
            eng.append(si_price_ratio)
            
            # Short interest to price volatility ratio
            if len(daily_returns) > 1:
                price_volatility = np.std(daily_returns)
                si_vol_ratio = short_interest / max(price_volatility * 100, 1e-8)  # Scaled for numerical stability
                eng.append(si_vol_ratio)
            else:
                eng.append(0)  # Placeholder
            
            # Short interest to cumulative return ratio
            if len(daily_returns) >= 5:
                cum_ret_5d = np.sum(daily_returns[-5:])
                si_ret_ratio = short_interest / max(abs(cum_ret_5d) * 100, 1e-8)  # Scaled for numerical stability
                eng.append(si_ret_ratio)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 12. Mean reversion indicators
        if len(close_prices) >= 10:
            # Z-score (price deviation from mean)
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            z_score = (close_prices[-1] - mean_price) / max(std_price, 1e-8)
            eng.append(z_score)
            
            # Mean reversion potential (extreme z-score)
            mean_rev_potential = 0
            if z_score > 2:  # Significantly above mean
                mean_rev_potential = -1  # Potential downside reversion
            elif z_score < -2:  # Significantly below mean
                mean_rev_potential = 1  # Potential upside reversion
            eng.append(mean_rev_potential)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 13. Volatility regime
        if len(daily_returns) >= 10:
            # Current volatility vs historical
            recent_vol = np.std(daily_returns[-5:])
            historical_vol = np.std(daily_returns[-10:])
            vol_regime = recent_vol / max(historical_vol, 1e-8) - 1
            eng.append(vol_regime)
            
            # Volatility clustering (autocorrelation of absolute returns)
            abs_returns = np.abs(daily_returns)
            if len(abs_returns) >= 5:
                # Simple autocorrelation approximation
                lag1_corr = np.sum((abs_returns[1:] - np.mean(abs_returns)) * 
                                  (abs_returns[:-1] - np.mean(abs_returns))) / \
                           max(np.sum((abs_returns - np.mean(abs_returns))**2), 1e-8)
                eng.append(lag1_corr)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 14. Short squeeze potential indicators
        # Days to cover (short interest / daily volume)
        days_to_cover = short_interest / max(avg_volume, 1e-8)
        eng.append(days_to_cover)
        
        # Short squeeze pressure (days to cover * recent return)
        if len(daily_returns) > 0:
            squeeze_pressure = days_to_cover * max(daily_returns[-1], 0)  # Only positive returns create pressure
            eng.append(squeeze_pressure)
        else:
            eng.append(0)  # Placeholder
        
        # Ensure we don't exceed MAX_NEW features
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Stack all rows and handle NaN values
    result_array = np.stack(result)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
============================================================

ITERATION 4:
Performance: MAPE = 12.37%
Improvement: -4.04%
Features: 80
----------------------------------------
def construct_features(data):
    RAW_DIM = 62
    MAX_TOTAL = 80
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (consistently important)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        raw_keep.extend([short_interest, avg_volume])
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last 5 days)
        # Based on feature importance analysis showing recent price data matters most
        if len(close_prices) >= 5:
            raw_keep.extend(close_prices[-5:].tolist())  # Last 5 closes
            raw_keep.append(open_prices[-1])  # Most recent open
            raw_keep.append(high_prices[-1])  # Most recent high
            raw_keep.append(low_prices[-1])   # Most recent low
        else:
            # Pad with zeros if not enough data
            raw_keep.extend(close_prices.tolist())
            padding_needed = 5 - len(close_prices)
            raw_keep.extend([0] * padding_needed)
            
            if len(open_prices) > 0:
                raw_keep.append(open_prices[-1])
            else:
                raw_keep.append(0)
                
            if len(high_prices) > 0:
                raw_keep.append(high_prices[-1])
            else:
                raw_keep.append(0)
                
            if len(low_prices) > 0:
                raw_keep.append(low_prices[-1])
            else:
                raw_keep.append(0)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short interest relative metrics (focus on target variable)
        # Short interest to volume ratio (key relationship that showed high importance)
        si_vol_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_vol_ratio)
        
        # Days to cover (short interest / daily volume) - important for short squeeze potential
        days_to_cover = short_interest / max(avg_volume, 1e-8)
        eng.append(days_to_cover)
        
        # Short interest momentum (change from previous period)
        if t > 0:
            prev_short_interest = data[t-1, 0]
            si_change = (short_interest - prev_short_interest) / max(prev_short_interest, 1e-8)
            eng.append(si_change)
            
            # Short interest acceleration (second derivative)
            if t > 1:
                prev_prev_short_interest = data[t-2, 0]
                prev_si_change = (prev_short_interest - prev_prev_short_interest) / max(prev_prev_short_interest, 1e-8)
                si_acceleration = si_change - prev_si_change
                eng.append(si_acceleration)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 2. Price-based features with focus on recent price action
        if len(close_prices) > 1:
            # Daily returns (more granular than previous implementation)
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Most recent return (1-day)
            eng.append(daily_returns[-1] if len(daily_returns) > 0 else 0)
            
            # 3-day cumulative return
            cum_ret_3d = np.sum(daily_returns[-3:]) if len(daily_returns) >= 3 else np.sum(daily_returns)
            eng.append(cum_ret_3d)
            
            # Return volatility (standard deviation) - showed high importance
            ret_vol = np.std(daily_returns) if len(daily_returns) > 1 else 0
            eng.append(ret_vol)
            
            # Skewness of returns (asymmetry measure)
            if len(daily_returns) >= 3:
                mean_ret = np.mean(daily_returns)
                skew_numerator = np.mean((daily_returns - mean_ret) ** 3)
                skew_denominator = max(np.std(daily_returns) ** 3, 1e-8)
                skewness = skew_numerator / skew_denominator
                eng.append(skewness)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0, 0])  # Placeholders
        
        # 3. Price range and volatility metrics
        if len(close_prices) >= 3:
            # True Range (TR) - captures volatility
            tr_values = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            # Average True Range (ATR) - normalized by price
            atr = np.mean(tr_values) / max(np.mean(close_prices[-3:]), 1e-8)
            eng.append(atr)
            
            # ATR to short interest ratio (volatility relative to short interest)
            atr_si_ratio = atr / max(short_interest, 1e-8)
            eng.append(atr_si_ratio)
            
            # Normalized price range (high-low spread)
            norm_range = np.mean((high_prices[-3:] - low_prices[-3:]) / np.maximum(close_prices[-3:], 1e-8))
            eng.append(norm_range)
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 4. Moving averages and trend indicators
        if len(close_prices) >= 5:
            # 5-day SMA
            sma5 = np.mean(close_prices[-5:])
            # Price to SMA ratio (momentum indicator)
            price_to_sma5 = close_prices[-1] / max(sma5, 1e-8)
            eng.append(price_to_sma5)
            
            if len(close_prices) >= 10:
                # 10-day SMA
                sma10 = np.mean(close_prices[-10:])
                # SMA crossover indicator (trend signal)
                sma_crossover = sma5 / max(sma10, 1e-8) - 1
                eng.append(sma_crossover)
                
                # Price trend strength
                price_trend = (close_prices[-1] - close_prices[-10]) / max(close_prices[-10], 1e-8)
                eng.append(price_trend)
            else:
                eng.extend([0, 0])  # Placeholders
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 5. RSI (Relative Strength Index) - improved implementation
        if len(daily_returns) >= 14:
            gains = np.maximum(daily_returns, 0)
            losses = np.maximum(-daily_returns, 0)
            avg_gain = np.mean(gains[-14:])
            avg_loss = np.mean(losses[-14:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi)
            
            # RSI extremes (overbought/oversold indicator)
            rsi_extreme = 0
            if rsi > 70:  # Overbought
                rsi_extreme = 1
            elif rsi < 30:  # Oversold
                rsi_extreme = -1
            eng.append(rsi_extreme)
        else:
            eng.extend([50, 0])  # Default RSI value and placeholders
        
        # 6. Volume analysis - showed high importance in previous iterations
        # Volume trend (normalized)
        if t > 0:
            prev_avg_volume = data[t-1, 1]
            volume_change = (avg_volume - prev_avg_volume) / max(prev_avg_volume, 1e-8)
            eng.append(volume_change)
            
            # Volume acceleration
            if t > 1:
                prev_prev_avg_volume = data[t-2, 1]
                prev_volume_change = (prev_avg_volume - prev_prev_avg_volume) / max(prev_prev_avg_volume, 1e-8)
                volume_acceleration = volume_change - prev_volume_change
                eng.append(volume_acceleration)
            else:
                eng.append(0)  # Placeholder
            
            # Volume to price ratio change
            if len(close_prices) > 0:
                vol_price_ratio = avg_volume / max(close_prices[-1], 1e-8)
                if t > 1 and len(data[t-1, 2:].reshape(15, 4)[:, 3]) > 0:
                    prev_close = data[t-1, 2:].reshape(15, 4)[:, 3][-1]
                    prev_vol_price_ratio = prev_avg_volume / max(prev_close, 1e-8)
                    vol_price_ratio_change = vol_price_ratio / max(prev_vol_price_ratio, 1e-8) - 1
                    eng.append(vol_price_ratio_change)
                else:
                    eng.append(0)  # Placeholder
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 7. Bollinger Bands - simplified and focused on most important aspects
        if len(close_prices) >= 10:
            sma20 = np.mean(close_prices[-10:])  # Using 10 instead of 20 due to data constraints
            std20 = np.std(close_prices[-10:])
            
            # %B indicator (position within Bollinger Bands)
            upper_band = sma20 + (2 * std20)
            lower_band = sma20 - (2 * std20)
            percent_b = (close_prices[-1] - lower_band) / max((upper_band - lower_band), 1e-8)
            eng.append(percent_b)
            
            # Bollinger Band width (volatility indicator)
            bb_width = (upper_band - lower_band) / max(sma20, 1e-8)
            eng.append(bb_width)
        else:
            eng.extend([0.5, 0])  # Default %B is 0.5 (middle of the band)
        
        # 8. Short interest to price relationship
        if len(close_prices) > 0:
            # Short interest to price ratio
            si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
            eng.append(si_price_ratio)
            
            # Short interest to price volatility ratio
            if len(daily_returns) > 1:
                price_volatility = np.std(daily_returns)
                si_vol_ratio = short_interest / max(price_volatility * 100, 1e-8)  # Scaled for numerical stability
                eng.append(si_vol_ratio)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 9. Mean reversion indicators
        if len(close_prices) >= 10:
            # Z-score (price deviation from mean)
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            z_score = (close_prices[-1] - mean_price) / max(std_price, 1e-8)
            eng.append(z_score)
        else:
            eng.append(0)  # Placeholder
        
        # 10. Volatility regime
        if len(daily_returns) >= 10:
            # Current volatility vs historical
            recent_vol = np.std(daily_returns[-5:])
            historical_vol = np.std(daily_returns[-10:])
            vol_regime = recent_vol / max(historical_vol, 1e-8) - 1
            eng.append(vol_regime)
        else:
            eng.append(0)  # Placeholder
        
        # 11. Short squeeze potential indicators
        # Short squeeze pressure (days to cover * recent return)
        if len(daily_returns) > 0:
            squeeze_pressure = days_to_cover * max(daily_returns[-1], 0)  # Only positive returns create pressure
            eng.append(squeeze_pressure)
        else:
            eng.append(0)  # Placeholder
        
        # 12. New: Relative Volume Indicator
        # Compare current volume to historical average
        if t > 0 and len(data) > 5:
            historical_volumes = [data[max(0, t-i), 1] for i in range(1, min(6, t+1))]
            avg_historical_volume = np.mean(historical_volumes)
            relative_volume = avg_volume / max(avg_historical_volume, 1e-8)
            eng.append(relative_volume)
        else:
            eng.append(1.0)  # Default to neutral
        
        # 13. New: Short Interest Trend Strength
        # Measure consistency of short interest direction
        if t >= 3:
            si_values = [data[t-i, 0] for i in range(4)]
            si_changes = [si_values[i] - si_values[i+1] for i in range(3)]
            # Count consistent direction changes
            consistent_up = sum(1 for change in si_changes if change > 0)
            consistent_down = sum(1 for change in si_changes if change < 0)
            # Convert to a normalized indicator (-1 to 1)
            si_trend_strength = (consistent_up - consistent_down) / 3.0
            eng.append(si_trend_strength)
        else:
            eng.append(0)  # Placeholder
        
        # 14. New: Price Momentum Oscillator
        # Similar to Rate of Change but normalized
        if len(close_prices) >= 10:
            price_10d_ago = close_prices[-10]
            roc_10 = (close_prices[-1] / max(price_10d_ago, 1e-8)) - 1
            # Normalize to typical range
            norm_roc = min(max(roc_10 * 10, -1), 1)  # Scale and clamp to [-1, 1]
            eng.append(norm_roc)
        else:
            eng.append(0)  # Placeholder
        
        # 15. New: Short Interest to Float Ratio Proxy
        # We don't have float data, but can approximate using volume as proxy
        if len(close_prices) >= 10 and avg_volume > 0:
            # Use 10-day total volume as proxy for tradable float
            total_volume_proxy = avg_volume * 10
            si_float_ratio_proxy = short_interest / max(total_volume_proxy, 1e-8)
            eng.append(si_float_ratio_proxy)
        else:
            eng.append(0)  # Placeholder
        
        # 16. New: Short Interest Volatility
        # Measure how much short interest fluctuates
        if t >= 5:
            si_history = [data[t-i, 0] for i in range(5)]
            si_volatility = np.std(si_history) / max(np.mean(si_history), 1e-8)
            eng.append(si_volatility)
        else:
            eng.append(0)  # Placeholder
        
        # 17. New: Price-Volume Divergence
        # Detect when price and volume move in opposite directions
        if len(close_prices) >= 5 and t > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            prev_avg_volume = data[t-1, 1] if t > 0 else avg_volume
            volume_change = (avg_volume / max(prev_avg_volume, 1e-8)) - 1
            
            # Divergence occurs when signs differ
            divergence = 0
            if price_change > 0 and volume_change < 0:
                divergence = 1  # Bullish divergence
            elif price_change < 0 and volume_change > 0:
                divergence = -1  # Bearish divergence
            eng.append(divergence)
        else:
            eng.append(0)  # Placeholder
        
        # 18. New: Short Interest Reversal Signal
        # Detect potential reversals in short interest trend
        if t >= 3:
            si_values = [data[t-i, 0] for i in range(4)]
            # Check for pattern: 3 consistent moves followed by reversal
            consistent_up = all(si_values[i] > si_values[i+1] for i in range(2))
            consistent_down = all(si_values[i] < si_values[i+1] for i in range(2))
            
            reversal_signal = 0
            if consistent_up and si_values[0] < si_values[1]:
                reversal_signal = -1  # Uptrend potentially reversing down
            elif consistent_down and si_values[0] > si_values[1]:
                reversal_signal = 1  # Downtrend potentially reversing up
            eng.append(reversal_signal)
        else:
            eng.append(0)  # Placeholder
        
        # 19. New: Normalized Short Interest Change
        # Measure rate of change in short interest relative to its level
        if t > 0:
            prev_si = data[t-1, 0]
            norm_si_change = (short_interest - prev_si) / max(prev_si, 1e-8)
            # Scale to typical range
            norm_si_change = min(max(norm_si_change * 5, -1), 1)  # Scale and clamp
            eng.append(norm_si_change)
        else:
            eng.append(0)  # Placeholder
        
        # 20. New: Short Interest Acceleration Normalized
        # Second derivative of short interest, normalized
        if t > 1:
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            change_t = si_t - si_t1
            change_t1 = si_t1 - si_t2
            
            si_accel = change_t - change_t1
            norm_si_accel = si_accel / max(abs(si_t2), 1e-8)
            # Scale to typical range
            norm_si_accel = min(max(norm_si_accel * 10, -1), 1)  # Scale and clamp
            eng.append(norm_si_accel)
        else:
            eng.append(0)  # Placeholder
        
        # Ensure we don't exceed MAX_NEW features
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Stack all rows and handle NaN values
    result_array = np.stack(result)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
============================================================

ITERATION 5:
Performance: MAPE = 8.36%
Improvement: -0.04%
Features: 80
----------------------------------------
def construct_features(data):
    RAW_DIM = 62
    MAX_TOTAL = 80
    
    lookback_window = data.shape[0]
    result = []
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (consistently important)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        raw_keep.extend([short_interest, avg_volume])
        
        # Reshape OHLC data for easier access
        ohlc = data[t, 2:].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last 5 days)
        # Based on feature importance analysis showing recent price data matters most
        if len(close_prices) >= 5:
            raw_keep.extend(close_prices[-5:].tolist())  # Last 5 closes
            raw_keep.append(open_prices[-1])  # Most recent open
            raw_keep.append(high_prices[-1])  # Most recent high
            raw_keep.append(low_prices[-1])   # Most recent low
        else:
            # Pad with zeros if not enough data
            raw_keep.extend(close_prices.tolist())
            padding_needed = 5 - len(close_prices)
            raw_keep.extend([0] * padding_needed)
            raw_keep.append(open_prices[-1] if len(open_prices) > 0 else 0)
            raw_keep.append(high_prices[-1] if len(high_prices) > 0 else 0)
            raw_keep.append(low_prices[-1] if len(low_prices) > 0 else 0)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short interest relative metrics (focus on target variable)
        # Short interest to volume ratio (key relationship that showed high importance)
        si_vol_ratio = short_interest / max(avg_volume, 1e-8)
        eng.append(si_vol_ratio)
        
        # Days to cover (short interest / daily volume) - important for short squeeze potential
        days_to_cover = short_interest / max(avg_volume / 15, 1e-8)  # Adjusted to daily volume
        eng.append(days_to_cover)
        
        # Short interest momentum (change from previous period)
        si_change = 0
        if t > 0:
            prev_short_interest = data[t-1, 0]
            si_change = (short_interest - prev_short_interest) / max(prev_short_interest, 1e-8)
            eng.append(si_change)
        else:
            eng.append(0)  # Placeholder
        
        # 2. Price-based features with focus on recent price action
        if len(close_prices) > 1:
            # Daily returns (more granular than previous implementation)
            daily_returns = np.diff(close_prices) / np.maximum(close_prices[:-1], 1e-8)
            
            # Most recent return (1-day)
            latest_return = daily_returns[-1] if len(daily_returns) > 0 else 0
            eng.append(latest_return)
            
            # 3-day cumulative return
            cum_ret_3d = np.sum(daily_returns[-3:]) if len(daily_returns) >= 3 else np.sum(daily_returns)
            eng.append(cum_ret_3d)
            
            # Return volatility (standard deviation) - showed high importance
            ret_vol = np.std(daily_returns) if len(daily_returns) > 1 else 0
            eng.append(ret_vol)
        else:
            eng.extend([0, 0, 0])  # Placeholders
        
        # 3. Price range and volatility metrics
        if len(close_prices) >= 3:
            # True Range (TR) - captures volatility
            tr_values = []
            for i in range(1, len(close_prices)):
                high_low = high_prices[i] - low_prices[i]
                high_close = abs(high_prices[i] - close_prices[i-1])
                low_close = abs(low_prices[i] - close_prices[i-1])
                tr = max(high_low, high_close, low_close)
                tr_values.append(tr)
            
            # Average True Range (ATR) - normalized by price
            atr = np.mean(tr_values) / max(np.mean(close_prices[-3:]), 1e-8)
            eng.append(atr)
            
            # Normalized price range (high-low spread)
            norm_range = np.mean((high_prices[-3:] - low_prices[-3:]) / np.maximum(close_prices[-3:], 1e-8))
            eng.append(norm_range)
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 4. Moving averages and trend indicators
        if len(close_prices) >= 5:
            # 5-day SMA
            sma5 = np.mean(close_prices[-5:])
            # Price to SMA ratio (momentum indicator)
            price_to_sma5 = close_prices[-1] / max(sma5, 1e-8)
            eng.append(price_to_sma5)
            
            if len(close_prices) >= 10:
                # 10-day SMA
                sma10 = np.mean(close_prices[-10:])
                # SMA crossover indicator (trend signal)
                sma_crossover = sma5 / max(sma10, 1e-8) - 1
                eng.append(sma_crossover)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 5. RSI (Relative Strength Index) - improved implementation
        if len(daily_returns) >= 5:  # Reduced from 14 to 5 due to data constraints
            gains = np.maximum(daily_returns, 0)
            losses = np.maximum(-daily_returns, 0)
            avg_gain = np.mean(gains[-5:])
            avg_loss = np.mean(losses[-5:])
            rs = avg_gain / max(avg_loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
            eng.append(rsi / 100)  # Normalize to [0,1]
        else:
            eng.append(0.5)  # Default RSI value
        
        # 6. Volume analysis - showed high importance in previous iterations
        # Volume trend (normalized)
        if t > 0:
            prev_avg_volume = data[t-1, 1]
            volume_change = (avg_volume - prev_avg_volume) / max(prev_avg_volume, 1e-8)
            eng.append(volume_change)
            
            # Volume to price ratio
            if len(close_prices) > 0:
                vol_price_ratio = avg_volume / max(close_prices[-1], 1e-8)
                eng.append(vol_price_ratio)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.extend([0, 0])  # Placeholders
        
        # 7. Bollinger Bands - simplified and focused on most important aspects
        if len(close_prices) >= 10:
            sma10 = np.mean(close_prices[-10:])  # Using 10 instead of 20 due to data constraints
            std10 = np.std(close_prices[-10:])
            
            # %B indicator (position within Bollinger Bands)
            upper_band = sma10 + (2 * std10)
            lower_band = sma10 - (2 * std10)
            percent_b = (close_prices[-1] - lower_band) / max((upper_band - lower_band), 1e-8)
            eng.append(percent_b)
        else:
            eng.append(0.5)  # Default %B is 0.5 (middle of the band)
        
        # 8. Short interest to price relationship
        if len(close_prices) > 0:
            # Short interest to price ratio
            si_price_ratio = short_interest / max(close_prices[-1], 1e-8)
            eng.append(si_price_ratio)
        else:
            eng.append(0)  # Placeholder
        
        # 9. Mean reversion indicators
        if len(close_prices) >= 10:
            # Z-score (price deviation from mean)
            mean_price = np.mean(close_prices[-10:])
            std_price = np.std(close_prices[-10:])
            z_score = (close_prices[-1] - mean_price) / max(std_price, 1e-8)
            eng.append(z_score)
        else:
            eng.append(0)  # Placeholder
        
        # 10. Short squeeze potential indicators
        # Short squeeze pressure (days to cover * recent return)
        if len(daily_returns) > 0:
            squeeze_pressure = days_to_cover * max(latest_return, 0)  # Only positive returns create pressure
            eng.append(squeeze_pressure)
        else:
            eng.append(0)  # Placeholder
        
        # 11. Relative Volume Indicator
        # Compare current volume to historical average
        if t > 0 and t >= 5:
            historical_volumes = [data[max(0, t-i), 1] for i in range(1, min(6, t+1))]
            avg_historical_volume = np.mean(historical_volumes)
            relative_volume = avg_volume / max(avg_historical_volume, 1e-8)
            eng.append(relative_volume)
        else:
            eng.append(1.0)  # Default to neutral
        
        # 12. Short Interest Trend Strength
        # Measure consistency of short interest direction
        if t >= 3:
            si_values = [data[t-i, 0] for i in range(4)]
            si_changes = [si_values[i] - si_values[i+1] for i in range(3)]
            # Count consistent direction changes
            consistent_up = sum(1 for change in si_changes if change > 0)
            consistent_down = sum(1 for change in si_changes if change < 0)
            # Convert to a normalized indicator (-1 to 1)
            si_trend_strength = (consistent_up - consistent_down) / 3.0
            eng.append(si_trend_strength)
        else:
            eng.append(0)  # Placeholder
        
        # 13. Price Momentum Oscillator
        if len(close_prices) >= 10:
            price_10d_ago = close_prices[-10]
            roc_10 = (close_prices[-1] / max(price_10d_ago, 1e-8)) - 1
            # Normalize to typical range
            norm_roc = min(max(roc_10 * 5, -1), 1)  # Scale and clamp to [-1, 1]
            eng.append(norm_roc)
        else:
            eng.append(0)  # Placeholder
        
        # 14. Short Interest Volatility
        # Measure how much short interest fluctuates
        if t >= 3:
            si_history = [data[t-i, 0] for i in range(min(4, t+1))]
            si_volatility = np.std(si_history) / max(np.mean(si_history), 1e-8)
            eng.append(si_volatility)
        else:
            eng.append(0)  # Placeholder
        
        # 15. Price-Volume Divergence
        # Detect when price and volume move in opposite directions
        if len(close_prices) >= 5 and t > 0:
            price_change = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            prev_avg_volume = data[t-1, 1]
            volume_change = (avg_volume / max(prev_avg_volume, 1e-8)) - 1
            
            # Divergence occurs when signs differ - use continuous measure instead of discrete
            divergence = -1 * price_change * volume_change  # Positive when diverging
            eng.append(divergence)
        else:
            eng.append(0)  # Placeholder
        
        # 16. Normalized Short Interest Change
        # Measure rate of change in short interest relative to its level
        if t > 0:
            prev_si = data[t-1, 0]
            norm_si_change = (short_interest - prev_si) / max(prev_si, 1e-8)
            eng.append(norm_si_change)
        else:
            eng.append(0)  # Placeholder
        
        # 17. NEW: Short Interest Momentum Oscillator
        # Similar to RSI but for short interest changes
        if t >= 5:
            si_changes = []
            for i in range(1, min(6, t+1)):
                prev_si = data[t-i, 0]
                current_si = data[t-i+1, 0]
                si_changes.append((current_si - prev_si) / max(prev_si, 1e-8))
            
            up_changes = [max(change, 0) for change in si_changes]
            down_changes = [max(-change, 0) for change in si_changes]
            
            avg_up = np.mean(up_changes) if up_changes else 0
            avg_down = np.mean(down_changes) if down_changes else 0
            
            rs_si = avg_up / max(avg_down, 1e-8)
            si_rsi = 100 - (100 / (1 + rs_si))
            # Normalize to [-1, 1] and center at 0
            si_oscillator = (si_rsi / 50) - 1
            eng.append(si_oscillator)
        else:
            eng.append(0)  # Placeholder
        
        # 18. NEW: Short Interest to Price Momentum Correlation
        # Measure if short interest changes correlate with price changes
        if t >= 5 and len(close_prices) >= 5:
            si_changes = []
            price_changes = []
            
            for i in range(1, min(5, t+1)):
                if t-i >= 0:
                    prev_si = data[t-i, 0]
                    current_si = data[t-i+1, 0]
                    si_changes.append((current_si - prev_si) / max(prev_si, 1e-8))
                    
                    if i < len(close_prices):
                        prev_price = close_prices[-i-1] if i+1 < len(close_prices) else close_prices[0]
                        current_price = close_prices[-i]
                        price_changes.append((current_price - prev_price) / max(prev_price, 1e-8))
            
            # Simple correlation proxy (avoid using np.corrcoef for stability)
            if len(si_changes) >= 3 and len(price_changes) >= 3:
                # Normalize both series
                si_changes_norm = [(x - np.mean(si_changes)) / max(np.std(si_changes), 1e-8) for x in si_changes]
                price_changes_norm = [(x - np.mean(price_changes)) / max(np.std(price_changes), 1e-8) for x in price_changes]
                
                # Calculate dot product of normalized vectors (limited to min length)
                min_len = min(len(si_changes_norm), len(price_changes_norm))
                corr_proxy = sum(si_changes_norm[i] * price_changes_norm[i] for i in range(min_len)) / max(min_len, 1)
                # Clamp to [-1, 1]
                corr_proxy = max(min(corr_proxy, 1), -1)
                eng.append(corr_proxy)
            else:
                eng.append(0)  # Placeholder
        else:
            eng.append(0)  # Placeholder
        
        # 19. NEW: Short Interest Acceleration
        # Second derivative of short interest (acceleration)
        if t >= 2:
            si_t = short_interest
            si_t1 = data[t-1, 0]
            si_t2 = data[t-2, 0]
            
            first_derivative_t = (si_t - si_t1) / max(si_t1, 1e-8)
            first_derivative_t1 = (si_t1 - si_t2) / max(si_t2, 1e-8)
            
            si_acceleration = first_derivative_t - first_derivative_t1
            # Normalize to typical range
            norm_si_accel = min(max(si_acceleration * 5, -1), 1)  # Scale and clamp
            eng.append(norm_si_accel)
        else:
            eng.append(0)  # Placeholder
        
        # 20. NEW: Short Interest Reversal Signal
        # Detect potential reversals in short interest trend
        if t >= 3:
            si_values = [data[t-i, 0] for i in range(4)]
            
            # Check for pattern: consistent trend followed by reversal
            trend_up = si_values[1] > si_values[2] and si_values[2] > si_values[3]
            trend_down = si_values[1] < si_values[2] and si_values[2] < si_values[3]
            
            reversal_signal = 0
            if trend_up and si_values[0] < si_values[1]:
                reversal_signal = -1  # Uptrend reversing down
            elif trend_down and si_values[0] > si_values[1]:
                reversal_signal = 1  # Downtrend reversing up
            eng.append(reversal_signal)
        else:
            eng.append(0)  # Placeholder
        
        # 21. NEW: Short Interest to Price Ratio Change
        # Track changes in the relationship between short interest and price
        if t > 0 and len(close_prices) > 0 and len(data[t-1, 2:].reshape(15, 4)[:, 3]) > 0:
            current_ratio = short_interest / max(close_prices[-1], 1e-8)
            prev_close = data[t-1, 2:].reshape(15, 4)[:, 3][-1]
            prev_si = data[t-1, 0]
            prev_ratio = prev_si / max(prev_close, 1e-8)
            
            ratio_change = (current_ratio / max(prev_ratio, 1e-8)) - 1
            eng.append(ratio_change)
        else:
            eng.append(0)  # Placeholder
        
        # 22. NEW: Volatility-Adjusted Short Interest
        # Normalize short interest by price volatility
        if len(daily_returns) > 1:
            price_volatility = np.std(daily_returns)
            vol_adjusted_si = short_interest / max(price_volatility * 100, 1e-8)
            eng.append(vol_adjusted_si)
        else:
            eng.append(0)  # Placeholder
        
        # 23. NEW: Short Interest Trend Consistency
        # Measure how consistent the short interest trend has been
        if t >= 4:
            si_values = [data[t-i, 0] for i in range(5)]
            si_changes = [si_values[i] - si_values[i+1] for i in range(4)]
            
            # Count sign changes (trend reversals)
            sign_changes = 0
            for i in range(1, len(si_changes)):
                if (si_changes[i] > 0 and si_changes[i-1] < 0) or (si_changes[i] < 0 and si_changes[i-1] > 0):
                    sign_changes += 1
            
            # Convert to consistency score (0 = inconsistent, 1 = perfectly consistent)
            consistency = 1 - (sign_changes / (len(si_changes) - 1))
            eng.append(consistency)
        else:
            eng.append(0.5)  # Placeholder
        
        # 24. NEW: Short Interest Regime
        # Identify if we're in a high or low short interest regime
        if t >= 5:
            si_history = [data[max(0, t-i), 0] for i in range(min(10, t+1))]
            si_mean = np.mean(si_history)
            si_std = np.std(si_history)
            
            # Z-score of current SI relative to recent history
            si_regime = (short_interest - si_mean) / max(si_std, 1e-8)
            # Normalize to [-1, 1]
            si_regime = min(max(si_regime / 2, -1), 1)
            eng.append(si_regime)
        else:
            eng.append(0)  # Placeholder
        
        # 25. NEW: Short Interest to Volume Trend
        # Track how the relationship between SI and volume is changing
        if t >= 2:
            current_ratio = short_interest / max(avg_volume, 1e-8)
            prev_ratio = data[t-1, 0] / max(data[t-1, 1], 1e-8)
            prev_prev_ratio = data[t-2, 0] / max(data[t-2, 1], 1e-8)
            
            # First and second derivatives
            first_deriv = current_ratio - prev_ratio
            second_deriv = (current_ratio - prev_ratio) - (prev_ratio - prev_prev_ratio)
            
            # Normalize
            norm_first_deriv = min(max(first_deriv * 10, -1), 1)
            eng.append(norm_first_deriv)
        else:
            eng.append(0)  # Placeholder
        
        # 26. NEW: Short Interest Efficiency Ratio
        # Measure how efficiently short interest is moving in one direction
        if t >= 5:
            si_values = [data[t-i, 0] for i in range(min(6, t+1))]
            
            # Calculate net change and total path length
            net_change = abs(si_values[0] - si_values[-1])
            path_length = sum(abs(si_values[i] - si_values[i+1]) for i in range(len(si_values)-1))
            
            # Efficiency ratio (0 = inefficient, 1 = perfectly efficient)
            efficiency = net_change / max(path_length, 1e-8)
            eng.append(efficiency)
        else:
            eng.append(0.5)  # Placeholder
        
        # 27. NEW: Short Interest Rate of Change Oscillator
        # Track rate of change in short interest over multiple periods
        if t >= 5:
            # Calculate ROC over different periods
            roc_1 = (short_interest / max(data[t-1, 0], 1e-8)) - 1 if t >= 1 else 0
            roc_3 = (short_interest / max(data[t-3, 0], 1e-8)) - 1 if t >= 3 else 0
            roc_5 = (short_interest / max(data[t-5, 0], 1e-8)) - 1 if t >= 5 else 0
            
            # Weighted average of ROCs (more weight to recent)
            weighted_roc = (3 * roc_1 + 2 * roc_3 + roc_5) / 6
            # Normalize
            norm_weighted_roc = min(max(weighted_roc * 5, -1), 1)
            eng.append(norm_weighted_roc)
        else:
            eng.append(0)  # Placeholder
        
        # 28. NEW: Short Interest Surprise
        # Measure unexpected changes in short interest
        if t >= 5:
            si_history = [data[t-i, 0] for i in range(1, min(6, t+1))]
            expected_si = np.mean(si_history)  # Simple prediction based on recent average
            
            # Surprise = actual - expected (normalized)
            surprise = (short_interest - expected_si) / max(expected_si, 1e-8)
            # Scale and clamp
            norm_surprise = min(max(surprise * 5, -1), 1)
            eng.append(norm_surprise)
        else:
            eng.append(0)  # Placeholder
        
        # 29. NEW: Short Interest to Price Momentum Divergence
        # Detect when short interest and price momentum move in opposite expected directions
        if t >= 2 and len(close_prices) >= 5:
            # Short interest change
            si_change = (short_interest - data[t-1, 0]) / max(data[t-1, 0], 1e-8)
            
            # Price momentum
            price_momentum = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
            
            # Typically, increasing short interest correlates with negative price momentum
            # So divergence occurs when they have the same sign
            divergence = si_change * price_momentum
            eng.append(divergence)
        else:
            eng.append(0)  # Placeholder
        
        # 30. NEW: Short Interest Seasonality
        # Capture potential reporting cycle effects
        if t >= 15:
            # Compare current SI to SI from one reporting cycle ago (15 days)
            si_15d_ago = data[t-15, 0]
            si_cycle_change = (short_interest - si_15d_ago) / max(si_15d_ago, 1e-8)
            eng.append(si_cycle_change)
        else:
            eng.append(0)  # Placeholder
        
        # Ensure we don't exceed MAX_NEW features
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Pad or truncate to MAX_TOTAL
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result.append(row)
    
    # Stack all rows and handle NaN values
    result_array = np.stack(result)
    result_array = np.nan_to_num(result_array, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result_array
============================================================
