============================================================
ITERATIVE AGENT-BASED FEATURE SELECTION SUMMARY
============================================================
Stock: TSLA
Date: 2025-10-09 00:21:23
Total Iterations: 2

PERFORMANCE TREND:
----------------------------------------
Iteration 0: Baseline - MAPE: 11.99% (Baseline)
Iteration 1: Iteration 1 - MAPE: 12.29% (-0.30%)
Iteration 2: Iteration 2 - MAPE: 11.59% (+0.39%)

Best Model: Iteration 2 - MAPE: 11.59%
Final Test MAPE: 5.85%
Final Improvement: -0.11%

============================================================
FEATURE ENGINEERING CODES
============================================================

ITERATION 1:
Performance: MAPE = 12.29%
Improvement: -0.30%
Features: 25
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Always keep short interest and average volume (critical base features)
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        raw_keep.extend([short_interest, avg_volume, days_to_cover])
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Keep only the most recent OHLC values (last day)
        last_open, last_high, last_low, last_close = open_prices[-1], high_prices[-1], low_prices[-1], close_prices[-1]
        raw_keep.extend([last_open, last_high, last_low, last_close])
        
        # Keep options data (high importance from baseline)
        options_put_call_ratio = data[t, 64]
        options_synthetic_short_cost = data[t, 65]
        options_avg_implied_volatility = data[t, 66]
        raw_keep.extend([options_put_call_ratio, options_synthetic_short_cost, options_avg_implied_volatility])
        
        # Extract short volume and total volume data
        short_volume = data[t, 68:83]
        total_volume = data[t, 83:98]
        
        # Keep shares outstanding (important for relative measures)
        shares_outstanding = data[t, 67]
        raw_keep.append(shares_outstanding)
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (recent trend)
        short_volume_ratio = np.mean(short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))
        eng.append(short_volume_ratio)
        
        # 2. Short Interest to Float Ratio
        si_to_float = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_to_float)
        
        # 3. Price momentum (5-day)
        if len(close_prices) >= 5:
            momentum_5d = (close_prices[-1] / max(close_prices[-5], 1e-8)) - 1
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 4. Volatility (standard deviation of returns)
        if len(close_prices) >= 5:
            returns = np.diff(close_prices[-6:]) / np.maximum(close_prices[-6:-1], 1e-8)
            volatility = np.std(returns) if len(returns) > 0 else 0
        else:
            volatility = 0
        eng.append(volatility)
        
        # 5. Average True Range (ATR) - volatility indicator
        tr_values = []
        for i in range(1, min(10, len(high_prices))):
            high_low = high_prices[-i] - low_prices[-i]
            high_close = abs(high_prices[-i] - close_prices[-i-1])
            low_close = abs(low_prices[-i] - close_prices[-i-1])
            tr = max(high_low, high_close, low_close)
            tr_values.append(tr)
        atr = np.mean(tr_values) if tr_values else 0
        eng.append(atr)
        
        # 6. Short Volume Acceleration (change in short volume)
        if len(short_volume) >= 5:
            short_vol_change = (np.mean(short_volume[-2:]) / max(np.mean(short_volume[-5:-2]), 1e-8)) - 1
        else:
            short_vol_change = 0
        eng.append(short_vol_change)
        
        # 7. Options Volatility to Price Ratio
        options_vol_price_ratio = options_avg_implied_volatility / max(last_close, 1e-8)
        eng.append(options_vol_price_ratio)
        
        # 8. RSI (Relative Strength Index)
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            gain = np.sum(np.where(delta > 0, delta, 0))
            loss = np.sum(np.where(delta < 0, -delta, 0))
            rs = gain / max(loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 9. Short Interest Trend (rate of change)
        si_trend = 0
        if t > 0:
            prev_si = data[t-1, 0]
            si_trend = (short_interest / max(prev_si, 1e-8)) - 1
        eng.append(si_trend)
        
        # 10. Price to Volume Ratio (indicates buying/selling pressure)
        price_volume_ratio = last_close / max(avg_volume, 1e-8)
        eng.append(price_volume_ratio)
        
        # 11. Short Interest to Days to Cover Ratio
        si_dtc_ratio = short_interest / max(days_to_cover, 1e-8)
        eng.append(si_dtc_ratio)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size (pad or truncate)
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN and infinity values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
============================================================

ITERATION 2:
Performance: MAPE = 11.59%
Improvement: +0.39%
Features: 25
----------------------------------------
def construct_features(data):
    RAW_DIM = 97
    MAX_TOTAL = 25
    
    lookback_window = data.shape[0]
    result = np.zeros((lookback_window, MAX_TOTAL), dtype=np.float32)
    
    for t in range(lookback_window):
        # Initialize lists for raw features to keep and engineered features
        raw_keep = []
        eng = []
        
        # Extract key raw features
        short_interest = data[t, 0]
        avg_volume = data[t, 1]
        days_to_cover = data[t, 2]
        
        # Extract OHLC data for the past 15 days
        ohlc = data[t, 3:63].reshape(15, 4)
        open_prices, high_prices, low_prices, close_prices = ohlc[:, 0], ohlc[:, 1], ohlc[:, 2], ohlc[:, 3]
        
        # Extract options data (high importance from baseline)
        options_put_call_ratio = data[t, 64]
        options_synthetic_short_cost = data[t, 65]
        options_avg_implied_volatility = data[t, 66]
        shares_outstanding = data[t, 67]
        
        # Extract short volume and total volume data
        short_volume = data[t, 68:83]
        total_volume = data[t, 83:98]
        
        # Keep critical raw features based on importance analysis
        # Feature_3_t1, Feature_12_t1, Feature_7_t1, Feature_64_t1, Feature_50_t2 were top important
        raw_keep.extend([
            short_interest,                  # Always keep target-related feature
            avg_volume,                      # Always keep volume
            days_to_cover,                   # Important for short squeeze potential
            close_prices[-1],                # Last close price (Feature_7_t1 equivalent)
            options_put_call_ratio,          # Feature_64_t1 equivalent
            options_synthetic_short_cost,    # Important for short cost analysis
            options_avg_implied_volatility,  # Important for volatility expectations
            shares_outstanding               # Important for relative measures
        ])
        
        # Calculate MAX_NEW based on raw features kept
        MAX_NEW = MAX_TOTAL - len(raw_keep)
        
        # 1. Short Volume Ratio (recent trend) - improved with weighted average
        # More weight to recent days to capture trend acceleration
        weights = np.linspace(0.5, 1.0, 5)
        weighted_short_ratio = np.sum(weights * (short_volume[-5:] / np.maximum(total_volume[-5:], 1e-8))) / np.sum(weights)
        eng.append(weighted_short_ratio)
        
        # 2. Short Interest to Float Ratio - key metric for short squeeze potential
        si_to_float = short_interest / max(shares_outstanding, 1e-8)
        eng.append(si_to_float)
        
        # 3. Short Interest Utilization Rate - measures how much of available shares are being shorted
        # Higher values indicate increased short squeeze risk
        si_utilization = short_interest / max(shares_outstanding * 0.8, 1e-8)  # Assuming ~80% of shares are typically available
        eng.append(si_utilization)
        
        # 4. Price Momentum (5-day) - improved with exponential weighting
        if len(close_prices) >= 5:
            returns = np.diff(close_prices[-6:]) / np.maximum(close_prices[-6:-1], 1e-8)
            weights = np.exp(np.linspace(0, 1, len(returns)))
            momentum_5d = np.sum(weights * returns) / np.sum(weights)
        else:
            momentum_5d = 0
        eng.append(momentum_5d)
        
        # 5. Volatility (EWMA of returns) - more responsive to recent volatility changes
        if len(close_prices) >= 10:
            returns = np.diff(close_prices[-11:]) / np.maximum(close_prices[-11:-1], 1e-8)
            weights = np.exp(np.linspace(0, 1, len(returns)))
            volatility = np.sqrt(np.sum(weights * returns**2) / np.sum(weights))
        else:
            volatility = 0
        eng.append(volatility)
        
        # 6. Short Volume Acceleration - second derivative of short volume
        if len(short_volume) >= 7:
            short_vol_3d_avg = np.mean(short_volume[-3:])
            short_vol_prev_3d_avg = np.mean(short_volume[-6:-3])
            short_vol_prev_prev_3d_avg = np.mean(short_volume[-9:-6]) if len(short_volume) >= 9 else short_vol_prev_3d_avg
            
            first_derivative = short_vol_3d_avg / max(short_vol_prev_3d_avg, 1e-8) - 1
            prev_first_derivative = short_vol_prev_3d_avg / max(short_vol_prev_prev_3d_avg, 1e-8) - 1
            
            short_vol_accel = first_derivative - prev_first_derivative
        else:
            short_vol_accel = 0
        eng.append(short_vol_accel)
        
        # 7. Options Implied Volatility to Historical Volatility Ratio
        # Measures market expectations vs. realized volatility
        if volatility > 0:
            iv_hv_ratio = options_avg_implied_volatility / max(volatility, 1e-8)
        else:
            iv_hv_ratio = 1.0
        eng.append(iv_hv_ratio)
        
        # 8. RSI (Relative Strength Index) - improved with EMA for smoother signal
        if len(close_prices) >= 14:
            delta = np.diff(close_prices[-15:])
            weights = np.exp(np.linspace(0, 1, len(delta)))
            gain = np.sum(weights * np.where(delta > 0, delta, 0)) / np.sum(weights)
            loss = np.sum(weights * np.where(delta < 0, -delta, 0)) / np.sum(weights)
            rs = gain / max(loss, 1e-8)
            rsi = 100 - (100 / (1 + rs))
        else:
            rsi = 50  # Neutral value when not enough data
        eng.append(rsi)
        
        # 9. Short Interest Trend (rate of change)
        si_trend = 0
        if t > 0:
            prev_si = data[t-1, 0]
            si_trend = (short_interest / max(prev_si, 1e-8)) - 1
        eng.append(si_trend)
        
        # 10. Bollinger Band Width - measures volatility expansion/contraction
        if len(close_prices) >= 10:
            sma = np.mean(close_prices[-10:])
            std = np.std(close_prices[-10:])
            bb_width = (2 * std) / max(sma, 1e-8)
        else:
            bb_width = 0
        eng.append(bb_width)
        
        # 11. Short Cost Pressure - combines synthetic short cost with put/call ratio
        # Higher values indicate increased pressure on shorts
        short_cost_pressure = options_synthetic_short_cost * (1 + options_put_call_ratio)
        eng.append(short_cost_pressure)
        
        # 12. Days to Cover Trend - rate of change in days to cover
        dtc_trend = 0
        if t > 0:
            prev_dtc = data[t-1, 2]
            dtc_trend = (days_to_cover / max(prev_dtc, 1e-8)) - 1
        eng.append(dtc_trend)
        
        # 13. Price to Short Volume Ratio - indicates potential price impact of short covering
        if len(short_volume) >= 5:
            price_short_ratio = close_prices[-1] / max(np.mean(short_volume[-5:]), 1e-8)
        else:
            price_short_ratio = close_prices[-1] / max(short_volume[-1], 1e-8)
        eng.append(price_short_ratio)
        
        # 14. Short Interest to Options Volume Ratio - measures hedging activity
        si_options_ratio = short_interest / max(options_put_call_ratio * avg_volume, 1e-8)
        eng.append(si_options_ratio)
        
        # 15. Normalized Short Interest - short interest relative to its recent range
        if t >= 5:
            si_history = np.array([data[max(0, t-i), 0] for i in range(5)])
            si_min, si_max = np.min(si_history), np.max(si_history)
            si_range = si_max - si_min
            norm_si = (short_interest - si_min) / max(si_range, 1e-8) if si_range > 0 else 0.5
        else:
            norm_si = 0.5
        eng.append(norm_si)
        
        # 16. Volume Surge Indicator - detects unusual volume that might precede short squeezes
        if len(total_volume) >= 10:
            recent_vol_avg = np.mean(total_volume[-3:])
            baseline_vol_avg = np.mean(total_volume[-10:-3])
            vol_surge = recent_vol_avg / max(baseline_vol_avg, 1e-8) - 1
        else:
            vol_surge = 0
        eng.append(vol_surge)
        
        # 17. Short Volume to Price Momentum Ratio - captures divergence between shorting and price
        if abs(momentum_5d) > 1e-8:
            short_momentum_divergence = weighted_short_ratio / max(abs(momentum_5d), 1e-8)
        else:
            short_momentum_divergence = 0
        eng.append(short_momentum_divergence)
        
        # Ensure we don't exceed MAX_NEW
        if len(eng) > MAX_NEW:
            eng = eng[:MAX_NEW]
        
        # Combine raw and engineered features
        row = np.array(raw_keep + eng, dtype=np.float32)
        
        # Ensure consistent size (pad or truncate)
        if row.size < MAX_TOTAL:
            row = np.pad(row, (0, MAX_TOTAL - row.size), 'constant')
        elif row.size > MAX_TOTAL:
            row = row[:MAX_TOTAL]
        
        result[t] = row
    
    # Handle NaN and infinity values
    result = np.nan_to_num(result, nan=0.0, posinf=0.0, neginf=0.0)
    
    return result
============================================================
